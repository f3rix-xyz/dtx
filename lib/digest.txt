Directory structure:
└── lib/
    ├── main.dart
    ├── models/
    │   ├── auth_model.dart
    │   ├── chat_message.dart
    │   ├── error_model.dart
    │   ├── feed_models.dart
    │   ├── filter_model.dart
    │   ├── like_models.dart
    │   ├── location_model.dart
    │   ├── match_user.dart
    │   ├── media_upload_model.dart
    │   ├── user_model.dart
    │   └── ws_message_model.dart
    ├── providers/
    │   ├── audio_player_provider.dart
    │   ├── audio_upload_provider.dart
    │   ├── auth_provider.dart
    │   ├── conversation_provider.dart
    │   ├── error_provider.dart
    │   ├── feed_provider.dart
    │   ├── filter_provider.dart
    │   ├── liker_profile_provider.dart
    │   ├── location_provider.dart
    │   ├── matches_provider.dart
    │   ├── media_upload_provider.dart
    │   ├── recieved_likes_provider.dart
    │   ├── service_provider.dart
    │   ├── status_provider.dart
    │   └── user_provider.dart
    ├── repositories/
    │   ├── auth_repository.dart
    │   ├── auth_status_repository.dart
    │   ├── chat_repository.dart
    │   ├── filter_repository.dart
    │   ├── like_repository.dart
    │   ├── match_repository.dart
    │   ├── media_repository.dart
    │   └── user_repository.dart
    ├── services/
    │   ├── api_service.dart
    │   ├── chat_service.dart
    │   └── http_service.dart
    ├── utils/
    │   ├── app_enums.dart
    │   ├── date_formatter.dart
    │   ├── datetime_formatter.dart
    │   ├── env_config.dart
    │   └── token_storage.dart
    ├── views/
    │   ├── audioprompt.dart
    │   ├── audiopromptsselect.dart
    │   ├── chat_detail_screen.dart
    │   ├── chat_screen.dart
    │   ├── dating_intentions.dart
    │   ├── dob.dart
    │   ├── drinking.dart
    │   ├── filter_settings_dialog.dart
    │   ├── gender.dart
    │   ├── google_sign_in_screen.dart
    │   ├── height.dart
    │   ├── home.dart
    │   ├── hometown.dart
    │   ├── job.dart
    │   ├── liker_profile_screen.dart
    │   ├── location.dart
    │   ├── main_navigation_screen.dart
    │   ├── matches_screen.dart
    │   ├── media.dart
    │   ├── name.dart
    │   ├── profile_screens.dart
    │   ├── prompt.dart
    │   ├── religion.dart
    │   ├── selfie_capture_screen.dart
    │   ├── settings_screen.dart
    │   ├── smoking.dart
    │   ├── splash_screen.dart
    │   ├── study.dart
    │   ├── textpromptsselect.dart
    │   ├── verification_message_screen.dart
    │   ├── verification_pending_screen.dart
    │   ├── who_liked_you_screen.dart
    │   ├── writeprompt.dart
    │   ├── youtube.dart
    │   └── core/
    │       └── error_handler.dart
    └── widgets/
        ├── basic_liker_profile_card.dart
        ├── full_liker_profile_card.dart
        ├── home_profile_card.dart
        ├── match_list_tile.dart
        ├── message_bubble.dart
        └── report_reason_dialog.dart

================================================
File: main.dart
================================================
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/gender.dart';
import 'package:dtx/views/height.dart';
import 'package:dtx/views/home.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/prompt.dart';
import 'package:flutter/material.dart';
import 'package:dtx/views/splash_screen.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

void main() async {
  // Ensure Flutter is initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Load environment variables
  await dotenv.load(fileName: ".env");

  runApp(
    // Adding ProviderScope at the root of the app
    const ProviderScope(
      child: MyApp(),
    ),
  );
}

// Change StatelessWidget to ConsumerWidget to use Riverpod
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp(
      title: 'DTX',
      debugShowCheckedModeBanner: false, // Optional: removes debug banner
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // You can add more theme configurations here
      ),
      // You can change the home screen here based on your flow
      // For example, start with PhoneInputScreen for authentication flow
      home: const SplashScreen(),
    );
  }
}



================================================
File: models/auth_model.dart
================================================
// File: models/auth_model.dart

// --- UPDATED ENUM ---
enum AuthStatus {
  login, // Needs to log in (no valid token or check failed)
  onboarding1, // Logged in, needs location/gender
  onboarding2, // Logged in, location/gender set, needs main profile details
  home, // Fully authenticated and onboarded
  unknown, // Initial state or error during status check
}
// --- END UPDATED ENUM ---

class AuthState {
  // --- REMOVED FIELDS ---
  // final String? unverifiedPhone;
  // final String? verificationId;
  // final int? resendTimer;
  // --- END REMOVED FIELDS ---

  final bool isLoading;
  final String? error; // Keep error for general auth errors
  final String? jwtToken;
  final AuthStatus authStatus;

  const AuthState({
    this.isLoading = false,
    this.error,
    this.jwtToken,
    this.authStatus = AuthStatus.unknown, // Default to unknown
  });

  AuthState copyWith({
    bool? isLoading,
    String? Function()? error,
    String? Function()? jwtToken, // Function to allow setting null
    AuthStatus? authStatus,
  }) {
    return AuthState(
      isLoading: isLoading ?? this.isLoading,
      error: error != null ? error() : this.error,
      jwtToken: jwtToken != null ? jwtToken() : this.jwtToken,
      authStatus: authStatus ?? this.authStatus,
    );
  }

  // Check if user is considered authenticated (has a token)
  bool get isAuthenticated => jwtToken != null && jwtToken!.isNotEmpty;
}



================================================
File: models/chat_message.dart
================================================
// lib/models/chat_message.dart
import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';

// Enum for message status remains the same
enum ChatMessageStatus {
  pending,
  uploading,
  sent,
  failed,
}

class ChatMessage {
  final String? tempId;
  final int messageID;
  final int senderUserID;
  final int recipientUserID;
  final String messageText;
  final String? mediaUrl;
  final String? mediaType;
  final DateTime sentAt;
  final bool isRead;
  final DateTime? readAt;

  // Fields for optimistic UI (remain the same)
  final ChatMessageStatus status;
  final String? localFilePath;
  final String? initialLocalPath;
  final String? errorMessage;

  // *** Reply fields (Keep as is) ***
  final int? replyToMessageID;
  final int? repliedMessageSenderID;
  final String? repliedMessageTextSnippet;
  final String? repliedMessageMediaType;
  // *** END ADDED ***

  ChatMessage({
    this.tempId,
    required this.messageID,
    required this.senderUserID,
    required this.recipientUserID,
    required this.messageText,
    this.mediaUrl,
    this.mediaType,
    required this.sentAt,
    this.isRead = false,
    this.readAt,
    this.status = ChatMessageStatus.sent,
    this.localFilePath,
    this.initialLocalPath,
    this.errorMessage,
    // *** Reply fields to constructor (Keep as is) ***
    this.replyToMessageID,
    this.repliedMessageSenderID,
    this.repliedMessageTextSnippet,
    this.repliedMessageMediaType,
    // *** END ADDED ***
  });

  bool isMe(int currentUserId) => senderUserID == currentUserId;

  // *** isReply getter (Keep as is) ***
  bool get isReply => replyToMessageID != null && replyToMessageID! > 0;
  // *** END ADDED ***

  bool get isMedia =>
      (mediaUrl != null && mediaUrl!.isNotEmpty) ||
      (localFilePath != null && localFilePath!.isNotEmpty);

  String get formattedTimestamp {
    // Formatting logic remains the same
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final messageDay = DateTime(sentAt.year, sentAt.month, sentAt.day);

    if (messageDay == today) {
      return DateFormat.jm().format(sentAt.toLocal());
    } else if (today.difference(messageDay).inDays == 1) {
      return 'Yesterday';
    } else {
      return DateFormat.yMd().format(sentAt.toLocal());
    }
  }

  // --- *** CORRECTED: fromJson Factory *** ---
  factory ChatMessage.fromJson(Map<String, dynamic> json) {
    // --- Helper Functions (Keep as is) ---
    DateTime parseTimestamp(dynamic tsField) {
      if (tsField is String) {
        try {
          return DateTime.parse(tsField).toLocal();
        } catch (e) {
          print(
              "[ChatMessage.fromJson->parseTimestamp] Error parsing '$tsField': $e");
          return DateTime.now().toLocal();
        }
      } else if (tsField is Map &&
          tsField['Valid'] == true &&
          tsField['Time'] is String) {
        try {
          return DateTime.parse(tsField['Time']).toLocal();
        } catch (e) {
          print(
              "[ChatMessage.fromJson->parseTimestamp] Error parsing from map '$tsField': $e");
          return DateTime.now().toLocal();
        }
      }
      print(
          "[ChatMessage.fromJson->parseTimestamp] Invalid timestamp type: ${tsField.runtimeType}. Returning local now.");
      return DateTime.now().toLocal();
    }

    DateTime? parseNullableTimestamp(dynamic tsField) {
      if (tsField is String) {
        try {
          return DateTime.parse(tsField).toLocal();
        } catch (_) {
          return null;
        }
      } else if (tsField is Map &&
          tsField['Valid'] == true &&
          tsField['Time'] is String) {
        try {
          return DateTime.parse(tsField['Time']).toLocal();
        } catch (_) {
          return null;
        }
      }
      return null;
    }

    String parsePgtypeText(dynamic field) {
      if (field is String) {
        return field;
      } else if (field is Map &&
          field['Valid'] == true &&
          field['String'] is String) {
        return field['String'];
      }
      return '';
    }

    String? parseNullablePgtypeText(dynamic field) {
      if (field is String) {
        return field.isNotEmpty ? field : null;
      } else if (field is Map &&
          field['Valid'] == true &&
          field['String'] is String) {
        return (field['String'] as String).isNotEmpty ? field['String'] : null;
      }
      return null;
    }

    int? parsePgtypeInt(dynamic field) {
      if (field is int) {
        return field;
      } else if (field is Map && field['Valid'] == true) {
        if (field.containsKey('Int64') && field['Int64'] is num) {
          return (field['Int64'] as num).toInt();
        } else if (field.containsKey('Int32') && field['Int32'] is num) {
          return (field['Int32'] as num).toInt();
        }
      } else if (field is String) {
        return int.tryParse(field);
      }
      return null;
    }

    String parseMessageTextRobust(Map<String, dynamic> jsonData) {
      if (jsonData['text'] is String)
        return jsonData['text']; // Direct check added
      if (jsonData['message_text'] is String)
        return jsonData['message_text']; // Direct check added
      return parsePgtypeText(jsonData['message_text']);
    }
    // --- End Helper Functions ---

    final messageID = json['id'] as int? ?? 0;
    final senderUserID = json['sender_user_id'] as int? ?? 0;
    final recipientUserID = json['recipient_user_id'] as int? ?? 0;
    final text = parseMessageTextRobust(json);
    final mediaUrl = parseNullablePgtypeText(json['media_url']);
    final mediaType = parseNullablePgtypeText(json['media_type']);
    final sentAt = parseTimestamp(json['sent_at']);
    final isRead = json['is_read'] as bool? ?? false;
    final readAt = parseNullableTimestamp(json['read_at']);

    // *** CORRECTED: Parse reply fields from nested 'reply_to' object ***
    int? replyToMessageID;
    int? repliedMessageSenderID;
    String? repliedMessageTextSnippet;
    String? repliedMessageMediaType; // Need to parse this as well

    // Check if the 'reply_to' key exists and is a Map
    if (json.containsKey('reply_to') &&
        json['reply_to'] is Map<String, dynamic>) {
      final replyData = json['reply_to'] as Map<String, dynamic>;
      print(
          "[ChatMessage.fromJson ID: $messageID] Found 'reply_to' object: $replyData"); // Log found reply data

      // Try parsing fields within the 'reply_to' map
      replyToMessageID =
          parsePgtypeInt(replyData['message_id']); // Use helper for flexibility
      repliedMessageSenderID =
          parsePgtypeInt(replyData['sender_id']); // Use helper for flexibility

      // Snippet might be directly a string or null
      repliedMessageTextSnippet = replyData['text_snippet'] as String?;

      // Media type might be pgtype.Text or direct string
      repliedMessageMediaType =
          parseNullablePgtypeText(replyData['media_type']);
    } else if (json.containsKey('reply_to')) {
      print(
          "[ChatMessage.fromJson ID: $messageID] Found 'reply_to' key, but it's not a Map. Type: ${json['reply_to'].runtimeType}");
    }

    if (kDebugMode) {
      print(
          "[ChatMessage.fromJson ID: $messageID] Parsed Core: sender=$senderUserID, recipient=$recipientUserID, text='$text', mediaUrl=$mediaUrl, mediaType=$mediaType, sentAt=$sentAt, isRead=$isRead, readAt=$readAt");
      if (replyToMessageID != null) {
        print(
            "[ChatMessage.fromJson ID: $messageID] Parsed Reply Info: replyTo=$replyToMessageID, origSender=$repliedMessageSenderID, snippet='$repliedMessageTextSnippet', origMediaType=$repliedMessageMediaType");
      } else {
        print(
            "[ChatMessage.fromJson ID: $messageID] No valid reply info parsed.");
      }
    }

    return ChatMessage(
      messageID: messageID,
      senderUserID: senderUserID,
      recipientUserID: recipientUserID,
      messageText: text,
      mediaUrl: mediaUrl,
      mediaType: mediaType,
      sentAt: sentAt,
      isRead: isRead,
      readAt: readAt,
      status: ChatMessageStatus.sent,
      // *** Pass correctly parsed reply fields ***
      replyToMessageID: replyToMessageID,
      repliedMessageSenderID: repliedMessageSenderID,
      repliedMessageTextSnippet: repliedMessageTextSnippet,
      repliedMessageMediaType: repliedMessageMediaType,
      // *** END ADDED ***
    );
  }
  // --- END CORRECTED fromJson Factory ---

  // --- copyWith method (Keep as is) ---
  ChatMessage copyWith({
    String? tempId,
    int? messageID,
    int? senderUserID,
    int? recipientUserID,
    String? messageText,
    String? mediaUrl,
    String? mediaType,
    DateTime? sentAt,
    bool? isRead,
    DateTime? readAt,
    ChatMessageStatus? status,
    String? localFilePath,
    bool clearLocalFilePath = false,
    String? initialLocalPath,
    String? errorMessage,
    bool clearErrorMessage = false,
    int? Function()? replyToMessageID,
    int? Function()? repliedMessageSenderID,
    String? Function()? repliedMessageTextSnippet,
    String? Function()? repliedMessageMediaType,
  }) {
    return ChatMessage(
      tempId: tempId ?? this.tempId,
      messageID: messageID ?? this.messageID,
      senderUserID: senderUserID ?? this.senderUserID,
      recipientUserID: recipientUserID ?? this.recipientUserID,
      messageText: messageText ?? this.messageText,
      mediaUrl: mediaUrl ?? this.mediaUrl,
      mediaType: mediaType ?? this.mediaType,
      sentAt: sentAt ?? this.sentAt,
      isRead: isRead ?? this.isRead,
      readAt: readAt ?? this.readAt,
      status: status ?? this.status,
      localFilePath:
          clearLocalFilePath ? null : (localFilePath ?? this.localFilePath),
      initialLocalPath: initialLocalPath ?? this.initialLocalPath,
      errorMessage:
          clearErrorMessage ? null : (errorMessage ?? this.errorMessage),
      replyToMessageID:
          replyToMessageID != null ? replyToMessageID() : this.replyToMessageID,
      repliedMessageSenderID: repliedMessageSenderID != null
          ? repliedMessageSenderID()
          : this.repliedMessageSenderID,
      repliedMessageTextSnippet: repliedMessageTextSnippet != null
          ? repliedMessageTextSnippet()
          : this.repliedMessageTextSnippet,
      repliedMessageMediaType: repliedMessageMediaType != null
          ? repliedMessageMediaType()
          : this.repliedMessageMediaType,
    );
  }
  // --- END copyWith ---
}



================================================
File: models/error_model.dart
================================================
enum ErrorType { network, validation, auth, generic, locationService, server }

class AppError {
  final String message;
  final ErrorType type;
  final DateTime timestamp;

  AppError({
    required this.message,
    required this.type,
  }) : timestamp = DateTime.now();

  factory AppError.network(String message) => AppError(
        message: message,
        type: ErrorType.network,
      );

  factory AppError.validation(String message) => AppError(
        message: message,
        type: ErrorType.validation,
      );

  factory AppError.auth(String message) => AppError(
        message: message,
        type: ErrorType.auth,
      );

  factory AppError.locationService(String message) => AppError(
        message: message,
        type: ErrorType.locationService,
      );

  factory AppError.server(String message) => AppError(
        message: message,
        type: ErrorType.server,
      );

  factory AppError.generic(String message) => AppError(
        message: message,
        type: ErrorType.generic, // Use the generic type
      );
}



================================================
File: models/feed_models.dart
================================================
import 'package:dtx/utils/app_enums.dart';

// --- REMOVED QuickFeedProfile ---

// --- FeedProfile (Kept for potential reuse, but not directly used by HomeScreen anymore) ---
// Consider removing if truly unused later.
class FeedProfile {
  final int id;
  final String? name;
  final String? lastName;
  final DateTime? dateOfBirth;
  final List<String>? mediaUrls;
  final Gender? gender;
  final double? distanceKm;

  FeedProfile({
    required this.id,
    this.name,
    this.lastName,
    this.dateOfBirth,
    this.mediaUrls,
    this.gender,
    this.distanceKm,
  });

  String get firstName => name ?? '';

  int? get age {
    if (dateOfBirth == null) return null;
    final now = DateTime.now();
    int age = now.year - dateOfBirth!.year;
    if (now.month < dateOfBirth!.month ||
        (now.month == dateOfBirth!.month && now.day < dateOfBirth!.day)) {
      age--;
    }
    return age < 18 ? null : age;
  }

  String? get firstMediaUrl {
    if (mediaUrls != null &&
        mediaUrls!.isNotEmpty &&
        mediaUrls![0].isNotEmpty) {
      return mediaUrls![0];
    }
    return null;
  }

  factory FeedProfile.fromJson(Map<String, dynamic> json) {
    DateTime? parseDate(dynamic dateField) {
      if (dateField is Map &&
          dateField['Valid'] == true &&
          dateField['Time'] != null) {
        try {
          return DateTime.parse(dateField['Time'] as String);
        } catch (e) {
          return null;
        }
      } else if (dateField is String) {
        // Handle direct string date
        try {
          return DateTime.parse(dateField);
        } catch (e) {
          return null;
        }
      }
      return null;
    }

    List<String>? parseMediaUrls(dynamic urls) {
      if (urls is List) {
        return List<String>.from(
            urls.where((item) => item is String && item.isNotEmpty));
      }
      return null;
    }

    Gender? parseGender(dynamic genderField) {
      String? genderStr;
      if (genderField is Map &&
          genderField['Valid'] == true &&
          genderField['GenderEnum'] != null) {
        genderStr = genderField['GenderEnum'] as String?;
      } else if (genderField is String) {
        genderStr = genderField;
      }

      if (genderStr != null) {
        if (genderStr == 'man') return Gender.man;
        if (genderStr == 'woman') return Gender.woman;
      }
      return null;
    }

    return FeedProfile(
      id: json['id'] as int? ?? 0,
      name: (json['name'] is Map && json['name']['Valid'])
          ? json['name']['String'] as String?
          : json['name'] as String?, // Handle direct string
      lastName: (json['last_name'] is Map && json['last_name']['Valid'])
          ? json['last_name']['String'] as String?
          : json['last_name'] as String?, // Handle direct string
      dateOfBirth: parseDate(json['date_of_birth']),
      mediaUrls: parseMediaUrls(json['media_urls']),
      gender: parseGender(json['gender']),
      distanceKm: (json['distance_km'] as num?)?.toDouble(),
    );
  }
}



================================================
File: models/filter_model.dart
================================================
// lib/models/filter_model.dart
import 'package:dtx/utils/app_enums.dart'; // For Gender enum (ensure correct import if needed)

// --- NEW: Enum for Gender Preference in Filters ---
// Aligns with backend Go enum values ('man', 'woman')
enum FilterGenderPref {
  man('man'),
  woman('woman');

  final String value;
  const FilterGenderPref(this.value);

  // Helper to convert string from API/JSON back to enum
  static FilterGenderPref? fromValue(String? value) {
    if (value == null) return null;
    try {
      return FilterGenderPref.values.firstWhere(
        (e) => e.value.toLowerCase() == value.toLowerCase(),
      );
    } catch (e) {
      return null; // Return null if value doesn't match any enum
    }
  }
}
// --- END NEW ---

class FilterSettings {
  final int? userId; // Keep user ID if needed to associate filters
  final FilterGenderPref? whoYouWantToSee; // Updated type
  final int? radiusKm;
  final bool? activeToday;
  final int? ageMin;
  final int? ageMax;
  final DateTime? createdAt; // Optional: For informational purposes
  final DateTime? updatedAt; // Optional: For informational purposes

  // Define default values (you might want to adjust these)
  static const FilterGenderPref defaultGenderPref = FilterGenderPref.woman;
  static const int defaultRadius = 50; // e.g., 50 km
  static const bool defaultActiveToday = false;
  static const int defaultAgeMin = 18;
  static const int defaultAgeMax = 55;

  const FilterSettings({
    this.userId,
    this.whoYouWantToSee = defaultGenderPref, // Default to show women
    this.radiusKm = defaultRadius,
    this.activeToday = defaultActiveToday,
    this.ageMin = defaultAgeMin,
    this.ageMax = defaultAgeMax,
    this.createdAt,
    this.updatedAt,
  });

  // Check if the current settings are the default ones
  bool get isDefault {
    return whoYouWantToSee == defaultGenderPref &&
        radiusKm == defaultRadius &&
        activeToday == defaultActiveToday &&
        ageMin == defaultAgeMin &&
        ageMax == defaultAgeMax;
  }

  // copyWith method for immutability
  FilterSettings copyWith({
    int? userId,
    FilterGenderPref? Function()? whoYouWantToSee, // Use nullable functions
    int? Function()? radiusKm,
    bool? Function()? activeToday,
    int? Function()? ageMin,
    int? Function()? ageMax,
    DateTime? createdAt, // Optional: For informational purposes
    DateTime? updatedAt, // Optional: For informational purposes
  }) {
    return FilterSettings(
      userId: userId ?? this.userId,
      whoYouWantToSee:
          whoYouWantToSee != null ? whoYouWantToSee() : this.whoYouWantToSee,
      radiusKm: radiusKm != null ? radiusKm() : this.radiusKm,
      activeToday: activeToday != null ? activeToday() : this.activeToday,
      ageMin: ageMin != null ? ageMin() : this.ageMin,
      ageMax: ageMax != null ? ageMax() : this.ageMax,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  // Convert to JSON for API requests (align keys with backend)
  Map<String, dynamic> toJsonForApi() {
    final Map<String, dynamic> data = {};
    // Only include fields that are non-null or should be sent
    if (whoYouWantToSee != null)
      data['whoYouWantToSee'] = whoYouWantToSee!.value;
    if (radiusKm != null) data['radius'] = radiusKm;
    if (activeToday != null) data['activeToday'] = activeToday;
    if (ageMin != null) data['ageMin'] = ageMin;
    if (ageMax != null) data['ageMax'] = ageMax;
    return data;
  }

  // Factory to parse from JSON API response
  factory FilterSettings.fromJson(Map<String, dynamic> json) {
    // Helper to safely parse nullable integers from potential pgtype structure
    int? parseInt(dynamic field) {
      if (field is Map &&
          field['Valid'] == true &&
          field['Int32'] != null &&
          field['Int32'] is num) {
        return (field['Int32'] as num).toInt();
      }
      // Handle direct int case if backend sends it sometimes
      if (field is int) return field;
      return null;
    }

    // Helper to safely parse gender preference from potential pgtype structure
    FilterGenderPref? parseGenderPref(dynamic field) {
      if (field is Map &&
          field['Valid'] == true &&
          field['GenderEnum'] != null) {
        return FilterGenderPref.fromValue(field['GenderEnum'] as String?);
      }
      // Handle direct string case
      if (field is String) {
        return FilterGenderPref.fromValue(field);
      }
      return null;
    }

    DateTime? parseDateTime(String? dateString) {
      if (dateString == null) return null;
      try {
        return DateTime.parse(dateString);
      } catch (_) {
        return null; // Return null if parsing fails
      }
    }

    // Adapt the keys ('WhoYouWantToSee', 'RadiusKm', etc.) to match your exact API response structure
    // Use the helpers for nullable fields
    final FilterGenderPref? parsedGender =
        parseGenderPref(json['WhoYouWantToSee']); // Check API response key case
    final int? parsedRadius =
        parseInt(json['RadiusKm']); // Check API response key case
    final int? parsedAgeMin =
        parseInt(json['AgeMin']); // Check API response key case
    final int? parsedAgeMax =
        parseInt(json['AgeMax']); // Check API response key case
    // Assuming 'ActiveToday' is sent as a direct boolean or pgtype.Bool
    final bool? parsedActive = (json['ActiveToday'] is Map &&
            json['ActiveToday']['Valid'] == true)
        ? json['ActiveToday']['Bool'] as bool?
        : (json['ActiveToday'] is bool ? json['ActiveToday'] as bool? : null);

    return FilterSettings(
      userId: json['UserID'], // Assume UserID is directly available
      whoYouWantToSee: parsedGender ??
          FilterSettings.defaultGenderPref, // Fallback to default
      radiusKm: parsedRadius ?? FilterSettings.defaultRadius,
      activeToday: parsedActive ?? FilterSettings.defaultActiveToday,
      ageMin: parsedAgeMin ?? FilterSettings.defaultAgeMin,
      ageMax: parsedAgeMax ?? FilterSettings.defaultAgeMax,
      createdAt: parseDateTime(json['CreatedAt'] as String?),
      updatedAt: parseDateTime(json['UpdatedAt'] as String?),
    );
  }
}



================================================
File: models/like_models.dart
================================================
// File: models/like_models.dart
import 'package:dtx/models/user_model.dart'; // Import UserProfileData definition source
import 'package:dtx/utils/app_enums.dart'; // For GenderEnum if needed
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Only needed if UserProfileData uses Riverpod types directly, unlikely.

// --- Enums (from Phase 8) ---
enum ContentLikeType {
  media('media'),
  promptStory('prompt_story'),
  promptMytype('prompt_mytype'),
  promptGettingpersonal('prompt_gettingpersonal'),
  promptDatevibes('prompt_datevibes'),
  audioPrompt('audio_prompt'),
  profile('profile'); // <<<--- ADDED THIS LINE

  final String value;
  const ContentLikeType(this.value);

  // --- UPDATED fromValue for robustness ---
  static ContentLikeType? fromValue(String? value) {
    if (value == null) return null;
    try {
      // Find the enum value matching the string
      return ContentLikeType.values.firstWhere((e) => e.value == value);
    } catch (e) {
      // Handle cases where the string doesn't match any enum value
      print("Warning: Unknown ContentLikeType value '$value'");
      return null; // Return null if not found
    }
  }
  // --- END UPDATED fromValue ---
}

enum LikeInteractionType {
  standard('standard'),
  rose('rose');

  final String value;
  const LikeInteractionType(this.value);
  static LikeInteractionType? fromValue(String? value) {
    if (value == null) return null;
    try {
      // Added try-catch for robustness
      return LikeInteractionType.values.firstWhere((e) => e.value == value);
    } catch (e) {
      print("Warning: Unknown LikeInteractionType value '$value'");
      return null; // Return null if not found
    }
    // Original: return LikeInteractionType.values.firstWhere((e) => e.value == value, orElse: () => LikeInteractionType.standard);
  }
}

// --- Custom Exceptions (from Phase 8) ---
class LikeLimitExceededException implements Exception {
  final String message;
  LikeLimitExceededException([this.message = 'Daily like limit reached.']);
  @override
  String toString() => message;
}

class InsufficientRosesException implements Exception {
  final String message;
  InsufficientRosesException([this.message = 'You don\'t have enough Roses.']);
  @override
  String toString() => message;
}

// --- Liker Data Structures ---

// Structure for Full Profile Liker (Matches API Response `full_profiles` item)
class FullProfileLiker {
  final int likerUserId;
  final String? likeComment; // Nullable string
  final bool isRose;
  final DateTime? likedAt; // Parsed timestamp
  final UserProfileData profile; // Embedded full profile data

  FullProfileLiker({
    required this.likerUserId,
    this.likeComment,
    required this.isRose,
    this.likedAt,
    required this.profile,
  });

  factory FullProfileLiker.fromJson(Map<String, dynamic> json) {
    DateTime? parseTimestamp(dynamic ts) {
      if (ts is String) {
        try {
          return DateTime.parse(ts).toLocal();
        } catch (_) {} // Parse and convert to local time
      }
      return null;
    }

    // Safely get comment string
    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        // Handle direct string just in case
        return commentField;
      }
      return null;
    }

    // --- UPDATED isRose parsing ---
    bool parseIsRose(dynamic isRoseField, dynamic interactionTypeField) {
      if (isRoseField is bool) {
        return isRoseField; // Prefer direct boolean if present
      }
      // Fallback to checking interaction_type string
      return interactionTypeField == LikeInteractionType.rose.value;
    }
    // --- END UPDATED ---

    return FullProfileLiker(
      likerUserId: json['liker_user_id'] as int? ?? 0,
      likeComment: getComment(json['like_comment']),
      // Use helper to parse isRose
      isRose: parseIsRose(json['is_rose'], json['interaction_type']),
      likedAt: parseTimestamp(json['liked_at']),
      // Assuming 'profile' contains the full UserProfileData structure
      profile: UserProfileData.fromJson(
          json['profile'] as Map<String, dynamic>? ?? {}),
    );
  }
}

// Structure for Basic Profile Liker (Matches API Response `other_likers` item)
class BasicProfileLiker {
  final int likerUserId;
  final String name; // Should ideally always have a name
  final String? firstProfilePicUrl; // Nullable string
  final String? likeComment; // Nullable string
  final bool isRose;
  final DateTime? likedAt; // Parsed timestamp

  BasicProfileLiker({
    required this.likerUserId,
    required this.name,
    this.firstProfilePicUrl,
    this.likeComment,
    required this.isRose,
    this.likedAt,
  });

  factory BasicProfileLiker.fromJson(Map<String, dynamic> json) {
    DateTime? parseTimestamp(dynamic ts) {
      if (ts is String) {
        try {
          return DateTime.parse(ts).toLocal();
        } catch (_) {}
      }
      return null;
    }

    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        return commentField;
      }
      return null;
    }

    String? getPicUrl(dynamic urls) {
      if (urls is List && urls.isNotEmpty && urls[0] is String) {
        return urls[0];
      }
      return null;
    }

    String buildName(dynamic nameField, dynamic lastNameField) {
      String firstName = (nameField is Map && nameField['Valid'] == true)
          ? nameField['String'] ?? ''
          : '';
      String lastName = (lastNameField is Map && lastNameField['Valid'] == true)
          ? lastNameField['String'] ?? ''
          : '';
      return '$firstName $lastName'.trim(); // Combine and trim whitespace
    }

    // --- UPDATED isRose parsing (same as FullProfileLiker) ---
    bool parseIsRose(dynamic isRoseField, dynamic interactionTypeField) {
      if (isRoseField is bool) {
        return isRoseField; // Prefer direct boolean if present
      }
      // Fallback to checking interaction_type string
      return interactionTypeField == LikeInteractionType.rose.value;
    }
    // --- END UPDATED ---

    return BasicProfileLiker(
      likerUserId: json['liker_user_id'] as int? ?? 0,
      name: buildName(json['name'], json['last_name']), // Build name safely
      firstProfilePicUrl: getPicUrl(json['media_urls']), // Get first URL safely
      likeComment: getComment(json['like_comment']),
      // Use helper to parse isRose
      isRose: parseIsRose(json['is_rose'], json['interaction_type']),
      likedAt: parseTimestamp(json['liked_at']),
    );
  }
}

class LikeInteractionDetails {
  final String? likeComment; // Nullable string
  final bool isRose;

  LikeInteractionDetails({
    this.likeComment,
    required this.isRose,
  });

  factory LikeInteractionDetails.fromJson(Map<String, dynamic> json) {
    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        return commentField;
      }
      return null;
    }

    // --- UPDATED isRose parsing (same logic) ---
    bool parseIsRose(dynamic isRoseField, dynamic interactionTypeField) {
      if (isRoseField is bool) {
        return isRoseField; // Prefer direct boolean if present
      }
      // Fallback to checking interaction_type string
      return interactionTypeField == LikeInteractionType.rose.value;
    }
    // --- END UPDATED ---

    return LikeInteractionDetails(
      likeComment: getComment(
          json['comment']), // Assuming key is 'comment' from GetLikeDetailsRow
      // Use helper to parse isRose
      isRose: parseIsRose(json['is_rose'], json['interaction_type']),
    );
  }
}

// --- Placeholder for UserProfileData (ensure consistency) ---
// Re-using UserModel seems appropriate based on current needs
class UserProfileData extends UserModel {
  UserProfileData({
    // Inherit all fields from UserModel
    super.id, // <<< ADDED super.id
    super.name,
    super.lastName,
    super.email,
    super.phoneNumber,
    super.dateOfBirth,
    super.latitude,
    super.longitude,
    super.gender,
    super.datingIntention,
    super.height,
    super.hometown,
    super.jobTitle,
    super.education,
    super.religiousBeliefs,
    super.drinkingHabit,
    super.smokingHabit,
    super.mediaUrls,
    super.prompts = const [],
    super.audioPrompt,
    super.verificationStatus,
    super.verificationPic,
    super.role,
    super.mediaChangedDuringEdit, // <<< ADDED super.mediaChangedDuringEdit
  });

  factory UserProfileData.fromJson(Map<String, dynamic> json) {
    // Parse UserModel fields using its factory
    final userModel = UserModel.fromJson(json);

    return UserProfileData(
      id: userModel.id, // Pass id
      name: userModel.name,
      lastName: userModel.lastName,
      email: userModel.email,
      phoneNumber: userModel.phoneNumber,
      dateOfBirth: userModel.dateOfBirth,
      latitude: userModel.latitude,
      longitude: userModel.longitude,
      gender: userModel.gender,
      datingIntention: userModel.datingIntention,
      height: userModel.height,
      hometown: userModel.hometown,
      jobTitle: userModel.jobTitle,
      education: userModel.education,
      religiousBeliefs: userModel.religiousBeliefs,
      drinkingHabit: userModel.drinkingHabit,
      smokingHabit: userModel.smokingHabit,
      mediaUrls: userModel.mediaUrls,
      prompts: userModel.prompts,
      audioPrompt: userModel.audioPrompt,
      verificationStatus: userModel.verificationStatus,
      verificationPic: userModel.verificationPic,
      role: userModel.role,
      mediaChangedDuringEdit: userModel.mediaChangedDuringEdit, // Pass flag
    );
  }
}



================================================
File: models/location_model.dart
================================================
class LocationState {
  final bool isLoading;
  final bool isFetching;
  final double latitude;
  final double longitude;
  final double? cachedLatitude;
  final double? cachedLongitude;
  final bool isMapReady;

  LocationState({
    this.isLoading = true,
    this.isFetching = false,
    this.latitude = 19.2183, // Default location
    this.longitude = 73.0864,
    this.cachedLatitude,
    this.cachedLongitude,
    this.isMapReady = false,
  });

  LocationState copyWith({
    bool? isLoading,
    bool? isFetching,
    double? latitude,
    double? longitude,
    double? cachedLatitude,
    double? cachedLongitude,
    bool? isMapReady,
  }) {
    return LocationState(
      isLoading: isLoading ?? this.isLoading,
      isFetching: isFetching ?? this.isFetching,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      cachedLatitude: cachedLatitude ?? this.cachedLatitude,
      cachedLongitude: cachedLongitude ?? this.cachedLongitude,
      isMapReady: isMapReady ?? this.isMapReady,
    );
  }
}



================================================
File: models/match_user.dart
================================================
// lib/models/match_user.dart
import 'package:dtx/models/user_model.dart'; // Re-use UserModel for consistency?

// Option 1: Simple Match User (if /api/matches returns minimal data)
// class MatchUser {
//   final int id;
//   final String name;
//   final String? avatarUrl;

//   MatchUser({
//     required this.id,
//     required this.name,
//     this.avatarUrl,
//   });

//   factory MatchUser.fromJson(Map<String, dynamic> json) {
//     // Adjust keys based on your ACTUAL /api/matches response
//     return MatchUser(
//       id: json['id'] as int? ?? 0,
//       name: json['name'] as String? ?? 'Unknown Match',
//       avatarUrl: json['avatar_url'] as String?,
//     );
//   }
// }

// Option 2: Reuse UserModel (if /api/matches returns full user profiles)
// This might be slightly heavier but avoids creating a separate model if the data is similar
typedef MatchUser = UserModel; // Use UserModel as the MatchUser type

// If using Option 2, no separate fromJson is needed here,
// just ensure your repository parses the response using UserModel.fromJson



================================================
File: models/media_upload_model.dart
================================================

// models/media_upload_model.dart
import 'dart:io';

enum UploadStatus {
  idle,
  inProgress,
  success,
  failed,
}

class MediaUploadModel {
  final File file;
  final String fileName;
  final String fileType;
  final String? presignedUrl;
  final UploadStatus status;
  final String? errorMessage;
  
  MediaUploadModel({
    required this.file,
    required this.fileName,
    required this.fileType,
    this.presignedUrl,
    this.status = UploadStatus.idle,
    this.errorMessage,
  });
  
  MediaUploadModel copyWith({
    File? file,
    String? fileName,
    String? fileType,
    String? Function()? presignedUrl,
    UploadStatus? status,
    String? Function()? errorMessage,
  }) {
    return MediaUploadModel(
      file: file ?? this.file,
      fileName: fileName ?? this.fileName,
      fileType: fileType ?? this.fileType,
      presignedUrl: presignedUrl != null ? presignedUrl() : this.presignedUrl,
      status: status ?? this.status,
      errorMessage: errorMessage != null ? errorMessage() : this.errorMessage,
    );
  }
}



================================================
File: models/user_model.dart
================================================
// File: lib/models/user_model.dart
import 'dart:convert';
import 'package:flutter/foundation.dart'; // For kDebugMode
import 'package:intl/intl.dart'; // For date formatting if needed
import 'package:dtx/utils/app_enums.dart';

// --- Prompt Class --- (No changes needed)
class Prompt {
  final PromptCategory category;
  final PromptType question;
  final String answer;

  Prompt({
    required this.category,
    required this.question,
    required this.answer,
  });

  Map<String, dynamic> toJson() => {
        'category': category.value,
        'question': question.value,
        'answer': answer,
      };

  factory Prompt.fromJson(Map<String, dynamic> json) {
    PromptCategory category = PromptCategory.values
        .firstWhere((e) => e.value == json['category'], orElse: () {
      print(
          "[Prompt fromJson] Warning: Unknown prompt category '${json['category']}', defaulting to storyTime.");
      return PromptCategory.storyTime;
    });
    PromptType question = PromptType.values
        .firstWhere((e) => e.value == json['question'], orElse: () {
      print(
          "[Prompt fromJson] Warning: Unknown prompt question '${json['question']}' for category '${category.value}', defaulting.");
      List<PromptType> categoryPrompts = category.getPrompts();
      return categoryPrompts.isNotEmpty
          ? categoryPrompts.first
          : PromptType.twoTruthsAndALie;
    });

    return Prompt(
      category: category,
      question: question,
      answer: json['answer'] ?? '',
    );
  }

  Prompt copyWith({String? answer}) {
    return Prompt(
      category: category,
      question: question,
      answer: answer ?? this.answer,
    );
  }

  @override
  String toString() {
    return 'Prompt(question: ${question.label}, answer: $answer)';
  }
}

// --- AudioPromptModel Class --- (No changes needed)
class AudioPromptModel {
  final AudioPrompt prompt;
  final String audioUrl;

  AudioPromptModel({
    required this.prompt,
    required this.audioUrl,
  });

  Map<String, dynamic> toJson() => {
        'question': prompt.value,
        'answer_url': audioUrl,
      };

  factory AudioPromptModel.fromJson(Map<String, dynamic> json) {
    final promptValue =
        json['audio_prompt_question']?['AudioPrompt'] as String?;
    final bool isPromptValid =
        json['audio_prompt_question']?['Valid'] as bool? ?? false;

    if (!isPromptValid || promptValue == null) {
      throw const FormatException(
          'Invalid or missing audio prompt question data in JSON');
    }

    AudioPrompt prompt = AudioPrompt.values
        .firstWhere((e) => e.value == promptValue, orElse: () {
      print(
          "[AudioPromptModel fromJson] Warning: Unknown audio prompt '$promptValue', defaulting to aBoundaryOfMineIs.");
      return AudioPrompt.aBoundaryOfMineIs;
    });

    String? audioUrlValue;
    dynamic answerField = json['audio_prompt_answer'];

    if (answerField is String) {
      audioUrlValue = answerField;
    } else if (answerField is Map) {
      if (answerField['Valid'] == true && answerField['String'] is String) {
        audioUrlValue = answerField['String'] as String;
      }
    }

    if (audioUrlValue == null || audioUrlValue.isEmpty) {
      throw const FormatException(
          'Invalid or missing audio prompt answer data in JSON');
    }

    return AudioPromptModel(
      prompt: prompt,
      audioUrl: audioUrlValue,
    );
  }
}

// --- UserModel Class ---
class UserModel {
  final int? id;
  final String? name;
  final String? lastName;
  final String? phoneNumber;
  final String? email;
  final DateTime? dateOfBirth;
  final double? latitude;
  final double? longitude;
  final Gender? gender;
  final DatingIntention? datingIntention;
  final String? height;
  final String? hometown;
  final String? jobTitle;
  final String? education;
  final Religion? religiousBeliefs;
  final DrinkingSmokingHabits? drinkingHabit;
  final DrinkingSmokingHabits? smokingHabit;
  final List<String>? mediaUrls;
  final List<Prompt> prompts;
  final AudioPromptModel? audioPrompt;
  final String? verificationStatus;
  final String? verificationPic;
  final String? role;
  final bool mediaChangedDuringEdit;
  // --- NEW FIELDS ---
  final bool isOnline; // Directly store bool
  final DateTime? lastOnline; // Store as DateTime?

  UserModel({
    this.id,
    this.name,
    this.lastName,
    this.phoneNumber,
    this.email,
    this.dateOfBirth,
    this.latitude,
    this.longitude,
    this.gender,
    this.datingIntention,
    this.height,
    this.hometown,
    this.jobTitle,
    this.education,
    this.religiousBeliefs,
    this.drinkingHabit,
    this.smokingHabit,
    this.mediaUrls,
    this.prompts = const [],
    this.audioPrompt,
    this.verificationStatus,
    this.verificationPic,
    this.role,
    this.mediaChangedDuringEdit = false,
    // --- INITIALIZE NEW FIELDS ---
    this.isOnline = false, // Default to false
    this.lastOnline,
  });

  int? get age {
    if (dateOfBirth == null) return null;
    final now = DateTime.now();
    int age = now.year - dateOfBirth!.year;
    if (now.month < dateOfBirth!.month ||
        (now.month == dateOfBirth!.month && now.day < dateOfBirth!.day)) {
      age--;
    }
    return age < 18 ? null : age;
  }

  String? get firstMediaUrl {
    if (mediaUrls != null &&
        mediaUrls!.isNotEmpty &&
        mediaUrls![0].isNotEmpty) {
      return mediaUrls![0];
    }
    return null;
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'last_name': lastName,
        'phone_number': phoneNumber,
        'email': email,
        'date_of_birth': dateOfBirth?.toIso8601String().split('T').first,
        'latitude': latitude,
        'longitude': longitude,
        'gender': gender?.value,
        'dating_intention': datingIntention?.value,
        'height': height,
        'hometown': hometown,
        'job_title': jobTitle,
        'education': education,
        'religious_beliefs': religiousBeliefs?.value,
        'drinking_habit': drinkingHabit?.value,
        'smoking_habit': smokingHabit?.value,
        'media_urls': mediaUrls,
        'prompts': prompts.map((prompt) => prompt.toJson()).toList(),
        'audio_prompt': audioPrompt?.toJson(),
        'verification_status': verificationStatus,
        'verification_pic': verificationPic,
        'role': role,
        // --- ADD TO JSON (Optional, depends if you ever send this full model back) ---
        'is_online': isOnline,
        'last_online': lastOnline?.toUtc().toIso8601String(),
      };

  Map<String, dynamic> toJsonForProfileUpdate() {
    String? formattedDate(DateTime? dt) {
      if (dt == null) return null;
      return "${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')}";
    }

    final Map<String, dynamic> data = {};
    if (name != null) data['name'] = name;
    data['last_name'] = lastName ?? "";
    if (dateOfBirth != null) data['date_of_birth'] = formattedDate(dateOfBirth);
    if (datingIntention != null)
      data['dating_intention'] = datingIntention!.value;
    if (height != null) data['height'] = height;
    if (hometown != null) data['hometown'] = hometown;
    if (jobTitle != null) data['job_title'] = jobTitle;
    if (education != null) data['education'] = education;
    if (religiousBeliefs != null)
      data['religious_beliefs'] = religiousBeliefs!.value;
    if (drinkingHabit != null) data['drinking_habit'] = drinkingHabit!.value;
    if (smokingHabit != null) data['smoking_habit'] = smokingHabit!.value;
    if (prompts.isNotEmpty)
      data['prompts'] = prompts.map((p) => p.toJson()).toList();
    return data;
  }

  Map<String, dynamic> toJsonForEdit() {
    final Map<String, dynamic> data = {};
    if (datingIntention != null)
      data['dating_intention'] = datingIntention!.value;
    if (height != null && height!.isNotEmpty) data['height'] = height;
    if (hometown != null && hometown!.isNotEmpty) data['hometown'] = hometown;
    if (jobTitle != null && jobTitle!.isNotEmpty) data['job_title'] = jobTitle;
    if (education != null && education!.isNotEmpty)
      data['education'] = education;
    if (religiousBeliefs != null)
      data['religious_beliefs'] = religiousBeliefs!.value;
    if (drinkingHabit != null) data['drinking_habit'] = drinkingHabit!.value;
    if (smokingHabit != null) data['smoking_habit'] = smokingHabit!.value;
    if (hometown == null) data['hometown'] = null;
    if (jobTitle == null) data['job_title'] = null;
    if (education == null) data['education'] = null;
    data['prompts'] = prompts.map((p) => p.toJson()).toList();
    if (audioPrompt != null) {
      data['audio_prompt'] = audioPrompt!.toJson();
    } else {
      data['audio_prompt'] = null;
    }
    data['media_urls'] = mediaUrls ?? [];
    return data;
  }

  factory UserModel.fromJson(Map<String, dynamic> json) {
    if (kDebugMode) {
      print(
          "[UserModel fromJson] START Parsing User ID: ${json['id'] ?? json['ID']}");
    }

    // --- Helper Functions --- (keep existing helpers)
    String? getString(dynamic field) {
      if (field is String) return field.isNotEmpty ? field : null;
      if (field is Map && field['Valid'] == true && field['String'] is String)
        return field['String'];
      if (field is num) return field.toString();
      return null;
    }

    String? getHeight(dynamic field) {
      if (field is String && field.isNotEmpty) return field;
      if (field is Map && field['Valid'] == true && field['String'] is String)
        return field['String'];
      if (field is Map && field['Valid'] == true && field['Float64'] is num) {
        double totalInches = (field['Float64'] as num).toDouble();
        if (totalInches <= 0) return null;
        int feet = (totalInches / 12).floor();
        int inches = (totalInches % 12).round();
        if (inches == 12) {
          feet++;
          inches = 0;
        }
        return "$feet' $inches\"";
      }
      if (field is num) {
        double totalInches = field.toDouble();
        if (totalInches <= 0) return null;
        int feet = (totalInches / 12).floor();
        int inches = (totalInches % 12).round();
        if (inches == 12) {
          feet++;
          inches = 0;
        }
        return "$feet' $inches\"";
      }
      return null;
    }

    String? getEnumString(dynamic field, String key) {
      if (field is String) return field;
      if (field is Map && field['Valid'] == true && field[key] != null)
        return field[key] as String?;
      return null;
    }

    DateTime? getDate(dynamic field) {
      String? dateStr;
      if (field is String) {
        dateStr = field;
      } else if (field is Map &&
          field['Valid'] == true &&
          field['Time'] != null) {
        dateStr = field['Time'] as String?;
      }
      if (dateStr != null) {
        try {
          if (dateStr.contains('T'))
            return DateTime.parse(dateStr.split('T').first).toLocal();
          else if (RegExp(r'^\d{4}-\d{2}-\d{2}$').hasMatch(dateStr))
            return DateTime.parse(dateStr).toLocal();
        } catch (e) {
          print(
              "[UserModel fromJson] Error parsing date: $e, value: '$dateStr'");
        }
      }
      return null;
    }

    double? getDouble(dynamic field) {
      if (field is num) return field.toDouble();
      if (field is Map && field['Valid'] == true && field['Float64'] != null)
        return (field['Float64'] as num?)?.toDouble();
      return null;
    }

    T? parseEnum<T>(List<T> enumValues, dynamic field, String key) {
      final valueStr = getEnumString(field, key);
      if (valueStr != null) {
        for (final enumValue in enumValues) {
          try {
            if ((enumValue as dynamic).value.toString() == valueStr)
              return enumValue;
          } catch (e) {
            if (enumValue.toString().split('.').last == valueStr)
              return enumValue;
          }
        }
        print(
            "[UserModel fromJson] Warning: Enum value '$valueStr' not found in ${T.toString()}. Field: $field");
      }
      return null;
    }

    List<String>? getMediaUrls(dynamic field) {
      if (field is List) {
        final urls = field
            .where((item) => item is String && item.isNotEmpty)
            .map((item) => item as String)
            .toList();
        return urls.isNotEmpty ? urls : null;
      }
      return null;
    }

    int? getId(dynamic idField) {
      if (idField is int) return idField;
      if (idField is String) return int.tryParse(idField);
      if (idField is Map && idField['Valid'] == true) {
        if (idField['Int64'] is num) return (idField['Int64'] as num).toInt();
        if (idField['Int32'] is num) return (idField['Int32'] as num).toInt();
      }
      return null;
    }

    List<Prompt> getPrompts(Map<String, dynamic> json) {
      List<Prompt> parsedPrompts = [];
      final promptsField = json['prompts'];
      if (promptsField is List) {
        for (var promptData in promptsField) {
          if (promptData is Map<String, dynamic>) {
            try {
              final parsedPrompt = Prompt.fromJson(promptData);
              if (parsedPrompt.answer.trim().isNotEmpty)
                parsedPrompts.add(parsedPrompt);
            } catch (e) {
              print(
                  "[UserModel fromJson] Error parsing prompt from list: $e, data: $promptData");
            }
          }
        }
      } else if (promptsField is String) {
        try {
          final List<dynamic> decodedList = jsonDecode(promptsField);
          for (var promptData in decodedList) {
            if (promptData is Map<String, dynamic>) {
              try {
                final parsedPrompt = Prompt.fromJson(promptData);
                if (parsedPrompt.answer.trim().isNotEmpty)
                  parsedPrompts.add(parsedPrompt);
              } catch (e) {
                print(
                    "[UserModel fromJson] Error parsing prompt from JSON string: $e, data: $promptData");
              }
            }
          }
        } catch (e) {
          print(
              "[UserModel fromJson] Error decoding prompts JSON string: $e, value: '$promptsField'");
        }
      }
      return parsedPrompts;
    }

    AudioPromptModel? getAudioPrompt(Map<String, dynamic> json, int? userId) {
      final questionData =
          json['audio_prompt_question'] ?? json['AudioPromptQuestion'];
      final answerData =
          json['audio_prompt_answer'] ?? json['AudioPromptAnswer'];
      bool isQuestionValid = false;
      String? questionValue;
      if (questionData is Map &&
          questionData['Valid'] == true &&
          questionData['AudioPrompt'] is String) {
        questionValue = questionData['AudioPrompt'] as String;
        isQuestionValid = questionValue.isNotEmpty;
      }
      if (!isQuestionValid) return null;
      String? audioUrlValue;
      if (answerData is String && answerData.isNotEmpty) {
        audioUrlValue = answerData;
      } else if (answerData is Map &&
          answerData['Valid'] == true &&
          answerData['String'] is String) {
        audioUrlValue = answerData['String'] as String?;
        if (audioUrlValue != null && audioUrlValue.isEmpty)
          audioUrlValue = null;
      }
      if (audioUrlValue == null) return null;
      try {
        AudioPrompt promptEnum = AudioPrompt.values.firstWhere(
            (e) => e.value == questionValue,
            orElse: () => AudioPrompt.aBoundaryOfMineIs);
        return AudioPromptModel(prompt: promptEnum, audioUrl: audioUrlValue);
      } catch (e) {
        print(
            "[UserModel fromJson getAudioPrompt ID: $userId] Error creating AudioPromptModel: $e");
        return null;
      }
    }

    // --- NEW: Helper for is_online ---
    bool getIsOnline(Map<String, dynamic> json) {
      // Check for Go backend keys first
      final goKey = json['is_online']; // From GetUserByID, SetUserOnline etc.
      final matchKey = json['matched_user_is_online']; // From GetMatches...

      if (goKey is bool) {
        if (kDebugMode)
          print("[UserModel fromJson] getIsOnline: Found bool 'is_online'");
        return goKey;
      }
      if (matchKey is bool) {
        if (kDebugMode)
          print(
              "[UserModel fromJson] getIsOnline: Found bool 'matched_user_is_online'");
        return matchKey;
      }
      // Fallback checks for other potential types
      if (goKey is int) return goKey == 1;
      if (matchKey is int) return matchKey == 1;
      if (goKey is String) return goKey.toLowerCase() == 'true';
      if (matchKey is String) return matchKey.toLowerCase() == 'true';

      if (kDebugMode)
        print(
            "[UserModel fromJson] getIsOnline: Could not parse is_online or matched_user_is_online. Defaulting to false.");
      return false; // Default to false if not found or invalid type
    }
    // --- END NEW HELPER ---

    // --- NEW: Helper for last_online ---
    DateTime? getLastOnline(Map<String, dynamic> json) {
      // Check for Go backend keys first
      final goKeyData = json['last_online'];
      final matchKeyData = json['matched_user_last_online'];

      // Prioritize Go key
      dynamic dataToParse = goKeyData ?? matchKeyData;

      if (dataToParse == null) {
        if (kDebugMode)
          print(
              "[UserModel fromJson] getLastOnline: Both last_online fields are null.");
        return null;
      }

      // Handle pgtype.Timestamptz map structure
      if (dataToParse is Map &&
          dataToParse['Valid'] == true &&
          dataToParse['Time'] != null) {
        final timeStr = dataToParse['Time'] as String?;
        if (timeStr != null) {
          try {
            final parsedTime = DateTime.parse(timeStr).toLocal();
            if (kDebugMode)
              print(
                  "[UserModel fromJson] getLastOnline: Parsed from Map: $parsedTime");
            return parsedTime;
          } catch (e) {
            print(
                "[UserModel fromJson] getLastOnline: Error parsing timestamp from Map: $e, value: '$timeStr'");
          }
        }
      }
      // Handle direct string (ISO 8601)
      else if (dataToParse is String) {
        try {
          final parsedTime = DateTime.parse(dataToParse).toLocal();
          if (kDebugMode)
            print(
                "[UserModel fromJson] getLastOnline: Parsed from String: $parsedTime");
          return parsedTime;
        } catch (e) {
          print(
              "[UserModel fromJson] getLastOnline: Error parsing timestamp from String: $e, value: '$dataToParse'");
        }
      } else {
        if (kDebugMode)
          print(
              "[UserModel fromJson] getLastOnline: Unhandled data type for last_online: ${dataToParse.runtimeType}");
      }

      return null; // Return null if parsing failed or type was unexpected
    }
    // --- END NEW HELPER ---

    // --- Parse using helpers ---
    final int? currentUserId = getId(json['id'] ?? json['ID']);
    if (kDebugMode)
      print("[UserModel fromJson ID: $currentUserId] Parsing core fields...");
    final parsedUser = UserModel(
      id: currentUserId,
      name: getString(json['name'] ?? json['Name']),
      lastName: getString(json['last_name'] ?? json['LastName']),
      email: json['email'] as String? ?? json['Email'] as String?,
      phoneNumber: getString(json['phone_number'] ?? json['PhoneNumber']),
      dateOfBirth: getDate(json['date_of_birth'] ?? json['DateOfBirth']),
      latitude: getDouble(json['latitude'] ?? json['Latitude']),
      longitude: getDouble(json['longitude'] ?? json['Longitude']),
      gender: parseEnum(
          Gender.values, json['gender'] ?? json['Gender'], 'GenderEnum'),
      datingIntention: parseEnum(
          DatingIntention.values,
          json['dating_intention'] ?? json['DatingIntention'],
          'DatingIntention'),
      height: getHeight(json['height'] ?? json['Height']),
      hometown: getString(json['hometown'] ?? json['Hometown']),
      jobTitle: getString(json['job_title'] ?? json['JobTitle']),
      education: getString(json['education'] ?? json['Education']),
      religiousBeliefs: parseEnum(Religion.values,
          json['religious_beliefs'] ?? json['ReligiousBeliefs'], 'Religion'),
      drinkingHabit: parseEnum(
          DrinkingSmokingHabits.values,
          json['drinking_habit'] ?? json['DrinkingHabit'],
          'DrinkingSmokingHabits'),
      smokingHabit: parseEnum(
          DrinkingSmokingHabits.values,
          json['smoking_habit'] ?? json['SmokingHabit'],
          'DrinkingSmokingHabits'),
      mediaUrls: getMediaUrls(json['media_urls'] ?? json['MediaUrls']),
      verificationStatus: json['verification_status'] as String? ??
          json['VerificationStatus'] as String?,
      verificationPic:
          getString(json['verification_pic'] ?? json['VerificationPic']),
      role: json['role'] as String? ?? json['Role'] as String?,
      audioPrompt: getAudioPrompt(json, currentUserId),
      prompts: getPrompts(json),
      // --- PARSE NEW FIELDS ---
      isOnline: getIsOnline(json),
      lastOnline: getLastOnline(json),
    );
    if (kDebugMode) {
      print(
          "[UserModel fromJson ID: $currentUserId] END Parsing. Result: isOnline=${parsedUser.isOnline}, lastOnline=${parsedUser.lastOnline}");
    }

    return parsedUser;
  }

  UserModel copyWith({
    int? Function()? id,
    String? Function()? name,
    String? Function()? lastName,
    String? Function()? phoneNumber,
    String? Function()? email,
    DateTime? Function()? dateOfBirth,
    double? Function()? latitude,
    double? Function()? longitude,
    Gender? Function()? gender,
    DatingIntention? Function()? datingIntention,
    String? Function()? height,
    String? Function()? hometown,
    String? Function()? jobTitle,
    String? Function()? education,
    Religion? Function()? religiousBeliefs,
    DrinkingSmokingHabits? Function()? drinkingHabit,
    DrinkingSmokingHabits? Function()? smokingHabit,
    List<String>? Function()? mediaUrls,
    List<Prompt>? prompts,
    AudioPromptModel? Function()? audioPrompt,
    String? Function()? verificationStatus,
    String? Function()? verificationPic,
    String? Function()? role,
    bool? mediaChangedDuringEdit,
    // --- ADD TO COPYWITH ---
    bool? isOnline,
    DateTime? Function()? lastOnline,
  }) {
    return UserModel(
      id: id != null ? id() : this.id,
      name: name != null ? name() : this.name,
      lastName: lastName != null ? lastName() : this.lastName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      email: email != null ? email() : this.email,
      dateOfBirth: dateOfBirth != null ? dateOfBirth() : this.dateOfBirth,
      latitude: latitude != null ? latitude() : this.latitude,
      longitude: longitude != null ? longitude() : this.longitude,
      gender: gender != null ? gender() : this.gender,
      datingIntention:
          datingIntention != null ? datingIntention() : this.datingIntention,
      height: height != null ? height() : this.height,
      hometown: hometown != null ? hometown() : this.hometown,
      jobTitle: jobTitle != null ? jobTitle() : this.jobTitle,
      education: education != null ? education() : this.education,
      religiousBeliefs:
          religiousBeliefs != null ? religiousBeliefs() : this.religiousBeliefs,
      drinkingHabit:
          drinkingHabit != null ? drinkingHabit() : this.drinkingHabit,
      smokingHabit: smokingHabit != null ? smokingHabit() : this.smokingHabit,
      mediaUrls: mediaUrls != null ? mediaUrls() : this.mediaUrls,
      prompts: prompts ?? List.from(this.prompts),
      audioPrompt: audioPrompt != null ? audioPrompt() : this.audioPrompt,
      verificationStatus: verificationStatus != null
          ? verificationStatus()
          : this.verificationStatus,
      verificationPic:
          verificationPic != null ? verificationPic() : this.verificationPic,
      role: role != null ? role() : this.role,
      mediaChangedDuringEdit:
          mediaChangedDuringEdit ?? this.mediaChangedDuringEdit,
      // --- ASSIGN IN COPYWITH ---
      isOnline: isOnline ?? this.isOnline,
      lastOnline: lastOnline != null ? lastOnline() : this.lastOnline,
    );
  }

  bool isProfileValid() {
    final dobValid = dateOfBirth != null &&
        DateTime.now().difference(dateOfBirth!).inDays >= (18 * 365.25);
    return name != null &&
        name!.trim().isNotEmpty &&
        name!.trim().length >= 3 &&
        dobValid &&
        datingIntention != null;
  }

  bool isLocationValid() {
    return latitude != null &&
        longitude != null &&
        latitude != 0.0 &&
        longitude != 0.0;
  }
}



================================================
File: models/ws_message_model.dart
================================================
// START OF FILE: lib/models/ws_message_model.dart
// NEW FILE: lib/models/ws_message_model.dart

import 'dart:convert';

/// Represents the structure of messages exchanged over WebSocket.
/// Used for BOTH sending (client -> server) and receiving (server -> client).
/// Fields are nullable to accommodate different message types.
class WsMessage {
  // General fields
  final String
      type; // Type sent BY backend ("chat_message", "error", "info", "status_update", etc.)
  final int? id; // Message ID (usually for chat messages, sent by backend)

  // Chat Message specific fields
  final int? senderUserID;
  final int? recipientUserID; // REQUIRED when sending FROM client
  final String? text; // Nullable
  final String? mediaURL; // Nullable
  final String? mediaType; // Nullable
  final String? sentAt; // ISO 8601 string (sent by backend)
  final int? replyToMessageID; // Nullable

  // Reaction specific fields
  final int? messageID; // The ID of the message being reacted to
  final String? emoji; // Nullable
  final int? reactorUserID; // User who reacted (sent by backend)
  final bool? isRemoved; // True if reaction was removed (sent by backend)

  // Status update specific fields
  final int? userID; // User whose status changed (sent by backend)
  final String? status; // "online" or "offline" (sent by backend)

  // Read receipt specific fields (when other user reads messages)
  final int? readerUserID; // User who read the messages (sent by backend)
  // MessageID (re-used from reaction fields) indicates up to which message was read

  // Generic/Error/Info fields
  final String? content; // For error/info messages (sent by backend)

  // Acknowledgement specific fields (server confirms client message)
  final int? count; // e.g., for mark_read_ack

  WsMessage({
    required this.type, // Type is always required for received messages
    this.id,
    this.senderUserID,
    this.recipientUserID,
    this.text,
    this.mediaURL,
    this.mediaType,
    this.sentAt,
    this.replyToMessageID,
    this.messageID,
    this.emoji,
    this.reactorUserID,
    this.isRemoved,
    this.userID,
    this.status,
    this.readerUserID,
    this.content,
    this.count,
  });

  // Factory constructor for parsing JSON received from WebSocket
  factory WsMessage.fromJson(Map<String, dynamic> json) {
    // Helper function to safely get int?
    int? getInt(String key) {
      final value = json[key];
      if (value is int) return value;
      if (value is String) return int.tryParse(value);
      return null;
    }

    // Helper function to safely get bool?
    bool? getBool(String key) {
      final value = json[key];
      if (value is bool) return value;
      if (value is String) return value.toLowerCase() == 'true';
      if (value is int) return value == 1;
      return null;
    }

    // Helper function to safely get String?
    String? getString(String key) {
      final value = json[key];
      if (value is String) return value;
      return null;
    }

    return WsMessage(
      type: getString('type') ?? 'unknown', // Default to 'unknown' if missing
      id: getInt('id'),
      senderUserID: getInt('sender_user_id'),
      recipientUserID: getInt('recipient_user_id'),
      text: getString('text'),
      mediaURL: getString('media_url'),
      mediaType: getString('media_type'),
      sentAt: getString('sent_at'), // Keep as string for now
      replyToMessageID: getInt('reply_to_message_id'),
      messageID: getInt('message_id'), // Used for reactions and read receipts
      emoji: getString('emoji'),
      reactorUserID: getInt('reactor_user_id'),
      isRemoved: getBool('is_removed'),
      userID: getInt('user_id'), // Used for status updates
      status: getString('status'),
      readerUserID: getInt('reader_user_id'),
      content: getString('content'),
      count: getInt('count'),
    );
  }

  // Method to convert to JSON (mainly for debugging, sending structure is simpler)
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {
      'type': type,
    };
    // Add fields only if they are not null
    if (id != null) data['id'] = id;
    if (senderUserID != null) data['sender_user_id'] = senderUserID;
    if (recipientUserID != null) data['recipient_user_id'] = recipientUserID;
    if (text != null) data['text'] = text;
    if (mediaURL != null) data['media_url'] = mediaURL;
    if (mediaType != null) data['media_type'] = mediaType;
    if (sentAt != null) data['sent_at'] = sentAt;
    if (replyToMessageID != null)
      data['reply_to_message_id'] = replyToMessageID;
    if (messageID != null) data['message_id'] = messageID;
    if (emoji != null) data['emoji'] = emoji;
    if (reactorUserID != null) data['reactor_user_id'] = reactorUserID;
    if (isRemoved != null) data['is_removed'] = isRemoved;
    if (userID != null) data['user_id'] = userID;
    if (status != null) data['status'] = status;
    if (readerUserID != null) data['reader_user_id'] = readerUserID;
    if (content != null) data['content'] = content;
    if (count != null) data['count'] = count;
    return data;
  }
}

// END OF FILE: lib/models/ws_message_model.dart



================================================
File: providers/audio_player_provider.dart
================================================

// providers/audio_player_provider.dart
import 'package:audioplayers/audioplayers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

enum AudioPlayerState {
  idle,
  loading,
  playing,
  paused,
  completed,
  error,
}

final audioPlayerStateProvider = StateProvider<AudioPlayerState>((ref) => AudioPlayerState.idle);
final currentAudioUrlProvider = StateProvider<String?>((ref) => null);

final audioPlayerProvider = Provider<AudioPlayer>((ref) {
  final player = AudioPlayer();
  
  player.onPlayerComplete.listen((_) {
    ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.completed;
  });
  
  player.onPlayerStateChanged.listen((state) {
    if (state == PlayerState.playing) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.playing;
    } else if (state == PlayerState.paused) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.paused;
    } else if (state == PlayerState.stopped) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.idle;
    }
  });
  
  // Handle cleanup when the provider is disposed
  ref.onDispose(() {
    player.dispose();
  });
  
  return player;
});

class AudioPlayerNotifier extends StateNotifier<AudioPlayerState> {
  final Ref ref;
  final AudioPlayer _player;
  
  AudioPlayerNotifier(this.ref)
      : _player = ref.read(audioPlayerProvider),
        super(AudioPlayerState.idle);
  
  Future<void> play(String url) async {
    try {
      // If another audio is playing, stop it
      if (state == AudioPlayerState.playing) {
        await _player.stop();
      }
      
      state = AudioPlayerState.loading;
      ref.read(currentAudioUrlProvider.notifier).state = url;
      
      await _player.play(UrlSource(url));
      // State will be updated via listener in audioPlayerProvider
    } catch (e) {
      print("Error playing audio: $e");
      state = AudioPlayerState.error;
    }
  }
  
  Future<void> pause() async {
    if (state == AudioPlayerState.playing) {
      await _player.pause();
      // State will be updated via listener
    }
  }
  
  Future<void> resume() async {
    if (state == AudioPlayerState.paused) {
      await _player.resume();
      // State will be updated via listener
    }
  }
  
  Future<void> stop() async {
    await _player.stop();
    ref.read(currentAudioUrlProvider.notifier).state = null;
    // State will be updated via listener
  }
}

final audioPlayerControllerProvider = StateNotifierProvider<AudioPlayerNotifier, AudioPlayerState>((ref) {
  return AudioPlayerNotifier(ref);
});



================================================
File: providers/audio_upload_provider.dart
================================================
// providers/audio_upload_provider.dart
import 'dart:io';
import 'dart:math';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../models/user_model.dart';
import '../repositories/media_repository.dart';
import '../utils/app_enums.dart';
import 'error_provider.dart';
import 'service_provider.dart';
import 'user_provider.dart';

// Provider definition remains the same
final audioUploadProvider =
    StateNotifierProvider<AudioUploadNotifier, MediaUploadModel?>(
  (ref) {
    print('[AudioUpload] Initializing AudioUploadProvider');
    final mediaRepository = ref.watch(mediaRepositoryProvider);
    return AudioUploadNotifier(ref, mediaRepository);
  },
);

class AudioUploadNotifier extends StateNotifier<MediaUploadModel?> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  AudioPrompt? _selectedPrompt; // Internal state to hold the selected prompt
  String? _recordingPath;

  // Initialize with null (no audio uploaded yet)
  AudioUploadNotifier(this.ref, this._mediaRepository) : super(null) {
    print('[AudioUpload] AudioUploadNotifier created');
  }

  // Max audio size (10 MB)
  static const int _maxAudioSizeBytes = 10 * 1024 * 1024;

  // Supported audio MIME types
  static final Set<String> _supportedAudioTypes = {
    'audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/webm',
    'audio/aac', 'audio/x-m4a', 'audio/x-aiff', 'audio/flac',
    'audio/mp4' // Add this line to support M4A files
  };

  // Save the recording path for later use
  void setRecordingPath(String path) {
    print('[AudioUpload] Setting recording path: $path');
    _recordingPath = path;
    // Don't clear the selected prompt when setting path
  }

  // Prepare audio file with validation
  bool prepareAudioFile() {
    print('[AudioUpload] Preparing audio file');
    print('[AudioUpload] Recording path: $_recordingPath');
    // --- FIX: Read internal _selectedPrompt ---
    print('[AudioUpload] Selected prompt: ${_selectedPrompt?.value}');

    if (_recordingPath == null || _selectedPrompt == null) {
      // --- END FIX ---
      print('[AudioUpload] ERROR: Missing recording path or prompt');
      // Optionally set an error if needed
      // ref.read(errorProvider.notifier).setError(AppError.validation("Please select a prompt and record audio."));
      return false;
    }

    final file = File(_recordingPath!);
    if (!file.existsSync()) {
      print(
          '[AudioUpload] ERROR: File does not exist at path: $_recordingPath');
      return false;
    }

    try {
      // Validate file size
      final fileSize = file.lengthSync();
      print('[AudioUpload] File size: ${fileSize / 1024} KB');

      if (fileSize > _maxAudioSizeBytes) {
        print(
            '[AudioUpload] ERROR: File too large: ${fileSize / 1024 / 1024} MB (max: ${_maxAudioSizeBytes / 1024 / 1024} MB)');
        ref.read(errorProvider.notifier).setError(
              AppError.validation("Audio is too large. Maximum size is 10 MB."),
            );
        return false;
      }

      // Detect MIME type
      final fileName = path.basename(file.path);
      final mimeType =
          lookupMimeType(file.path) ?? 'audio/mpeg'; // Keep default
      print('[AudioUpload] Filename: $fileName');
      print('[AudioUpload] MIME type: $mimeType');

      // Validate audio type
      if (!_supportedAudioTypes.contains(mimeType)) {
        print('[AudioUpload] ERROR: Unsupported audio format: $mimeType');
        ref.read(errorProvider.notifier).setError(
              AppError.validation(
                  "Unsupported audio format. Please use MP3, WAV, OGG, M4A, or other common audio formats."), // Updated message
            );
        return false;
      }

      // Update state (the MediaUploadModel itself)
      print('[AudioUpload] Creating MediaUploadModel state');
      state = MediaUploadModel(
        file: file,
        fileName: fileName,
        fileType: mimeType,
        status: UploadStatus.idle,
      );

      print('[AudioUpload] Audio file prepared successfully (state updated)');
      return true;
    } catch (e, stack) {
      print('[AudioUpload] ERROR preparing audio file: $e');
      print('[AudioUpload] Stack trace: $stack');
      ref
          .read(errorProvider.notifier)
          .setError(AppError.generic("Error preparing audio file."));
      return false;
    }
  }

  // Clear audio state (MediaUploadModel) AND internal variables
  void clearAudio() {
    print('[AudioUpload] Clearing audio state and internal variables');
    state = null;
    _recordingPath = null;
    _selectedPrompt = null; // Also clear the internal selected prompt
  }

  // Upload audio and save to user profile
  Future<bool> uploadAudioAndSaveToProfile() async {
    print('[AudioUpload] Starting uploadAudioAndSaveToProfile');

    // --- FIX: Check internal _selectedPrompt ---
    if (state == null || _selectedPrompt == null) {
      // --- END FIX ---
      print(
          '[AudioUpload] State or prompt is null, attempting to prepare file');
      final prepared = prepareAudioFile();
      if (!prepared) {
        print('[AudioUpload] Failed to prepare audio file');
        // Error should be set within prepareAudioFile
        return false;
      }
      // Re-check state after preparation
      if (state == null) {
        print(
            '[AudioUpload] Error: State is still null after successful preparation.');
        ref.read(errorProvider.notifier).setError(
            AppError.generic("Internal error preparing audio state."));
        return false;
      }
    }

    // --- FIX: Ensure _selectedPrompt is not null again ---
    if (_selectedPrompt == null) {
      print('[AudioUpload] Error: Selected prompt became null unexpectedly.');
      ref.read(errorProvider.notifier).setError(AppError.validation(
          "Audio prompt selection was lost. Please re-select."));
      return false;
    }
    // --- END FIX ---

    try {
      print('[AudioUpload] Clearing any previous errors');
      ref.read(errorProvider.notifier).clearError();

      // Update state to show upload in progress
      print('[AudioUpload] Setting state to UPLOADING');
      // Use the state that was confirmed/set after prepareAudioFile
      state = state!.copyWith(status: UploadStatus.inProgress);

      // Get presigned URL for audio
      print('[AudioUpload] Getting presigned URL for ${state!.fileName}');
      final presignedUrlResponse = await _mediaRepository.getAudioPresignedUrl(
        state!.fileName,
        state!.fileType,
        _selectedPrompt!, // Use the validated internal prompt
      );

      print(
          '[AudioUpload] Received presigned URL response: ${presignedUrlResponse.toString().substring(0, min(100, presignedUrlResponse.toString().length))}...'); // Safely print start

      // Update state with presigned URL
      print('[AudioUpload] Updating state with presigned URL');
      state = state!.copyWith(
        presignedUrl: () => presignedUrlResponse['url'],
      );

      // Upload audio to S3
      print('[AudioUpload] Uploading file to S3');
      bool success = await _mediaRepository.uploadFileToS3(state!);
      print('[AudioUpload] Initial upload result: $success');

      // If failed, retry
      if (!success) {
        print('[AudioUpload] Initial upload failed, retrying...');
        success = await _mediaRepository.retryUpload(state!);
        print('[AudioUpload] Retry upload result: $success');
      }

      // Update state with result
      print(
          '[AudioUpload] Setting final upload status: ${success ? "SUCCESS" : "FAILED"}');
      state = state!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload audio',
      );

      if (success) {
        // Create AudioPromptModel
        print(
            '[AudioUpload] Creating AudioPromptModel with prompt: ${_selectedPrompt!.value}');
        final audioPromptModel = AudioPromptModel(
          prompt: _selectedPrompt!, // Use the internal prompt
          audioUrl: presignedUrlResponse['url'],
        );

        // Add to user model
        print('[AudioUpload] Updating user model with audio prompt');
        ref.read(userProvider.notifier).updateAudioPrompt(audioPromptModel);
        print('[AudioUpload] User model updated successfully');
      } else {
        // If upload failed, set error if not already set by repo/service
        if (ref.read(errorProvider) == null) {
          ref
              .read(errorProvider.notifier)
              .setError(AppError.network("Failed to upload audio to storage."));
        }
      }

      return success;
    } catch (e, stack) {
      print('[AudioUpload] ERROR during upload: $e');
      print('[AudioUpload] Stack trace: $stack');

      if (state != null) {
        state = state!.copyWith(
          status: UploadStatus.failed,
          errorMessage: () => 'Failed to upload audio: ${e.toString()}',
        );
      }
      // Set error if not already set
      if (ref.read(errorProvider) == null) {
        if (e is ApiException) {
          ref.read(errorProvider.notifier).setError(AppError.server(e.message));
        } else {
          ref.read(errorProvider.notifier).setError(AppError.generic(
              "An unexpected error occurred during audio upload."));
        }
      }
      return false;
    }
  }

  // Get the selected prompt (public getter for the internal state)
  AudioPrompt? get selectedPrompt => _selectedPrompt;

  // --- FIX: Update setSelectedPrompt to accept nullable AudioPrompt ---
  // Set the selected prompt (updates internal state)
  void setSelectedPrompt(AudioPrompt? prompt) {
    // --- END FIX ---
    print('[AudioUpload] Setting selected prompt: ${prompt?.value}');
    _selectedPrompt = prompt;
    // Note: This does NOT change the main `state` (MediaUploadModel) directly.
    // It only updates the internal variable used for validation and API calls.
  }
}



================================================
File: providers/auth_provider.dart
================================================
// File: providers/auth_provider.dart
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import providers to invalidate
import 'package:dtx/providers/filter_provider.dart';
import 'package:dtx/providers/matches_provider.dart';
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../models/error_model.dart';
import '../repositories/auth_repository.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import 'error_provider.dart';
import 'service_provider.dart';

// Provider for GoogleSignIn instance (remains the same)
final googleSignInProvider = Provider<GoogleSignIn>((ref) {
  return GoogleSignIn(
    scopes: ['email', 'profile'],
  );
});

// AuthProvider definition (remains the same)
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final authRepository = ref.watch(authRepositoryProvider);
  // *** Pass ref to the notifier ***
  return AuthNotifier(ref, authRepository);
});

class AuthNotifier extends StateNotifier<AuthState> {
  // *** Store the Ref object ***
  final Ref ref;
  final AuthRepository _authRepository;

  // *** Modify constructor to accept Ref ***
  AuthNotifier(this.ref, this._authRepository) : super(const AuthState()) {
    _loadTokenAndCheckStatus();
  }

  // _loadTokenAndCheckStatus, checkAuthStatus, signInWithGoogle remain the same

  Future<void> _loadTokenAndCheckStatus() async {
    print('[AuthNotifier] Loading token and checking initial status...');
    state = state.copyWith(isLoading: true);
    final token = await TokenStorage.getToken();
    if (token != null && token.isNotEmpty) {
      print(
          '[AuthNotifier] Token found, setting in state and checking status.');
      state = state.copyWith(jwtToken: () => token);
      await checkAuthStatus(updateState: true); // Check status if token exists
    } else {
      print('[AuthNotifier] No token found, setting state to login.');
      // If no token, status is definitely login
      state = state.copyWith(
          isLoading: false, authStatus: AuthStatus.login, jwtToken: () => null);
    }
  }

  Future<AuthStatus> checkAuthStatus({bool updateState = true}) async {
    print('[AuthNotifier checkAuthStatus] Called. updateState: $updateState');
    if (updateState) {
      state = state.copyWith(isLoading: true, error: () => null);
    }

    // Use token from state if available, otherwise try storage
    final token = state.jwtToken ?? await TokenStorage.getToken();

    // If still no token, return login status immediately
    if (token == null || token.isEmpty) {
      print(
          '[AuthNotifier checkAuthStatus] No token available, returning login status.');
      if (updateState) {
        state = state.copyWith(
            isLoading: false,
            authStatus: AuthStatus.login,
            jwtToken: () => null);
      }
      return AuthStatus.login;
    }

    try {
      final backendStatus = await _authRepository.checkAuthStatus(token);
      print(
          '[AuthNotifier checkAuthStatus] Backend status received: $backendStatus');

      if (updateState) {
        state = state.copyWith(
          isLoading: false,
          authStatus: backendStatus,
          // Keep the token in state if status is not login
          // No need to clear token here unless backendStatus is login
          jwtToken: backendStatus == AuthStatus.login ? () => null : null,
        );
        if (backendStatus == AuthStatus.login) {
          print(
              '[AuthNotifier checkAuthStatus] Status is login, removing token from storage.');
          await TokenStorage.removeToken(); // Also remove from storage
        }
      }
      print(
          '[AuthNotifier checkAuthStatus] Finished. Returning: $backendStatus');
      return backendStatus;
    } catch (e) {
      print('[AuthNotifier checkAuthStatus] Error: $e');
      if (updateState) {
        state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login, // Default to login on error
          error: () => 'Failed to check status: ${e.toString()}',
          jwtToken: () => null, // Clear token on error
        );
        print(
            '[AuthNotifier checkAuthStatus] Error occurred, removing token from storage.');
        await TokenStorage.removeToken(); // Also remove from storage
      }
      return AuthStatus.login; // Return login on error
    }
  }

  Future<AuthStatus> signInWithGoogle() async {
    print('[AuthNotifier signInWithGoogle] Attempting Google Sign-In...');
    state = state.copyWith(isLoading: true, error: () => null);
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors

    try {
      final googleSignIn = ref.read(googleSignInProvider);
      final googleUser = await googleSignIn.signIn(); // Prompts user

      if (googleUser == null) {
        print('[AuthNotifier signInWithGoogle] User cancelled Google Sign-In.');
        state = state.copyWith(isLoading: false, authStatus: AuthStatus.login);
        return AuthStatus.login; // User cancelled
      }

      print(
          '[AuthNotifier signInWithGoogle] Google Sign-In successful for: ${googleUser.email}');
      final googleAuth = await googleUser.authentication;
      final googleAccessToken = googleAuth.accessToken;

      if (googleAccessToken == null) {
        print(
            '[AuthNotifier signInWithGoogle] Failed to get Google Access Token.');
        throw ApiException('Could not retrieve access token from Google.');
      }

      print(
          '[AuthNotifier signInWithGoogle] Verifying Google Access Token with backend...');
      final appJwt = await _authRepository.verifyGoogleToken(googleAccessToken);
      print(
          '[AuthNotifier signInWithGoogle] Backend verification successful. App JWT received.');

      await TokenStorage.saveToken(appJwt);
      print('[AuthNotifier signInWithGoogle] App JWT saved to storage.');

      // IMPORTANT: After successful login and getting the JWT,
      // immediately check the status with the backend to know the next step.
      state = state.copyWith(jwtToken: () => appJwt); // Set token in state
      print(
          '[AuthNotifier signInWithGoogle] JWT set in state. Checking auth status...');
      final finalStatus = await checkAuthStatus(
          updateState: true); // Update state with final status

      print(
          '[AuthNotifier signInWithGoogle] Sign-in process complete. Final Status: $finalStatus');
      return finalStatus; // Return the status determined by checkAuthStatus
    } on ApiException catch (e) {
      print('[AuthNotifier signInWithGoogle] API Exception: ${e.message}');
      state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login,
          error: () => e.message);
      ref.read(errorProvider.notifier).setError(AppError.auth(e.message));
      await logout(); // Clear any potentially saved invalid token
      return AuthStatus.login;
    } catch (e) {
      print(
          '[AuthNotifier signInWithGoogle] Unexpected Error: ${e.toString()}');
      state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login,
          error: () => 'An unexpected error occurred during sign-in.');
      ref.read(errorProvider.notifier).setError(
          AppError.auth("An unexpected error occurred. Please try again."));
      await logout(); // Clear any potentially saved invalid token
      return AuthStatus.login;
    }
  }

  // Logout user
  Future<void> logout() async {
    print('[AuthNotifier] Logging out...');
    final currentToken = state.jwtToken ?? await TokenStorage.getToken();

    try {
      final googleSignIn = ref.read(googleSignInProvider);
      await googleSignIn.signOut(); // Sign out from Google
      await googleSignIn.disconnect().catchError((e) {
        // Catch errors during disconnect specifically, as it can sometimes fail
        print('[AuthNotifier] Non-critical error during Google disconnect: $e');
      });
    } catch (e) {
      print('[AuthNotifier] Error during Google Sign Out: $e');
      // Decide if you want to proceed with app logout even if Google logout fails
    } finally {
      await TokenStorage.removeToken(); // Remove app token *always*
      print('[AuthNotifier] Token removed from storage.');

      // Reset auth state *first*
      state = const AuthState(authStatus: AuthStatus.login);
      print('[AuthNotifier] Auth state reset to login.');

      // *** Invalidate other user-specific providers ***
      print('[AuthNotifier] Invalidating user-specific providers...');
      ref.invalidate(userProvider);
      ref.invalidate(feedProvider);
      ref.invalidate(receivedLikesProvider);
      ref.invalidate(filterProvider);
      ref.invalidate(matchesProvider); // <--- ADD THIS LINE
      // Add any other providers that store user-specific data here
      // e.g., ref.invalidate(chatProvider);
      // e.g., ref.invalidate(likerProfileProvider); // .family needs specific handling if needed globally
      print('[AuthNotifier] Providers invalidated.');

      // Optionally, you could call a backend logout endpoint if you have one
      // if (currentToken != null) {
      //   try {
      //     await _authRepository.logoutBackend(currentToken);
      //     print('[AuthNotifier] Backend logout successful.');
      //   } catch (e) {
      //     print('[AuthNotifier] Backend logout failed (non-critical): $e');
      //   }
      // }

      print('[AuthNotifier] Local logout complete.');
    }
  }
}



================================================
File: providers/conversation_provider.dart
================================================
// File: lib/providers/conversation_provider.dart
import 'dart:async';
import 'package:dtx/models/chat_message.dart';
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/service_provider.dart'; // Keep for repository provider
import 'package:dtx/providers/status_provider.dart';
import 'package:dtx/repositories/chat_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/foundation.dart';

// --- ConversationData Class (No change needed) ---
class ConversationData {
  final List<ChatMessage> messages;
  final bool otherUserIsOnline;
  final DateTime? otherUserLastOnline;
  ConversationData(
      {required this.messages,
      required this.otherUserIsOnline,
      this.otherUserLastOnline});
}
// ---

// --- ConversationState Class (MODIFIED) ---
class ConversationState {
  final bool isLoading;
  final List<ChatMessage> messages;
  final AppError? error;
  final bool otherUserIsOnline;
  final DateTime? otherUserLastOnline;
  // *** ADDED: Field to track the message being replied to ***
  final ChatMessage? replyingToMessage;
  // *** END ADDED ***

  const ConversationState({
    this.isLoading = false,
    this.messages = const [],
    this.error,
    this.otherUserIsOnline = false,
    this.otherUserLastOnline,
    this.replyingToMessage, // *** ADDED: Default null ***
  });

  // --- MODIFIED: copyWith ---
  ConversationState copyWith({
    bool? isLoading,
    List<ChatMessage>? messages,
    AppError? Function()? error,
    bool? otherUserIsOnline,
    DateTime? Function()? otherUserLastOnline,
    // *** ADDED: Parameter for replyingToMessage ***
    // Use nullable function to allow clearing (setting to null)
    ChatMessage? Function()? replyingToMessage,
    // *** END ADDED ***
  }) {
    return ConversationState(
      isLoading: isLoading ?? this.isLoading,
      messages: messages ?? this.messages,
      error: error != null ? error() : this.error,
      otherUserIsOnline: otherUserIsOnline ?? this.otherUserIsOnline,
      otherUserLastOnline: otherUserLastOnline != null
          ? otherUserLastOnline()
          : this.otherUserLastOnline,
      // *** ADDED: Assign replyingToMessage ***
      replyingToMessage: replyingToMessage != null
          ? replyingToMessage()
          : this.replyingToMessage,
      // *** END ADDED ***
    );
  }
  // --- END MODIFIED ---
}
// --- END ConversationState ---

class ConversationNotifier extends StateNotifier<ConversationState> {
  final ChatRepository _chatRepository;
  final int _otherUserId;

  ConversationNotifier(this._chatRepository, this._otherUserId)
      : super(const ConversationState()) {
    print("[Provider Init: $_otherUserId] Fetching initial messages...");
    fetchMessages();
  }

  // --- updateOtherUserStatus (No change needed) ---
  void updateOtherUserStatus(bool isOnline, DateTime eventTimestamp) {
    if (!mounted) {
      print(
          "[Provider UpdateStatus WS: $_otherUserId] Not mounted, ignoring update.");
      return;
    }
    if (state.otherUserIsOnline != isOnline) {
      print(
          "[Provider UpdateStatus WS: $_otherUserId] Updating status from ${state.otherUserIsOnline} to $isOnline via WebSocket event.");
      final newLastOnline = isOnline ? null : eventTimestamp;
      state = state.copyWith(
        otherUserIsOnline: isOnline,
        otherUserLastOnline: () => newLastOnline,
      );
      print(
          "[Provider UpdateStatus WS: $_otherUserId] State updated: isOnline=$isOnline, lastOnline=$newLastOnline");
    } else {
      if (kDebugMode)
        print(
            "[Provider UpdateStatus WS: $_otherUserId] Received status update, but otherUserIsOnline ($isOnline) is already the same. No state change needed.");
    }
  }

  // --- fetchMessages (No change needed) ---
  Future<void> fetchMessages() async {
    if (state.isLoading) {
      print(
          "[Provider Fetch: $_otherUserId] Skipping fetch: isLoading=${state.isLoading}");
      return;
    }
    print(
        "[Provider Fetch: $_otherUserId] Fetching ALL messages and status via API...");
    state = state.copyWith(isLoading: true, error: () => null);
    try {
      final ConversationData conversationData =
          await _chatRepository.fetchConversation(otherUserId: _otherUserId);

      if (mounted) {
        bool statusBeforeAPISet = state.otherUserIsOnline;
        DateTime? lastOnlineBeforeAPISet = state.otherUserLastOnline;
        final oldMessagesHashCode = state.messages.hashCode;
        final reversedMessages = conversationData.messages.reversed.toList();
        state = state.copyWith(
          isLoading: false,
          messages: reversedMessages,
          otherUserIsOnline: conversationData.otherUserIsOnline,
          otherUserLastOnline: () => conversationData.otherUserLastOnline,
        );
        print(
            "[Provider Fetch: $_otherUserId] API Fetch completed. Fetched ${conversationData.messages.length} messages. Stored ${reversedMessages.length} (Newest first). API Status Set: isOnline=${state.otherUserIsOnline}, lastOnline=${state.otherUserLastOnline}. List hashCode changed: ${state.messages.hashCode != oldMessagesHashCode}");
        if (kDebugMode &&
            (statusBeforeAPISet != state.otherUserIsOnline ||
                lastOnlineBeforeAPISet != state.otherUserLastOnline)) {
          print(
              "[Provider Fetch: $_otherUserId] Note: API status set. If a WS update occurred during fetch, it might be momentarily overwritten until the *next* WS event.");
        }
      }
    } on ApiException catch (e) {
      print(
          "[Provider Fetch Error: $_otherUserId] API Exception: ${e.message}");
      if (mounted) {
        state = state.copyWith(
            isLoading: false, error: () => AppError.server(e.message));
      }
    } catch (e, stacktrace) {
      print("[Provider Fetch Error: $_otherUserId] Unexpected Error: $e");
      print(stacktrace);
      if (mounted) {
        state = state.copyWith(
            isLoading: false,
            error: () => AppError.generic("Failed to load conversation."));
      }
    }
  }

  // --- addSentMessage (No change needed) ---
  void addSentMessage(ChatMessage message) {
    if (!mounted) return;
    print(
        "[Provider AddSent: $_otherUserId] Adding message to START: TempID=${message.tempId}, RealID=${message.messageID}, Status=${message.status}, Type=${message.isMedia ? message.mediaType : 'text'}");
    final oldMessagesHashCode = state.messages.hashCode;
    // *** ADDED: Clear reply state when adding a new SENT message ***
    state = state.copyWith(
      messages: [message, ...state.messages],
      replyingToMessage: () => null, // Clear reply state after sending
    );
    // *** END ADDED ***
    print(
        "[Provider AddSent: $_otherUserId] Message added to start. Reply state cleared. List hashCode changed: ${state.messages.hashCode != oldMessagesHashCode}. New count: ${state.messages.length}");
  }

  // --- addReceivedMessage (No change needed) ---
  void addReceivedMessage(ChatMessage message) {
    if (!mounted) return;
    print(
        "[Provider AddRcvd: $_otherUserId] Adding received message to START: RealID=${message.messageID}, Type=${message.isMedia ? message.mediaType : 'text'}");
    final oldMessagesHashCode = state.messages.hashCode;
    state = state.copyWith(messages: [message, ...state.messages]);
    print(
        "[Provider AddRcvd: $_otherUserId] Message added to start. List hashCode changed: ${state.messages.hashCode != oldMessagesHashCode}. New count: ${state.messages.length}");
  }

  // --- updateMessageStatus (No change needed) ---
  void updateMessageStatus(String tempOrRealId, ChatMessageStatus newStatus,
      {int? finalMessageId, String? finalMediaUrl, String? errorMessage}) {
    if (!mounted) return;
    print(
        "[Provider UpdateStatus API: $_otherUserId] Attempting update: ID=$tempOrRealId, NewStatus=$newStatus, FinalMsgID=$finalMessageId, FinalURL=${finalMediaUrl != null}, Error=${errorMessage != null}");
    final currentMessages = state.messages;
    final messageIndex = currentMessages.indexWhere((msg) =>
        (msg.tempId != null && msg.tempId == tempOrRealId) ||
        (msg.messageID != 0 && msg.messageID.toString() == tempOrRealId));
    if (messageIndex != -1) {
      final messageToUpdate = currentMessages[messageIndex];
      print(
          "[Provider UpdateStatus API: $_otherUserId] Found message at index $messageIndex (Newest=0). Current Status=${messageToUpdate.status}");
      final updatedMessage = messageToUpdate.copyWith(
        status: newStatus,
        messageID: finalMessageId ?? messageToUpdate.messageID,
        mediaUrl: finalMediaUrl,
        errorMessage: errorMessage,
        clearErrorMessage: errorMessage == null,
        clearLocalFilePath: false,
      );
      final updatedMessages = List<ChatMessage>.from(currentMessages);
      updatedMessages[messageIndex] = updatedMessage;
      final oldMessagesHashCode = state.messages.hashCode;
      final oldListIdentityHashCode = identityHashCode(state.messages);
      state = state.copyWith(messages: updatedMessages);
      final newListIdentityHashCode = identityHashCode(state.messages);
      print(
          "[Provider UpdateStatus API: $_otherUserId] Status updated for ID $tempOrRealId. RealID: ${updatedMessage.messageID}, NewStatus: ${updatedMessage.status}. List hashCode changed: ${state.messages.hashCode != oldMessagesHashCode}. List instance changed: ${oldListIdentityHashCode != newListIdentityHashCode}");
    } else {
      print(
          "[Provider UpdateStatus API: $_otherUserId] WARNING: Could not find message with Temp/Real ID $tempOrRealId to update status.");
    }
  }

  // *** ADDED: Methods to manage reply state ***
  void startReplying(ChatMessage messageToReply) {
    if (!mounted) return;
    print(
        "[Provider Reply: $_otherUserId] Starting reply to Message ID: ${messageToReply.messageID}");
    state = state.copyWith(replyingToMessage: () => messageToReply);
  }

  void cancelReply() {
    if (!mounted) return;
    if (state.replyingToMessage != null) {
      print("[Provider Reply: $_otherUserId] Cancelling reply.");
      state = state.copyWith(replyingToMessage: () => null);
    }
  }
  // *** END ADDED ***
}

// --- Provider Definition (No change needed) ---
final conversationProvider = StateNotifierProvider.family
    .autoDispose<ConversationNotifier, ConversationState, int>(
        (ref, otherUserId) {
  final repo = ref.watch(chatRepositoryProvider);
  final notifier = ConversationNotifier(repo, otherUserId);
  final statusSubscription =
      ref.listen<UserStatusUpdate?>(userStatusUpdateProvider, (prev, next) {
    if (next != null && next.userId == otherUserId) {
      notifier.updateOtherUserStatus(next.isOnline, next.timestamp);
    }
  });
  ref.onDispose(() {
    print(
        "[Provider Dispose Hook: $otherUserId] Cancelling status listener subscription.");
    statusSubscription.close();
  });
  return notifier;
});
// --- END Provider Definition ---



================================================
File: providers/error_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/error_model.dart';

final errorProvider = StateNotifierProvider<ErrorNotifier, AppError?>((ref) {
  return ErrorNotifier();
});

class ErrorNotifier extends StateNotifier<AppError?> {
  ErrorNotifier() : super(null);

  void setError(AppError error) => state = error;
  void clearError() => state = null;
}



================================================
File: providers/feed_provider.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/user_model.dart'; // Use full UserModel
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/user_repository.dart';
import 'package:dtx/services/api_service.dart';
// Removed FeedType import
import 'package:flutter_riverpod/flutter_riverpod.dart';

// --- Removed QuickFeedState ---

// --- Home Feed State ---
class HomeFeedState {
  final bool isLoading;
  final List<UserModel> profiles; // Use full UserModel for Home Feed
  final AppError? error;
  final bool hasFetchedOnce; // Track if initial fetch happened
  final bool hasMore; // Track if API indicates more profiles available

  const HomeFeedState({
    this.isLoading = false, // Start not loading until fetch is called
    this.profiles = const [],
    this.error,
    this.hasFetchedOnce = false,
    this.hasMore = true, // Assume more initially
  });

  HomeFeedState copyWith({
    bool? isLoading,
    List<UserModel>? profiles,
    AppError? Function()? error,
    bool? hasFetchedOnce,
    bool? hasMore,
  }) {
    return HomeFeedState(
      isLoading: isLoading ?? this.isLoading,
      profiles: profiles ?? this.profiles,
      error: error != null ? error() : this.error,
      hasFetchedOnce: hasFetchedOnce ?? this.hasFetchedOnce,
      hasMore: hasMore ?? this.hasMore,
    );
  }
}

// --- Simplified Feed Notifier (Only Home Feed) ---
class FeedNotifier extends StateNotifier<HomeFeedState> {
  final UserRepository _userRepository;
  final Ref _ref;

  FeedNotifier(this._userRepository, this._ref) : super(const HomeFeedState());

  Future<void> fetchFeed({bool forceRefresh = false}) async {
    print("[FeedNotifier] fetchFeed called. forceRefresh: $forceRefresh");

    if (state.isLoading) {
      print("[FeedNotifier] Skipping fetch (already loading).");
      return;
    }
    // If already fetched and not forcing refresh, and we have profiles or know there are no more, skip
    if (state.hasFetchedOnce &&
        !forceRefresh &&
        (state.profiles.isNotEmpty || !state.hasMore)) {
      print(
          "[FeedNotifier] Skipping fetch (already fetched & no force required). Has Profiles: ${state.profiles.isNotEmpty}, Has More: ${state.hasMore}");
      return;
    }

    state = state.copyWith(isLoading: true, error: () => null);

    try {
      // Directly fetch home feed profiles
      final result = await _userRepository
          .fetchHomeFeed(); // Assuming repo returns Map now
      final profiles = result['profiles'] as List<UserModel>;
      final hasMore =
          result['has_more'] as bool? ?? false; // Default to false if missing

      print(
          "[FeedNotifier] Fetched ${profiles.length} home profiles. Has More: $hasMore");
      if (!mounted) return;

      state = HomeFeedState(
        isLoading: false,
        profiles: profiles,
        error: null,
        hasFetchedOnce: true, // Mark as fetched
        hasMore: hasMore, // Update hasMore status
      );
    } on ApiException catch (e) {
      print("[FeedNotifier] API Exception: ${e.message}");
      if (!mounted) return;
      state = state.copyWith(
        isLoading: false,
        error: () => AppError.server(e.message),
        hasFetchedOnce:
            true, // Mark as fetched even on error to prevent reload loops
        hasMore: false, // Assume no more on error
      );
    } catch (e) {
      print("[FeedNotifier] Unexpected Error: ${e.toString()}");
      if (!mounted) return;
      state = state.copyWith(
        isLoading: false,
        error: () => AppError.generic("Failed to load feed."),
        hasFetchedOnce: true,
        hasMore: false,
      );
    }
  }

  // Method to remove a profile after interaction
  void removeProfile(int userId) {
    print("[FeedNotifier] Removing profile ID: $userId");
    if (!mounted) return;
    final updatedProfiles =
        state.profiles.where((profile) => profile.id != userId).toList();

    state = state.copyWith(profiles: updatedProfiles);

    // Optional: Fetch more if the list gets too small and we know there are more
    if (updatedProfiles.length < 3 && state.hasMore && !state.isLoading) {
      print(
          "[FeedNotifier] Profile list low (<3) and hasMore=true, fetching more...");
      fetchFeed(); // Fetch more without forcing refresh
    } else if (updatedProfiles.isEmpty && !state.hasMore) {
      print("[FeedNotifier] Profile list empty and hasMore=false.");
      // State already reflects empty list
    }
  }
}

// --- Provider Definition ---
final feedProvider = StateNotifierProvider<FeedNotifier, HomeFeedState>((ref) {
  final userRepository = ref.watch(userRepositoryProvider);
  return FeedNotifier(userRepository, ref);
});



================================================
File: providers/filter_provider.dart
================================================
// File: lib/providers/filter_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import feed provider
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/filter_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// --- StateNotifier Provider (No change) ---
final filterProvider =
    StateNotifierProvider<FilterNotifier, FilterSettings>((ref) {
  final filterRepository = ref.watch(filterRepositoryProvider);
  return FilterNotifier(ref, filterRepository);
});

// --- StateNotifier ---
class FilterNotifier extends StateNotifier<FilterSettings> {
  final Ref ref;
  final FilterRepository _filterRepository;
  bool _isLoading = false; // Internal loading state
  bool get isLoading => _isLoading; // Getter for UI

  FilterNotifier(this.ref, this._filterRepository)
      : super(const FilterSettings()) {
    // Optionally load filters on initialization if needed, or rely on UI trigger
    // loadFilters();
  }

  // Load filters from the repository (No change)
  Future<void> loadFilters({bool forceRemote = false}) async {
    // Prevent multiple fetches if already loading or if data exists and not forced
    if (_isLoading || (state != const FilterSettings() && !forceRemote)) {
      return;
    }
    _setLoading(true);
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors

    try {
      final filters = await _filterRepository.fetchFilters();
      if (mounted) {
        state = filters; // Update state
      }
    } catch (e) {
      if (mounted) {
        ref
            .read(errorProvider.notifier)
            .setError(AppError.generic("Could not load filter settings."));
        // Don't reset to default, keep previous state or handle error UI
      }
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  // Save filters (used by full dialog)
  Future<bool> saveFilters(FilterSettings newFilters) async {
    if (_isLoading) return false;
    _setLoading(true);
    ref.read(errorProvider.notifier).clearError();
    final previousState = state; // Keep old state in case of failure
    state = newFilters; // Optimistically update UI

    try {
      final success = await _filterRepository.updateFilters(newFilters);
      if (!success) {
        // If API returns false, revert state and show error
        if (mounted) {
          state = previousState;
          ref
              .read(errorProvider.notifier)
              .setError(AppError.server("Failed to save filters."));
        }
        return false;
      }
      // Refresh feed after saving from the *full* dialog as well
      print("[FilterNotifier] Filters saved via full dialog. Refreshing feed.");
      ref.read(feedProvider.notifier).fetchFeed(forceRefresh: true);
      return true; // Success
    } on ApiException catch (e) {
      if (mounted) {
        state = previousState; // Revert state on error
        ref.read(errorProvider.notifier).setError(AppError.server(e.message));
      }
      return false;
    } catch (e) {
      if (mounted) {
        state = previousState; // Revert state on error
        ref
            .read(errorProvider.notifier)
            .setError(AppError.generic("An unexpected error occurred."));
      }
      return false;
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  // Helper to manage internal loading state (No change)
  void _setLoading(bool loading) {
    if (_isLoading != loading) {
      _isLoading = loading;
    }
  }

  // Method to update a single filter value in the *state* (No change)
  // Ensures immutability by using copyWith
  void updateSingleFilter<T>(T value, FilterField field) {
    if (_isLoading) return; // Prevent updates while saving/loading
    print("[FilterNotifier] Updating single filter state $field to $value");
    state = state.copyWith(
      whoYouWantToSee: field == FilterField.whoYouWantToSee
          ? () => value as FilterGenderPref?
          : null,
      radiusKm: field == FilterField.radiusKm ? () => value as int? : null,
      activeToday:
          field == FilterField.activeToday ? () => value as bool? : null,
      ageMin: field == FilterField.ageMin ? () => value as int? : null,
      ageMax: field == FilterField.ageMax ? () => value as int? : null,
    );
  }

  // --- *** NEW METHOD: Save Current State *** ---
  // Saves the current state held by the notifier to the backend
  Future<bool> saveCurrentFilterState() async {
    if (_isLoading) return false;
    _setLoading(true);
    ref.read(errorProvider.notifier).clearError();
    print("[FilterNotifier] Saving current filter state via API: ${state.toJsonForApi()}");

    try {
      final success = await _filterRepository.updateFilters(state); // Pass current state
      if (!success) {
        if (mounted) {
          // Error is likely set by repo, but add fallback
          if (ref.read(errorProvider) == null) {
            ref.read(errorProvider.notifier).setError(AppError.server("Failed to save filter change."));
          }
        }
        print("[FilterNotifier] Failed to save current filter state via API.");
        return false;
      }
      // Filters saved, now refresh feed
      print("[FilterNotifier] Current filter state saved successfully via API. Refreshing feed.");
      ref.read(feedProvider.notifier).fetchFeed(forceRefresh: true);
      return true; // Success
    } on ApiException catch (e) {
      if (mounted) {
        ref.read(errorProvider.notifier).setError(AppError.server(e.message));
      }
       print("[FilterNotifier] API Exception saving current filter state: ${e.message}");
      return false;
    } catch (e) {
       if (mounted) {
         ref.read(errorProvider.notifier).setError(AppError.generic("An unexpected error occurred saving filter."));
      }
      print("[FilterNotifier] Unexpected error saving current filter state: $e");
      return false;
    } finally {
      if (mounted) _setLoading(false);
    }
  }
  // --- *** END NEW METHOD *** ---
}

// Enum to identify which filter field is being updated (No change)
enum FilterField { whoYouWantToSee, radiusKm, activeToday, ageMin, ageMax }



================================================
File: providers/liker_profile_provider.dart
================================================
// File: providers/liker_profile_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State Definition
class LikerProfileState {
  final bool isLoading;
  final UserProfileData? profile;
  final LikeInteractionDetails? likeDetails;
  final AppError? error;

  const LikerProfileState({
    this.isLoading = true, // Start loading
    this.profile,
    this.likeDetails,
    this.error,
  });

  LikerProfileState copyWith({
    bool? isLoading,
    UserProfileData? Function()? profile, // Nullable functions
    LikeInteractionDetails? Function()? likeDetails,
    AppError? Function()? error,
  }) {
    return LikerProfileState(
      isLoading: isLoading ?? this.isLoading,
      profile: profile != null ? profile() : this.profile,
      likeDetails: likeDetails != null ? likeDetails() : this.likeDetails,
      error: error != null ? error() : this.error,
    );
  }
}

// StateNotifier Definition
class LikerProfileNotifier extends StateNotifier<LikerProfileState> {
  final LikeRepository _likeRepository;
  final int _likerUserId;

  LikerProfileNotifier(this._likeRepository, this._likerUserId)
      : super(const LikerProfileState()) {
    fetchProfile(); // Fetch profile on initialization
  }

  Future<void> fetchProfile() async {
    print(
        "[LikerProfileNotifier] Fetching profile for liker ID: $_likerUserId");
    // Don't clear profile/details on refetch, only on error maybe?
    state = state.copyWith(isLoading: true, error: () => null);
    try {
      final result = await _likeRepository.fetchLikerProfile(_likerUserId);
      final profileData = result['profile'] as UserProfileData?;
      final likeDetailsData = result['likeDetails'] as LikeInteractionDetails?;

      if (profileData != null && likeDetailsData != null) {
        print("[LikerProfileNotifier] Fetch successful.");
        state = state.copyWith(
          isLoading: false,
          profile: () => profileData,
          likeDetails: () => likeDetailsData,
          error: () => null,
        );
      } else {
        // This case should ideally be caught by the repository throwing an exception
        print(
            "[LikerProfileNotifier] Fetch failed: Repository returned null data.");
        state = state.copyWith(
            isLoading: false,
            error: () => AppError.server("Failed to load profile data."));
      }
    } on ApiException catch (e) {
      print("[LikerProfileNotifier] API Exception: ${e.message}");
      // Handle 404 Not Found specifically maybe
      if (e.statusCode == 404) {
        state = state.copyWith(
            isLoading: false,
            error: () => AppError.server(
                "Profile not found or you were not liked by this user."));
      } else {
        state = state.copyWith(
            isLoading: false, error: () => AppError.server(e.message));
      }
    } catch (e) {
      print("[LikerProfileNotifier] Unexpected Error: ${e.toString()}");
      state = state.copyWith(
          isLoading: false,
          error: () => AppError.generic("Failed to load profile."));
    }
  }
}

// Provider Definition (.family)
final likerProfileProvider =
    StateNotifierProvider.family<LikerProfileNotifier, LikerProfileState, int>(
        (ref, likerUserId) {
  final likeRepository = ref.watch(likeRepositoryProvider);
  return LikerProfileNotifier(likeRepository, likerUserId);
});



================================================
File: providers/location_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:geolocator/geolocator.dart';
import '../models/error_model.dart';
import '../models/location_model.dart';
import 'error_provider.dart';
import 'user_provider.dart';

final locationProvider =
    StateNotifierProvider<LocationNotifier, LocationState>((ref) {
  return LocationNotifier(ref);
});

class LocationNotifier extends StateNotifier<LocationState> {
  final Ref ref;

  LocationNotifier(this.ref) : super(LocationState());

  void setMapReady(bool ready) {
    state = state.copyWith(isMapReady: ready);
  }

  Future<void> openLocationSettings() async {
    try {
      await Geolocator.openLocationSettings();
    } catch (e) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.network("Failed to open location settings"));
    }
  }

  Future<void> fetchCurrentLocation() async {
    // Clear any existing errors
    ref.read(errorProvider.notifier).clearError();

    // Reset state for fresh fetch
    state = state.copyWith(
      isFetching: true,
      isLoading: true,
      cachedLatitude: null,
      cachedLongitude: null,
    );

    try {
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        ref.read(errorProvider.notifier).setError(
            AppError.locationService("Location services are disabled"));
        state = state.copyWith(isLoading: false);
        return;
      }

      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          ref
              .read(errorProvider.notifier)
              .setError(AppError.validation("Location permissions are denied"));
          state = state.copyWith(isLoading: false);
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Location permissions are permanently denied"));
        state = state.copyWith(isLoading: false);
        return;
      }

      Position position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.high);

      final newLatitude = position.latitude;
      final newLongitude = position.longitude;

      // Update user provider with the location
      ref.read(userProvider.notifier).updateLocation(newLatitude, newLongitude);

      state = state.copyWith(
        latitude: newLatitude,
        longitude: newLongitude,
        cachedLatitude: newLatitude,
        cachedLongitude: newLongitude,
        isLoading: false,
      );
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
          AppError.network("Failed to fetch location: ${e.toString()}"));
      state = state.copyWith(isLoading: false);
    } finally {
      state = state.copyWith(isFetching: false);
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(latitude: latitude, longitude: longitude);
    ref.read(userProvider.notifier).updateLocation(latitude, longitude);
  }

  void useCachedLocation() {
    if (state.cachedLatitude != null && state.cachedLongitude != null) {
      updateLocation(state.cachedLatitude!, state.cachedLongitude!);
    }
  }
}



================================================
File: providers/matches_provider.dart
================================================
// File: lib/providers/matches_provider.dart
import 'dart:async';
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/user_model.dart'; // Using UserModel as MatchUser
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/providers/status_provider.dart'; // <-- IMPORT ADDED
import 'package:dtx/repositories/match_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/foundation.dart'; // <-- IMPORT ADDED

// --- MatchesState remains the same ---
class MatchesState {
  final bool isLoading;
  final List<UserModel> matches;
  final AppError? error;

  const MatchesState({
    this.isLoading = false,
    this.matches = const [],
    this.error,
  });

  MatchesState copyWith({
    bool? isLoading,
    List<UserModel>? matches,
    AppError? Function()? error,
  }) {
    return MatchesState(
      isLoading: isLoading ?? this.isLoading,
      matches: matches ?? this.matches,
      error: error != null ? error() : this.error,
    );
  }
}
// --- End MatchesState ---

class MatchesNotifier extends StateNotifier<MatchesState> {
  final MatchRepository _matchRepository;
  final Ref _ref; // <-- REF ADDED
  StreamSubscription? _statusSubscription; // <-- Listener Subscription

  MatchesNotifier(this._matchRepository, this._ref) // <-- REF ADDED
      : super(const MatchesState()) {
    _listenToStatusUpdates(); // <-- Start listening on creation
  }

  // --- CORRECTED: Listen for status updates ---
  void _listenToStatusUpdates() {
    print("[MatchesNotifier] Initializing status update listener.");
    // Use ref.listen, NOT listenManual
    _ref.listen<UserStatusUpdate?>(userStatusUpdateProvider, (prev, next) {
      // Listener callback receives previous and next state
      if (next != null) {
        if (kDebugMode)
          print(
              "[MatchesNotifier Listener Callback] Received status update: UserID=${next.userId}, isOnline=${next.isOnline}");
        _updateMatchStatus(next.userId, next.isOnline);
      }
    });
  }
  // --- END CORRECTION ---

  // --- NEW: Update status in the list ---
  void _updateMatchStatus(int userId, bool isOnline) {
    if (!mounted) {
      print(
          "[MatchesNotifier _updateMatchStatus] Not mounted, ignoring update for UserID: $userId");
      return;
    }

    final currentMatches = state.matches;
    final matchIndex = currentMatches.indexWhere((match) => match.id == userId);

    if (matchIndex != -1) {
      final matchToUpdate = currentMatches[matchIndex];

      // Only update if the status has actually changed
      if (matchToUpdate.isOnline != isOnline) {
        print(
            "[MatchesNotifier _updateMatchStatus] Found match UserID: $userId at index $matchIndex. Updating status from ${matchToUpdate.isOnline} to $isOnline.");

        // Create updated user model
        // CORRECTED: Pass function for nullable lastOnline
        final updatedMatch = matchToUpdate.copyWith(
          isOnline: isOnline,
          // Pass a function returning the value for nullable fields in copyWith
          lastOnline: () => matchToUpdate.lastOnline,
        );

        // Create new list with updated model
        final updatedMatches = List<UserModel>.from(currentMatches);
        updatedMatches[matchIndex] = updatedMatch;

        // Update state
        state = state.copyWith(matches: updatedMatches);
        print(
            "[MatchesNotifier _updateMatchStatus] State updated for UserID: $userId.");
      } else {
        if (kDebugMode)
          print(
              "[MatchesNotifier _updateMatchStatus] Match UserID: $userId found, but isOnline status ($isOnline) is already the same. No state change needed.");
      }
    } else {
      if (kDebugMode)
        print(
            "[MatchesNotifier _updateMatchStatus] Received status update for UserID: $userId, but they are not in the current matches list.");
    }
  }
  // --- END NEW ---

  // --- fetchMatches remains the same ---
  Future<void> fetchMatches({bool forceRefresh = false}) async {
    if (state.isLoading) return;
    if (state.matches.isNotEmpty && !forceRefresh) return;

    print("[MatchesNotifier] Fetching matches...");
    state = state.copyWith(isLoading: true, error: () => null);

    try {
      final matches = await _matchRepository.fetchMatches();
      if (mounted) {
        state = state.copyWith(isLoading: false, matches: matches);
        print("[MatchesNotifier] Fetched ${matches.length} matches.");
      }
    } on ApiException catch (e) {
      print("[MatchesNotifier] API Exception: ${e.message}");
      if (mounted) {
        state = state.copyWith(
          isLoading: false,
          error: () => AppError.server(e.message),
        );
      }
    } catch (e, stacktrace) {
      print("[MatchesNotifier] Unexpected Error: $e");
      print("[MatchesNotifier] Stacktrace: $stacktrace");
      if (mounted) {
        state = state.copyWith(
          isLoading: false,
          error: () => AppError.generic("Failed to load matches."),
        );
      }
    }
  }

  // --- ADDED dispose ---
  // Note: We don't need to manually cancel the subscription created with ref.listen.
  // Riverpod handles the lifecycle automatically when the provider is disposed.
  // However, explicitly overriding dispose is fine for logging or other cleanup.
  @override
  void dispose() {
    print("[MatchesNotifier] Disposing.");
    // _statusSubscription?.cancel(); // Cancellation handled by Riverpod for ref.listen
    super.dispose();
  }
  // --- END ADDED ---
}

// --- UPDATED Provider Definition ---
final matchesProvider =
    StateNotifierProvider<MatchesNotifier, MatchesState>((ref) {
  final repo = ref.watch(matchRepositoryProvider);
  // Pass the ref to the notifier's constructor
  final notifier = MatchesNotifier(repo, ref);
  // The listener is now started inside the constructor.
  return notifier;
});
// --- END UPDATED ---



================================================
File: providers/media_upload_provider.dart
================================================
import 'dart:io';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../repositories/media_repository.dart';
import 'error_provider.dart';
import 'service_provider.dart';

final mediaUploadProvider = StateNotifierProvider<MediaUploadNotifier, List<MediaUploadModel?>>((ref) {
  final mediaRepository = ref.watch(mediaRepositoryProvider);
  return MediaUploadNotifier(ref, mediaRepository);
});

class MediaUploadNotifier extends StateNotifier<List<MediaUploadModel?>> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  
  // Initialize with 6 null slots for media
  MediaUploadNotifier(this.ref, this._mediaRepository) : super(List.filled(6, null));
  
  // File size limits in bytes
  static const int _maxImageSizeBytes = 10 * 1024 * 1024; // 10 MB
  static const int _maxVideoSizeBytes = 50 * 1024 * 1024; // 50 MB

  MediaUploadModel? _verificationImage;

  MediaUploadModel? get verificationImage => _verificationImage;

  void setVerificationImage(File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'image/jpeg';

    final isImage = mimeType.startsWith('image/');

    if (!isImage) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Only image files are allowed."),
      );
      return;
    }

    if (fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }

    // Update state
    _verificationImage = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
  }

  void clearVerificationImage() {
    _verificationImage = null;
  }

  Future<bool> uploadVerificationImage() async {
    if (_verificationImage == null) return false;

    try {
      // Clear any existing errors
      ref.read(errorProvider.notifier).clearError();

      // Get presigned URL
      final presignedUrl = await _mediaRepository.getVerificationPresignedUrl(
        _verificationImage!.fileName,
        _verificationImage!.fileType,
      );

      // Update verification image with presigned URL
      _verificationImage = _verificationImage!.copyWith(
        presignedUrl: () => presignedUrl,
        status: UploadStatus.inProgress,
      );

      // Upload the file
      final success = await _mediaRepository.uploadFileToS3(_verificationImage!);

      // Update status
      _verificationImage = _verificationImage!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload verification image',
      );

      return success;
    } on ApiException catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => e.message,
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.message),
      );
      return false;
    } catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => 'An unexpected error occurred. Please try again.',
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth("An unexpected error occurred. Please try again."),
      );
      return false;
    }
  }
  
  // Add or update media at a specific index
  void setMediaFile(int index, File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'application/octet-stream';
    
    final isImage = mimeType.startsWith('image/');
    final isVideo = mimeType.startsWith('video/');
    
    // Size validation
    if (isImage && fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }
    
    if (isVideo && fileSize > _maxVideoSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Video is too large. Maximum size is 50 MB."),
      );
      return;
    }
    
    // Update state
    final updatedState = [...state];
    updatedState[index] = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
    state = updatedState;
  }
  
  // Remove media at a specific index
  void removeMedia(int index) {
    final updatedState = [...state];
    updatedState[index] = null;
    state = updatedState;
  }
  
  // Get all non-null media items
  List<MediaUploadModel> getMediaItems() {
    return state.whereType<MediaUploadModel>().toList();
  }
  
  // Check if we have minimum required media (3)
  bool hasMinimumMedia() {
    return getMediaItems().length >= 3;
  }
  
  // Upload all media
  Future<bool> uploadAllMedia() async {
    final mediaItems = getMediaItems();
    if (mediaItems.isEmpty) return false;
    
    try {
      // Prepare file details for presigned URL request
      final fileDetails = mediaItems.map((item) => {
        'filename': item.fileName,
        'type': item.fileType,
      }).toList();
      
  print("lauda lassan 2");
      // Get presigned URLs
      final presignedUrlsResponse = await _mediaRepository.getPresignedUrls(fileDetails);
      
      // Update media items with presigned URLs
      final updatedState = [...state];
      for (int i = 0; i < mediaItems.length; i++) {
        final index = state.indexOf(mediaItems[i]);
        if (index >= 0 && index < presignedUrlsResponse.length) {
          updatedState[index] = mediaItems[i].copyWith(
            presignedUrl: () => presignedUrlsResponse[i]['url'],
            status: UploadStatus.inProgress,
          );
        }
      }
      state = updatedState;
      
      // Upload each file
      bool allSucceeded = true;
      for (int i = 0; i < mediaItems.length; i++) {
        final mediaItem = state.firstWhere(
          (item) => item?.fileName == mediaItems[i].fileName,
          orElse: () => null,
        );
        
        if (mediaItem != null) {
          final index = state.indexOf(mediaItem);
          bool success = false;
          
          try {
            success = await _mediaRepository.uploadFileToS3(mediaItem);
          } catch (e) {
            print('Initial upload failed: $e');
            success = false;
          }
          
          // Retry if failed
          if (!success) {
            success = await _mediaRepository.retryUpload(mediaItem);
          }
          
          // Update state with result
          final newUpdatedState = [...state];
          newUpdatedState[index] = mediaItem.copyWith(
            status: success ? UploadStatus.success : UploadStatus.failed,
            errorMessage: success ? () => null : () => 'Failed to upload',
          );
          state = newUpdatedState;
          
          if (!success) allSucceeded = false;
        }
      }
      
      return allSucceeded;
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.toString()),
      );
      return false;
    }
  }
}



================================================
File: providers/recieved_likes_provider.dart
================================================
// File: providers/received_likes_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State definition remains the same
class ReceivedLikesState {
  final bool isLoading;
  final List<FullProfileLiker> fullProfiles;
  final List<BasicProfileLiker> otherLikers;
  final AppError? error;

  const ReceivedLikesState({
    this.isLoading = false, // Start NOT loading initially
    this.fullProfiles = const [],
    this.otherLikers = const [],
    this.error,
  });

  ReceivedLikesState copyWith({
    bool? isLoading,
    List<FullProfileLiker>? fullProfiles,
    List<BasicProfileLiker>? otherLikers,
    AppError? Function()? error,
  }) {
    return ReceivedLikesState(
      isLoading: isLoading ?? this.isLoading,
      fullProfiles: fullProfiles ?? this.fullProfiles,
      otherLikers: otherLikers ?? this.otherLikers,
      error: error != null ? error() : this.error,
    );
  }
}

// StateNotifier definition
class ReceivedLikesNotifier extends StateNotifier<ReceivedLikesState> {
  final LikeRepository _likeRepository;

  ReceivedLikesNotifier(this._likeRepository)
      : super(const ReceivedLikesState());

  Future<void> fetchLikes() async {
    // Prevent concurrent fetches if already loading
    if (state.isLoading) {
      print("[ReceivedLikesNotifier] fetchLikes skipped, already loading.");
      return;
    }

    print("[ReceivedLikesNotifier] fetchLikes called. Setting isLoading=true.");
    state = state.copyWith(
        isLoading: true, error: () => null); // Set loading true *here*

    try {
      print(
          "[ReceivedLikesNotifier] Calling _likeRepository.fetchReceivedLikes()...");
      final result = await _likeRepository.fetchReceivedLikes();
      print(
          "[ReceivedLikesNotifier] Repository call finished. Result received.");

      // Ensure component is still mounted before modifying state
      if (!mounted) {
        print(
            "[ReceivedLikesNotifier] Component unmounted after fetch. Aborting state update.");
        return;
      }

      final fullProfiles = result['full'] as List<FullProfileLiker>? ?? [];
      final otherLikers = result['other'] as List<BasicProfileLiker>? ?? [];
      print(
          "[ReceivedLikesNotifier] fetchLikes success. Full: ${fullProfiles.length}, Other: ${otherLikers.length}. Setting isLoading=false.");

      state = state.copyWith(
        isLoading: false, // Set loading false on success
        fullProfiles: fullProfiles,
        otherLikers: otherLikers,
        error: () => null,
      );
    } on ApiException catch (e) {
      print(
          "[ReceivedLikesNotifier] fetchLikes API Exception: ${e.message}. Setting isLoading=false.");
      if (mounted) {
        state = state.copyWith(
            isLoading: false, // Set loading false on error
            error: () => AppError.server(e.message));
      } else {
        print(
            "[ReceivedLikesNotifier] Component unmounted after API exception.");
      }
    } catch (e, stacktrace) {
      // Catch generic errors and stacktrace
      print(
          "[ReceivedLikesNotifier] fetchLikes Unexpected Error: ${e.toString()}. Setting isLoading=false.");
      print(
          "[ReceivedLikesNotifier] Stacktrace: $stacktrace"); // Log stacktrace
      if (mounted) {
        state = state.copyWith(
            isLoading: false, // Set loading false on error
            error: () => AppError.generic("Failed to load likes."));
      } else {
        print(
            "[ReceivedLikesNotifier] Component unmounted after unexpected error.");
      }
    }
    // Removed finally block as isLoading=false is handled in try/catch
  }
}

// Provider definition
final receivedLikesProvider =
    StateNotifierProvider<ReceivedLikesNotifier, ReceivedLikesState>((ref) {
  final likeRepository = ref.watch(likeRepositoryProvider);
  return ReceivedLikesNotifier(likeRepository);
});



================================================
File: providers/service_provider.dart
================================================
// File: providers/service_provider.dart
import 'package:dtx/repositories/filter_repository.dart';
import 'package:dtx/repositories/user_repository.dart';
import 'package:dtx/repositories/media_repository.dart';
import 'package:dtx/repositories/like_repository.dart';
// *** ADDED Imports ***
import 'package:dtx/repositories/match_repository.dart';
import 'package:dtx/repositories/chat_repository.dart';
import 'package:dtx/services/chat_service.dart'; // Import ChatService
// *** END ADDED Imports ***
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/api_service.dart';
import '../services/http_service.dart';
import '../repositories/auth_repository.dart';
import '../utils/env_config.dart';

// API Service provider
final apiServiceProvider = Provider<ApiService>((ref) {
  // *** Determine WebSocket URL from HTTP Base URL ***
  final httpBaseUrl = EnvConfig.apiBaseUrl;
  // Simple replacement, adjust if your URLs differ more significantly
  final wsBaseUrl = httpBaseUrl
          .replaceFirst('http://', 'ws://')
          .replaceFirst('https://', 'wss://') +
      '/chat'; // Add the specific chat path
  print("[ServiceProvider] HTTP Base URL: $httpBaseUrl");
  print("[ServiceProvider] WS Base URL: $wsBaseUrl");
  // *** End Base URL Determination ***

  return HttpService(baseUrl: EnvConfig.apiBaseUrl);
});

// Auth Repository provider
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AuthRepository(apiService);
});

// Media Repository provider
final mediaRepositoryProvider = Provider<MediaRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return MediaRepository(apiService, ref);
});

// User Repository provider
final userRepositoryProvider = Provider<UserRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return UserRepository(apiService);
});

// Like Repository Provider
final likeRepositoryProvider = Provider<LikeRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return LikeRepository(apiService);
});

// Filter Repository Provider
final filterRepositoryProvider = Provider<FilterRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return FilterRepository(apiService);
});

// *** ADDED: Match Repository Provider ***
final matchRepositoryProvider = Provider<MatchRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return MatchRepository(apiService);
});
// *** END ADDED ***

// *** ADDED: Chat Repository Provider ***
final chatRepositoryProvider = Provider<ChatRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return ChatRepository(apiService);
});
// *** END ADDED ***

// *** ADDED: Chat Service Provider (Singleton) ***
final chatServiceProvider = Provider<ChatService>((ref) {
  final httpBaseUrl = EnvConfig.apiBaseUrl;
  // Simple replacement, adjust if your URLs differ more significantly
  final wsBaseUrl = httpBaseUrl
          .replaceFirst('http://', 'ws://')
          .replaceFirst('https://', 'wss://') +
      '/chat'; // Add the specific chat path

  return ChatService(ref, wsBaseUrl);
});
// *** END ADDED ***



================================================
File: providers/status_provider.dart
================================================
// File: lib/providers/status_provider.dart
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Represents a single user status update event.
@immutable // Ensures the state object is immutable
class UserStatusUpdate {
  final int userId;
  final bool isOnline;
  final DateTime timestamp; // To differentiate events

  const UserStatusUpdate({
    required this.userId,
    required this.isOnline,
    required this.timestamp,
  });

  // Optional: Override == and hashCode if needed for complex comparisons,
  // but timestamp usually suffices for differentiation.
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserStatusUpdate &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          isOnline == other.isOnline &&
          timestamp == other.timestamp;

  @override
  int get hashCode => userId.hashCode ^ isOnline.hashCode ^ timestamp.hashCode;

  @override
  String toString() {
    return 'UserStatusUpdate(userId: $userId, isOnline: $isOnline, timestamp: $timestamp)';
  }
}

// --- StateNotifier ---
class UserStatusNotifier extends StateNotifier<UserStatusUpdate?> {
  // Initialize with null state, meaning no update has occurred yet.
  UserStatusNotifier() : super(null);

  /// Updates the state with the latest status change.
  void updateStatus(int userId, bool isOnline) {
    final newStatus = UserStatusUpdate(
      userId: userId,
      isOnline: isOnline,
      timestamp: DateTime.now(), // Use current time for the event
    );
    if (kDebugMode) {
      print("[UserStatusNotifier] Broadcasting status update: $newStatus");
    }
    // Only update if it's different from the last state to avoid unnecessary rebuilds
    // (though timestamp makes it always different, good practice)
    if (state != newStatus) {
      state = newStatus;
    }
  }
}

// --- StateNotifierProvider ---
/// Provider that broadcasts the latest user status update event received via WebSocket.
/// Other providers (like MatchesNotifier, ConversationNotifier) can watch this
/// to react to real-time status changes.
final userStatusUpdateProvider =
    StateNotifierProvider<UserStatusNotifier, UserStatusUpdate?>((ref) {
  return UserStatusNotifier();
});



================================================
File: providers/user_provider.dart
================================================
// File: providers/user_provider.dart
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:latlong2/latlong.dart'; // Keep if used
import '../models/error_model.dart';
import '../models/user_model.dart';
import '../utils/app_enums.dart';

final userLoadingProvider = StateProvider<bool>((ref) => false);

final userProvider = StateNotifierProvider<UserNotifier, UserModel>((ref) {
  return UserNotifier(ref);
});

class UserNotifier extends StateNotifier<UserModel> {
  final Ref ref;

  UserNotifier(this.ref) : super(UserModel());

  Future<bool> fetchProfile() async {
    // Only set loading true if profile is actually empty
    bool shouldShowLoading = state.id == null;
    if (shouldShowLoading) ref.read(userLoadingProvider.notifier).state = true;
    ref.read(errorProvider.notifier).clearError();

    try {
      final userRepository = ref.read(userRepositoryProvider);
      final userModel = await userRepository.fetchUserProfile();
      state = userModel; // Direct assignment from fetch is fine
      if (shouldShowLoading)
        ref.read(userLoadingProvider.notifier).state = false;
      return true;
    } on ApiException catch (e) {
      if (shouldShowLoading)
        ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
            AppError.server(e.message), // Use server error type
          );
      return false;
    } catch (e) {
      if (shouldShowLoading)
        ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
            AppError.generic(
                "Failed to load profile: ${e.toString()}"), // Use generic
          );
      return false;
    }
  }

  // --- NO CHANGE: name, dob, location, gender updates are NOT used for editing ---
  void updateName(String firstName, String? lastName) {
    // This logic is only for onboarding validation
    ref.read(errorProvider.notifier).clearError();
    if (firstName.isEmpty || firstName.trim().length < 3) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("First name must be at least 3 characters"),
          );
      // Don't update state if invalid during onboarding
      // For edit, we rely on the ProfileScreen to handle this before save
      return;
    }
    state = state.copyWith(
      name: () => firstName.trim(),
      lastName: () => lastName?.trim(),
    );
  }

  void updateDateOfBirth(DateTime date) {
    // This logic is only for onboarding validation
    ref.read(errorProvider.notifier).clearError();
    final today = DateTime.now();
    final age = today.difference(date).inDays ~/ 365.25;

    if (date.year < 1900 || date.isAfter(today)) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Invalid year"));
      return;
    }
    if (age < 18) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("You must be at least 18 years old"));
      return;
    }
    try {
      final validatedDate = DateTime(date.year, date.month, date.day);
      state = state.copyWith(dateOfBirth: () => validatedDate);
    } catch (e) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Invalid date combination"));
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(
      latitude: () => latitude,
      longitude: () => longitude,
    );
  }

  void updateGender(Gender? gender) {
    state = state.copyWith(gender: () => gender);
  }
  // --- END NO CHANGE ---

  LatLng getCurrentLocation() {
    return LatLng(state.latitude ?? 19.2183, state.longitude ?? 73.0864);
  }

  bool isLocationValid() {
    return state.latitude != null &&
        state.longitude != null &&
        state.latitude != 0.0 &&
        state.longitude != 0.0;
  }

  bool isNameValid() => (state.name?.trim().length ?? 0) >= 3;

  // --- Editable Fields ---
  void updateDatingIntention(DatingIntention? intention) {
    state = state.copyWith(datingIntention: () => intention);
  }

  bool isDatingIntentionSelected() {
    return state.datingIntention != null;
  }

  void updateHeight(String height) {
    state = state.copyWith(height: () => height);
  }

  bool isHeightSelected() {
    return state.height != null && state.height!.isNotEmpty;
  }

  void updateHometown(String? hometown) {
    // Allow setting to null for clearing
    state = state.copyWith(hometown: () => hometown?.trim());
  }

  bool isHometownSelected() {
    return state.hometown != null && state.hometown!.isNotEmpty;
  }

  void updateJobTitle(String? jobTitle) {
    // Allow setting to null for clearing
    state = state.copyWith(jobTitle: () => jobTitle?.trim());
  }

  void updateEducation(String? education) {
    // Allow setting to null for clearing
    state = state.copyWith(education: () => education?.trim());
  }

  void updateReligiousBeliefs(Religion? religion) {
    state = state.copyWith(religiousBeliefs: () => religion);
  }

  void updateDrinkingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(drinkingHabit: () => habit);
  }

  void updateSmokingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(smokingHabit: () => habit);
  }

  void addPrompt(Prompt prompt) {
    if (prompt.answer.trim().isEmpty) return;
    if (state.prompts.length >= 3) return;
    final updatedPrompts = List<Prompt>.from(state.prompts)..add(prompt);
    state = state.copyWith(prompts: updatedPrompts);
  }

  void updatePromptAtIndex(int index, Prompt newPrompt) {
    if (newPrompt.answer.trim().isEmpty) return;
    final updatedPrompts = List<Prompt>.from(state.prompts);
    if (index >= 0 && index < updatedPrompts.length) {
      updatedPrompts[index] = newPrompt;
      state = state.copyWith(prompts: updatedPrompts);
    }
  }

  void removePromptAtIndex(int index) {
    final updatedPrompts = List<Prompt>.from(state.prompts);
    if (index >= 0 && index < updatedPrompts.length) {
      updatedPrompts.removeAt(index);
      state = state.copyWith(prompts: updatedPrompts);
    }
  }

  void updateAudioPrompt(AudioPromptModel? audioPrompt) {
    state = state.copyWith(audioPrompt: () => audioPrompt);
  }

  // --- Media Updates (for edit mode) ---
  void updateMediaUrls(List<String> urls) {
    // Directly update the URLs list (typically after upload during save)
    state = state.copyWith(mediaUrls: () => urls);
    // Reset the change flag after URLs are explicitly updated post-save
    state = state.copyWith(mediaChangedDuringEdit: false);
  }

  void setMediaChangedFlag(bool changed) {
    // This flag is set by ProfileScreen when returning from MediaPickerScreen in edit mode
    state = state.copyWith(mediaChangedDuringEdit: changed);
    print("[UserNotifier] Media changed flag set to: $changed");
  }
  // --- End Media Updates ---

  // saveProfile remains for ONBOARDING STEP 2 (POST request)
  Future<bool> saveProfile() async {
    print("[UserNotifier saveProfile] Called (for onboarding step 2 - POST).");
    ref.read(userLoadingProvider.notifier).state = true;
    ref.read(errorProvider.notifier).clearError();

    if (!state.isProfileValid()) {
      // Uses onboarding validation
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Please complete all required profile fields."),
          );
      ref.read(userLoadingProvider.notifier).state = false;
      return false;
    }

    try {
      final userRepository = ref.read(userRepositoryProvider);
      // This now internally calls updateProfileDetails (POST) with the correct payload
      final success = await userRepository.updateProfile(state);

      ref.read(userLoadingProvider.notifier).state = false;
      if (!success && ref.read(errorProvider) == null) {
        // Check if error already set
        ref
            .read(errorProvider.notifier)
            .setError(AppError.server("Failed to save profile."));
      }
      return success;
    } on ApiException catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(AppError.server(e.message));
      return false;
    } catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref
          .read(errorProvider.notifier)
          .setError(AppError.generic("An unexpected error occurred."));
      return false;
    }
  }

  bool isProfileValid() {
    // For onboarding step 2 POST
    return state.isProfileValid(); // Delegate to UserModel's method
  }
}



================================================
File: repositories/auth_repository.dart
================================================
// File: repositories/auth_repository.dart
import '../models/auth_model.dart'; // Keep for AuthStatus enum
import '../services/api_service.dart';

class AuthRepository {
  final ApiService _apiService;

  AuthRepository(this._apiService);

  // --- REMOVED METHODS ---
  // Future<bool> sendOtp(String phoneNumber) async { ... }
  // Future<String> verifyOtp(String phoneNumber, String otpCode) async { ... }
  // --- END REMOVED METHODS ---

  // --- NEW METHOD ---
  /// Verifies Google Access Token with the backend and returns the App JWT.
  Future<String> verifyGoogleToken(String googleAccessToken) async {
    final String methodName = 'verifyGoogleToken';
    print('[AuthRepository $methodName] Verifying Google token...');
    try {
      final response = await _apiService.post(
        '/api/auth/google/verify', // Endpoint from API documentation
        body: {'accessToken': googleAccessToken},
      );

      if (response['success'] == true && response['token'] != null) {
        print(
            '[AuthRepository $methodName] Google token verified, got App JWT.');
        return response['token'].toString();
      } else {
        final message = response['message']?.toString() ??
            'Verification failed, no token received.';
        print('[AuthRepository $methodName] Verification failed: $message');
        throw ApiException(
            message); // Throw with message from backend if available
      }
    } on ApiException catch (e) {
      print(
          '[AuthRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      // Re-throw API exceptions to be handled by the provider
      rethrow;
    } catch (e) {
      print('[AuthRepository $methodName] Unexpected Error: ${e.toString()}');
      // Wrap other errors in ApiException
      throw ApiException(
          'An unexpected error occurred during Google verification: ${e.toString()}');
    }
  }
  // --- END NEW METHOD ---

  // Check authentication status - Updated to handle new states
  Future<AuthStatus> checkAuthStatus(String? token) async {
    final String methodName = 'checkAuthStatus';
    print('[AuthRepository $methodName] Starting auth status check.');

    if (token == null || token.isEmpty) {
      print(
          '[AuthRepository $methodName] No token provided, returning login status.');
      return AuthStatus.login;
    }

    try {
      final headers = {'Authorization': 'Bearer $token'};
      print('[AuthRepository $methodName] Making request to /api/auth-status.');
      final response =
          await _apiService.get('/api/auth-status', headers: headers);

      print('[AuthRepository $methodName] Received response: $response');

      if (response['success'] == true && response['status'] != null) {
        final statusString = response['status'].toString().toLowerCase();
        switch (statusString) {
          case 'home':
            print('[AuthRepository $methodName] Status: home');
            return AuthStatus.home;
          case 'onboarding1': // Handle new state
            print('[AuthRepository $methodName] Status: onboarding1');
            return AuthStatus.onboarding1;
          case 'onboarding2': // Handle new state
            print('[AuthRepository $methodName] Status: onboarding2');
            return AuthStatus.onboarding2;
          default:
            // If backend returns an unexpected status, treat as login
            print(
                '[AuthRepository $methodName] Status: unknown ($statusString), defaulting to login.');
            return AuthStatus.login;
        }
      } else {
        // If success is false or status is missing, treat as login needed
        print(
            '[AuthRepository $methodName] API response indicates failure or missing status, returning login.');
        return AuthStatus.login;
      }
    } on ApiException catch (e) {
      // If API returns 401/403 or other errors indicating invalid session, treat as login needed
      print(
          '[AuthRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode}), returning login.');
      return AuthStatus.login;
    } catch (e) {
      print(
          '[AuthRepository $methodName] Unexpected Error: ${e.toString()}, returning unknown.');
      return AuthStatus.unknown; // Indicate an issue occurred during the check
    }
  }
}



================================================
File: repositories/auth_status_repository.dart
================================================
// File: repositories/auth_status_repository.dart
import '../services/api_service.dart';
import '../utils/token_storage.dart';

enum AuthStatus {
  home,       // User authenticated with complete profile
  onboarding, // User authenticated but profile incomplete
  login,      // User not authenticated or invalid token
  unknown     // Error or initial state
}

class AuthStatusRepository {
  final ApiService _apiService;
  
  AuthStatusRepository(this._apiService);
  
  Future<AuthStatus> checkAuthStatus() async {
    try {
      // Get the saved token
      final token = await TokenStorage.getToken();
      
      if (token == null || token.isEmpty) {
        return AuthStatus.login;
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      // Make the API request
      final response = await _apiService.get(
        '/api/auth-status',
        headers: headers,
      );
      
      if (response['success'] == true) {
        final status = response['status']?.toString().toLowerCase();
        
        if (status == 'home') {
          return AuthStatus.home;
        } else if (status == 'onboarding') {
          return AuthStatus.onboarding;
        }
      }
      
      // Default to login if status is not recognized or success is false
      return AuthStatus.login;
    } on ApiException catch (e) {
      print('Auth status check failed: $e');
      // For authentication errors, redirect to login
      return AuthStatus.login;
    } catch (e) {
      print('Unexpected error during auth status check: $e');
      return AuthStatus.unknown;
    }
  }
}



================================================
File: repositories/chat_repository.dart
================================================
// lib/repositories/chat_repository.dart
import 'package:dtx/models/chat_message.dart';
import 'package:dtx/providers/conversation_provider.dart'; // Import ConversationData
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/token_storage.dart';
import 'package:flutter/foundation.dart'; // For kDebugMode
import 'dart:convert'; // For jsonDecode if needed for raw logging

class ChatRepository {
  final ApiService _apiService;

  ChatRepository(this._apiService);

  // --- MODIFIED Logic ---
  Future<ConversationData> fetchConversation({
    required int otherUserId,
  }) async {
    final String methodName = 'fetchConversation';
    print(
        '[ChatRepository $methodName] Fetching conversation WITH STATUS for user $otherUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) {
        print("[ChatRepository $methodName] Auth token missing.");
        throw ApiException('Authentication token missing');
      }
      final headers = {'Authorization': 'Bearer $token'};

      final endpoint = '/api/conversation';
      final body = {'other_user_id': otherUserId};

      print('[ChatRepository $methodName] Making POST request to: $endpoint');
      print('[ChatRepository $methodName] Request Body: $body');

      final response = await _apiService.post(
        endpoint,
        body: body,
        headers: headers,
      );
      if (kDebugMode) {
        try {
          print(
              '[ChatRepository $methodName] Raw API Response Map: ${jsonEncode(response)}');
        } catch (e) {
          print(
              '[ChatRepository $methodName] Raw API Response Map: (Could not encode, likely large or complex)');
        }
      }

      if (response['success'] == true) {
        // --- PARSE MESSAGES ---
        final List<dynamic> messagesData = response['messages'] as List? ?? [];
        print(
            '[ChatRepository $methodName] API Success. Raw messagesData length: ${messagesData.length}');

        final messages = messagesData
            .map((data) {
              if (kDebugMode) {
                // Log raw data *before* parsing attempt
                print(
                    "[ChatRepository $methodName map] Processing raw message data item: $data");
              }
              try {
                if (data is Map<String, dynamic>) {
                  // *** The ChatMessage.fromJson factory now handles parsing all fields, including reply info ***
                  return ChatMessage.fromJson(data);
                } else {
                  print(
                      "[ChatRepository $methodName map] Warning: Invalid item type in messages list: ${data.runtimeType}");
                  return null;
                }
              } catch (e, stacktrace) {
                print(
                    "[ChatRepository $methodName map] Error parsing chat message: $e");
                print(
                    "[ChatRepository $methodName map] Stacktrace: $stacktrace");
                print("[ChatRepository $methodName map] Faulty Data: $data");
                return null;
              }
            })
            .whereType<ChatMessage>()
            .toList(); // Filter out any nulls resulting from parsing errors
        print(
            '[ChatRepository $methodName] Parsed Messages Count: ${messages.length}');

        // --- PARSE STATUS (No change needed here) ---
        final bool isOnline = response['other_user_is_online'] as bool? ??
            false; // Default to false
        final String? lastOnlineStr =
            response['other_user_last_online'] as String?;
        DateTime? lastOnline;
        if (lastOnlineStr != null) {
          try {
            lastOnline = DateTime.parse(lastOnlineStr)
                .toLocal(); // Parse and convert to local time
          } catch (e) {
            print(
                "[ChatRepository $methodName] Error parsing lastOnline timestamp '$lastOnlineStr': $e");
          }
        }
        print(
            '[ChatRepository $methodName] Parsed Status: isOnline=$isOnline, lastOnline=$lastOnline');

        // --- RETURN ConversationData ---
        return ConversationData(
          messages: messages,
          otherUserIsOnline: isOnline,
          otherUserLastOnline: lastOnline,
        );
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch conversation.';
        print(
            '[ChatRepository $methodName] API call returned success=false: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[ChatRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e, stacktrace) {
      print('[ChatRepository $methodName] Unexpected Error: $e');
      print("[ChatRepository $methodName] Stacktrace: $stacktrace");
      throw ApiException(
          'An unexpected error occurred while fetching conversation: ${e.toString()}');
    }
  }
  // --- END MODIFIED Logic ---
}



================================================
File: repositories/filter_repository.dart
================================================
// lib/repositories/filter_repository.dart
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/token_storage.dart';

class FilterRepository {
  final ApiService _apiService;

  FilterRepository(this._apiService);

  Future<FilterSettings> fetchFilters() async {
    final String methodName = 'fetchFilters';
    print('[FilterRepository $methodName] Fetching filters...');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};

      // *** Log the raw response from the API ***
      final response =
          await _apiService.get('/api/get-filters', headers: headers);
      print('[FilterRepository $methodName] Raw API Response: $response');
      // *** End Log ***

      if (response['success'] == true) {
        if (response['filters'] != null &&
            response['filters'] is Map<String, dynamic>) {
          print('[FilterRepository $methodName] Filters found, parsing...');
          // Parsing happens within the factory now
          return FilterSettings.fromJson(
              response['filters'] as Map<String, dynamic>);
        } else {
          print(
              '[FilterRepository $methodName] Filters not set by API, returning defaults.');
          return const FilterSettings(); // Return default settings
        }
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch filters (API success false).';
        print('[FilterRepository $methodName] Fetch failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[FilterRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      print(
          '[FilterRepository $methodName] Returning default filters due to API Exception.');
      return const FilterSettings(); // Return default on API error
    } catch (e) {
      print('[FilterRepository $methodName] Unexpected Error: $e');
      print(
          '[FilterRepository $methodName] Returning default filters due to Unexpected Error.');
      return const FilterSettings(); // Return default on unexpected errors
    }
  }

  Future<bool> updateFilters(FilterSettings filters) async {
    // ... (updateFilters remains the same as previous version) ...
    final String methodName = 'updateFilters';
    print('[FilterRepository $methodName] Updating filters...');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = filters.toJsonForApi();
      print('[FilterRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/filters', body: body, headers: headers);
      print('[FilterRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print('[FilterRepository $methodName] Filters updated successfully.');
        return true;
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to update filters.';
        print('[FilterRepository $methodName] Update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[FilterRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[FilterRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while updating filters: ${e.toString()}');
    }
  }
}



================================================
File: repositories/like_repository.dart
================================================
// File: repositories/like_repository.dart
import '../models/like_models.dart';
import '../models/error_model.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import '../utils/app_enums.dart';

class LikeRepository {
  final ApiService _apiService;

  LikeRepository(this._apiService);

  // --- Existing methods (likeContent, dislikeUser, likeBackUserProfile, etc.) ---
  // ... (keep existing methods as they are) ...
  Future<bool> likeContent({
    required int likedUserId,
    required ContentLikeType contentType,
    required String contentIdentifier,
    required LikeInteractionType interactionType,
    String? comment,
  }) async {
    final String methodName = 'likeContent';
    print(
        '[LikeRepository $methodName] Liking UserID: $likedUserId, Type: ${contentType.value}, Identifier: $contentIdentifier, Interaction: ${interactionType.value}');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'liked_user_id': likedUserId,
        'content_type': contentType.value,
        'content_identifier': contentIdentifier,
        'interaction_type': interactionType.value,
        if (comment != null && comment.trim().isNotEmpty)
          'comment': comment.trim(),
      };
      print('[LikeRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/like', body: body, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      if (e.statusCode == 403) {
        if (e.message.toLowerCase().contains('limit reached'))
          throw LikeLimitExceededException(e.message);
        else if (e.message.toLowerCase().contains('insufficient consumables') ||
            e.message.toLowerCase().contains('rose'))
          throw InsufficientRosesException(e.message);
      } else if (e.statusCode == 409) {
        print("[LikeRepository $methodName] Conflict: Already liked/matched?");
        rethrow;
      }
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while liking content: ${e.toString()}');
    }
  }

  Future<bool> dislikeUser({required int dislikedUserId}) async {
    final String methodName = 'dislikeUser';
    print('[LikeRepository $methodName] Disliking UserID: $dislikedUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'disliked_user_id': dislikedUserId};
      print('[LikeRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/dislike', body: body, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while disliking user: ${e.toString()}');
    }
  }

  Future<bool> likeBackUserProfile({required int likedUserId}) async {
    final String methodName = 'likeBackUserProfile';
    print('[LikeRepository $methodName] Liking back UserID: $likedUserId');
    try {
      return await likeContent(
        likedUserId: likedUserId,
        contentType: ContentLikeType.profile,
        contentIdentifier: ContentLikeType.profile.value,
        interactionType: LikeInteractionType.standard,
        comment: null,
      );
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      if (e.statusCode == 409) {
        print("[LikeRepository $methodName] Conflict: Already liked/matched?");
      }
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while liking back user: ${e.toString()}');
    }
  }

  Future<Map<String, List<dynamic>>> fetchReceivedLikes() async {
    final String methodName = 'fetchReceivedLikes';
    print('[LikeRepository $methodName] Fetching received likes...');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) {
        print(
            '[LikeRepository $methodName] Error: Authentication token missing.');
        throw ApiException('Authentication token missing');
      }
      final headers = {'Authorization': 'Bearer $token'};
      print(
          '[LikeRepository $methodName] Making GET request to /api/likes/received...');
      final response =
          await _apiService.get('/api/likes/received', headers: headers);
      print('[LikeRepository $methodName] API Response received: $response');

      if (response['success'] == true) {
        print('[LikeRepository $methodName] Parsing successful response...');
        final List<FullProfileLiker> fullProfiles =
            (response['full_profiles'] as List? ?? [])
                .map((data) {
                  try {
                    return FullProfileLiker.fromJson(
                        data as Map<String, dynamic>);
                  } catch (e) {
                    print(
                        "[LikeRepository $methodName] Error parsing FullProfileLiker: $e, Data: $data");
                    return null;
                  }
                })
                .whereType<FullProfileLiker>()
                .toList();
        final List<BasicProfileLiker> otherLikers =
            (response['other_likers'] as List? ?? [])
                .map((data) {
                  try {
                    return BasicProfileLiker.fromJson(
                        data as Map<String, dynamic>);
                  } catch (e) {
                    print(
                        "[LikeRepository $methodName] Error parsing BasicProfileLiker: $e, Data: $data");
                    return null;
                  }
                })
                .whereType<BasicProfileLiker>()
                .toList();
        print(
            '[LikeRepository $methodName] Parsed ${fullProfiles.length} full, ${otherLikers.length} basic profiles.');
        return {'full': fullProfiles, 'other': otherLikers};
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch received likes.';
        print(
            '[LikeRepository $methodName] Fetch failed in API response: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception caught: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e, stacktrace) {
      print('[LikeRepository $methodName] Unexpected Error caught: $e');
      print('[LikeRepository $methodName] Stacktrace: $stacktrace');
      throw ApiException(
          'An unexpected error occurred while fetching likes: ${e.toString()}');
    }
  }

  Future<Map<String, dynamic>> fetchLikerProfile(int likerUserId) async {
    final String methodName = 'fetchLikerProfile';
    print(
        '[LikeRepository $methodName] Fetching profile for liker ID: $likerUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final endpoint = '/api/liker-profile/$likerUserId';
      print('[LikeRepository $methodName] Making GET request to: $endpoint');
      final response = await _apiService.get(endpoint, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');

      if (response['success'] == true &&
          response['profile'] != null &&
          response['like_details'] != null) {
        if (response['profile'] is Map<String, dynamic> &&
            response['like_details'] is Map<String, dynamic>) {
          final profileData = UserProfileData.fromJson(
              response['profile'] as Map<String, dynamic>);
          final likeDetailsData = LikeInteractionDetails.fromJson(
              response['like_details'] as Map<String, dynamic>);
          print(
              '[LikeRepository $methodName] Successfully parsed profile and like details.');
          return {'profile': profileData, 'likeDetails': likeDetailsData};
        } else {
          print(
              '[LikeRepository $methodName] Error: Invalid data format in response.');
          throw ApiException('Invalid data format received for liker profile.');
        }
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch liker profile or like details.';
        print('[LikeRepository $methodName] Fetch failed: $message');
        throw ApiException(message, statusCode: response['statusCode'] as int?);
      }
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while fetching the liker profile: ${e.toString()}');
    }
  }
  // --- END Existing Methods ---

  // --- ADDED: Unmatch User Method ---
  Future<bool> unmatchUser({required int targetUserId}) async {
    final String methodName = 'unmatchUser';
    print('[LikeRepository $methodName] Unmatching UserID: $targetUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'target_user_id': targetUserId
      }; // Match backend Go struct field name
      print('[LikeRepository $methodName] Request Body: $body');

      final response = await _apiService.post('/api/unmatch',
          body: body, headers: headers); // Use POST

      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow; // Let the provider/UI handle specific errors if needed
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while unmatching user: ${e.toString()}');
    }
  }
  // --- END ADDED ---

  // --- ADDED: Report User Method ---
  Future<bool> reportUser(
      {required int targetUserId, required ReportReason reason}) async {
    final String methodName = 'reportUser';
    print(
        '[LikeRepository $methodName] Reporting UserID: $targetUserId, Reason: ${reason.value}');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'reported_user_id': targetUserId, // Match backend Go struct field name
        'reason': reason.value // Send the enum value string
      };
      print('[LikeRepository $methodName] Request Body: $body');

      final response = await _apiService.post('/api/report',
          body: body, headers: headers); // Use POST

      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while reporting user: ${e.toString()}');
    }
  }
  // --- END ADDED ---
}



================================================
File: repositories/match_repository.dart
================================================
// lib/repositories/match_repository.dart
import 'package:dtx/models/user_model.dart'; // Explicitly import UserModel
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/token_storage.dart';

class MatchRepository {
  final ApiService _apiService;

  MatchRepository(this._apiService);

  Future<List<UserModel>> fetchMatches() async {
    final String methodName = 'fetchMatches';
    print('[MatchRepository $methodName] Fetching matches...');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};

      final response = await _apiService.get('/api/matches', headers: headers);
      print('[MatchRepository $methodName] API Response: $response');

      if (response['success'] == true && response['matches'] != null) {
        final List<dynamic> matchesData = response['matches'] as List? ?? [];

        // *** NEW SIMPLIFIED MAPPING LOGIC ***
        final matches = matchesData.map((data) {
          // Create a mutable map from the received data
          final Map<String, dynamic> modelInputData =
              Map<String, dynamic>.from(data as Map<String, dynamic>);

          // 1. Ensure 'id' key exists using 'matched_user_id'
          if (modelInputData.containsKey('matched_user_id')) {
            modelInputData['id'] = modelInputData['matched_user_id'];
          } else {
            modelInputData['id'] = null; // Ensure 'id' exists even if null
            print(
                "[MatchRepository $methodName] Warning: Missing 'matched_user_id' in match data: $data");
          }

          // 2. Ensure 'name' key exists (it's already correct in the curl response)
          if (!modelInputData.containsKey('name')) {
            modelInputData['name'] = null; // Ensure 'name' exists if missing
          }

          // 3. Ensure 'last_name' exists (not in curl, assume null/empty)
          if (!modelInputData.containsKey('last_name')) {
            modelInputData['last_name'] =
                null; // Or "" depending on UserModel needs
          }

          // 4. Create 'media_urls' from 'first_profile_pic_url'
          if (modelInputData.containsKey('first_profile_pic_url')) {
            final avatarUrl =
                modelInputData['first_profile_pic_url'] as String?;
            if (avatarUrl != null && avatarUrl.isNotEmpty) {
              modelInputData['media_urls'] = [avatarUrl];
            } else {
              modelInputData['media_urls'] = <String>[];
            }
          } else {
            modelInputData['media_urls'] = <String>[];
          }

          // 5. Add default/null values for other fields expected by UserModel.fromJson
          //    if they are not present in the /api/matches response. This prevents
          //    parsing errors in UserModel.fromJson.
          modelInputData.putIfAbsent('email', () => null);
          modelInputData.putIfAbsent('date_of_birth', () => null);
          modelInputData.putIfAbsent('latitude', () => null);
          modelInputData.putIfAbsent('longitude', () => null);
          modelInputData.putIfAbsent('gender', () => null);
          modelInputData.putIfAbsent('dating_intention', () => null);
          modelInputData.putIfAbsent('height', () => null);
          modelInputData.putIfAbsent('hometown', () => null);
          modelInputData.putIfAbsent('job_title', () => null);
          modelInputData.putIfAbsent('education', () => null);
          modelInputData.putIfAbsent('religious_beliefs', () => null);
          modelInputData.putIfAbsent('drinking_habit', () => null);
          modelInputData.putIfAbsent('smoking_habit', () => null);
          modelInputData.putIfAbsent(
              'verification_status', () => 'false'); // Default status?
          modelInputData.putIfAbsent('verification_pic', () => null);
          modelInputData.putIfAbsent('role', () => 'user'); // Default role?
          modelInputData.putIfAbsent('audio_prompt_question', () => null);
          modelInputData.putIfAbsent('audio_prompt_answer', () => null);
          modelInputData.putIfAbsent(
              'prompts', () => <dynamic>[]); // Default empty list

          // Now parse the prepared map
          try {
            print(
                "[MatchRepository $methodName] Parsing prepared data: $modelInputData");
            return UserModel.fromJson(modelInputData);
          } catch (e) {
            print(
                "[MatchRepository $methodName] ERROR parsing match data: $e. Data was: $modelInputData");
            // Return a default/empty UserModel or rethrow/handle as needed
            return UserModel(
                id: modelInputData['id']); // Return with ID at least
          }
        }).toList();
        // *** END SIMPLIFIED MAPPING LOGIC ***

        print(
            '[MatchRepository $methodName] Successfully processed ${matches.length} matches.');
        return matches;
      } else if (response['success'] == true && response['matches'] == null) {
        print('[MatchRepository $methodName] No matches found.');
        return [];
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch matches.';
        print('[MatchRepository $methodName] Fetch failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[MatchRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[MatchRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while fetching matches: ${e.toString()}');
    }
  }
}



================================================
File: repositories/media_repository.dart
================================================
// File: repositories/media_repository.dart
import 'dart:convert';
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/utils/token_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// Removed unused http_parser import
// Removed unused path import

import '../models/media_upload_model.dart';
import '../services/api_service.dart';

class MediaRepository {
  final ApiService _apiService;
  final Ref? ref; // Keep ref if needed for token access

  MediaRepository(this._apiService, [this.ref]);

  // --- Helper to get token (avoids repetition) ---
  Future<String?> _getAuthToken() async {
    String? token;
    if (ref != null) {
      try {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      } catch (e) {
        print(
            "[MediaRepository _getAuthToken] Error reading auth provider: $e");
      }
    }
    if (token == null || token.isEmpty) {
      token = await TokenStorage.getToken();
    }
    return token;
  }
  // --- END Helper ---

  // --- Method for CHAT Media Presigned URL ---
  Future<Map<String, String>> getChatMediaPresignedUrl(
      String filename, String fileType) async {
    final String methodName = 'getChatMediaPresignedUrl';
    print(
        '[MediaRepository $methodName] Getting chat media presigned URL for $filename ($fileType)...');
    try {
      String? token = await _getAuthToken();
      if (token == null) {
        throw ApiException('Authentication token is missing');
      }
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'filename': filename, 'type': fileType};
      print('[MediaRepository $methodName] Request Body: $body');

      final response = await _apiService.post(
        '/api/chat/upload', // Use the CHAT media endpoint
        body: body,
        headers: headers,
      );

      print('[MediaRepository $methodName] API Response: $response');
      if (response['success'] == true &&
          response['presigned_url'] != null &&
          response['object_url'] != null) {
        print('[MediaRepository $methodName] URLs received successfully.');
        return {
          'presigned_url': response['presigned_url'].toString(),
          'object_url': response['object_url'].toString(),
        };
      } else {
        final message = response['message']?.toString() ??
            'Failed to get chat media presigned URL.';
        print('[MediaRepository $methodName] Failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[MediaRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      rethrow;
    } catch (e) {
      print('[MediaRepository $methodName] Unexpected Error: $e');
      throw ApiException('Error getting chat presigned URL: ${e.toString()}');
    }
  }
  // --- END CHAT Media Method ---

  // --- Existing methods (getEditPresignedUrls, getPresignedUrls, getAudioPresignedUrl, getVerificationPresignedUrl) ---
  // ... keep the existing code for these methods ...
  Future<List<Map<String, dynamic>>> getEditPresignedUrls(
      List<Map<String, String>> fileDetails) async {
    final String methodName = 'getEditPresignedUrls';
    print(
        '[MediaRepository $methodName] Getting presigned URLs for editing...');
    if (fileDetails.isEmpty) {
      print(
          '[MediaRepository $methodName] No file details provided, returning empty list.');
      return []; // Return empty list if no files need uploading
    }
    try {
      String? token = await _getAuthToken(); // Use helper to get token
      if (token == null) {
        throw ApiException('Authentication token is missing');
      }
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'files': fileDetails};
      print('[MediaRepository $methodName] Request Body: $body');

      final response = await _apiService.post(
        '/api/edit-presigned-urls', // <-- Use the NEW endpoint
        body: body,
        headers: headers,
      );

      print('[MediaRepository $methodName] API Response: $response');
      if (response['uploads'] != null && response['uploads'] is List) {
        print('[MediaRepository $methodName] Presigned URLs received.');
        return List<Map<String, dynamic>>.from(response['uploads']);
      } else {
        final message = response['message']?.toString() ??
            'Failed to get edit presigned URLs.';
        print('[MediaRepository $methodName] Failed: $message');
        // Throw specific error if prerequisite failed
        if (message.contains("must have at least 3 existing media items")) {
          throw ApiException(message,
              statusCode: 400); // Use 400 as indicated in docs for this error
        }
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[MediaRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      rethrow;
    } catch (e) {
      print('[MediaRepository $methodName] Unexpected Error: $e');
      throw ApiException('Error getting edit presigned URLs: ${e.toString()}');
    }
  }

  Future<List<Map<String, dynamic>>> getPresignedUrls(
      List<Map<String, String>> fileDetails) async {
    // (Used for initial onboarding media upload)
    final String methodName = 'getPresignedUrls (Onboarding)';
    print(
        '[MediaRepository $methodName] Getting presigned URLs for onboarding...');
    try {
      String? token = await _getAuthToken();
      if (token == null) throw ApiException('Authentication token is missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'files': fileDetails};
      print('[MediaRepository $methodName] Request Body: $body');

      final response = await _apiService.post(
        '/upload', // <-- Uses the ORIGINAL endpoint for onboarding
        body: body,
        headers: headers,
      );

      print('[MediaRepository $methodName] API Response: $response');
      if (response['uploads'] != null && response['uploads'] is List) {
        print('[MediaRepository $methodName] Presigned URLs received.');
        return List<Map<String, dynamic>>.from(response['uploads']);
      } else {
        final message = response['message']?.toString() ??
            'Failed to get onboarding presigned URLs.';
        print('[MediaRepository $methodName] Failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[MediaRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      rethrow;
    } catch (e) {
      print('[MediaRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'Error getting onboarding presigned URLs: ${e.toString()}');
    }
  }

  Future<Map<String, dynamic>> getAudioPresignedUrl(
      String filename, String fileType, AudioPrompt prompt) async {
    // (Keep as is for audio)
    final String methodName = 'getAudioPresignedUrl';
    print('[MediaRepository $methodName] Getting audio presigned URL...');
    try {
      String? token = await _getAuthToken();
      if (token == null) throw ApiException('Authentication token is missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'filename': filename,
        'type': fileType,
        'prompt': prompt.value,
      };
      print('[MediaRepository $methodName] Request Body: $body');
      final response = await _apiService.post(
        '/audio',
        body: body,
        headers: headers,
      );
      print('[MediaRepository $methodName] API Response: $response');
      return response;
    } on ApiException catch (e) {
      print(
          '[MediaRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      rethrow;
    } catch (e) {
      print('[MediaRepository $methodName] Unexpected Error: $e');
      throw ApiException('Error getting audio presigned URL: ${e.toString()}');
    }
  }

  Future<String> getVerificationPresignedUrl(
      String filename, String fileType) async {
    // (Keep as is for verification)
    final String methodName = 'getVerificationPresignedUrl';
    print(
        '[MediaRepository $methodName] Getting verification presigned URL...');
    try {
      String? token = await _getAuthToken();
      if (token == null) throw ApiException('Authentication token is missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'filename': filename, 'type': fileType};
      print('[MediaRepository $methodName] Request Body: $body');
      final response = await _apiService.post(
        '/verify',
        body: body,
        headers: headers,
      );
      print('[MediaRepository $methodName] API Response: $response');
      if (response['upload_url'] != null) {
        print('[MediaRepository $methodName] Presigned URL received.');
        return response['upload_url'];
      } else {
        final message = response['message']?.toString() ??
            'Failed to get verification presigned URL.';
        print('[MediaRepository $methodName] Failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[MediaRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      rethrow;
    } catch (e) {
      print('[MediaRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'Error getting verification presigned URL: ${e.toString()}');
    }
  }
  // --- End Existing Methods ---

  // --- Upload a file to S3 using presigned URL (No changes needed) ---
  Future<bool> uploadFileToS3(MediaUploadModel mediaUpload) async {
    if (mediaUpload.presignedUrl == null) {
      throw ApiException('Missing presigned URL for upload');
    }

    final file = mediaUpload.file;
    final contentType = mediaUpload.fileType;
    final filePath = file.path;

    try {
      print('⏫ Starting S3 upload for: ${mediaUpload.fileName}');
      print('📁 File path: $filePath');
      print('📦 Content-Type: $contentType');
      print('📏 File size: ${(await file.length()) / 1024} KB');
      print('🔗 Presigned URL: ${mediaUpload.presignedUrl}');

      final client = HttpClient();
      final request = await client.putUrl(Uri.parse(mediaUpload.presignedUrl!));

      request.headers.set(HttpHeaders.contentTypeHeader, contentType);
      request.headers.set(HttpHeaders.contentLengthHeader,
          (await file.length()).toString()); // Ensure length header

      final fileStream = file.openRead();
      await request.addStream(fileStream);
      final response = await request.close();

      final statusCode = response.statusCode;
      final responseBody = await response.transform(utf8.decoder).join();

      print('📩 Upload response: Status=$statusCode, Body=$responseBody');

      if (statusCode != HttpStatus.ok && statusCode != HttpStatus.created) {
        // Allow 201 Created as well
        print('❌ Upload failed with status $statusCode');
        return false;
      }

      print('✅ Upload successful for ${mediaUpload.fileName}');
      return true;
    } catch (e, stack) {
      print('‼️ Critical upload error: $e');
      print('🛑 Stack trace: $stack');
      return false; // Indicate failure
    }
  }
  // --- End S3 Upload ---

  // --- Retry failed uploads with exponential backoff (No changes needed) ---
  Future<bool> retryUpload(MediaUploadModel mediaUpload,
      {int maxRetries = 3}) async {
    int retryCount = 0;
    int backoffMs = 1000;

    while (retryCount < maxRetries) {
      try {
        // Add a small delay before retrying
        await Future.delayed(Duration(milliseconds: backoffMs ~/ 2));
        print(
            '🔄 Retrying upload ($retryCount/${maxRetries - 1}) for: ${mediaUpload.fileName}');
        final success = await uploadFileToS3(mediaUpload);
        if (success) return true;
      } catch (e) {
        print('Retry $retryCount failed: $e');
      }

      retryCount++;
      if (retryCount < maxRetries) {
        await Future.delayed(Duration(milliseconds: backoffMs));
        backoffMs *= 2;
      }
    }
    print(
        '❌ Upload failed after $maxRetries retries for: ${mediaUpload.fileName}');
    return false;
  }
  // --- End Retry Upload ---
}



================================================
File: repositories/user_repository.dart
================================================
// File: lib/repositories/user_repository.dart
import '../models/user_model.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import '../utils/app_enums.dart';

class UserRepository {
  final ApiService _apiService;

  UserRepository(this._apiService);

  // updateLocationGender remains the same
  Future<bool> updateLocationGender(
      double lat, double lon, Gender gender) async {
    final String methodName = 'updateLocationGender';
    print(
        '[UserRepository $methodName] Called with lat: $lat, lon: $lon, gender: ${gender.value}');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'latitude': lat,
        'longitude': lon,
        'gender': gender.value,
      };

      print(
          '[UserRepository $methodName] Making POST request to /api/profile/location-gender');
      final response = await _apiService.post(
        '/api/profile/location-gender',
        body: body,
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print(
            '[UserRepository $methodName] Location/Gender update successful.');
        return true;
      } else {
        final message = response['message']?.toString() ??
            'Failed to update location and gender.';
        print(
            '[UserRepository $methodName] Location/Gender update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while updating location/gender: ${e.toString()}');
    }
  }

  // updateProfileDetails remains the same (used for onboarding step 2)
  Future<bool> updateProfileDetails(Map<String, dynamic> profileData) async {
    final String methodName = 'updateProfileDetails';
    print('[UserRepository $methodName] Called.');
    // Remove any lingering null values which might cause issues with JSON encoding or backend validation
    profileData.removeWhere((key, value) => value == null);
    print('[UserRepository $methodName] Payload to send: $profileData');

    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making POST request to /api/profile');
      final response = await _apiService.post(
        '/api/profile', // The endpoint for main profile details
        body: profileData, // Send the prepared data
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print(
            '[UserRepository $methodName] Profile details update successful.');
        return true;
      } else {
        final message = response['message']?.toString() ??
            'Failed to update profile details.';
        print(
            '[UserRepository $methodName] Profile details update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while updating profile details: ${e.toString()}');
    }
  }

  // --- ADDED editProfile METHOD ---
  Future<bool> editProfile(Map<String, dynamic> profileData) async {
    final String methodName = 'editProfile';
    print('[UserRepository $methodName] Called.');
    // Remove any lingering null values (important for PATCH)
    profileData.removeWhere((key, value) => value == null);
    print(
        '[UserRepository $methodName] Payload to send via PATCH: $profileData');

    // Ensure there's actually something to update
    if (profileData.isEmpty) {
      print(
          '[UserRepository $methodName] No changes detected. Skipping API call.');
      // Consider returning a specific value or message? For now, true as nothing failed.
      return true; // Or throw ApiException("No changes to save.") if preferred
    }

    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }
      final headers = {'Authorization': 'Bearer $token'};

      print(
          '[UserRepository $methodName] Making PATCH request to /api/profile/edit');
      final response = await _apiService.patch(
        '/api/profile/edit', // The specific PATCH endpoint
        body: profileData,
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print('[UserRepository $methodName] Profile edit successful.');
        return true;
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to edit profile.';
        print('[UserRepository $methodName] Profile edit failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while editing profile: ${e.toString()}');
    }
  }
  // --- END ADDED editProfile METHOD ---

  // fetchHomeFeed remains the same
  Future<Map<String, dynamic>> fetchHomeFeed() async {
    final String methodName = 'fetchHomeFeed';
    print('[UserRepository $methodName] Called.');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making GET request to /api/homefeed');
      final response = await _apiService.get('/api/homefeed', headers: headers);

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        final profilesList =
            response['profiles'] as List? ?? []; // Handle null case
        final profiles = profilesList
            .map((profileJson) =>
                UserModel.fromJson(profileJson as Map<String, dynamic>))
            .toList();
        final hasMore = response['has_more'] as bool? ??
            false; // Default to false if missing

        print(
            '[UserRepository $methodName] Home feed fetch successful. Count: ${profiles.length}, Has More: $hasMore');
        return {'profiles': profiles, 'has_more': hasMore};
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch home feed.';
        print('[UserRepository $methodName] Home feed fetch failed: $message');
        // Handle case where 'profiles' might be null but success is true (empty feed)
        if (response['success'] == true &&
            (response['profiles'] == null ||
                (response['profiles'] is List &&
                    (response['profiles'] as List).isEmpty))) {
          print('[UserRepository $methodName] Feed is empty.');
          return {
            'profiles': <UserModel>[],
            'has_more': false
          }; // Return empty list and has_more=false
        }
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while fetching the home feed: ${e.toString()}');
    }
  }

  // fetchUserProfile remains the same
  Future<UserModel> fetchUserProfile() async {
    final String methodName = 'fetchUserProfile';
    print('[UserRepository $methodName] Called.');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making GET request to /get-profile');
      final response = await _apiService.get('/get-profile', headers: headers);

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true && response['user'] != null) {
        print('[UserRepository $methodName] Profile fetch successful.');
        if (response['user'] is Map<String, dynamic>) {
          return UserModel.fromJson(response['user'] as Map<String, dynamic>);
        } else {
          print(
              '[UserRepository $methodName] Error: Invalid user data format in response.');
          throw ApiException('Invalid user data format received from server.');
        }
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch user profile.';
        print('[UserRepository $methodName] Profile fetch failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while fetching the profile: ${e.toString()}');
    }
  }

  // updateProfile (DEPRECATED for edit - keep for onboarding step 2)
  // This uses the POST /api/profile endpoint
  Future<bool> updateProfile(UserModel userModel) async {
    print(
        "[UserRepository updateProfile] Calling updateProfileDetails (POST)...");
    Map<String, dynamic> profileData = userModel.toJsonForProfileUpdate();
    return await updateProfileDetails(profileData);
  }
}



================================================
File: services/api_service.dart
================================================
// File: services/api_service.dart
import 'dart:convert';

/// Abstract class defining the API service interface
abstract class ApiService {
  /// Base URL for all API requests
  String get baseUrl;

  /// Makes a GET request to the specified endpoint
  Future<Map<String, dynamic>> get(String endpoint,
      {Map<String, String>? headers});

  /// Makes a POST request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a PUT request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a PATCH request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> patch(
    // <<< ADDED
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a DELETE request to the specified endpoint
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  });

  /// Adds authorization token to headers
  Map<String, String> addAuthToken(Map<String, String>? headers, String token);
}

/// Exception thrown when API requests fail
class ApiException implements Exception {
  final String message;
  final int? statusCode;

  ApiException(this.message, {this.statusCode});

  @override
  String toString() =>
      'ApiException: $message ${statusCode != null ? '(Status code: $statusCode)' : ''}';
}



================================================
File: services/chat_service.dart
================================================
// File: lib/services/chat_service.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';
// WebSocket Imports
import 'package:web_socket_channel/io.dart';
import 'package:web_socket_channel/status.dart' as WebSocketStatus;
import 'package:web_socket_channel/web_socket_channel.dart';

// App-specific Imports
import 'package:dtx/models/chat_message.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/providers/conversation_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/providers/status_provider.dart';
import 'package:dtx/utils/token_storage.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// --- WebSocketConnectionState enum and webSocketStateProvider (Keep as is) ---
enum WebSocketConnectionState { disconnected, connecting, connected, error }

final webSocketStateProvider = StateProvider<WebSocketConnectionState>(
    (ref) => WebSocketConnectionState.disconnected);
// ---

class ChatService {
  final Ref _ref;
  final String _wsUrl;
  WebSocketChannel? _channel;
  StreamSubscription? _streamSubscription;
  Timer? _reconnectTimer;
  bool _isManualDisconnect = false;
  int _reconnectAttempts = 0;
  static const int _maxReconnectAttempts = 5;
  static const Duration _initialReconnectDelay = Duration(seconds: 2);

  final Map<String, int> _pendingMessages = {};

  ChatService(this._ref, this._wsUrl) {
    print("[ChatService] Initialized with URL: $_wsUrl");
  }

  // --- connect, _onMessageReceived, _handleMessageAck, lifecycle handlers (Keep as is) ---
  Future<void> connect() async {
    _isManualDisconnect = false;
    if (_channel != null &&
        _ref.read(webSocketStateProvider) ==
            WebSocketConnectionState.connected) {
      print("[ChatService] Already connected.");
      return;
    }
    if (_ref.read(webSocketStateProvider) ==
        WebSocketConnectionState.connecting) {
      print("[ChatService] Connection attempt already in progress.");
      return;
    }
    print("[ChatService] Attempting to connect to $_wsUrl...");
    _updateState(WebSocketConnectionState.connecting);
    String? token =
        _ref.read(authProvider).jwtToken ?? await TokenStorage.getToken();
    if (token == null) {
      print("[ChatService] Connection failed: Auth token not found.");
      _updateState(WebSocketConnectionState.error);
      return;
    }
    try {
      final headers = {'Authorization': 'Bearer $token'};
      _channel = IOWebSocketChannel.connect(
        Uri.parse(_wsUrl),
        headers: headers,
        pingInterval: const Duration(seconds: 15),
      );
      print("[ChatService] WebSocket channel created. Listening...");
      _streamSubscription = _channel!.stream.listen(
        _onMessageReceived,
        onDone: _handleDisconnect,
        onError: _handleError,
        cancelOnError: false,
      );
      _updateState(WebSocketConnectionState.connected);
      _reconnectAttempts = 0;
      print("[ChatService] Connection established successfully.");
    } catch (e) {
      print("[ChatService] Connection failed: $e");
      _handleError(e);
    }
  }

  void _onMessageReceived(dynamic message) {
    if (kDebugMode) print("[ChatService] Message received: $message");
    try {
      final Map<String, dynamic> decodedMessage = jsonDecode(message);
      final type = decodedMessage['type'] as String?;

      switch (type) {
        case 'chat_message':
          final messageId = decodedMessage['id'] as int?;
          final senderId = decodedMessage['sender_user_id'] as int?;
          final recipientId = decodedMessage['recipient_user_id'] as int?;
          final sentAtString = decodedMessage['sent_at'] as String?;
          final textContent = decodedMessage['text'] as String?;
          final mediaUrlContent = decodedMessage['media_url'] as String?;
          final mediaTypeContent = decodedMessage['media_type'] as String?;
          // --- ADDED: Parse reply info from received message ---
          final replyToMessageId =
              decodedMessage['reply_to_message_id'] as int?;
          final repliedMessageSenderID =
              decodedMessage['replied_message_sender_id'] as int?;
          final repliedMessageTextSnippet =
              decodedMessage['replied_message_text_snippet'] as String?;
          final repliedMessageMediaType =
              decodedMessage['replied_message_media_type'] as String?;
          // --- END ADDED ---

          if (messageId == null ||
              messageId <= 0 ||
              senderId == null ||
              recipientId == null ||
              sentAtString == null) {
            print(
                "[ChatService] Received 'chat_message' with invalid/missing essential fields. Msg: $decodedMessage");
            return;
          }
          final currentUserId = _ref.read(currentUserIdProvider);
          if (currentUserId == null || recipientId != currentUserId) {
            if (kDebugMode)
              print(
                  "[ChatService] Received message not intended for current user ($currentUserId). Recipient was $recipientId. Ignoring.");
            return;
          }
          if (senderId == currentUserId) {
            if (kDebugMode)
              print(
                  "[ChatService] Received message loopback from self (ID: $messageId). Ignoring.");
            return;
          }
          DateTime sentAt;
          try {
            sentAt = DateTime.parse(sentAtString).toLocal();
          } catch (e) {
            print(
                "[ChatService] Error parsing sent_at '$sentAtString': $e. Using local time as fallback.");
            sentAt = DateTime.now();
          }
          final ChatMessage chatMessage = ChatMessage(
            messageID: messageId,
            senderUserID: senderId,
            recipientUserID: recipientId,
            messageText: textContent ?? '',
            mediaUrl: mediaUrlContent,
            mediaType: mediaTypeContent,
            sentAt: sentAt,
            status: ChatMessageStatus.sent,
            isRead: false,
            readAt: null,
            // --- ADDED: Pass reply fields to constructor ---
            replyToMessageID: replyToMessageId,
            repliedMessageSenderID: repliedMessageSenderID,
            repliedMessageTextSnippet: repliedMessageTextSnippet,
            repliedMessageMediaType: repliedMessageMediaType,
            // --- END ADDED ---
          );
          _ref
              .read(conversationProvider(senderId).notifier)
              .addReceivedMessage(chatMessage);
          if (kDebugMode)
            print(
                "[ChatService] Added received 'chat_message' (ID: $messageId) to conversation with $senderId. ReplyTo: $replyToMessageId");
          break;

        case 'message_ack':
          if (kDebugMode)
            print("[ChatService] Received message_ack: $decodedMessage");
          _handleMessageAck(decodedMessage);
          break;

        case 'status_update':
          if (kDebugMode)
            print("[ChatService] Received status_update: $decodedMessage");
          final userId = decodedMessage['user_id'] as int?;
          final status = decodedMessage['status'] as String?;
          if (userId == null || userId <= 0 || status == null) {
            print(
                "[ChatService] Invalid status_update message: Missing user_id or status. Data: $decodedMessage");
            return;
          }
          final bool isOnline = status.toLowerCase() == 'online';
          if (kDebugMode)
            print(
                "[ChatService] Parsed status_update: UserID=$userId, isOnline=$isOnline");
          _ref
              .read(userStatusUpdateProvider.notifier)
              .updateStatus(userId, isOnline);
          break;

        case 'error':
          print(
              "[ChatService] Received error message from server: ${decodedMessage['content']}");
          break;

        case 'info':
          print(
              "[ChatService] Received info message from server: ${decodedMessage['content']}");
          break;

        default:
          print(
              "[ChatService] Received unhandled message type '$type': $decodedMessage");
      }
    } catch (e, stacktrace) {
      print("[ChatService] Error processing received message: $e");
      print("[ChatService] Stacktrace: $stacktrace");
    }
  }

  // --- MODIFIED: sendMessage signature and logic ---
  void sendMessage(
    int recipientUserId, {
    String? text,
    String? mediaUrl,
    String? mediaType,
    int? replyToMessageId, // <<< ADDED parameter
  }) {
    if (_channel == null ||
        _ref.read(webSocketStateProvider) !=
            WebSocketConnectionState.connected) {
      print("[ChatService] Cannot send message: Not connected.");
      return;
    }
    final currentUserId = _ref.read(currentUserIdProvider);
    if (currentUserId == null) {
      print("[ChatService] Cannot send message: Current User ID is null.");
      return;
    }
    Map<String, dynamic> payload = {
      'type': "chat_message",
      'recipient_user_id': recipientUserId,
    };
    bool isMediaMessage = false;
    String? optimisticTempId;
    if (mediaUrl != null &&
        mediaUrl.isNotEmpty &&
        mediaType != null &&
        mediaType.isNotEmpty) {
      payload['media_url'] = mediaUrl;
      payload['media_type'] = mediaType;
      payload['text'] = null; // Ensure text is null for media messages
      isMediaMessage = true;
      print("[ChatService] Preparing media message payload.");
    } else if (text != null && text.trim().isNotEmpty) {
      payload['text'] = text.trim();
      payload['media_url'] = null; // Ensure media is null for text messages
      payload['media_type'] = null;
      isMediaMessage = false;
      print("[ChatService] Preparing text message payload.");
    } else {
      print("[ChatService] Cannot send: Message must have text or media.");
      return;
    }

    // *** ADDED: Include replyToMessageId in payload if provided ***
    if (replyToMessageId != null && replyToMessageId > 0) {
      payload['reply_to_message_id'] = replyToMessageId;
      print(
          "[ChatService] Adding replyToMessageId: $replyToMessageId to payload.");
    }
    // *** END ADDED ***

    final messageJson = jsonEncode(payload);
    print("[ChatService] Sending message (Type: chat_message): $messageJson");
    try {
      if (!isMediaMessage) {
        optimisticTempId = DateTime.now().millisecondsSinceEpoch.toString();
        // Create optimistic message (no reply info needed for optimistic UI?)
        // We only need the *real* message to display the reply snippet.
        final sentMessage = ChatMessage(
          tempId: optimisticTempId,
          messageID: 0,
          senderUserID: currentUserId,
          recipientUserID: recipientUserId,
          messageText: text!,
          sentAt: DateTime.now().toLocal(),
          status: ChatMessageStatus.pending,
          isRead: false, // Assuming not read yet
          readAt: null,
          mediaUrl: null,
          mediaType: null,
          // No reply info needed for optimistic display of the *new* message
        );
        addPendingMessage(optimisticTempId, recipientUserId);
        _ref
            .read(conversationProvider(recipientUserId).notifier)
            .addSentMessage(sentMessage);
        print(
            "[ChatService] Added optimistic TEXT message (TempID: $optimisticTempId) to conversation with $recipientUserId");
      } else {
        print(
            "[ChatService] Media message payload prepared. Optimistic message added by ChatDetailScreen.");
      }
      _channel!.sink.add(messageJson);
      print("[ChatService] Message added to WebSocket sink.");
    } catch (e) {
      print("[ChatService] Error adding message to WebSocket sink: $e");
      if (optimisticTempId != null) {
        print(
            "[ChatService] Marking optimistic message $optimisticTempId as failed due to sink error.");
        removePendingMessage(optimisticTempId);
        _ref
            .read(conversationProvider(recipientUserId).notifier)
            .updateMessageStatus(optimisticTempId, ChatMessageStatus.failed,
                errorMessage: "Failed to send message.");
      }
      _handleError(e);
    }
  }
  // --- END MODIFIED ---

  // --- _handleMessageAck (Keep as is) ---
  void _handleMessageAck(Map<String, dynamic> ackData) {
    final realMessageId = ackData['id'] as int?;
    final ackContent = ackData['content'] as String?;
    final mediaUrlAck = ackData['media_url'] as String?;
    if (kDebugMode)
      print(
          "[ChatService _handleMessageAck] Received: RealID=$realMessageId, Content='$ackContent', MediaURL='$mediaUrlAck'");
    if (realMessageId == null) {
      print("[ChatService _handleMessageAck] Invalid ack: Missing real ID.");
      return;
    }
    final currentUserId = _ref.read(currentUserIdProvider);
    if (currentUserId == null) {
      print(
          "[ChatService _handleMessageAck] Cannot process ack: Current User ID is null.");
      return;
    }
    String? foundTempId;
    int? foundRecipientId;
    if (_pendingMessages.isNotEmpty) {
      foundTempId = _pendingMessages.keys.first;
      foundRecipientId = _pendingMessages.values.first;
      if (kDebugMode)
        print(
            "[ChatService _handleMessageAck] Found pending message via map (FIFO): TempID=$foundTempId for Recipient=$foundRecipientId");
      removePendingMessage(foundTempId);
    } else {
      print(
          "[ChatService _handleMessageAck] No pending messages found in tracking map.");
    }
    if (foundTempId != null && foundRecipientId != null) {
      if (kDebugMode)
        print(
            "[ChatService _handleMessageAck] Updating message (TempID: $foundTempId) for ack (Real ID: $realMessageId). Status -> Sent.");
      final conversationNotifier =
          _ref.read(conversationProvider(foundRecipientId).notifier);
      conversationNotifier.updateMessageStatus(
          foundTempId, ChatMessageStatus.sent,
          finalMessageId: realMessageId, finalMediaUrl: mediaUrlAck);
      if (kDebugMode)
        print(
            "[ChatService _handleMessageAck] Message status updated successfully.");
    } else {
      print(
          "[ChatService _handleMessageAck] WARNING: Received message_ack for Real ID $realMessageId, but couldn't find a matching tracked pending message.");
    }
  }

  // --- Public Helper methods for tracking pending messages (Keep as is) ---
  void addPendingMessage(String tempId, int recipientId) {
    _pendingMessages[tempId] = recipientId;
    print(
        "[ChatService addPendingMessage] Added TempID: $tempId for Recipient: $recipientId. Count: ${_pendingMessages.length}");
  }

  void removePendingMessage(String tempId) {
    if (_pendingMessages.containsKey(tempId)) {
      _pendingMessages.remove(tempId);
      print(
          "[ChatService removePendingMessage] Removed TempID: $tempId. Count: ${_pendingMessages.length}");
    }
  }
  // --- End Public Helpers ---

  // --- WebSocket Lifecycle Handlers (Keep as is) ---
  void _handleDisconnect() {
    print("[ChatService] WebSocket disconnected.");
    _channel = null;
    _streamSubscription?.cancel();
    _streamSubscription = null;
    _pendingMessages.clear();
    print("[ChatService _handleDisconnect] Cleared pending messages map.");
    _updateState(WebSocketConnectionState.disconnected);
    if (!_isManualDisconnect) {
      _scheduleReconnect();
    }
  }

  void _handleError(dynamic error) {
    print("[ChatService] WebSocket error: $error");
    _channel = null;
    _streamSubscription?.cancel();
    _streamSubscription = null;
    _pendingMessages.clear();
    print("[ChatService _handleError] Cleared pending messages map.");
    _updateState(WebSocketConnectionState.error);
    if (!_isManualDisconnect) {
      _scheduleReconnect();
    }
  }

  void _scheduleReconnect() {
    if (_reconnectTimer?.isActive ?? false) return;
    if (_reconnectAttempts >= _maxReconnectAttempts) {
      print("[ChatService] Max reconnect attempts reached.");
      _updateState(WebSocketConnectionState.disconnected);
      return;
    }
    _reconnectAttempts++;
    final delayMilliseconds =
        _initialReconnectDelay.inMilliseconds * (1 << (_reconnectAttempts - 1));
    final delay = Duration(milliseconds: delayMilliseconds);
    print(
        "[ChatService] Scheduling reconnect attempt $_reconnectAttempts/$_maxReconnectAttempts in $delay...");
    _reconnectTimer = Timer(delay, () {
      print("[ChatService] Attempting reconnect...");
      connect();
    });
  }

  void disconnect() {
    print("[ChatService] Manual disconnect initiated.");
    _isManualDisconnect = true;
    _reconnectTimer?.cancel();
    _reconnectAttempts = 0;
    _streamSubscription?.cancel();
    _pendingMessages.clear();
    print("[ChatService disconnect] Cleared pending messages map.");
    _channel?.sink.close(WebSocketStatus.normalClosure);
    _channel = null;
    _streamSubscription = null;
    _updateState(WebSocketConnectionState.disconnected);
    print("[ChatService] Disconnected.");
  }

  void _updateState(WebSocketConnectionState newState) {
    Future.microtask(() {
      if (_ref.read(webSocketStateProvider) != newState) {
        _ref.read(webSocketStateProvider.notifier).state = newState;
        print("[ChatService] WebSocket state updated to: $newState");
      }
    });
  }
  // --- End Lifecycle Handlers ---
}

// --- currentUserIdProvider (Keep as is) ---
final currentUserIdProvider = Provider<int?>((ref) {
  return ref.watch(userProvider.select((user) => user.id));
});
// ---



================================================
File: services/http_service.dart
================================================
// File: services/http_service.dart
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'api_service.dart';
import 'dart:developer' as developer; // Import developer for log function

/// Implementation of ApiService using the http package
class HttpService implements ApiService {
  @override
  final String baseUrl;

  HttpService({required this.baseUrl});

  // Helper function for logging
  void _log(String method, String url,
      {Object? body, Map<String, String>? headers}) {
    final logMessage = StringBuffer();
    logMessage.writeln("--------- HTTP Request ---------");
    logMessage.writeln("Method: $method");
    logMessage.writeln("URL: $url");
    if (headers != null) {
      // Avoid logging sensitive headers like Authorization directly in production logs if possible
      final sanitizedHeaders = Map<String, String>.from(headers);
      if (sanitizedHeaders.containsKey('Authorization')) {
        sanitizedHeaders['Authorization'] = 'Bearer [REDACTED]';
      }
      logMessage.writeln("Headers: $sanitizedHeaders");
    }
    if (body != null) {
      try {
        // Try to encode body for pretty printing, limit length
        String bodyString = json.encode(body);
        if (bodyString.length > 500) {
          bodyString = '${bodyString.substring(0, 500)}... [TRUNCATED]';
        }
        logMessage.writeln("Body: $bodyString");
      } catch (e) {
        logMessage.writeln("Body: (Could not encode body for logging: $e)");
      }
    }
    logMessage.write("--------------------------------");
    developer.log(logMessage.toString(),
        name: 'HttpService'); // Use developer.log
  }

  @override
  Map<String, String> addAuthToken(Map<String, String>? headers, String token) {
    final updatedHeaders = {...(headers ?? {})};
    updatedHeaders['Authorization'] = 'Bearer $token';
    // Avoid logging the token directly here if possible, logged sanitized in _log
    return updatedHeaders;
  }

  @override
  Future<Map<String, dynamic>> get(String endpoint,
      {Map<String, String>? headers}) async {
    final url = '$baseUrl$endpoint';
    _log('GET', url, headers: headers); // Log request
    try {
      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type':
              'application/json', // Still specify expected request type
          // 'Accept-Charset': 'utf-8', // Tell server we prefer UTF-8
          ...?headers,
        },
      );
      // Pass the raw response to _handleResponse
      return _handleResponse(response, 'GET', url);
    } on SocketException catch (e) {
      developer.log('SocketException on GET $url: $e',
          name: 'HttpService', error: e);
      throw ApiException('No internet connection or server unavailable.');
    } catch (e) {
      developer.log('Error performing GET $url: $e',
          name: 'HttpService', error: e);
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform GET request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    final url = '$baseUrl$endpoint';
    _log('POST', url, body: body, headers: headers); // Log request
    try {
      final response = await http.post(
        Uri.parse(url),
        headers: {
          'Content-Type':
              'application/json; charset=utf-8', // Specify UTF-8 in request
          // 'Accept-Charset': 'utf-8', // And accept it
          ...?headers,
        },
        // json.encode naturally handles UTF-8
        body: json.encode(body),
      );
      // Pass the raw response to _handleResponse
      return _handleResponse(response, 'POST', url);
    } on SocketException catch (e) {
      developer.log('SocketException on POST $url: $e',
          name: 'HttpService', error: e);
      throw ApiException('No internet connection or server unavailable.');
    } catch (e) {
      developer.log('Error performing POST $url: $e',
          name: 'HttpService', error: e);
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform POST request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    final url = '$baseUrl$endpoint';
    _log('PUT', url, body: body, headers: headers); // Log request
    try {
      final response = await http.put(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          // 'Accept-Charset': 'utf-8',
          ...?headers,
        },
        body: json.encode(body),
      );
      return _handleResponse(response, 'PUT', url);
    } on SocketException catch (e) {
      developer.log('SocketException on PUT $url: $e',
          name: 'HttpService', error: e);
      throw ApiException('No internet connection or server unavailable.');
    } catch (e) {
      developer.log('Error performing PUT $url: $e',
          name: 'HttpService', error: e);
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform PUT request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> patch(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    final url = '$baseUrl$endpoint';
    _log('PATCH', url, body: body, headers: headers); // Log request
    try {
      final response = await http.patch(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          // 'Accept-Charset': 'utf-8',
          ...?headers,
        },
        body: json.encode(body),
      );
      return _handleResponse(response, 'PATCH', url);
    } on SocketException catch (e) {
      developer.log('SocketException on PATCH $url: $e',
          name: 'HttpService', error: e);
      throw ApiException('No internet connection or server unavailable.');
    } catch (e) {
      developer.log('Error performing PATCH $url: $e',
          name: 'HttpService', error: e);
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform PATCH request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  }) async {
    final url = '$baseUrl$endpoint';
    _log('DELETE', url, body: body, headers: headers); // Log request
    try {
      final request = http.Request('DELETE', Uri.parse(url));

      request.headers.addAll({
        'Content-Type': 'application/json; charset=utf-8',
        // 'Accept-Charset': 'utf-8',
        ...?headers,
      });

      if (body != null) {
        request.body = json.encode(body);
      }

      final streamedResponse = await request.send();
      final response = await http.Response.fromStream(streamedResponse);

      return _handleResponse(response, 'DELETE', url);
    } on SocketException catch (e) {
      developer.log('SocketException on DELETE $url: $e',
          name: 'HttpService', error: e);
      throw ApiException('No internet connection or server unavailable.');
    } catch (e) {
      developer.log('Error performing DELETE $url: $e',
          name: 'HttpService', error: e);
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform DELETE request: ${e.toString()}');
    }
  }

  /// Handle the HTTP response, decode it, and convert to a standardized format
  Map<String, dynamic> _handleResponse(
      http.Response response, String method, String url) {
    final logResponse = StringBuffer();
    logResponse.writeln("--------- HTTP Response ---------");
    logResponse.writeln("URL: $method $url");
    logResponse.writeln("Status Code: ${response.statusCode}");
    logResponse.writeln("Headers: ${response.headers}");
    // Log raw bytes (truncated) - useful for seeing if corruption happened before decoding
    final bytesLength = response.bodyBytes.length;
    final truncatedBytes =
        response.bodyBytes.sublist(0, (bytesLength > 200 ? 200 : bytesLength));
    logResponse.writeln(
        "Raw Body Bytes (first ${truncatedBytes.length}): $truncatedBytes");

    String responseBody = ''; // Store decoded body

    try {
      // *** Explicitly decode response body as UTF-8 ***
      // Use allowMalformed: true to prevent crashing if bytes are truly invalid
      // Although if they are invalid, the source is likely the server or proxy.
      responseBody = utf8.decode(response.bodyBytes, allowMalformed: true);
      logResponse.writeln(
          "Decoded Body (UTF-8, truncated): ${responseBody.substring(0, (responseBody.length > 500 ? 500 : responseBody.length))}...");
      logResponse.write("--------------------------------");
      developer.log(logResponse.toString(),
          name: 'HttpService'); // Log before JSON decode attempt

      // --- Process based on Status Code ---
      if (response.statusCode >= 200 && response.statusCode < 300) {
        if (responseBody.isEmpty) {
          developer.log(
              'Success (Status ${response.statusCode}) with empty body.',
              name: 'HttpService');
          return {'success': true, 'message': 'Operation successful'};
        }
        // Attempt to decode the JSON from the UTF-8 string
        final responseData = json.decode(responseBody) as Map<String, dynamic>;
        developer.log('Success (Status ${response.statusCode}) with JSON body.',
            name: 'HttpService');
        return responseData; // Assuming server sends success field if applicable
      } else {
        // --- Handle Error Status Codes ---
        developer.log('Error Status Code: ${response.statusCode}',
            name: 'HttpService');
        Map<String, dynamic>? responseData;
        String errorMessage =
            'Request failed: ${response.statusCode} ${response.reasonPhrase ?? ''}'; // Default error

        try {
          if (responseBody.isNotEmpty) {
            // Try to parse error details from the body
            responseData = json.decode(responseBody) as Map<String, dynamic>;
            if (responseData.containsKey('message')) {
              errorMessage = responseData['message'].toString();
            } else if (responseData.containsKey('error')) {
              errorMessage = responseData['error'].toString();
            }
            developer.log('Parsed error response body: $responseData',
                name: 'HttpService');
          }
        } on FormatException {
          developer.log('Warning: Non-JSON error response body received.',
              name: 'HttpService');
          // Use the default errorMessage from status code/reason phrase
        }

        // Throw the specific error
        throw ApiException(errorMessage, statusCode: response.statusCode);
      }
    } on FormatException catch (e) {
      // Catch errors during json.decode()
      final bodyStart = responseBody.substring(
          0, (responseBody.length > 200 ? 200 : responseBody.length));
      developer.log(
          'JSON FormatException: $e. Decoded body started with: "$bodyStart"',
          name: 'HttpService',
          error: e);
      throw ApiException('Invalid JSON format received from server.',
          statusCode: response.statusCode);
    } catch (e) {
      // Catch other errors during response handling (e.g., UTF-8 decode if malformed bytes were strict)
      developer.log('Error processing response: $e',
          name: 'HttpService', error: e);
      // Re-throw specific ApiException if it came from the error handling block above
      if (e is ApiException) rethrow;
      // Otherwise, wrap in a generic ApiException
      throw ApiException('Failed to process response: ${e.toString()}',
          statusCode: response.statusCode);
    }
  }
}



================================================
File: utils/app_enums.dart
================================================
// File: lib/utils/app_enums.dart
// Import the correct location of ContentLikeType
import 'package:dtx/models/like_models.dart' show ContentLikeType;

// --- Existing Enums (Gender, DatingIntention, Religion, etc.) ---
// ... (keep all existing enums as they are) ...

enum Gender {
  man('man', 'Man'),
  woman('woman', 'Woman');

  final String value;
  final String label;
  const Gender(this.value, this.label);
}

enum DatingIntention {
  lifePartner('lifePartner', 'Life partner'),
  longTerm('longTerm', 'Long-term relationship'),
  longTermOpenShort(
      'longTermOpenShort', 'Long-term, open to short'), // Shortened label
  shortTermOpenLong(
      'shortTermOpenLong', 'Short-term, open to long'), // Shortened label
  shortTerm('shortTerm', 'Short-term relationship'),
  figuringOut('figuringOut', 'Figuring out my dating goals');

  final String value;
  final String label;
  const DatingIntention(this.value, this.label);
}

enum Religion {
  agnostic('agnostic', 'Agnostic'),
  atheist('atheist', 'Atheist'),
  buddhist('buddhist', 'Buddhist'),
  christian('christian', 'Christian'),
  hindu('hindu', 'Hindu'),
  jain('jain', 'Jain'),
  jewish('jewish', 'Jewish'),
  muslim('muslim', 'Muslim'),
  zoroastrian('zoroastrian', 'Zoroastrian'),
  sikh('sikh', 'Sikh'),
  spiritual('spiritual', 'Spiritual');

  final String value;
  final String label;
  const Religion(this.value, this.label);
}

enum DrinkingSmokingHabits {
  yes('yes', 'Yes'),
  sometimes('sometimes', 'Sometimes'),
  no('no', 'No');

  final String value;
  final String label;
  const DrinkingSmokingHabits(this.value, this.label);
}

enum PromptCategory {
  storyTime('storyTime', 'Story time'),
  myType('myType', 'My type'),
  gettingPersonal('gettingPersonal', 'Getting personal'),
  dateVibes('dateVibes', 'Date vibes');

  final String value;
  final String label;
  const PromptCategory(this.value, this.label);

  ContentLikeType get contentType {
    switch (this) {
      case PromptCategory.storyTime:
        return ContentLikeType.promptStory;
      case PromptCategory.myType:
        return ContentLikeType.promptMytype;
      case PromptCategory.gettingPersonal:
        return ContentLikeType.promptGettingpersonal;
      case PromptCategory.dateVibes:
        return ContentLikeType.promptDatevibes;
    }
  }

  List<PromptType> getPrompts() {
    switch (this) {
      case PromptCategory.storyTime:
        return [
          PromptType.twoTruthsAndALie,
          PromptType.worstIdea,
          PromptType.biggestRisk,
          PromptType.biggestDateFail,
          PromptType.neverHaveIEver,
          PromptType.bestTravelStory,
          PromptType.weirdestGift,
          PromptType.mostSpontaneous,
          PromptType.oneThingNeverDoAgain,
        ];
      case PromptCategory.myType:
        return [
          PromptType.nonNegotiable,
          PromptType.hallmarkOfGoodRelationship,
          PromptType.lookingFor,
          PromptType.weirdlyAttractedTo,
          PromptType.allIAskIsThatYou,
          PromptType.wellGetAlongIf,
          PromptType.wantSomeoneWho,
          PromptType.greenFlags,
          PromptType.sameTypeOfWeird,
          PromptType.fallForYouIf,
          PromptType.bragAboutYou,
        ];
      case PromptCategory.gettingPersonal:
        return [
          PromptType.oneThingYouShouldKnow,
          PromptType.loveLanguage,
          PromptType.dorkiestThing,
          PromptType.dontHateMeIf,
          PromptType.geekOutOn,
          PromptType.ifLovingThisIsWrong,
          PromptType.keyToMyHeart,
          PromptType.wontShutUpAbout,
          PromptType.shouldNotGoOutWithMeIf,
          PromptType.whatIfIToldYouThat,
        ];
      case PromptCategory.dateVibes:
        return [
          PromptType.togetherWeCould,
          PromptType.firstRoundIsOnMeIf,
          PromptType.whatIOrderForTheTable,
          PromptType.bestSpotInTown,
          PromptType.bestWayToAskMeOut,
        ];
    }
  }
}

enum PromptType {
  // Story Time
  twoTruthsAndALie('twoTruthsAndALie', 'Two truths and a lie'),
  worstIdea('worstIdea', 'Worst idea I\'ve ever had'),
  biggestRisk('biggestRisk', 'Biggest risk I\'ve taken'),
  biggestDateFail('biggestDateFail', 'My biggest date fail'),
  neverHaveIEver('neverHaveIEver', 'Never have I ever'),
  bestTravelStory('bestTravelStory', 'Best travel story'),
  weirdestGift('weirdestGift', 'Weirdest gift I\'ve given or received'),
  mostSpontaneous('mostSpontaneous', 'Most spontaneous thing I\'ve done'),
  oneThingNeverDoAgain(
      'oneThingNeverDoAgain', 'One thing I\'ll never do again'),
  // My Type
  nonNegotiable('nonNegotiable', 'Something that\'s non-negotiable for me is'),
  hallmarkOfGoodRelationship(
      'hallmarkOfGoodRelationship', 'The hallmark of a good relationship is'),
  lookingFor('lookingFor', 'I\'m looking for'),
  weirdlyAttractedTo('weirdlyAttractedTo', 'I\'m weirdly attracted to'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  wellGetAlongIf('wellGetAlongIf', 'We\'ll get along if'),
  wantSomeoneWho('wantSomeoneWho', 'I want someone who'),
  greenFlags('greenFlags', 'Green flags I look out for'),
  sameTypeOfWeird('sameTypeOfWeird', 'We\'re the same type of weird if'),
  fallForYouIf('fallForYouIf', 'I\'d fall for you if'),
  bragAboutYou('bragAboutYou', 'I\'ll brag about you to my friends if'),
  // Getting Personal
  oneThingYouShouldKnow(
      'oneThingYouShouldKnow', 'The one thing you should know about me is'),
  loveLanguage('loveLanguage', 'My Love Language is'),
  dorkiestThing('dorkiestThing', 'The dorkiest thing about me is'),
  dontHateMeIf('dontHateMeIf', 'Don\'t hate me if I'),
  geekOutOn('geekOutOn', 'I geek out on'),
  ifLovingThisIsWrong('ifLovingThisIsWrong',
      'If loving this is wrong, I don\'t want to be right'),
  keyToMyHeart('keyToMyHeart', 'The key to my heart is'),
  wontShutUpAbout('wontShutUpAbout', 'I won\'t shut up about'),
  shouldNotGoOutWithMeIf(
      'shouldNotGoOutWithMeIf', 'You should *not* go out with me if'),
  whatIfIToldYouThat('whatIfIToldYouThat', 'What if I told you that'),
  // Date Vibes
  togetherWeCould('togetherWeCould', 'Together, we could'),
  firstRoundIsOnMeIf('firstRoundIsOnMeIf', 'First round is on me if'),
  whatIOrderForTheTable('whatIOrderForTheTable', 'What I order for the table'),
  bestSpotInTown('bestSpotInTown', 'I know the best spot in town for'),
  bestWayToAskMeOut('bestWayToAskMeOut', 'The best way to ask me out is by');

  final String value;
  final String label;
  const PromptType(this.value, this.label);

  PromptCategory getCategory() {
    for (var category in PromptCategory.values) {
      if (category.getPrompts().contains(this)) {
        return category;
      }
    }
    print("Warning: PromptType '$value' does not belong to a known category.");
    return PromptCategory.storyTime; // Defaulting
  }
}

enum AudioPrompt {
  canWeTalkAbout('canWeTalkAbout', 'Can we talk about?'),
  captionThisPhoto('captionThisPhoto', 'Caption this photo'),
  caughtInTheAct('caughtInTheAct', 'Caught in the act'),
  changeMyMindAbout('changeMyMindAbout', 'Change my mind about'),
  chooseOurFirstDate('chooseOurFirstDate', 'Choose our first date'),
  commentIfYouveBeenHere(
      'commentIfYouveBeenHere', 'Comment if you\'ve been here'),
  cookWithMe('cookWithMe', 'Cook with me'),
  datingMeIsLike('datingMeIsLike', 'Dating me is like'),
  datingMeWillLookLike('datingMeWillLookLike', 'Dating me will look like'),
  doYouAgreeOrDisagreeThat(
      'doYouAgreeOrDisagreeThat', 'Do you agree or disagree that'),
  dontHateMeIfI('dontHateMeIfI', 'Don\'t hate me if I'),
  dontJudgeMe('dontJudgeMe', 'Don\'t judge me'),
  mondaysAmIRight('mondaysAmIRight', 'Mondays... am I right?'),
  aBoundaryOfMineIs('aBoundaryOfMineIs', 'A boundary of mine is'),
  aDailyEssential('aDailyEssential', 'A daily essential'),
  aDreamHomeMustInclude('aDreamHomeMustInclude', 'A dream home must include'),
  aFavouriteMemoryOfMine(
      'aFavouriteMemoryOfMine', 'A favourite memory of mine'),
  aFriendsReviewOfMe('aFriendsReviewOfMe', 'A friend\'s review of me'),
  aLifeGoalOfMine('aLifeGoalOfMine', 'A life goal of mine'),
  aQuickRantAbout('aQuickRantAbout', 'A quick rant about'),
  aRandomFactILoveIs('aRandomFactILoveIs', 'A random fact I love is'),
  aSpecialTalentOfMine('aSpecialTalentOfMine', 'A special talent of mine'),
  aThoughtIRecentlyHadInTheShower('aThoughtIRecentlyHadInTheShower',
      'A thought I recently had in the shower'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  guessWhereThisPhotoWasTaken(
      'guessWhereThisPhotoWasTaken', 'Guess where this photo was taken'),
  helpMeIdentifyThisPhotoBomber(
      'helpMeIdentifyThisPhotoBomber', 'Help me identify this photo bomber'),
  hiFromMeAndMyPet('hiFromMeAndMyPet', 'Hi from me and my pet'),
  howIFightTheSundayScaries(
      'howIFightTheSundayScaries', 'How I fight the Sunday scaries'),
  howHistoryWillRememberMe(
      'howHistoryWillRememberMe', 'How history will remember me'),
  howMyFriendsSeeMe('howMyFriendsSeeMe', 'How my friends see me'),
  howToPronounceMyName('howToPronounceMyName', 'How to pronounce my name'),
  iBeatMyBluesBy('iBeatMyBluesBy', 'I beat my blues by'),
  iBetYouCant('iBetYouCant', 'I bet you can\'t'),
  iCanTeachYouHowTo('iCanTeachYouHowTo', 'I can teach you how to'),
  iFeelFamousWhen('iFeelFamousWhen', 'I feel famous when'),
  iFeelMostSupportedWhen(
      'iFeelMostSupportedWhen', 'I feel most supported when');

  final String value;
  final String label;
  const AudioPrompt(this.value, this.label);
}

// --- ADDED: ReportReason Enum ---
enum ReportReason {
  notInterested('notInterested', 'Not Interested'),
  fakeProfile('fakeProfile', 'Fake Profile/Scam'),
  inappropriate('inappropriate', 'Inappropriate Content/Behavior'),
  minor('minor', 'Underage User'),
  spam('spam', 'Spam or Solicitation');

  final String value;
  final String label; // User-friendly label
  const ReportReason(this.value, this.label);
}
// --- END ADDED ---



================================================
File: utils/date_formatter.dart
================================================
// File: lib/utils/date_formatter.dart
import 'package:intl/intl.dart'; // Add intl package to pubspec.yaml if not already there
import 'package:flutter/foundation.dart';

String formatLastSeen(DateTime? lastSeen, {bool short = false}) {
  final methodName = 'formatLastSeen';
  if (lastSeen == null) {
    if (kDebugMode) print("[$methodName] Input DateTime is null.");
    return short ? '' : 'Last seen: unavailable';
  }

  final now = DateTime.now();
  final difference = now.difference(lastSeen);

  if (kDebugMode)
    print(
        "[$methodName] Formatting: Now=$now, LastSeen=$lastSeen, Diff=$difference");

  if (difference.inSeconds < 60) {
    return short ? 'just now' : 'Last seen: just now';
  } else if (difference.inMinutes < 60) {
    final minutes = difference.inMinutes;
    return short
        ? '${minutes}m ago'
        : 'Last seen: $minutes minute${minutes > 1 ? 's' : ''} ago';
  } else if (difference.inHours < 24 && now.day == lastSeen.day) {
    final hours = difference.inHours;
    return short
        ? '${hours}h ago'
        : 'Last seen: $hours hour${hours > 1 ? 's' : ''} ago';
  } else if (difference.inDays == 1 ||
      (difference.inHours < 48 && now.day == lastSeen.day + 1)) {
    return short ? 'Yesterday' : 'Last seen: Yesterday';
  } else if (difference.inDays < 7) {
    // Within the last week, show day name
    final formatter = DateFormat('EEEE'); // e.g., 'Monday'
    final dayName = formatter.format(lastSeen);
    return short ? dayName : 'Last seen: $dayName';
  } else {
    // Older than a week, show date
    final formatter = DateFormat('MMM d, yyyy'); // e.g., 'Apr 29, 2025'
    final dateStr = formatter.format(lastSeen);
    return short ? dateStr : 'Last seen: $dateStr';
  }
}



================================================
File: utils/datetime_formatter.dart
================================================
// File: lib/utils/date_formatter.dart
import 'package:intl/intl.dart';
import 'package:flutter/foundation.dart'; // For kDebugMode

class DateFormatter {
  // Static function to format the last seen timestamp
  static String formatLastSeen(DateTime? lastSeenUtc) {
    if (kDebugMode) {
      print("[DateFormatter formatLastSeen] Input (UTC?): $lastSeenUtc");
    }
    if (lastSeenUtc == null) {
      if (kDebugMode) {
        print("[DateFormatter formatLastSeen] Input is null, returning empty.");
      }
      return ""; // Return empty or maybe "Last seen: unavailable"
    }

    // Ensure we are comparing local times
    final DateTime lastSeenLocal = lastSeenUtc.toLocal();
    final DateTime now = DateTime.now();
    final Duration difference = now.difference(lastSeenLocal);

    if (kDebugMode) {
      print(
          "[DateFormatter formatLastSeen] Last Seen Local: $lastSeenLocal, Now: $now, Difference: ${difference.inMinutes} mins");
    }

    if (difference.isNegative) {
      // Timestamp is in the future? Should not happen, maybe due to clock skew.
      // Return a safe default.
      if (kDebugMode) {
        print(
            "[DateFormatter formatLastSeen] WARNING: Timestamp is in the future!");
      }
      return "Last seen: ${DateFormat.yMd().add_jm().format(lastSeenLocal)}";
    }

    if (difference.inSeconds < 60) {
      return "Last seen: just now";
    } else if (difference.inMinutes < 60) {
      return "Last seen: ${difference.inMinutes}m ago";
    } else if (difference.inHours < 24) {
      // Check if it was today but more than an hour ago
      if (lastSeenLocal.year == now.year &&
          lastSeenLocal.month == now.month &&
          lastSeenLocal.day == now.day) {
        return "Last seen: ${difference.inHours}h ago";
      } else {
        // If it crossed midnight but is less than 24 hours ago, show 'Yesterday'
        return "Last seen: Yesterday at ${DateFormat.jm().format(lastSeenLocal)}";
      }
    } else if (difference.inDays == 1 ||
        (difference.inHours < 48 &&
            (now.day - lastSeenLocal.day == 1 ||
                (now.day == 1 && lastSeenLocal.day >= 28)))) {
      // Handle 'Yesterday' specifically, accounting for day changes
      return "Last seen: Yesterday at ${DateFormat.jm().format(lastSeenLocal)}";
    } else if (difference.inDays < 7) {
      // Within the last week, show day name
      return "Last seen: ${DateFormat('EEEE').format(lastSeenLocal)} at ${DateFormat.jm().format(lastSeenLocal)}";
    } else {
      // Older than a week, show date
      return "Last seen: ${DateFormat.yMd().format(lastSeenLocal)}";
    }
  }

  // --- Keep your existing formatChatMessageTimestamp if you have it ---
  static String formatChatMessageTimestamp(DateTime timestamp) {
    final now = DateTime.now();
    final localTimestamp = timestamp.toLocal();

    if (now.year == localTimestamp.year &&
        now.month == localTimestamp.month &&
        now.day == localTimestamp.day) {
      // Today: Show time only
      return DateFormat.jm().format(localTimestamp);
    } else if (now.year == localTimestamp.year &&
        now.month == localTimestamp.month &&
        now.day - localTimestamp.day == 1) {
      // Yesterday: Show "Yesterday"
      return "Yesterday";
    } else if (now.difference(localTimestamp).inDays < 7) {
      // Within the last week: Show day name (e.g., "Tuesday")
      return DateFormat('EEEE').format(localTimestamp);
    } else {
      // Older than a week: Show date (e.g., "4/15/2024")
      return DateFormat.yMd().format(localTimestamp);
    }
  }
}



================================================
File: utils/env_config.dart
================================================

// File: utils/env_config.dart
import 'package:flutter_dotenv/flutter_dotenv.dart';

class EnvConfig {
  static String get apiBaseUrl => 
    dotenv.get('API_BASE_URL', fallback: 'http://10.61.67.128:8080');
}



================================================
File: utils/token_storage.dart
================================================

// File: utils/token_storage.dart
import 'package:shared_preferences/shared_preferences.dart';

class TokenStorage {
  static const String _tokenKey = 'auth_token';
  
  // Save the JWT token
  static Future<bool> saveToken(String token) async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.setString(_tokenKey, token);
  }
  
  // Get the stored JWT token
  static Future<String?> getToken() async {
    final prefs = await SharedPreferences.getInstance();
    print(prefs.getString(_tokenKey));
    return prefs.getString(_tokenKey);
  }
  
  // Remove the stored token (for logout)
  static Future<bool> removeToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.remove(_tokenKey);
  }
  
  // Check if a token exists
  static Future<bool> hasToken() async {
    final token = await getToken();
    return token != null && token.isNotEmpty;
  }
}



================================================
File: views/audioprompt.dart
================================================
// File: lib/views/audioprompt.dart
import 'dart:async';
import 'dart:io';
import 'dart:math'; // Import math

import 'package:audioplayers/audioplayers.dart';
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/media_upload_model.dart';
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/providers/audio_upload_provider.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/audiopromptsselect.dart';
import 'package:dtx/views/main_navigation_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:record/record.dart';
import 'package:dtx/repositories/user_repository.dart';

class VoicePromptScreen extends ConsumerStatefulWidget {
  final bool isEditing;

  const VoicePromptScreen({
    Key? key,
    this.isEditing = false,
  }) : super(key: key);

  @override
  ConsumerState<VoicePromptScreen> createState() => _VoicePromptScreenState();
}

class _VoicePromptScreenState extends ConsumerState<VoicePromptScreen> {
  final AudioRecorder _audioRecorder = AudioRecorder();
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isRecording = false;
  String _recordingTime = "0:00 / 0:30";
  String? _audioPath;
  bool _isPlaying = false;
  DateTime? _startTime;
  Timer? _recordingTimer;
  bool _isSaving = false;
  // Selected prompt is now managed solely within AudioUploadNotifier
  String? _existingAudioUrl;

  @override
  void initState() {
    super.initState();
    if (widget.isEditing) {
      final existingPromptModel = ref.read(userProvider).audioPrompt;
      if (existingPromptModel != null) {
        // Initialize the provider's internal selected prompt
        ref
            .read(audioUploadProvider.notifier)
            .setSelectedPrompt(existingPromptModel.prompt);
        _existingAudioUrl = existingPromptModel.audioUrl;
        print(
            "[VoicePromptScreen initState] Editing mode. Initial prompt set in provider: ${existingPromptModel.prompt.value}, Existing URL: $_existingAudioUrl");
      } else {
        // --- FIX: Pass null correctly ---
        ref.read(audioUploadProvider.notifier).setSelectedPrompt(null);
        _existingAudioUrl = null;
        print(
            "[VoicePromptScreen initState] Editing mode. No existing prompt found. Provider prompt set to null.");
        // --- END FIX ---
      }
    } else {
      // Onboarding: Clear audio provider state
      ref.read(audioUploadProvider.notifier).clearAudio();
      print(
          "[VoicePromptScreen initState] Onboarding mode. Cleared audio provider.");
      _existingAudioUrl = null;
    }
    _initializeAudioSession();
    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) setState(() => _isPlaying = false);
    });
    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted && state != PlayerState.playing) {
        if (_isPlaying && state != PlayerState.paused) {
          setState(() => _isPlaying = false);
        }
      }
    });
  }

  // _initializeAudioSession, _startRecording, _stopRecording, _playRecording remain the same
  Future<void> _initializeAudioSession() async {
    print("[VoicePromptScreen] Requesting microphone permission...");
    final status = await Permission.microphone.request();
    print("[VoicePromptScreen] Microphone permission status: $status");
    if (!status.isGranted && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Microphone permission is required.')),
      );
    }
  }

  Future<void> _startRecording() async {
    setState(() {
      _existingAudioUrl =
          null; // Clear existing URL when starting new recording
      _audioPath = null;
      _recordingTime = "0:00 / 0:30";
    });
    // Keep clearAudio call here? Yes, it clears the provider's file/path state.
    ref
        .read(audioUploadProvider.notifier)
        .clearAudio(); // Clears provider's file state AND internal selected prompt
    if (!await _audioRecorder.hasPermission()) {
      print("[VoicePromptScreen] Start Recording: Permission denied.");
      if (mounted)
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Microphone permission denied.')));
      return;
    }
    if (_isPlaying) {
      await _audioPlayer.stop();
      setState(() => _isPlaying = false);
    }
    try {
      print("[VoicePromptScreen] Starting recording...");
      final directory = await getApplicationDocumentsDirectory();
      final newPath =
          '${directory.path}/voice_prompt_${DateTime.now().millisecondsSinceEpoch}.m4a';
      print("[VoicePromptScreen] Recording path set to: $newPath");
      await _audioRecorder.start(
          const RecordConfig(encoder: AudioEncoder.aacLc),
          path: newPath);
      _audioPath = newPath;
      _startTime = DateTime.now();
      if (!mounted) return;
      setState(() => _isRecording = true);
      print("[VoicePromptScreen] Recording started.");
      _recordingTimer?.cancel();
      _recordingTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
        if (!_isRecording || !mounted || _startTime == null) {
          timer.cancel();
          return;
        }
        final duration = DateTime.now().difference(_startTime!).inSeconds;
        if (duration >= 30) {
          timer.cancel();
          _stopRecording();
          return;
        }
        if (mounted) {
          setState(() {
            _recordingTime = "0:${duration.toString().padLeft(2, '0')} / 0:30";
          });
        }
      });
    } catch (e) {
      print('[VoicePromptScreen] Recording error: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Recording failed: ${e.toString()}')));
        setState(() => _isRecording = false);
      }
    }
  }

  Future<void> _stopRecording() async {
    if (!_isRecording) return;
    _recordingTimer?.cancel();
    try {
      final path = await _audioRecorder.stop();
      print('[VoicePromptScreen] Recording stopped. Path from recorder: $path');
      if (path != null) {
        final file = File(path);
        if (!await file.exists() || await file.length() == 0) {
          print(
              '[VoicePromptScreen] Error: Recording file is missing or empty after stop.');
          if (mounted)
            ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                content: Text('Failed to save recording. Please try again.')));
          setState(() {
            _isRecording = false;
            _audioPath = null;
            _recordingTime = "0:00 / 0:30";
          });
          return;
        }
        _audioPath = path;
        if (mounted) {
          setState(() {
            _isRecording = false;
          });
          // Set the path in the provider, which is needed for prepareAudioFile
          ref.read(audioUploadProvider.notifier).setRecordingPath(_audioPath!);
          print(
              "[VoicePromptScreen] Recording path saved to provider: $_audioPath");
        }
      } else {
        print("[VoicePromptScreen] Stop recording returned null path.");
        if (mounted) {
          setState(() => _isRecording = false);
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Failed to save recording.')),
          );
        }
      }
    } catch (e) {
      print('[VoicePromptScreen] Stop recording error: $e');
      if (mounted) {
        setState(() => _isRecording = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error stopping recording: ${e.toString()}')),
        );
      }
    }
  }

  Future<void> _playRecording() async {
    final String? pathOrUrlToPlay = _audioPath ?? _existingAudioUrl;
    print(
        "[VoicePromptScreen] Play recording requested. Source: $pathOrUrlToPlay");
    if (pathOrUrlToPlay == null) {
      print("[VoicePromptScreen] Playback Error: No audio source available.");
      if (mounted)
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
            content:
                Text('Please record or ensure existing audio is loaded.')));
      return;
    }
    // Check local file existence if _audioPath is set
    if (_audioPath != null) {
      final file = File(_audioPath!);
      if (!await file.exists() || await file.length() == 0) {
        print(
            "[VoicePromptScreen] Playback Error: File is missing or empty at $_audioPath");
        if (mounted)
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
              content: Text('Recording file error. Please record again.')));
        setState(() {
          _audioPath = null; // Clear invalid path
          _recordingTime = "0:00 / 0:30";
        });
        return;
      }
    }
    try {
      // Determine the source based on whether _audioPath or _existingAudioUrl should be used
      final Source audioSource = (_audioPath != null &&
              File(_audioPath!).existsSync())
          ? DeviceFileSource(_audioPath!)
          : UrlSource(
              pathOrUrlToPlay); // Fallback to existing URL if local path invalid/null

      if (_isPlaying) {
        print("[VoicePromptScreen] Pausing playback.");
        await _audioPlayer.pause();
      } else {
        if (_audioPlayer.state == PlayerState.playing ||
            _audioPlayer.state == PlayerState.paused) {
          await _audioPlayer.stop(); // Stop previous before playing new/resume
        }
        print(
            "[VoicePromptScreen] Starting playback from: ${audioSource is UrlSource ? audioSource.url : (audioSource as DeviceFileSource).path}");
        await _audioPlayer.play(audioSource);
      }
      // State update (_isPlaying) is handled by listeners
    } catch (e) {
      print('[VoicePromptScreen] Playback error: $e');
      if (mounted) {
        setState(() => _isPlaying = false); // Reset playing state on error
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Playback failed: ${e.toString()}')));
      }
    }
  }

  void _selectPrompt() {
    if (_isPlaying) {
      _audioPlayer.pause();
    }
    print("[VoicePromptScreen] Navigating to select audio prompt.");
    Navigator.push(
      context,
      MaterialPageRoute(
          builder: (context) => AudioSelectPromptScreen(
                isEditing: widget.isEditing,
              )),
    ).then((_) {
      // Trigger rebuild after returning to update the displayed prompt text
      if (mounted) {
        setState(
            () {}); // Rebuild to reflect the change in the provider's selected prompt
        final selectedPrompt =
            ref.read(audioUploadProvider.notifier).selectedPrompt;
        print(
            "[VoicePromptScreen] Returned from prompt selection. Selected in provider: ${selectedPrompt?.label}");
      }
    });
  }

  // --- SAVE METHOD (No functional changes needed from previous fix) ---
  Future<void> _saveProfileAndNavigate() async {
    print(
        '[VoicePromptScreen] Starting _saveProfileAndNavigate (isEditing: ${widget.isEditing})');
    final errorNotifier = ref.read(errorProvider.notifier);
    final userNotifier = ref.read(userProvider.notifier);
    final authNotifier = ref.read(authProvider.notifier);
    final audioUploadNotifier = ref.read(audioUploadProvider.notifier);
    errorNotifier.clearError();

    // Read selected prompt directly from the provider
    final AudioPrompt? selectedPrompt = audioUploadNotifier.selectedPrompt;

    if (selectedPrompt == null) {
      print('[VoicePromptScreen] Validation Error: No audio prompt selected.');
      errorNotifier
          .setError(AppError.validation("Please select an audio prompt."));
      return;
    }

    bool isNewAudioRecording =
        _audioPath != null && File(_audioPath!).existsSync();
    bool audioPrepared = false;
    MediaUploadModel? audioUploadModel;
    String? finalAudioUrl =
        _existingAudioUrl; // Start with existing URL if editing

    // --- Audio Preparation (only if NEW recording exists) ---
    if (isNewAudioRecording) {
      print(
          '[VoicePromptScreen] New audio recording found at $_audioPath. Preparing for upload.');
      audioPrepared = audioUploadNotifier.prepareAudioFile();
      if (!audioPrepared) {
        print('[VoicePromptScreen] Audio file preparation/validation failed.');
        return;
      }
      audioUploadModel =
          ref.read(audioUploadProvider); // Get prepared model state
      if (audioUploadModel == null) {
        print(
            '[VoicePromptScreen] Error: Audio prepared but provider state is null.');
        errorNotifier
            .setError(AppError.generic("Error preparing audio model state."));
        return;
      }
    } else if (_existingAudioUrl == null && !widget.isEditing) {
      print(
          '[VoicePromptScreen] Validation Error: No audio recorded for onboarding.');
      errorNotifier.setError(
          AppError.validation("Please record your voice prompt answer."));
      return;
    } else if (_existingAudioUrl != null) {
      print('[VoicePromptScreen] Using existing audio URL: $_existingAudioUrl');
    }

    setState(() => _isSaving = true);

    try {
      // --- STEP 1: Upload General Media (ONLY during ONBOARDING) ---
      if (!widget.isEditing) {
        print(
            "[VoicePromptScreen Onboarding] Attempting to upload general media...");
        final mediaSuccess =
            await ref.read(mediaUploadProvider.notifier).uploadAllMedia();
        if (!mediaSuccess) {
          print("[VoicePromptScreen Onboarding] General media upload failed.");
          if (ref.read(errorProvider) == null) {
            errorNotifier
                .setError(AppError.server("Failed to upload photos/videos."));
          }
          throw ApiException(
              "Media upload failed during onboarding."); // Stop the process
        }
        print(
            "[VoicePromptScreen Onboarding] General media upload successful.");
      }

      // --- STEP 2: Upload Audio (if new recording exists) ---
      bool audioUploadedSuccessfully = true;
      if (isNewAudioRecording && audioPrepared && audioUploadModel != null) {
        print('[VoicePromptScreen] Attempting audio upload...');
        audioUploadedSuccessfully =
            await audioUploadNotifier.uploadAudioAndSaveToProfile();

        if (!audioUploadedSuccessfully) {
          print('[VoicePromptScreen] Audio upload failed.');
          throw ApiException("Audio upload failed.");
        }
        finalAudioUrl = ref.read(audioUploadProvider)?.presignedUrl;
        print(
            '[VoicePromptScreen] Audio upload successful. New URL: $finalAudioUrl');
      } else if (!isNewAudioRecording && _existingAudioUrl != null) {
        print(
            '[VoicePromptScreen] No new audio upload needed. Updating user model with existing URL.');
        final currentAudioModel = AudioPromptModel(
            prompt: selectedPrompt, audioUrl: _existingAudioUrl!);
        userNotifier.updateAudioPrompt(currentAudioModel);
        finalAudioUrl = _existingAudioUrl;
      } else if (widget.isEditing &&
          !isNewAudioRecording &&
          _existingAudioUrl == null) {
        print(
            '[VoicePromptScreen Editing] No existing or new audio. Setting audio prompt to null.');
        userNotifier.updateAudioPrompt(null);
        finalAudioUrl = null;
      }

      // --- STEP 3: Save Profile (POST for Onboarding, PATCH for Editing) ---
      bool profileSaved = false;
      if (widget.isEditing) {
        print('[VoicePromptScreen Editing] Saving profile changes (PATCH)...');
        final latestUserState = ref.read(userProvider);
        final payload = latestUserState.toJsonForEdit();
        if (finalAudioUrl != null) {
          payload['audio_prompt'] =
              AudioPromptModel(prompt: selectedPrompt, audioUrl: finalAudioUrl)
                  .toJson();
        } else {
          payload['audio_prompt'] = null;
        }
        print("[VoicePromptScreen Editing] PATCH Payload: $payload");
        profileSaved =
            await ref.read(userRepositoryProvider).editProfile(payload);
      } else {
        print(
            '[VoicePromptScreen Onboarding] Saving profile details (POST)...');
        profileSaved = await userNotifier.saveProfile();
      }

      // --- STEP 4: Navigation ---
      if (profileSaved) {
        print('[VoicePromptScreen] Profile save successful.');
        if (widget.isEditing) {
          print("[VoicePromptScreen Editing] Popping back.");
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                  content: Text("Audio prompt updated!"),
                  backgroundColor: Colors.green),
            );
            Navigator.of(context).pop();
          }
        } else {
          print('[VoicePromptScreen Onboarding] Fetching updated profile...');
          await userNotifier.fetchProfile();
          print('[VoicePromptScreen Onboarding] Profile fetch complete.');
          final finalStatus =
              await authNotifier.checkAuthStatus(updateState: true);
          if (mounted) {
            print(
                '[VoicePromptScreen Onboarding] Navigating to MainNavigationScreen. Status: $finalStatus');
            Navigator.of(context).pushAndRemoveUntil(
              MaterialPageRoute(builder: (_) => const MainNavigationScreen()),
              (route) => false,
            );
          }
        }
      } else {
        print('[VoicePromptScreen] Profile save failed.');
        if (mounted && ref.read(errorProvider) == null) {
          errorNotifier
              .setError(AppError.server("Failed to save profile changes."));
        }
      }
    } on ApiException catch (e) {
      print(
          '[VoicePromptScreen] Save Process Failed: API Exception - ${e.message}');
      if (mounted) errorNotifier.setError(AppError.server(e.message));
    } catch (e, stack) {
      print('[VoicePromptScreen] Save Process Failed: Unexpected Error - $e');
      print(stack);
      if (mounted)
        errorNotifier.setError(AppError.generic(
            "An unexpected error occurred. Please try again."));
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final errorState = ref.watch(errorProvider);
    // --- FIX: Read selected prompt directly from the notifier ---
    final AudioPrompt? selectedPrompt =
        ref.watch(audioUploadProvider.notifier).selectedPrompt;
    // --- END FIX ---

    final bool hasSelection = selectedPrompt != null;
    final bool hasAudioSource = _audioPath != null || _existingAudioUrl != null;
    // Allow saving null in edit mode OR if a new recording exists OR if an existing URL is present
    final bool canSave = hasSelection &&
        ((widget.isEditing &&
                _existingAudioUrl == null &&
                _audioPath == null) // Allow saving null
            ||
            hasAudioSource // Allow saving if audio exists
        ) &&
        !_isRecording;

    // --- UI Code ---
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(
                // Header
                padding: const EdgeInsets.only(top: 10.0, bottom: 10.0),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: _isSaving
                            ? null
                            : () => Navigator.of(context).pop(),
                      )
                    else
                      const SizedBox(width: 48), // Placeholder for alignment
                    Text(
                      widget.isEditing ? "Edit Voice Prompt" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canSave && !_isSaving
                            ? _saveProfileAndNavigate
                            : null,
                        child: _isSaving
                            ? const SizedBox(
                                width: 20,
                                height: 20,
                                child: CircularProgressIndicator(
                                    strokeWidth: 2, color: Color(0xFF8B5CF6)))
                            : Text(
                                "Done",
                                style: GoogleFonts.poppins(
                                  color: canSave && !_isSaving
                                      ? const Color(0xFF8B5CF6)
                                      : Colors.grey,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                      )
                    else
                      const SizedBox(width: 48), // Placeholder for alignment
                  ],
                ),
              ),
              if (!widget.isEditing) ...[
                // Onboarding Dots
                const SizedBox(height: 10),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: List.generate(
                      3,
                      (index) => Container(
                            margin: const EdgeInsets.symmetric(horizontal: 4),
                            height: 10,
                            width: 10,
                            decoration: BoxDecoration(
                              color: index < 2
                                  ? Colors.grey[300]
                                  : const Color(0xFF8b5cf6),
                              shape: BoxShape.circle,
                            ),
                          )),
                ),
                const SizedBox(height: 20),
              ],
              // Title
              Text(
                widget.isEditing
                    ? 'Edit your Voice Prompt'
                    : 'Add a Voice Prompt\nto your profile',
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing ? 28 : 32,
                  fontWeight: FontWeight.bold,
                  height: 1.2,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 12),
              // Subtitle
              Text(
                widget.isEditing
                    ? "Select a prompt and record your answer."
                    : "Let potential matches hear your voice!",
                style:
                    GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
              ),
              const SizedBox(height: 32),
              // Prompt Selection Row
              GestureDetector(
                onTap: _isSaving
                    ? null
                    : _selectPrompt, // Disable tap while saving
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: Colors.grey[300]!),
                    boxShadow: [
                      BoxShadow(
                          color: Colors.grey.withOpacity(0.1),
                          blurRadius: 5,
                          offset: const Offset(0, 2))
                    ],
                  ),
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          selectedPrompt?.label ??
                              'Select a prompt *', // Read from variable
                          style: GoogleFonts.poppins(
                            color: selectedPrompt != null
                                ? Colors.black87
                                : Colors.grey[600],
                            fontSize: 16,
                            fontWeight: selectedPrompt != null
                                ? FontWeight.w500
                                : FontWeight.normal,
                          ),
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(left: 8),
                        child: Icon(Icons.arrow_drop_down_rounded,
                            color: Colors.grey[800], size: 28),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 24),
              // Recording Area
              Expanded(
                child: GestureDetector(
                  onTap: _isRecording || _isSaving
                      ? null
                      : _startRecording, // Disable tap if recording/saving
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(24),
                    decoration: BoxDecoration(
                      color: Colors.grey[50],
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(color: Colors.grey[200]!),
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          _recordingTime,
                          style: GoogleFonts.poppins(
                              color: Colors.grey[500], fontSize: 18),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          _isRecording
                              ? 'Recording...'
                              : (_audioPath == null && _existingAudioUrl == null
                                  ? 'Tap microphone to start (Max 30s)'
                                  : 'Tap microphone to re-record'),
                          textAlign: TextAlign.center,
                          style: GoogleFonts.poppins(
                              color: Colors.grey[600], fontSize: 16),
                        ),
                        const Spacer(),
                        GestureDetector(
                          onTap: _isSaving
                              ? null
                              : (_isRecording
                                  ? _stopRecording
                                  : _startRecording), // Disable tap if saving
                          child: Container(
                            padding: const EdgeInsets.all(24),
                            decoration: BoxDecoration(
                              color: _isRecording
                                  ? Colors.redAccent
                                  : (_isSaving
                                      ? Colors.grey
                                      : const Color(
                                          0xFF8b5cf6)), // Grey out if saving
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                    color: (_isRecording
                                            ? Colors.redAccent
                                            : const Color(0xFF8b5cf6))
                                        .withOpacity(_isSaving
                                            ? 0.1
                                            : 0.3), // Reduce shadow if saving
                                    blurRadius: 10,
                                    offset: const Offset(0, 4))
                              ],
                            ),
                            child: Icon(
                                _isRecording
                                    ? Icons.stop_rounded
                                    : Icons.mic_rounded,
                                color: Colors.white,
                                size: 36),
                          ),
                        ),
                        const Spacer(),
                        if (hasAudioSource) // Show button if audio source exists
                          TextButton.icon(
                            onPressed: _isSaving || _isRecording
                                ? null
                                : _playRecording, // Disable if saving/recording
                            style: TextButton.styleFrom(
                                foregroundColor: _isSaving || _isRecording
                                    ? Colors.grey
                                    : const Color(
                                        0xFF8b5cf6)), // Grey out if disabled
                            icon: Icon(_isPlaying
                                ? Icons.pause_rounded
                                : Icons.play_arrow_rounded),
                            label: Text(
                              _isPlaying
                                  ? 'Pause'
                                  : 'Play ${_audioPath != null ? "recording" : "existing"}',
                              style: GoogleFonts.poppins(
                                  fontSize: 16, fontWeight: FontWeight.w500),
                            ),
                          )
                        else
                          const SizedBox(height: 48), // Keep placeholder space
                      ],
                    ),
                  ),
                ),
              ),
              // Error Display
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.only(top: 12.0, bottom: 8.0),
                  child: Center(
                    child: Text(
                      errorState.message,
                      style: GoogleFonts.poppins(
                          color: Colors.redAccent, fontSize: 14),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
              const SizedBox(height: 16),
              // Onboarding FAB
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.centerRight,
                  child: Padding(
                    padding: const EdgeInsets.only(bottom: 24.0),
                    child: _isSaving
                        ? const CircularProgressIndicator(
                            color: Color(0xFF8b5cf6))
                        : FloatingActionButton(
                            heroTag: 'audio_save_fab',
                            onPressed: canSave ? _saveProfileAndNavigate : null,
                            backgroundColor: canSave
                                ? const Color(0xFF8b5cf6)
                                : Colors.grey.shade400,
                            foregroundColor: Colors.white,
                            child: const Icon(Icons.check_rounded),
                          ),
                  ),
                ),
              if (widget.isEditing) const SizedBox(height: 24),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    print("[VoicePromptScreen] Disposing screen...");
    _recordingTimer?.cancel();
    try {
      _audioRecorder.dispose();
    } catch (e) {
      print("Error disposing recorder: $e");
    }
    try {
      if (_audioPlayer.state == PlayerState.playing ||
          _audioPlayer.state == PlayerState.paused) {
        _audioPlayer.stop();
      }
      _audioPlayer.dispose();
    } catch (e) {
      print("Error disposing player: $e");
    }
    super.dispose();
  }
}



================================================
File: views/audiopromptsselect.dart
================================================
// File: views/audiopromptsselect.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/providers/audio_upload_provider.dart';

class AudioSelectPromptScreen extends ConsumerWidget {
  final bool isEditing; // <<< ADDED

  const AudioSelectPromptScreen({
    Key? key,
    this.isEditing = false, // <<< ADDED default
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentPrompt =
        ref.watch(audioUploadProvider.notifier).selectedPrompt;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // Add back button if editing? Or rely on close? Let's use close.
                  const SizedBox(width: 24), // Placeholder for alignment
                  const Text(
                    "Select a Prompt",
                    style: TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () => Navigator.pop(context), // Always pop back
                    child: const Icon(Icons.close, size: 24),
                  ),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                itemCount: AudioPrompt.values.length,
                itemBuilder: (context, index) {
                  final prompt = AudioPrompt.values[index];
                  final isSelected = prompt == currentPrompt;

                  return GestureDetector(
                    onTap: () {
                      ref
                          .read(audioUploadProvider.notifier)
                          .setSelectedPrompt(prompt);
                      // Pop back to VoicePromptScreen, which handles further nav
                      Navigator.pop(context);
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                        color: isSelected ? const Color(0xFFEDE9FE) : null,
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              prompt.label,
                              style: TextStyle(
                                fontSize: 18,
                                color: isSelected
                                    ? const Color(0xFF8B5CF6)
                                    : Colors.black87,
                                fontWeight: isSelected
                                    ? FontWeight.w600
                                    : FontWeight.normal,
                              ),
                            ),
                          ),
                          if (isSelected)
                            const Icon(
                              Icons.check_circle,
                              color: Color(0xFF8B5CF6),
                            ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/chat_detail_screen.dart
================================================
// File: lib/views/chat_detail_screen.dart
import 'dart:async';
import 'dart:io';
import 'dart:typed_data';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:dtx/models/chat_message.dart';
import 'package:dtx/models/media_upload_model.dart';
// *** ADDED: Import UserProvider for sender name check ***
import 'package:dtx/models/user_model.dart';
// *** END ADDED ***
import 'package:dtx/providers/conversation_provider.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/matches_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/repositories/media_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/services/chat_service.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/utils/date_formatter.dart';
import 'package:dtx/widgets/message_bubble.dart';
import 'package:dtx/widgets/report_reason_dialog.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_cache_manager/flutter_cache_manager.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:mime/mime.dart';
import 'package:path/path.dart' as p;
import 'package:url_launcher/url_launcher.dart';

class ChatDetailScreen extends ConsumerStatefulWidget {
  final int matchUserId;
  final String matchName;
  final String? matchAvatarUrl;

  const ChatDetailScreen({
    super.key,
    required this.matchUserId,
    required this.matchName,
    this.matchAvatarUrl,
  });

  @override
  ConsumerState<ChatDetailScreen> createState() => _ChatDetailScreenState();
}

class _ChatDetailScreenState extends ConsumerState<ChatDetailScreen> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  final FocusNode _inputFocusNode = FocusNode();
  bool _isUploadingMedia = false;
  bool _isInteracting = false;

  // --- File Type Constants (Keep as is) ---
  static const int _maxImageSizeBytes = 10 * 1024 * 1024;
  static const int _maxVideoSizeBytes = 50 * 1024 * 1024;
  static const int _maxAudioSizeBytes = 10 * 1024 * 1024;
  static const int _maxFileSizeBytes = 25 * 1024 * 1024;
  static final Set<String> _allowedMimeTypes = {
    // Images
    'image/jpeg', 'image/png', 'image/gif', 'image/webp',
    // Videos
    'video/mp4', 'video/quicktime', 'video/webm', 'video/x-msvideo',
    'video/mpeg',
    // Audio
    'audio/mpeg', 'audio/ogg', 'audio/wav', 'audio/aac', 'audio/opus',
    'audio/webm', 'audio/mp4', 'audio/x-m4a',
    // Documents
    'application/pdf', 'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-powerpoint',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'text/plain',
  };

  @override
  void initState() {
    super.initState();
    print("[ChatDetailScreen Init: ${widget.matchUserId}] Initializing...");
    _inputFocusNode.addListener(_handleFocusChange);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final chatService = ref.read(chatServiceProvider);
      if (ref.read(webSocketStateProvider) !=
          WebSocketConnectionState.connected) {
        print(
            "[ChatDetailScreen Init: ${widget.matchUserId}] Connecting WebSocket...");
        chatService.connect();
      }
      // Fetch initial state which includes status
      ref
          .read(conversationProvider(widget.matchUserId).notifier)
          .fetchMessages();
    });
  }

  @override
  void dispose() {
    print("[ChatDetailScreen Dispose: ${widget.matchUserId}] Disposing...");
    _messageController.dispose();
    _scrollController.dispose();
    _inputFocusNode.removeListener(_handleFocusChange);
    _inputFocusNode.dispose();
    super.dispose();
  }

  void _handleFocusChange() {}

  // --- _readHeaderBytes (Keep as is) ---
  Future<Uint8List?> _readHeaderBytes(File file, [int length = 1024]) async {
    try {
      final stream = file.openRead(0, length);
      final completer = Completer<Uint8List>();
      final bytesBuilder = BytesBuilder();
      stream.listen(
        (chunk) => bytesBuilder.add(chunk),
        onDone: () => completer.complete(bytesBuilder.toBytes()),
        onError: (error) => completer.completeError(error),
        cancelOnError: true,
      );
      return await completer.future;
    } catch (e) {
      print("Error reading header bytes: $e");
      return null;
    }
  }

  // --- MODIFIED: _sendMessage ---
  void _sendMessage() {
    final text = _messageController.text.trim();
    if (text.isEmpty || _isUploadingMedia || _isInteracting) return;

    final chatService = ref.read(chatServiceProvider);
    final wsState = ref.read(webSocketStateProvider);
    // *** CORRECTED: Watch provider to get state, then access property ***
    final conversationState =
        ref.read(conversationProvider(widget.matchUserId));
    final replyingTo = conversationState.replyingToMessage;
    // *** END CORRECTION ***

    if (wsState == WebSocketConnectionState.connected) {
      print(
          "[ChatDetailScreen _sendMessage] Sending text. Replying to: ${replyingTo?.messageID}");
      // *** Pass replyToMessageId if available ***
      chatService.sendMessage(
        widget.matchUserId,
        text: text,
        replyToMessageId: replyingTo?.messageID, // Pass the ID if replying
      );
      // *** END ADDED ***

      _messageController.clear();
      ref.read(messageInputProvider.notifier).state = false;
      // *** No need to call cancelReply here, addSentMessage handles it ***
    } else {
      _showErrorSnackbar("Cannot send message. Not connected.");
      chatService.connect(); // Attempt to reconnect
    }
  }
  // --- END MODIFIED ---

  // --- _scrollToBottom, _showAttachmentOptions, _handleFileSelection, _handleMediaSelection (Keep as is) ---
  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      print(
          "[ChatDetailScreen Scroll: ${widget.matchUserId}] Animating scroll to top (0.0)");
      _scrollController.animateTo(
        0.0,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    } else {
      print(
          "[ChatDetailScreen Scroll: ${widget.matchUserId}] Cannot scroll, no clients.");
    }
  }

  void _showAttachmentOptions() {
    if (_isUploadingMedia || _isInteracting) return;
    FocusScope.of(context).unfocus();
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return SafeArea(
          child: Wrap(
            children: <Widget>[
              ListTile(
                leading: const Icon(Icons.photo_camera_outlined,
                    color: Color(0xFF8B5CF6)),
                title: Text('Take Photo/Video', style: GoogleFonts.poppins()),
                onTap: () {
                  Navigator.pop(context);
                  _handleMediaSelection(ImageSource.camera);
                },
              ),
              ListTile(
                leading: const Icon(Icons.photo_library_outlined,
                    color: Color(0xFF8B5CF6)),
                title:
                    Text('Choose from Gallery', style: GoogleFonts.poppins()),
                onTap: () {
                  Navigator.pop(context);
                  _handleMediaSelection(ImageSource.gallery);
                },
              ),
              ListTile(
                leading: const Icon(Icons.attach_file_rounded,
                    color: Color(0xFF8B5CF6)),
                title: Text('Choose File', style: GoogleFonts.poppins()),
                onTap: () {
                  Navigator.pop(context);
                  _handleFileSelection();
                },
              ),
              const SizedBox(height: 10),
            ],
          ),
        );
      },
    );
  }

  Future<void> _handleFileSelection() async {
    if (_isUploadingMedia || _isInteracting) return;
    try {
      FilePickerResult? result =
          await FilePicker.platform.pickFiles(type: FileType.any);
      if (result != null && result.files.single.path != null) {
        final filePath = result.files.single.path!;
        final file = File(filePath);
        final fileName = result.files.single.name;
        final fileSize = await file.length();
        final headerBytes = await _readHeaderBytes(file);
        String? mimeType = lookupMimeType(filePath, headerBytes: headerBytes) ??
            lookupMimeType(fileName) ??
            'application/octet-stream';
        bool isValid = false;
        String errorMsg = "Unsupported file type.";
        int maxSize = _maxFileSizeBytes;

        if (mimeType.startsWith('image/')) {
          maxSize = _maxImageSizeBytes;
          isValid = _allowedMimeTypes.contains(mimeType);
          errorMsg = "Unsupported image type.";
        } else if (mimeType.startsWith('video/')) {
          maxSize = _maxVideoSizeBytes;
          isValid = _allowedMimeTypes.contains(mimeType);
          errorMsg = "Unsupported video type.";
        } else if (mimeType.startsWith('audio/')) {
          maxSize = _maxAudioSizeBytes;
          isValid = _allowedMimeTypes.contains(mimeType);
          errorMsg = "Unsupported audio type.";
        } else if (_allowedMimeTypes.contains(mimeType)) {
          maxSize = _maxFileSizeBytes;
          isValid = true;
        }

        if (!isValid) {
          _showErrorSnackbar(errorMsg);
          return;
        }
        if (fileSize > maxSize) {
          _showErrorSnackbar(
              "File is too large. Max size: ${maxSize ~/ (1024 * 1024)} MB.");
          return;
        }
        _initiateMediaSend(file, fileName, mimeType);
      } else {
        print("[ChatDetailScreen] File picking cancelled.");
      }
    } catch (e) {
      print("[ChatDetailScreen] Error picking file: $e");
      _showErrorSnackbar("Error selecting file: ${e.toString()}");
    }
  }

  Future<void> _handleMediaSelection(ImageSource source) async {
    if (_isUploadingMedia || _isInteracting) return;
    final ImagePicker picker = ImagePicker();
    try {
      final XFile? pickedFile = await picker.pickMedia();
      if (pickedFile != null) {
        final file = File(pickedFile.path);
        final fileName = p.basename(pickedFile.path);
        final fileSize = await file.length();
        final headerBytes = await _readHeaderBytes(file);
        final mimeType =
            lookupMimeType(pickedFile.path, headerBytes: headerBytes) ??
                'application/octet-stream';
        bool isImage = mimeType.startsWith('image/');
        bool isVideo = mimeType.startsWith('video/');
        int maxSize =
            isImage ? _maxImageSizeBytes : (isVideo ? _maxVideoSizeBytes : 0);

        if (!isImage && !isVideo) {
          _showErrorSnackbar("Unsupported file type selected.");
          return;
        }
        if (!_allowedMimeTypes.contains(mimeType)) {
          _showErrorSnackbar(
              "Unsupported ${isImage ? 'image' : 'video'} format.");
          return;
        }
        if (fileSize > maxSize) {
          _showErrorSnackbar(
              "${isImage ? 'Image' : 'Video'} is too large. Max size: ${maxSize ~/ (1024 * 1024)} MB.");
          return;
        }
        _initiateMediaSend(file, fileName, mimeType);
      } else {
        print("[ChatDetailScreen] Media picking cancelled.");
      }
    } catch (e) {
      print("[ChatDetailScreen] Error picking media: $e");
      _showErrorSnackbar("Error selecting media: ${e.toString()}");
    }
  }

  // --- MODIFIED: _initiateMediaSend ---
  Future<void> _initiateMediaSend(
      File file, String fileName, String mimeType) async {
    if (!mounted) return;
    final conversationNotifier =
        ref.read(conversationProvider(widget.matchUserId).notifier);
    final currentUserId = ref.read(currentUserIdProvider);
    final chatService = ref.read(chatServiceProvider);
    // *** CORRECTED: Get reply state ***
    final conversationState =
        ref.read(conversationProvider(widget.matchUserId));
    final replyingTo = conversationState.replyingToMessage;
    // *** END CORRECTION ***

    if (currentUserId == null) {
      _showErrorSnackbar("Cannot send media: User not identified.");
      return;
    }
    final tempId = DateTime.now().millisecondsSinceEpoch.toString();
    final optimisticMessage = ChatMessage(
      tempId: tempId,
      messageID: 0,
      senderUserID: currentUserId,
      recipientUserID: widget.matchUserId,
      messageText: '',
      mediaUrl: null,
      mediaType: mimeType,
      sentAt: DateTime.now().toLocal(), // Use local time for optimistic UI
      isRead: false,
      status: ChatMessageStatus.pending,
      localFilePath: file.path,
      errorMessage: null,
      // *** Include reply info if available ***
      replyToMessageID: replyingTo?.messageID,
      repliedMessageSenderID: replyingTo?.repliedMessageSenderID,
      repliedMessageTextSnippet: replyingTo?.repliedMessageTextSnippet,
      repliedMessageMediaType: replyingTo?.repliedMessageMediaType,
      // *** END ADDED ***
    );
    print(
        "[ChatDetailScreen _initiateMediaSend: ${widget.matchUserId}] Adding optimistic media message TempID: $tempId. Replying to: ${replyingTo?.messageID}");

    // Add to pending messages and conversation state
    chatService.addPendingMessage(tempId, widget.matchUserId);
    conversationNotifier.addSentMessage(
        optimisticMessage); // This now also clears reply state in provider

    setState(() => _isUploadingMedia = true);

    // Start background upload/send
    _uploadAndSendMediaInBackground(file, fileName, mimeType, tempId,
            replyingTo?.messageID) // *** Pass reply ID ***
        .then((_) {
      if (mounted) {
        final stillProcessing = ref
            .read(conversationProvider(widget.matchUserId))
            .messages
            .any((m) =>
                m.senderUserID == currentUserId &&
                (m.status == ChatMessageStatus.uploading ||
                    m.status == ChatMessageStatus.pending));
        if (!stillProcessing) {
          print(
              "[ChatDetailScreen _initiateMediaSend: ${widget.matchUserId}] All uploads/acks seem finished for current user. Re-enabling input.");
          setState(() => _isUploadingMedia = false);
        } else {
          print(
              "[ChatDetailScreen _initiateMediaSend: ${widget.matchUserId}] Background task for $tempId finished, but others might be pending/uploading. Input remains disabled.");
        }
      }
    });
  }
  // --- END MODIFIED ---

  // --- MODIFIED: _uploadAndSendMediaInBackground ---
  Future<void> _uploadAndSendMediaInBackground(
      File file,
      String fileName,
      String mimeType,
      String tempId,
      int? replyToMessageId // <<< ADDED parameter
      ) async {
    final conversationNotifier =
        ref.read(conversationProvider(widget.matchUserId).notifier);
    final mediaRepo = ref.read(mediaRepositoryProvider);
    final chatService = ref.read(chatServiceProvider);
    final bool isImage = mimeType.startsWith('image/');

    // Update status to Uploading
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        print("[ChatBG Task $tempId] Updating status to Uploading");
        conversationNotifier.updateMessageStatus(
            tempId, ChatMessageStatus.uploading);
      }
    });

    String? objectUrl;
    try {
      print("[ChatBG Task $tempId] Getting chat presigned URL...");
      final urls = await mediaRepo.getChatMediaPresignedUrl(fileName, mimeType);
      final presignedUrl = urls['presigned_url'];
      objectUrl = urls['object_url'];
      if (presignedUrl == null || objectUrl == null) {
        throw ApiException("Failed to get upload URLs from server.");
      }

      print("[ChatBG Task $tempId] Uploading to S3...");
      final uploadModel = MediaUploadModel(
          file: file,
          fileName: fileName,
          fileType: mimeType,
          presignedUrl: presignedUrl);
      bool uploadSuccess = await mediaRepo.retryUpload(uploadModel);

      if (!uploadSuccess) {
        throw ApiException("Failed to upload media to storage.");
      }

      // Pre-cache image
      if (isImage && objectUrl != null) {
        print("[ChatBG Task $tempId] Pre-caching image: $objectUrl");
        try {
          await DefaultCacheManager().downloadFile(objectUrl);
          print("[ChatBG Task $tempId] Image pre-caching completed");
        } catch (cacheErr) {
          print(
              "[ChatBG Task $tempId] WARNING: Image pre-caching failed: $cacheErr");
        }
      }

      print(
          "[ChatBG Task $tempId] Upload successful. Sending WebSocket message. ReplyTo: $replyToMessageId");
      // *** Pass replyToMessageId to sendMessage ***
      chatService.sendMessage(
        widget.matchUserId,
        mediaUrl: objectUrl,
        mediaType: mimeType,
        replyToMessageId: replyToMessageId,
      );
      // *** END ADDED ***

      print("[ChatBG Task $tempId] WebSocket message sent. Awaiting ack...");
    } on ApiException catch (e) {
      print("[ChatBG Task $tempId] API Error: ${e.message}");
      if (mounted) {
        print("[ChatBG Task $tempId] Updating status to Failed (API Error)");
        conversationNotifier.updateMessageStatus(
            tempId, ChatMessageStatus.failed,
            errorMessage: e.message, finalMediaUrl: objectUrl);
      }
    } catch (e, stacktrace) {
      print("[ChatBG Task $tempId] General Error: $e");
      print("[ChatBG Task $tempId] Stacktrace: $stacktrace");
      if (mounted) {
        print(
            "[ChatBG Task $tempId] Updating status to Failed (General Error)");
        conversationNotifier.updateMessageStatus(
            tempId, ChatMessageStatus.failed,
            errorMessage: "Upload/Send failed: ${e.toString()}",
            finalMediaUrl: objectUrl);
      }
    }
  }
  // --- END MODIFIED ---

  // --- _showSnackbar, _showErrorSnackbar, _showMoreOptions, _confirmAndUnmatch, _reportUser (Keep as is) ---
  void _showSnackbar(String message,
      {bool isError = false, Duration duration = const Duration(seconds: 3)}) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).removeCurrentSnackBar();
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(message, style: GoogleFonts.poppins()),
        backgroundColor: isError ? Colors.redAccent : Colors.green,
        duration: duration));
  }

  void _showErrorSnackbar(String message) {
    _showSnackbar(message, isError: true);
  }

  void _showMoreOptions() {
    if (_isInteracting) return;
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return SafeArea(
          child: Wrap(
            children: <Widget>[
              ListTile(
                leading:
                    const Icon(Icons.block_flipped, color: Colors.redAccent),
                title: Text('Unmatch',
                    style: GoogleFonts.poppins(color: Colors.redAccent)),
                onTap: () {
                  Navigator.pop(context);
                  _confirmAndUnmatch();
                },
              ),
              ListTile(
                leading: const Icon(Icons.flag_outlined, color: Colors.orange),
                title: Text('Report',
                    style: GoogleFonts.poppins(color: Colors.orange)),
                onTap: () {
                  Navigator.pop(context);
                  _reportUser();
                },
              ),
              ListTile(
                leading: const Icon(Icons.cancel_outlined, color: Colors.grey),
                title: Text('Cancel', style: GoogleFonts.poppins()),
                onTap: () => Navigator.pop(context),
              ),
              const SizedBox(height: 10),
            ],
          ),
        );
      },
    );
  }

  Future<void> _confirmAndUnmatch() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text("Unmatch User?", style: GoogleFonts.poppins()),
        content: Text(
            "Are you sure you want to unmatch ${widget.matchName}? You won't be able to message them again.",
            style: GoogleFonts.poppins()),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text("Cancel",
                  style: GoogleFonts.poppins(color: Colors.grey))),
          TextButton(
              onPressed: () => Navigator.pop(context, true),
              child: Text("Unmatch",
                  style: GoogleFonts.poppins(color: Colors.red))),
        ],
      ),
    );
    if (confirm != true) return;
    if (!mounted) return;
    setState(() => _isInteracting = true);
    ref.read(errorProvider.notifier).clearError();
    try {
      final success = await ref
          .read(likeRepositoryProvider)
          .unmatchUser(targetUserId: widget.matchUserId);
      if (success && mounted) {
        _showSnackbar("Unmatched successfully.", isError: false);
        ref.invalidate(matchesProvider);
        Navigator.of(context).pop();
      } else if (!success && mounted) {
        _showErrorSnackbar("Failed to unmatch user.");
      }
    } on ApiException catch (e) {
      _showErrorSnackbar("Unmatch failed: ${e.message}");
    } catch (e) {
      _showErrorSnackbar("An unexpected error occurred during unmatch.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
  }

  Future<void> _reportUser() async {
    final selectedReason = await showReportReasonDialog(context);
    if (selectedReason == null) return;
    if (!mounted) return;
    setState(() => _isInteracting = true);
    ref.read(errorProvider.notifier).clearError();
    try {
      final success = await ref.read(likeRepositoryProvider).reportUser(
            targetUserId: widget.matchUserId,
            reason: selectedReason,
          );
      if (success && mounted) {
        _showSnackbar("Report submitted. Thank you.", isError: false);
        await _confirmAndUnmatch(); // Unmatch after reporting
      } else if (!success && mounted) {
        _showErrorSnackbar("Failed to submit report.");
      }
    } on ApiException catch (e) {
      _showErrorSnackbar("Report failed: ${e.message}");
    } catch (e) {
      _showErrorSnackbar("An unexpected error occurred during report.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
  }

  // --- CORRECTED: _buildReplyPreviewWidget (incorporating fix from previous turn) ---
  Widget _buildReplyPreviewWidget() {
    // Watch the provider to get the state, then access the property
    final conversationState =
        ref.watch(conversationProvider(widget.matchUserId));
    final replyingToMessage = conversationState.replyingToMessage;

    if (replyingToMessage == null) {
      if (kDebugMode)
        print(
            "[ChatDetailScreen _buildReplyPreviewWidget] No message being replied to.");
      return const SizedBox.shrink(); // Return empty space if not replying
    }

    if (kDebugMode)
      print(
          "[ChatDetailScreen _buildReplyPreviewWidget] Building preview for Message ID: ${replyingToMessage.messageID}");

    // Determine sender name ("You" or match name)
    final currentUserId = ref.read(currentUserIdProvider);
    final originalSenderName = replyingToMessage.senderUserID == currentUserId
        ? "You"
        : widget.matchName; // Use widget.matchName

    // Determine content preview
    // Use repliedMessageTextSnippet if available and not empty
    String contentPreview =
        (replyingToMessage.repliedMessageTextSnippet != null &&
                replyingToMessage.repliedMessageTextSnippet!.isNotEmpty)
            ? replyingToMessage.repliedMessageTextSnippet!
            : '';
    IconData? mediaIcon;

    // If text snippet is empty, determine preview from media type
    if (contentPreview.isEmpty) {
      final mediaType = replyingToMessage.repliedMessageMediaType;
      if (kDebugMode)
        print(
            "[ChatDetailScreen _buildReplyPreviewWidget] Original media type: $mediaType");
      if (mediaType?.startsWith('image/') ?? false) {
        contentPreview = "Photo";
        mediaIcon = Icons.photo_camera_back_outlined;
      } else if (mediaType?.startsWith('video/') ?? false) {
        contentPreview = "Video";
        mediaIcon = Icons.videocam_outlined;
      } else if (mediaType?.startsWith('audio/') ?? false) {
        contentPreview = "Audio";
        mediaIcon = Icons.headphones_outlined;
      } else if (mediaType != null) {
        contentPreview = "File"; // Generic file
        mediaIcon = Icons.attach_file_outlined;
      } else {
        contentPreview =
            "Original message"; // Fallback if both text and media type are missing
        if (kDebugMode)
          print(
              "[ChatDetailScreen _buildReplyPreviewWidget] Using fallback content preview.");
      }
    } else {
      if (kDebugMode)
        print(
            "[ChatDetailScreen _buildReplyPreviewWidget] Using text snippet: '$contentPreview'");
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
      decoration: BoxDecoration(
        color: Colors.grey[200], // Different background for preview bar
        border: Border(
          top: BorderSide(color: Colors.grey[300]!, width: 0.5),
        ),
      ),
      child: Row(
        children: [
          const Icon(Icons.reply_rounded, size: 18, color: Colors.black54),
          const SizedBox(width: 8),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  "Replying to $originalSenderName",
                  style: GoogleFonts.poppins(
                    fontWeight: FontWeight.w600,
                    fontSize: 13,
                    color: const Color(0xFF6B46C1),
                  ),
                ),
                const SizedBox(height: 2),
                Row(
                  children: [
                    if (mediaIcon != null)
                      Icon(mediaIcon, size: 14, color: Colors.black54),
                    if (mediaIcon != null) const SizedBox(width: 4),
                    Expanded(
                      child: Text(
                        contentPreview,
                        style: GoogleFonts.poppins(
                          fontSize: 13,
                          color: Colors.black54,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          IconButton(
            icon: const Icon(Icons.close_rounded, size: 20),
            color: Colors.black54,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(),
            tooltip: "Cancel Reply",
            onPressed: () {
              print("[ChatDetailScreen CancelReplyButton] Cancelling reply.");
              ref
                  .read(conversationProvider(widget.matchUserId).notifier)
                  .cancelReply();
            },
          ),
        ],
      ),
    );
  }
  // --- END CORRECTED ---

  @override
  Widget build(BuildContext context) {
    if (kDebugMode)
      print(
          "[ChatDetailScreen Build: ${widget.matchUserId}] Rebuilding Widget... IsUploading: $_isUploadingMedia, IsInteracting: $_isInteracting");
    final state = ref.watch(conversationProvider(widget.matchUserId));
    final currentUserId = ref.watch(currentUserIdProvider);

    if (kDebugMode)
      print(
          "[ChatDetailScreen Build: ${widget.matchUserId}] State status: otherUserIsOnline=${state.otherUserIsOnline}, otherUserLastOnline=${state.otherUserLastOnline}");

    // Listener for scroll (keep as is)
    ref.listen<ConversationState>(conversationProvider(widget.matchUserId),
        (prev, next) {
      final prevLength = prev?.messages.length ?? 0;
      final nextLength = next.messages.length;
      final isNewMessageFromMe = nextLength > prevLength &&
          next.messages.isNotEmpty &&
          next.messages.first.senderUserID == currentUserId;
      final isMessageStatusUpdate = nextLength == prevLength &&
          prevLength > 0 &&
          next.messages.isNotEmpty &&
          next.messages.first.tempId != null &&
          prev?.messages.first.status != next.messages.first.status;

      if (kDebugMode)
        print(
            "[ChatDetailScreen Listener: ${widget.matchUserId}] State changed. PrevLen=$prevLength, NextLen=$nextLength. IsNewFromMe=$isNewMessageFromMe, IsStatusUpdate=$isMessageStatusUpdate");

      if (isNewMessageFromMe) {
        print(
            "[ChatDetailScreen Listener: ${widget.matchUserId}] New PENDING message added by me. Scheduling scroll.");
        WidgetsBinding.instance.addPostFrameCallback((_) {
          // Add check if scrollController has clients before scrolling
          if (_scrollController.hasClients) {
            print(
                "[ChatDetailScreen Listener: ${widget.matchUserId}] Executing scroll after frame callback.");
            _scrollToBottom();
          } else {
            print(
                "[ChatDetailScreen Listener: ${widget.matchUserId}] ScrollController has no clients, skipping scroll.");
          }
        });
      } else if (isMessageStatusUpdate) {
        print(
            "[ChatDetailScreen Listener: ${widget.matchUserId}] Message status updated. No scroll triggered.");
      } else if (nextLength > prevLength && !isNewMessageFromMe) {
        print(
            "[ChatDetailScreen Listener: ${widget.matchUserId}] New message received from other user. No scroll triggered.");
      } else {
        print(
            "[ChatDetailScreen Listener: ${widget.matchUserId}] No scroll triggered (Other state change).");
      }
    });

    // Status text logic (keep as is)
    String statusText;
    Color statusColor;
    if (state.isLoading && state.messages.isEmpty) {
      statusText = 'Loading...';
      statusColor = Colors.grey;
    } else if (state.otherUserIsOnline) {
      statusText = 'Online';
      statusColor = Colors.green;
    } else {
      statusText = formatLastSeen(state.otherUserLastOnline, short: true);
      statusColor = Colors.grey;
    }

    return Scaffold(
      backgroundColor: Colors.grey[100],
      appBar: AppBar(
        // AppBar setup remains the same
        elevation: 1,
        backgroundColor: Colors.white,
        foregroundColor: Colors.black87,
        leading: IconButton(
          icon:
              Icon(Icons.arrow_back_ios_new, size: 20, color: Colors.grey[700]),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Row(
          /* ... Title Row ... */
          mainAxisSize: MainAxisSize.min,
          children: [
            CircleAvatar(
              radius: 18,
              backgroundImage: widget.matchAvatarUrl != null
                  ? NetworkImage(widget.matchAvatarUrl!)
                  : null,
              backgroundColor: Colors.grey[300],
              child: widget.matchAvatarUrl == null
                  ? const Icon(Icons.person, size: 20, color: Colors.white)
                  : null,
            ),
            const SizedBox(width: 10),
            Flexible(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    widget.matchName,
                    style: GoogleFonts.poppins(
                        fontSize: 16, fontWeight: FontWeight.w600),
                    overflow: TextOverflow.ellipsis,
                  ),
                  if (statusText.isNotEmpty)
                    Text(
                      statusText,
                      style: GoogleFonts.poppins(
                          fontSize: 12,
                          fontWeight: FontWeight.w400,
                          color: statusColor),
                      overflow: TextOverflow.ellipsis,
                    ),
                ],
              ),
            ),
          ],
        ),
        titleSpacing: 0,
        actions: [
          /* ... Actions ... */
          IconButton(
            icon: Icon(Icons.more_vert_rounded, color: Colors.grey[600]),
            tooltip: "More Options",
            onPressed: _isInteracting ? null : _showMoreOptions,
            disabledColor: Colors.grey[300],
          ),
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: GestureDetector(
              onTap: () => FocusScope.of(context).unfocus(),
              child: _buildMessagesList(state, currentUserId),
            ),
          ),
          // *** ADDED: Reply Preview Widget ***
          _buildReplyPreviewWidget(),
          // *** END ADDED ***
          if (_isInteracting)
            Container(
              // Keep loading indicator
              padding: const EdgeInsets.symmetric(vertical: 8.0),
              color: Colors.white.withOpacity(0.8),
              child: const Center(
                  child: CircularProgressIndicator(color: Color(0xFF8B5CF6))),
            )
          else
            _buildMessageInputArea(), // Keep input area
        ],
      ),
    );
  }

  // --- MODIFIED: _buildMessagesList ---
  Widget _buildMessagesList(ConversationState state, int? currentUserId) {
    if (kDebugMode)
      print(
          "[ChatDetailScreen _buildMessagesList: ${widget.matchUserId}] Building message list. Count: ${state.messages.length}");
    // --- Loading/Error/Empty checks remain the same ---
    if (state.isLoading && state.messages.isEmpty) {
      return const Center(
          child: CircularProgressIndicator(color: Color(0xFF8B5CF6)));
    }
    if (state.error != null && state.messages.isEmpty) {
      return Center(
          child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Text("Error loading messages: ${state.error!.message}",
                  style: GoogleFonts.poppins(color: Colors.red),
                  textAlign: TextAlign.center)));
    }
    if (!state.isLoading && state.messages.isEmpty) {
      return Center(
          child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Text("Start the conversation!",
                  style: GoogleFonts.poppins(
                      color: Colors.grey[600], fontSize: 16),
                  textAlign: TextAlign.center)));
    }
    // --- End Checks ---

    return ListView.builder(
      addAutomaticKeepAlives: true,
      controller: _scrollController,
      reverse: true,
      padding: const EdgeInsets.symmetric(vertical: 10.0, horizontal: 8.0),
      itemCount: state.messages.length,
      itemBuilder: (context, index) {
        final message = state.messages[index];
        final bool isMe = currentUserId != null && message.isMe(currentUserId);
        bool showTail = true;
        if (index > 0) {
          final prevMessage = state.messages[index - 1];
          if (prevMessage.senderUserID == message.senderUserID) {
            final timeDiff = message.sentAt.difference(prevMessage.sentAt);
            if (timeDiff.inSeconds < 60) {
              showTail = false;
            }
          }
        }
        final keyId = message.tempId ?? message.messageID.toString();
        String originalSenderDisplayName = "Unknown"; // Default
        if (message.isReply && message.repliedMessageSenderID != null) {
          originalSenderDisplayName =
              message.repliedMessageSenderID == currentUserId
                  ? "You"
                  : widget.matchName; // Use the match name passed to the screen
        }

        // *** ADDED: Pass onReplyInitiated callback ***
        return Padding(
            padding: const EdgeInsets.symmetric(vertical: 2.0),
            child: MessageBubble(
              key: ValueKey(
                  "${keyId}_${message.status}_${message.mediaUrl ?? message.localFilePath}_${message.isReply}"), // Add isReply to key
              message: message,
              isMe: isMe,
              showTail: showTail,
              originalSenderDisplayName:
                  originalSenderDisplayName, // *** ADDED ***
              // Call startReplying when bubble signals reply initiation
              onReplyInitiated: (messageToReply) {
                print(
                    "[ChatDetailScreen onReplyInitiated] Triggered for message ID: ${messageToReply.messageID}");
                ref
                    .read(conversationProvider(widget.matchUserId).notifier)
                    .startReplying(messageToReply);
              },
            ));
        // *** END ADDED ***
      },
    );
  }
  // --- END MODIFIED ---

  // --- _buildMessageInputArea (Keep as is) ---
  Widget _buildMessageInputArea() {
    final canSendText = ref.watch(messageInputProvider);
    final bool allowInput = !_isUploadingMedia && !_isInteracting;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
              color: Colors.grey.withOpacity(0.15),
              spreadRadius: 1,
              blurRadius: 5,
              offset: const Offset(0, -2))
        ],
      ),
      child: SafeArea(
        top: false, // Don't add padding for top safe area here
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            IconButton(
              icon: Icon(Icons.add_circle_outline_rounded,
                  color: allowInput ? Colors.grey[600] : Colors.grey[300]),
              onPressed: allowInput ? _showAttachmentOptions : null,
              tooltip: "Attach Media",
            ),
            const SizedBox(width: 4.0),
            Expanded(
              child: Container(
                decoration: BoxDecoration(
                    color: Colors.grey[100],
                    borderRadius: BorderRadius.circular(25.0)),
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: TextField(
                    focusNode: _inputFocusNode,
                    controller: _messageController,
                    textCapitalization: TextCapitalization.sentences,
                    decoration: InputDecoration(
                      hintText: allowInput
                          ? "Type a message..."
                          : (_isUploadingMedia
                              ? "Uploading..."
                              : "Processing..."),
                      hintStyle: GoogleFonts.poppins(color: Colors.grey[500]),
                      border: InputBorder.none,
                      contentPadding:
                          const EdgeInsets.symmetric(vertical: 12.0),
                    ),
                    onChanged: (text) {
                      ref.read(messageInputProvider.notifier).state =
                          text.trim().isNotEmpty;
                    },
                    onSubmitted: (_) =>
                        canSendText && allowInput ? _sendMessage() : null,
                    minLines: 1,
                    maxLines: 5,
                    keyboardType: TextInputType.multiline,
                    style: GoogleFonts.poppins(
                        color: Colors.black87, fontSize: 15),
                    enabled: allowInput,
                  ),
                ),
              ),
            ),
            const SizedBox(width: 8.0),
            IconButton(
              icon: const Icon(Icons.send_rounded),
              color: const Color(0xFF8B5CF6),
              onPressed: canSendText && allowInput ? _sendMessage : null,
              tooltip: "Send Message",
              disabledColor: Colors.grey[400],
            ),
          ],
        ),
      ),
    );
  }
}

// --- Keep messageInputProvider (No change needed) ---
final messageInputProvider = StateProvider<bool>((ref) => false);



================================================
File: views/chat_screen.dart
================================================
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class ChatPlaceholderScreen extends StatelessWidget {
  const ChatPlaceholderScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey[100],
      appBar: AppBar(
        title: Text('Messages',
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 1,
        automaticallyImplyLeading: false, // No back button in a tab screen
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.chat_bubble_outline_rounded,
                size: 80, color: Colors.grey[400]),
            const SizedBox(height: 20),
            Text(
              'Chat Coming Soon!',
              style: GoogleFonts.poppins(fontSize: 18, color: Colors.grey[600]),
            ),
            const SizedBox(height: 10),
            Text(
              'Your conversations with matches will appear here.',
              textAlign: TextAlign.center,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[500]),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dating_intentions.dart
================================================
// File: lib/views/dating_intentions.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';
import '../providers/user_provider.dart';
import 'height.dart'; // Keep for onboarding flow

class DatingIntentionsScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const DatingIntentionsScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<DatingIntentionsScreen> createState() =>
      _DatingIntentionsScreenState();
}

class _DatingIntentionsScreenState
    extends ConsumerState<DatingIntentionsScreen> {
  DatingIntention? _selectedIntention; // Local state for selection

  @override
  void initState() {
    super.initState();
    // Load current value if editing
    if (widget.isEditing) {
      _selectedIntention = ref.read(userProvider).datingIntention;
    }
  }

  void _handleNext() {
    if (_selectedIntention != null) {
      ref.read(userProvider.notifier).updateDatingIntention(_selectedIntention);
      if (widget.isEditing) {
        print("[DatingIntentionsScreen] Editing done, popping back.");
        Navigator.of(context).pop(); // Pop back to ProfileScreen
      } else {
        // Original onboarding navigation
        print("[DatingIntentionsScreen] Onboarding next: Height.");
        Navigator.push(
          context,
          MaterialPageRoute(
              builder: (context) => const HeightSelectionScreen()),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // Watch userState only to update UI if needed externally (unlikely here)
    // final userState = ref.watch(userProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            // --- Adjusted Header for Edit Mode ---
            Padding(
              padding: EdgeInsets.only(
                top: screenSize.height * 0.02,
                left: screenSize.width * 0.02,
                right: screenSize.width * 0.06,
              ),
              child: Row(
                mainAxisAlignment: widget.isEditing
                    ? MainAxisAlignment.spaceBetween
                    : MainAxisAlignment.start,
                children: [
                  if (widget.isEditing)
                    IconButton(
                      icon: const Icon(Icons.close, color: Colors.grey),
                      onPressed: () => Navigator.of(context).pop(),
                    )
                  else
                    const SizedBox(
                        width:
                            40), // Placeholder for alignment during onboarding

                  Text(
                    widget.isEditing
                        ? "Edit Intention"
                        : "", // Title only in edit mode
                    style: GoogleFonts.poppins(
                        fontSize: 18, fontWeight: FontWeight.w600),
                  ),
                  if (widget.isEditing)
                    TextButton(
                      onPressed:
                          _selectedIntention != null ? _handleNext : null,
                      child: Text(
                        "Done",
                        style: GoogleFonts.poppins(
                          color: _selectedIntention != null
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    )
                  else
                    const SizedBox(width: 40), // Placeholder during onboarding
                ],
              ),
            ),
            // --- End Adjusted Header ---
            Padding(
              padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06)
                  .copyWith(
                      top: widget.isEditing
                          ? 20
                          : screenSize.height *
                              0.01), // Less top padding if editing
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (!widget.isEditing) // Show title only during onboarding
                    Text(
                      "What's your dating intention?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width * 0.065,
                        fontWeight: FontWeight.bold,
                        color: Colors.black,
                      ),
                    ),
                  SizedBox(height: widget.isEditing ? 30 : 65),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                physics: const BouncingScrollPhysics(),
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                itemCount: DatingIntention.values.length,
                itemBuilder: (context, index) {
                  return _buildOption(DatingIntention.values[index]);
                },
              ),
            ),
            // --- Hide FAB in Edit Mode ---
            if (!widget.isEditing)
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding:
                      EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                  child: GestureDetector(
                    onTap: _selectedIntention != null
                        ? _handleNext
                        : null, // Use local state
                    child: Container(
                      width: 56,
                      height: 56,
                      decoration: BoxDecoration(
                        color: _selectedIntention != null
                            ? const Color(0xFF8B5CF6)
                            : Colors.grey.shade300,
                        shape: BoxShape.circle,
                        boxShadow: [
                          if (_selectedIntention != null)
                            BoxShadow(
                              color: Colors.black.withOpacity(0.2),
                              spreadRadius: 1,
                              blurRadius: 8,
                            ),
                        ],
                      ),
                      child: Icon(
                        Icons.arrow_forward_rounded,
                        size: 28,
                        color: _selectedIntention != null
                            ? Colors.white
                            : Colors.grey.shade500,
                      ),
                    ),
                  ),
                ),
              ),
            // --- End Hide FAB ---
            SizedBox(height: screenSize.height * 0.04),
          ],
        ),
      ),
    );
  }

  Widget _buildOption(DatingIntention intention) {
    final bool isSelected = _selectedIntention == intention; // Use local state

    return GestureDetector(
      onTap: () {
        setState(() {
          // Update local state
          _selectedIntention = intention;
        });
        // No need to update provider here, only on save/next
      },
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 16),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.transparent,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade300,
            width: 1.5,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Text(
                intention.label,
                style: GoogleFonts.poppins(
                  fontSize: intention.label.length > 20 ? 14 : 16,
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                  color: isSelected ? Colors.white : Colors.black,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            if (isSelected)
              const Icon(
                Icons.check_circle,
                color: Colors.white,
                size: 24,
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dob.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/dating_intentions.dart';
import 'package:dtx/views/location.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class DateOfBirthScreen extends ConsumerStatefulWidget {
  const DateOfBirthScreen({super.key});

  @override
  ConsumerState<DateOfBirthScreen> createState() => _DateOfBirthScreenState();
}

class _DateOfBirthScreenState extends ConsumerState<DateOfBirthScreen> {
  final TextEditingController _dayController = TextEditingController();
  final TextEditingController _monthController = TextEditingController();
  final TextEditingController _yearController = TextEditingController();

  final FocusNode _dayFocusNode = FocusNode();
  final FocusNode _monthFocusNode = FocusNode();
  final FocusNode _yearFocusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    _dayFocusNode.addListener(() {
      if (!_dayFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _monthFocusNode.addListener(() {
      if (!_monthFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _yearFocusNode.addListener(() {
      if (!_yearFocusNode.hasFocus) {
        _validateInputs();
      }
    });
  }

  @override
  void dispose() {
    _dayController.dispose();
    _monthController.dispose();
    _yearController.dispose();
    _dayFocusNode.dispose();
    _monthFocusNode.dispose();
    _yearFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.1),
                Text(
                  "What's your date of birth?",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.08,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    _buildDateInput(
                      "DD",
                      _dayController,
                      _dayFocusNode,
                      2,
                      _monthFocusNode,
                    ),
                    _buildDateInput(
                      "MM",
                      _monthController,
                      _monthFocusNode,
                      2,
                      _yearFocusNode,
                    ),
                    _buildDateInput(
                      "YYYY",
                      _yearController,
                      _yearFocusNode,
                      4,
                      null,
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.03),
                Text(
                  "We use this to calculate the age on your profile.",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.04,
                    color: Colors.white70,
                  ),
                ),
                if (error?.type == ErrorType.validation)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      error!.message,
                      style: GoogleFonts.poppins(
                        color: Colors.redAccent,
                        fontSize: screenSize.width * 0.035,
                      ),
                    ),
                  ),
                const Spacer(),
                _buildNextButton(screenSize),
                SizedBox(height: screenSize.height * 0.05),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDateInput(
    String hint,
    TextEditingController controller,
    FocusNode focusNode,
    int maxLength,
    FocusNode? nextFocusNode,
  ) {
    return Expanded(
      flex: maxLength == 4 ? 2 : 1,
      child: TextField(
        controller: controller,
        focusNode: focusNode,
        keyboardType: TextInputType.number,
        maxLength: maxLength,
        style: GoogleFonts.poppins(
          fontSize: 24,
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
        decoration: InputDecoration(
          hintText: hint,
          hintStyle: GoogleFonts.poppins(
            fontSize: 24,
            fontWeight: FontWeight.w500,
            color: Colors.white70,
          ),
          counterText: "",
          enabledBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white54, width: 2.0),
          ),
          focusedBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white, width: 2.5),
          ),
        ),
        textAlign: TextAlign.center,
        onChanged: (value) {
          if (value.length == maxLength) {
            focusNode.unfocus();
            if (nextFocusNode != null) {
              FocusScope.of(context).requestFocus(nextFocusNode);
            }
          }
          _validateInputs();
        },
      ),
    );
  }

  void _validateInputs() {
    ref.read(errorProvider.notifier).clearError();
    final day = int.tryParse(_dayController.text) ?? 0;
    final month = int.tryParse(_monthController.text) ?? 0;
    final year = int.tryParse(_yearController.text) ?? 0;

    if (_dayController.text.isEmpty ||
        _monthController.text.isEmpty ||
        _yearController.text.isEmpty) return;

    if (day < 1 || day > 31) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid day"),
          );
      return;
    }

    if (month < 1 || month > 12) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid month"),
          );
      return;
    }

    try {
      final date = DateTime(year, month, day);
      ref.read(userProvider.notifier).updateDateOfBirth(date);
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid date combination"),
          );
    }
  }

  Widget _buildNextButton(Size screenSize) {
    final isValid = _dayController.text.length == 2 &&
        _monthController.text.length == 2 &&
        _yearController.text.length == 4 &&
        ref.read(errorProvider) == null;

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: isValid ? _handleNext : null,
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: isValid ? Colors.white : Colors.grey.shade400,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: const EdgeInsets.all(16),
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24,
          color: isValid ? const Color(0xFF8B5CF6) : Colors.white54,
        ),
      ),
    );
  }

  void _handleNext() {
    final date = DateTime(
      int.parse(_yearController.text),
      int.parse(_monthController.text),
      int.parse(_dayController.text),
    );

    ref.read(userProvider.notifier).updateDateOfBirth(date);
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DatingIntentionsScreen()),
    );
  }
}



================================================
File: views/drinking.dart
================================================
// File: lib/views/drinking.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/smoking.dart'; // Keep for onboarding flow

class DrinkingScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const DrinkingScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<DrinkingScreen> createState() => _DrinkingScreenState();
}

class _DrinkingScreenState extends ConsumerState<DrinkingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedDrinkingHabit; // Local state
  // Removed _isOptionSelected, use _selectedDrinkingHabit directly
  late AnimationController _controller; // Keep for animations if desired
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );

    // Load initial value if editing
    if (widget.isEditing) {
      _selectedDrinkingHabit = ref.read(userProvider).drinkingHabit;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleNext() {
    if (_selectedDrinkingHabit != null) {
      ref
          .read(userProvider.notifier)
          .updateDrinkingHabit(_selectedDrinkingHabit);
      if (widget.isEditing) {
        print("[DrinkingScreen] Editing done, popping back.");
        Navigator.of(context).pop();
      } else {
        // Original onboarding navigation
        print("[DrinkingScreen] Onboarding next: Smoking.");
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const SmokingScreen()));
      }
    } else {
      // This should not happen if button is properly disabled, but as a fallback
      if (!widget.isEditing) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content:
                Text("Please select an option", style: GoogleFonts.poppins()),
            backgroundColor: Colors.red[400],
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically
    final bool canProceed = _selectedDrinkingHabit != null; // Check local state

    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder icon for onboarding
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: const Icon(Icons.local_bar_rounded,
                            color: Color(0xFF8B5CF6),
                            size: 30), // Slightly smaller icon
                      ),
                    Text(
                      widget.isEditing ? "Edit Drinking Habit" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canProceed ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for onboarding
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.03),
              Text(
                widget.isEditing
                    ? "Edit your drinking habits"
                    : "Do you drink?",
                textAlign: TextAlign.left,
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.07
                      : screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  height: 1.1,
                ),
              ),
              if (!widget.isEditing) // Show subtitle only during onboarding
                Text(
                  "Select your drinking habits",
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    color: Colors.grey[600],
                    height: 1.5,
                  ),
                ),
              SizedBox(height: screenSize.height * 0.04),
              Expanded(
                child: ListView.separated(
                  itemCount: DrinkingSmokingHabits.values.length,
                  separatorBuilder: (context, index) =>
                      const SizedBox(height: 12),
                  itemBuilder: (context, index) {
                    final habit = DrinkingSmokingHabits.values[index];
                    return _buildDrinkingOptionTile(
                      screenSize: screenSize,
                      title: habit.label,
                      value: habit,
                    );
                  },
                ),
              ),
              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: AnimatedScale(
                      scale: canProceed ? 1.0 : 0.95, // Use local state
                      duration: const Duration(milliseconds: 200),
                      child: GestureDetector(
                        onTap: _handleNext, // Use unified handler
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey.shade300,
                            borderRadius: BorderRadius.circular(35),
                            boxShadow: canProceed
                                ? [
                                    BoxShadow(
                                      color: const Color(0xFF8B5CF6)
                                          .withOpacity(0.3),
                                      blurRadius: 8,
                                      offset: const Offset(0, 4),
                                    ),
                                  ]
                                : null,
                          ),
                          child: Icon(
                            Icons.arrow_forward_rounded,
                            color: canProceed
                                ? Colors.white
                                : Colors.grey.shade600,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildDrinkingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedDrinkingHabit == value; // Use local state

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedDrinkingHabit = value; // Update local state
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/filter_settings_dialog.dart
================================================
// File: lib/views/filter_settings_dialog.dart
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class FilterSettingsDialog extends ConsumerStatefulWidget {
  const FilterSettingsDialog({super.key});

  @override
  ConsumerState<FilterSettingsDialog> createState() =>
      _FilterSettingsDialogState();
}

class _FilterSettingsDialogState extends ConsumerState<FilterSettingsDialog> {
  late FilterSettings _currentFilters;
  late RangeValues _currentAgeRange;
  late double _currentRadius;
  bool _isLoading = false; // Local loading state for saving

  @override
  void initState() {
    super.initState();
    // Initialize local state with current provider state when dialog opens
    final initialFilters = ref.read(filterProvider);
    _currentFilters = initialFilters;
    _currentAgeRange = RangeValues(
      initialFilters.ageMin?.toDouble() ??
          FilterSettings.defaultAgeMin.toDouble(),
      initialFilters.ageMax?.toDouble() ??
          FilterSettings.defaultAgeMax.toDouble(),
    );
    _currentRadius = initialFilters.radiusKm?.toDouble() ??
        FilterSettings.defaultRadius.toDouble();
  }

  Future<void> _applyFilters() async {
    if (_isLoading) return; // Prevent double taps

    setState(() => _isLoading = true);

    final newSettings = _currentFilters.copyWith(
      ageMin: () => _currentAgeRange.start.round(),
      ageMax: () => _currentAgeRange.end.round(),
      radiusKm: () => _currentRadius.round(),
      // whoYouWantToSee and activeToday are already updated in _currentFilters via setState
    );

    final success =
        await ref.read(filterProvider.notifier).saveFilters(newSettings);

    // Check if mounted before interacting with context or state
    if (!mounted) return;

    setState(() => _isLoading = false);

    if (success) {
      print(
          "[FilterSettingsDialog] Filters saved successfully. Refreshing feed.");
      // Trigger feed refresh AFTER saving filters
      ref.read(feedProvider.notifier).fetchFeed(forceRefresh: true);
      Navigator.of(context).pop(true); // Pop dialog and indicate success
    } else {
      // Error handling is likely done via the errorProvider in FilterNotifier
      // Optionally show a snackbar here too if desired.
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content:
                Text("Failed to save filters", style: GoogleFonts.poppins())),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // No need to watch provider's loading state directly, use local _isLoading for save button

    return AlertDialog(
      title: Text("Filters",
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
      contentPadding: const EdgeInsets.fromLTRB(20, 20, 20, 0),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // --- Who You Want To See ---
            Text("Show Me:",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: FilterGenderPref.values.map((genderPref) {
                return ChoiceChip(
                  label: Text(genderPref.value[0].toUpperCase() +
                      genderPref.value.substring(1)),
                  selected: _currentFilters.whoYouWantToSee == genderPref,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        // Use copyWith for immutability when updating local state
                        _currentFilters = _currentFilters.copyWith(
                            whoYouWantToSee: () => genderPref);
                      });
                    }
                  },
                  selectedColor: const Color(0xFFEDE9FE),
                  checkmarkColor: const Color(0xFF8B5CF6),
                  labelStyle: GoogleFonts.poppins(
                    color: _currentFilters.whoYouWantToSee == genderPref
                        ? const Color(0xFF8B5CF6)
                        : Colors.black87,
                  ),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                      side: BorderSide(
                          color: _currentFilters.whoYouWantToSee == genderPref
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey.shade300)),
                  backgroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 10),
                );
              }).toList(),
            ),
            const SizedBox(height: 20),

            // --- Age Range ---
            Text("Age Range:",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
            RangeSlider(
              values: _currentAgeRange,
              min: 18,
              max: 70,
              divisions: 52,
              labels: RangeLabels(
                _currentAgeRange.start.round().toString(),
                _currentAgeRange.end.round().toString(),
              ),
              activeColor: const Color(0xFF8B5CF6),
              inactiveColor: const Color(0xFF8B5CF6).withOpacity(0.3),
              onChanged: (RangeValues values) {
                setState(() {
                  if (values.start <= values.end) {
                    _currentAgeRange = values;
                  }
                });
              },
            ),
            Text(
              "${_currentAgeRange.start.round()} - ${_currentAgeRange.end.round()} years",
              style: GoogleFonts.poppins(color: Colors.grey[600], fontSize: 12),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),

            // --- Distance Radius ---
            Text("Distance (km):",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
            Slider(
              value: _currentRadius,
              min: 1,
              max: 500,
              divisions: 499,
              label: _currentRadius.round().toString(),
              activeColor: const Color(0xFF8B5CF6),
              inactiveColor: const Color(0xFF8B5CF6).withOpacity(0.3),
              onChanged: (double value) {
                setState(() {
                  _currentRadius = value;
                });
              },
            ),
            Text(
              "${_currentRadius.round()} km",
              style: GoogleFonts.poppins(color: Colors.grey[600], fontSize: 12),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),

            // --- Active Today ---
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text("Active Today Only:",
                    style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
                Switch(
                  value: _currentFilters.activeToday ??
                      FilterSettings.defaultActiveToday,
                  activeColor: const Color(0xFF8B5CF6),
                  onChanged: (bool value) {
                    setState(() {
                      _currentFilters =
                          _currentFilters.copyWith(activeToday: () => value);
                    });
                  },
                ),
              ],
            ),
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: Text('Cancel', style: GoogleFonts.poppins(color: Colors.grey)),
          onPressed: () =>
              Navigator.of(context).pop(false), // Indicate no change
        ),
        ElevatedButton(
          style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF8B5CF6),
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20))),
          onPressed: _isLoading ? null : _applyFilters, // Disable while saving
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                      strokeWidth: 2, color: Colors.white))
              : Text('Apply', style: GoogleFonts.poppins()),
        ),
      ],
      actionsPadding: const EdgeInsets.symmetric(horizontal: 15, vertical: 10),
    );
  }
}



================================================
File: views/gender.dart
================================================
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart'; // Import FilterProvider
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:dtx/views/main_navigation_screen.dart'; // Import MainNavigationScreen
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../models/error_model.dart';
import '../providers/user_provider.dart';
import '../providers/error_provider.dart';
import '../providers/service_provider.dart';
// Removed Home import

class GenderSelectionScreen extends ConsumerStatefulWidget {
  const GenderSelectionScreen({super.key});

  @override
  ConsumerState<GenderSelectionScreen> createState() =>
      _GenderSelectionScreenState();
}

class _GenderSelectionScreenState extends ConsumerState<GenderSelectionScreen> {
  bool _isSubmitting = false;

  void _initiateEarlyFetches() {
    print(
        "[GenderSelectionScreen] Initiating early data fetches (Filters, HomeFeed).");
    // Don't await, let them run in background
    ref.read(filterProvider.notifier).loadFilters();
    ref.read(feedProvider.notifier).fetchFeed();
  }

  Future<void> _submitLocationAndGender() async {
    final userState = ref.read(userProvider);
    final errorNotifier = ref.read(errorProvider.notifier);
    final authNotifier = ref.read(authProvider.notifier);

    errorNotifier.clearError();

    if (userState.latitude == null || userState.longitude == null) {
      errorNotifier.setError(
          AppError.validation("Location data is missing. Please go back."));
      return;
    }
    if (userState.gender == null) {
      errorNotifier.setError(AppError.validation("Please select a gender."));
      return;
    }

    setState(() => _isSubmitting = true);

    try {
      final userRepository = ref.read(userRepositoryProvider);
      final success = await userRepository.updateLocationGender(
        userState.latitude!,
        userState.longitude!,
        userState.gender!,
      );

      if (success) {
        print(
            "[GenderSelectionScreen] Location/Gender submitted successfully.");
        final finalStatus =
            await authNotifier.checkAuthStatus(updateState: true);
        print("[GenderSelectionScreen] Auth status updated to: $finalStatus");

        if (mounted) {
          Widget nextScreen;
          // Navigate to MainNavigationScreen if onboarding is complete (status onboarding2 or home)
          if (finalStatus == AuthStatus.onboarding2 ||
              finalStatus == AuthStatus.home) {
            print(
                "[GenderSelectionScreen] Navigating to MainNavigationScreen.");
            _initiateEarlyFetches(); // Start loading data
            nextScreen = const MainNavigationScreen();
          } else {
            // Fallback to GoogleSignInScreen if status is unexpectedly login/unknown
            print(
                "[GenderSelectionScreen] Unexpected status ($finalStatus), navigating to GoogleSignInScreen.");
            nextScreen = const GoogleSignInScreen();
          }

          Navigator.pushAndRemoveUntil(
            context,
            MaterialPageRoute(builder: (context) => nextScreen),
            (Route<dynamic> route) => false,
          );
        }
      } else {
        print(
            "[GenderSelectionScreen] Location/Gender submission failed (API returned false).");
        if (ref.read(errorProvider) == null) {
          errorNotifier
              .setError(AppError.server("Failed to update location/gender."));
        }
      }
    } on ApiException catch (e) {
      print(
          "[GenderSelectionScreen] API Exception during submit: ${e.message}");
      errorNotifier.setError(AppError.server(e.message));
    } catch (e) {
      print(
          "[GenderSelectionScreen] Unexpected error during submit: ${e.toString()}");
      errorNotifier.setError(
          AppError.generic("An unexpected error occurred. Please try again."));
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Build method remains largely the same, only navigation logic changed
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);
    final errorState = ref.watch(errorProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.03),
              Align(
                alignment: Alignment.topLeft,
                child: IconButton(
                  icon: Icon(Icons.arrow_back_ios_new, color: Colors.grey[600]),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              Text(
                "Which gender best\ndescribes you?",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.075,
                  fontWeight: FontWeight.bold,
                  color: Colors.black,
                  height: 1.2,
                ),
              ),
              SizedBox(height: screenSize.height * 0.05),
              Column(
                children: [Gender.man, Gender.woman]
                    .map((gender) => _buildOption(gender))
                    .toList(),
              ),
              const Spacer(),
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.only(bottom: 10.0),
                  child: Text(
                    errorState.message,
                    style: GoogleFonts.poppins(
                        color: Colors.redAccent, fontSize: 14),
                    textAlign: TextAlign.center,
                  ),
                ),
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding: const EdgeInsets.only(bottom: 20.0),
                  child: _isSubmitting
                      ? const CircularProgressIndicator(
                          color: Color(0xFF8B5CF6))
                      : FloatingActionButton(
                          heroTag: 'gender_next_fab',
                          onPressed: userState.gender != null
                              ? _submitLocationAndGender
                              : null,
                          backgroundColor: userState.gender != null
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey.shade300,
                          foregroundColor: Colors.white,
                          child: const Icon(Icons.arrow_forward_rounded),
                        ),
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOption(Gender gender) {
    // _buildOption implementation remains the same
    final bool isSelected = ref.watch(userProvider).gender == gender;
    final errorNotifier = ref.read(errorProvider.notifier);

    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: Material(
        borderRadius: BorderRadius.circular(12),
        color: isSelected ? const Color(0xFFEDE9FE) : Colors.grey.shade50,
        elevation: isSelected ? 1 : 0,
        shadowColor: const Color(0xFF8B5CF6).withOpacity(0.3),
        child: InkWell(
          onTap: () {
            errorNotifier.clearError();
            ref.read(userProvider.notifier).updateGender(gender);
          },
          borderRadius: BorderRadius.circular(12),
          child: Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color:
                    isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade300,
                width: isSelected ? 1.5 : 1,
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  gender.label,
                  style: GoogleFonts.poppins(
                    fontSize: 18,
                    fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
                    color: isSelected
                        ? const Color(0xFF8B5CF6)
                        : Colors.grey.shade800,
                  ),
                ),
                if (isSelected)
                  const Icon(
                    Icons.check_circle_outline_rounded,
                    color: Color(0xFF8B5CF6),
                    size: 24,
                  )
                else
                  Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      border:
                          Border.all(color: Colors.grey.shade400, width: 1.5),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/google_sign_in_screen.dart
================================================
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart'; // Import FilterProvider
import 'package:dtx/views/location.dart';
import 'package:dtx/views/main_navigation_screen.dart'; // Import MainNavigationScreen
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/models/auth_model.dart';
// Removed FeedType import
// Removed Home import
// Removed NameInputScreen import

class GoogleSignInScreen extends ConsumerWidget {
  const GoogleSignInScreen({super.key});

  void _initiateEarlyFetches(WidgetRef ref) {
    print(
        "[GoogleSignInScreen] Initiating early data fetches (Filters, HomeFeed).");
    // Don't await, let them run in background
    ref.read(filterProvider.notifier).loadFilters();
    ref.read(feedProvider.notifier).fetchFeed();
  }

  Future<void> _handleSignIn(BuildContext context, WidgetRef ref) async {
    final status = await ref.read(authProvider.notifier).signInWithGoogle();
    if (!context.mounted) return;

    Widget destination;
    switch (status) {
      case AuthStatus.home:
      case AuthStatus.onboarding2: // Both go to main screen now
        print('[GoogleSignInScreen] Navigating to MainNavigationScreen');
        _initiateEarlyFetches(ref); // Start loading data
        destination = const MainNavigationScreen();
        break;
      case AuthStatus.onboarding1:
        print('[GoogleSignInScreen] Navigating to LocationInputScreen');
        destination = const LocationInputScreen();
        break;
      case AuthStatus.login:
      case AuthStatus.unknown:
      default:
        // Stay on this screen if sign-in failed or status is unexpected
        print(
            '[GoogleSignInScreen] Sign in failed or status unknown/login. Staying on screen.');
        return;
    }
    // Use pushReplacement to prevent going back to the sign-in screen
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(builder: (context) => destination),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Build method remains largely the same, only navigation logic changed
    final authState = ref.watch(authProvider);
    final errorState = ref.watch(errorProvider);
    final screenSize = MediaQuery.of(context).size;

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  const Spacer(flex: 2),
                  Text(
                    'Peeple',
                    style: GoogleFonts.pacifico(
                      fontSize: screenSize.width * 0.15,
                      color: Colors.white,
                      shadows: [
                        Shadow(
                          color: Colors.black.withOpacity(0.5),
                          blurRadius: 10,
                          offset: const Offset(2, 2),
                        ),
                      ],
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.03),
                  Text(
                    'Connect Authentically',
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.045,
                      color: Colors.white.withOpacity(0.8),
                      fontWeight: FontWeight.w300,
                    ),
                  ),
                  const Spacer(flex: 3),
                  if (authState.isLoading)
                    const CircularProgressIndicator(color: Colors.white)
                  else
                    ElevatedButton.icon(
                      icon: Image.asset('assets/google_logo.png',
                          height: 24.0,
                          errorBuilder: (context, error, stackTrace) =>
                              const Icon(Icons.login, size: 24)),
                      label: Text(
                        'Sign In with Google',
                        style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                            color: Colors.black87),
                      ),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.white,
                        foregroundColor: Colors.black87,
                        minimumSize: const Size(double.infinity, 50),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                      onPressed: () => _handleSignIn(context, ref),
                    ),
                  SizedBox(height: screenSize.height * 0.02),
                  if (errorState != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 15.0),
                      child: Text(
                        errorState.message,
                        textAlign: TextAlign.center,
                        style: GoogleFonts.poppins(
                          color: Colors.redAccent[100],
                          fontSize: 14,
                        ),
                      ),
                    ),
                  const Spacer(flex: 1),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 20.0),
                    child: Text(
                      'By signing in, you agree to our Terms of Service and Privacy Policy.',
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                        fontSize: 12,
                        color: Colors.white.withOpacity(0.6),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/height.dart
================================================
// File: lib/views/height.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
// Removed unused app_enums import
import '../providers/user_provider.dart';
import 'hometown.dart'; // Keep for onboarding flow

class HeightSelectionScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const HeightSelectionScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<HeightSelectionScreen> createState() =>
      _HeightSelectionScreenState();
}

class _HeightSelectionScreenState extends ConsumerState<HeightSelectionScreen> {
  String _unit = "FT"; // Default unit is Feet
  int _selectedFeetIndex = 0; // Start at the first index (4' 0")
  int _selectedCmIndex = 30; // Start at 150 cm (index 30 for 120cm base)

  // Define the starting and ending points explicitly
  int _startFeet = 4;
  int _startInches = 0;
  int _endFeet = 7; // Extended range up to 7'0"
  int _endInches = 0;

  int _startCm = 120;
  int _endCm = 213; // Approx 7'0"

  late List<String> _feetValues;
  late List<String> _cmValues;

  String _initialHeightValue = ''; // Store initial value for comparison/reset

  // Function to convert CM to Feet and Inches string
  String _cmToFeet(int cm) {
    double totalInches = cm * 0.393701;
    int feet = (totalInches / 12).floor();
    int inches = (totalInches % 12).round();
    if (inches == 12) {
      feet++;
      inches = 0;
    }
    return "$feet' $inches\""; // API format
  }

  // Function to convert Feet and Inches string to CM
  int _feetToCm(String feetInchStr) {
    try {
      final parts = feetInchStr.replaceAll('"', '').split("'");
      if (parts.length == 2) {
        final feet = int.tryParse(parts[0]) ?? 0;
        final inches = int.tryParse(parts[1]) ?? 0;
        double totalInches = (feet * 12) + inches.toDouble();
        return (totalInches / 0.393701).round();
      }
    } catch (e) {
      print("Error parsing height $feetInchStr: $e");
    }
    return _startCm; // Default fallback
  }

  @override
  void initState() {
    super.initState();

    // Generate Feet Values (4'0" to 7'0")
    _feetValues = List.generate(
      ((_endFeet * 12) + _endInches) - ((_startFeet * 12) + _startInches) + 1,
      (index) {
        int totalInches = ((_startFeet * 12) + _startInches) + index;
        int feet = totalInches ~/ 12;
        int inches = totalInches % 12;
        return "$feet' $inches\""; // API format
      },
    );

    // Generate CM Values (120cm to 213cm)
    _cmValues = List.generate(
        _endCm - _startCm + 1, (index) => "${_startCm + index} cm");

    // Load initial value if editing
    if (widget.isEditing) {
      final currentHeight = ref.read(userProvider).height;
      _initialHeightValue = currentHeight ?? '';
      if (currentHeight != null && currentHeight.isNotEmpty) {
        // Determine initial unit and index
        if (currentHeight.contains("'")) {
          // Assume FT format
          _unit = "FT";
          _selectedFeetIndex = _feetValues.indexOf(currentHeight);
          if (_selectedFeetIndex == -1) _selectedFeetIndex = 0; // Fallback
        } else if (currentHeight.toLowerCase().contains('cm')) {
          // Assume CM format (unlikely based on save logic, but check)
          _unit = "CM";
          _selectedCmIndex = _cmValues.indexOf(currentHeight);
          if (_selectedCmIndex == -1) _selectedCmIndex = 30; // Fallback ~150cm
        } else {
          // If format is unknown, try parsing as FT
          _unit = "FT";
          _selectedFeetIndex = _feetValues.indexOf(currentHeight);
          if (_selectedFeetIndex == -1) _selectedFeetIndex = 0; // Fallback
        }
      } else {
        // Default if no existing height
        _unit = "FT";
        _selectedFeetIndex = 11; // Default to 5'11" approx
      }
    } else {
      // Default for onboarding
      _unit = "FT";
      _selectedFeetIndex = 11; // Default to 5'11" approx
    }
  }

  void _handleNext() {
    _updateHeight(ref, forceUpdate: true); // Ensure provider is updated
    if (widget.isEditing) {
      print("[HeightSelectionScreen] Editing done, popping back.");
      Navigator.of(context).pop(); // Pop back to ProfileScreen
    } else {
      // Original onboarding navigation
      print("[HeightSelectionScreen] Onboarding next: Hometown.");
      Navigator.push(
        context,
        MaterialPageRoute(builder: (context) => const HometownScreen()),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState =
        ref.watch(userProvider); // Watch for external updates if needed

    // Use appropriate values for the current unit
    final List<String> currentValues = _unit == "FT" ? _feetValues : _cmValues;
    int currentIndex = _unit == "FT" ? _selectedFeetIndex : _selectedCmIndex;

    // Check if the current value in the provider matches the displayed value
    final bool hasValueChanged = (_unit == "FT" &&
            userState.height != _feetValues[currentIndex]) ||
        (_unit == "CM" &&
            userState.height !=
                _cmToFeet(
                    int.parse(_cmValues[currentIndex].replaceAll(" cm", ""))));

    // Determine if the "Done" button should be enabled
    final bool canProceed =
        userState.height != null && userState.height!.isNotEmpty;

    // --- Create FixedExtentScrollController ---
    final scrollController =
        FixedExtentScrollController(initialItem: currentIndex);

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4), // Light background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: widget.isEditing
                      ? MainAxisAlignment.spaceBetween
                      : MainAxisAlignment.start,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      const SizedBox(width: 40), // Placeholder

                    Text(
                      widget.isEditing ? "Edit Height" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canProceed ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      const SizedBox(width: 40), // Placeholder
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(
                  height: widget.isEditing ? 40 : screenSize.height * 0.02),

              // Title (Shown in both modes, slightly smaller in edit)
              Center(
                child: Text(
                  "How tall are you?",
                  style: GoogleFonts.poppins(
                    fontSize: widget.isEditing
                        ? screenSize.width * 0.08
                        : screenSize.width * 0.1,
                    fontWeight: FontWeight.w700, // More bold title
                    color: const Color(0xFF333333), // Darker title color
                  ),
                ),
              ),

              SizedBox(
                  height: screenSize.height *
                      0.05), // Increased spacing below title

              // Height Selector
              Expanded(
                child: ListWheelScrollView.useDelegate(
                  controller: scrollController, // Use the controller
                  itemExtent: 70, // Increased item extent for better spacing
                  diameterRatio: 1.3, // Adjusted for better visual
                  physics: const FixedExtentScrollPhysics(),
                  onSelectedItemChanged: (index) {
                    setState(() {
                      if (_unit == "FT") {
                        _selectedFeetIndex = index;
                      } else {
                        _selectedCmIndex = index;
                      }
                      // Update provider immediately on scroll change
                      _updateHeight(ref);
                    });
                  },
                  childDelegate: ListWheelChildBuilderDelegate(
                    childCount: currentValues.length,
                    builder: (context, index) {
                      final isSelected = index == currentIndex;
                      return Center(
                        child: Text(
                          currentValues[index],
                          style: GoogleFonts.poppins(
                            fontSize: isSelected
                                ? 30
                                : 22, // Larger font sizes for list items
                            fontWeight: isSelected
                                ? FontWeight.w600
                                : FontWeight.w400, // Adjusted weight
                            color: isSelected
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey
                                    .shade700, // Highlighted selected color, darker unselected
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ),

              SizedBox(
                  height: screenSize.height *
                      0.03), // Reduced spacing above buttons

              // Unit Toggle Buttons - Improved UI
              Padding(
                padding: EdgeInsets.symmetric(
                    horizontal: screenSize.width *
                        0.1), // Add horizontal padding for buttons
                child: Row(
                  mainAxisAlignment:
                      MainAxisAlignment.spaceAround, // Space buttons evenly
                  children: [
                    _buildUnitButton("FT", screenSize, scrollController),
                    _buildUnitButton("CM", screenSize, scrollController),
                  ],
                ),
              ),

              SizedBox(
                  height: screenSize.height *
                      0.04), // Spacing before forward button

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Center(
                  child: GestureDetector(
                    onTap: canProceed ? _handleNext : null,
                    child: Container(
                      width: 70, // Even larger button
                      height: 70,
                      decoration: BoxDecoration(
                        color: canProceed
                            ? const Color(0xFF8B5CF6)
                            : Colors.grey.shade400,
                        borderRadius: BorderRadius.circular(35), // More rounded
                      ),
                      child: const Icon(
                        Icons.arrow_forward_rounded,
                        color: Colors.white,
                        size: 32, // Larger icon
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              SizedBox(
                  height: screenSize.height * 0.06), // Increased bottom spacing
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildUnitButton(String unit, Size screenSize,
      FixedExtentScrollController scrollController) {
    final isSelected = _unit == unit;
    return GestureDetector(
      onTap: () {
        if (_unit != unit) {
          // Only update if switching units
          setState(() {
            _unit = unit;
            // Update the scroll position when unit changes
            if (_unit == "FT") {
              // Convert CM index to approximate FT index
              final currentCm = _startCm + _selectedCmIndex;
              final feetStr = _cmToFeet(currentCm);
              _selectedFeetIndex = _feetValues.indexOf(feetStr);
              if (_selectedFeetIndex == -1) _selectedFeetIndex = 11; // Fallback
              // Animate scroll AFTER setState completes
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (scrollController.hasClients) {
                  scrollController.animateToItem(_selectedFeetIndex,
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut);
                }
              });
            } else {
              // Switching to CM
              // Convert FT index to approximate CM index
              final currentFt = _feetValues[_selectedFeetIndex];
              final cmValue = _feetToCm(currentFt);
              _selectedCmIndex = cmValue - _startCm;
              if (_selectedCmIndex < 0 ||
                  _selectedCmIndex >= _cmValues.length) {
                _selectedCmIndex = 30; // Fallback
              }
              // Animate scroll AFTER setState completes
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (scrollController.hasClients) {
                  scrollController.animateToItem(_selectedCmIndex,
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut);
                }
              });
            }
            // Update provider after unit switch and index calculation
            _updateHeight(ref);
          });
        }
      },
      child: Container(
        padding: EdgeInsets.symmetric(
            vertical: 12,
            horizontal: screenSize.width * 0.08), // Dynamic horizontal padding
        decoration: BoxDecoration(
          color: isSelected
              ? const Color(0xFF8B5CF6)
              : Colors.white, // White background for unselected
          border: Border.all(color: Colors.grey.shade300), // Subtle border
          borderRadius: BorderRadius.circular(30), // Even more rounded corners
          boxShadow: [
            // Subtle shadow for depth
            BoxShadow(
              color: Colors.grey.withOpacity(0.15),
              spreadRadius: 0,
              blurRadius: 3,
              offset: const Offset(0, 2), // changes position of shadow
            ),
          ],
        ),
        child: Text(
          unit,
          style: GoogleFonts.poppins(
            fontSize: 18, // Larger font size for buttons
            fontWeight: isSelected
                ? FontWeight.w600
                : FontWeight.w500, // Slightly bolder for selected
            color: isSelected
                ? Colors.white
                : const Color(0xFF555555), // Darker text for unselected
          ),
        ),
      ),
    );
  }

  // Modified to accept forceUpdate flag
  void _updateHeight(WidgetRef ref, {bool forceUpdate = false}) {
    String selectedValue = _unit == "FT"
        ? _feetValues[_selectedFeetIndex]
        : _cmValues[_selectedCmIndex];

    // Convert CM selection to FT' IN" format for saving
    String heightToSave = (_unit == "CM")
        ? _cmToFeet(int.parse(selectedValue.replaceAll(" cm", "")))
        : selectedValue;

    // Only update the provider if the value changed or if forced (e.g., on Done)
    if (forceUpdate || ref.read(userProvider).height != heightToSave) {
      print(
          "[HeightSelectionScreen] Updating height in provider to: $heightToSave");
      ref.read(userProvider.notifier).updateHeight(heightToSave);
    }
  }
}



================================================
File: views/home.dart
================================================
// File: lib/views/home.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/feed_provider.dart';
import 'package:dtx/providers/filter_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/views/filter_settings_dialog.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/widgets/home_profile_card.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/widgets/report_reason_dialog.dart'; // Added
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/utils/app_enums.dart';

class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen> {
  List<UserModel> _feedProfiles = [];
  bool _isInteracting = false; // To show overlay during API call

  // --- initState, dispose, _fetchFeed, _showCompleteProfileDialog, _removeTopCard ---
  // --- _callLikeRepository, _callDislikeRepository, _showErrorSnackbar ---
  // --- _openFilterDialog, _showMiniFilterEditor, _buildFilterChips, _buildFilterChip ---
  // --- Remain the same ---
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final feedState = ref.read(feedProvider);
      if (!feedState.hasFetchedOnce && !feedState.isLoading) {
        print("[HomeScreen initState] Feed not fetched yet, triggering fetch.");
        _fetchFeed();
      } else {
        if (mounted) {
          setState(() {
            _feedProfiles = feedState.profiles;
          });
        }
      }
      final filterState = ref.read(filterProvider);
      final filterNotifier = ref.read(filterProvider.notifier);
      if (filterState == const FilterSettings() && !filterNotifier.isLoading) {
        print(
            "[HomeScreen initState] Filters appear default, triggering load.");
        filterNotifier.loadFilters();
      }
    });
  }

  @override
  void dispose() {
    super.dispose();
  }

  Future<void> _fetchFeed({bool force = false}) async {
    print("[HomeScreen _fetchFeed] Fetching home feed. Force: $force");
    ref.read(errorProvider.notifier).clearError();
    await ref.read(feedProvider.notifier).fetchFeed(forceRefresh: force);
  }

  void _showCompleteProfileDialog() {
    /* ... keep existing implementation ... */
    showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext dialogContext) {
          return AlertDialog(
              title: Text("Complete Your Profile",
                  style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
              content: Text(
                  "To interact with profiles, please complete your profile setup.",
                  style: GoogleFonts.poppins()),
              actions: <Widget>[
                TextButton(
                    child: Text("Later",
                        style: GoogleFonts.poppins(color: Colors.grey)),
                    onPressed: () => Navigator.of(dialogContext).pop()),
                TextButton(
                    child: Text("Complete Profile",
                        style: GoogleFonts.poppins(
                            color: const Color(0xFF8B5CF6))),
                    onPressed: () {
                      Navigator.of(dialogContext).pop();
                      Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (_) => const NameInputScreen()));
                    })
              ]);
        });
  }

  void _removeTopCard() {
    print("[HomeScreen _removeTopCard] Removing top card from local state.");
    if (!mounted) return;
    if (_feedProfiles.isNotEmpty) {
      final removedUserId = _feedProfiles[0].id!;
      setState(() {
        _feedProfiles.removeAt(0);
      });
      print(
          "[HomeScreen _removeTopCard] Notifying FeedProvider to remove profile ID: $removedUserId");
      ref.read(feedProvider.notifier).removeProfile(removedUserId);
    }
  }

  Future<bool> _callLikeRepository(
      {required int targetUserId,
      required ContentLikeType contentType,
      required String contentIdentifier,
      required LikeInteractionType interactionType,
      String? comment}) async {
    final authStatus = ref.read(authProvider).authStatus;
    if (authStatus == AuthStatus.onboarding2) {
      _showCompleteProfileDialog();
      return false;
    }
    if (_isInteracting) return false;
    if (mounted) setState(() => _isInteracting = true);
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();
    bool success = false;
    try {
      final likeRepo = ref.read(likeRepositoryProvider);
      success = await likeRepo.likeContent(
          likedUserId: targetUserId,
          contentType: contentType,
          contentIdentifier: contentIdentifier,
          interactionType: interactionType,
          comment: comment);
      if (!success && mounted && ref.read(errorProvider) == null) {
        errorNotifier.setError(
            AppError.server("Could not send ${interactionType.value}."));
        _showErrorSnackbar("Could not send ${interactionType.value}.");
      }
    } on LikeLimitExceededException catch (e) {
      if (mounted) errorNotifier.setError(AppError.validation(e.message));
      _showErrorSnackbar(e.message);
    } on InsufficientRosesException catch (e) {
      if (mounted) errorNotifier.setError(AppError.validation(e.message));
      _showErrorSnackbar(e.message);
    } on ApiException catch (e) {
      if (mounted) errorNotifier.setError(AppError.server(e.message));
      _showErrorSnackbar(e.message);
    } catch (e) {
      if (mounted)
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
    return success;
  }

  Future<bool> _callDislikeRepository(int targetUserId) async {
    final authStatus = ref.read(authProvider).authStatus;
    if (authStatus == AuthStatus.onboarding2) {
      _showCompleteProfileDialog();
      return false;
    }
    if (_isInteracting) return false;
    if (mounted) setState(() => _isInteracting = true);
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();
    bool success = false;
    try {
      final likeRepo = ref.read(likeRepositoryProvider);
      success = await likeRepo.dislikeUser(dislikedUserId: targetUserId);
      if (!success && mounted && ref.read(errorProvider) == null) {
        errorNotifier.setError(AppError.server("Could not dislike user."));
        _showErrorSnackbar("Could not dislike user.");
      }
    } on ApiException catch (e) {
      if (mounted) errorNotifier.setError(AppError.server(e.message));
      _showErrorSnackbar(e.message);
    } catch (e) {
      if (mounted)
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
    return success;
  }

  void _showSnackbar(String message, {bool isError = false}) {
    // Added snackbar helper
    if (!mounted) return;
    ScaffoldMessenger.of(context).removeCurrentSnackBar();
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(message, style: GoogleFonts.poppins()),
        backgroundColor: isError ? Colors.redAccent : Colors.green));
  }

  void _showErrorSnackbar(String message) {
    _showSnackbar(message, isError: true);
  } // Added error snackbar helper

  Future<void> _openFilterDialog() async {
    /* ... keep existing implementation ... */
    print("[HomeScreen] Opening Full Filter Dialog.");
    await showDialog<bool>(
        context: context, builder: (context) => const FilterSettingsDialog());
  }

  Future<void> _showMiniFilterEditor(FilterField filterType) async {
    /* ... keep existing implementation ... */
    final filterNotifier = ref.read(filterProvider.notifier);
    final currentFilters = ref.read(filterProvider);
    bool changesMade = false;
    print("[HomeScreen] Opening mini-editor for: $filterType");
    final initialGender = currentFilters.whoYouWantToSee;
    final initialAgeRange = RangeValues(
        currentFilters.ageMin?.toDouble() ??
            FilterSettings.defaultAgeMin.toDouble(),
        currentFilters.ageMax?.toDouble() ??
            FilterSettings.defaultAgeMax.toDouble());
    final initialRadius = currentFilters.radiusKm?.toDouble() ??
        FilterSettings.defaultRadius.toDouble();
    final initialActive =
        currentFilters.activeToday ?? FilterSettings.defaultActiveToday;
    await showDialog(
        context: context,
        barrierDismissible: true,
        builder: (dialogContext) {
          FilterGenderPref? tempGender = initialGender;
          RangeValues tempAgeRange = initialAgeRange;
          double tempRadius = initialRadius;
          bool tempActive = initialActive;
          return StatefulBuilder(builder: (stfContext, stfSetState) {
            Widget editorContent;
            String title = "Edit Filter";
            switch (filterType) {
              case FilterField.whoYouWantToSee:
                title = "Show Me";
                editorContent = Column(
                    mainAxisSize: MainAxisSize.min,
                    children: FilterGenderPref.values.map((gender) {
                      return RadioListTile<FilterGenderPref>(
                          title: Text(
                              gender.value[0].toUpperCase() +
                                  gender.value.substring(1),
                              style: GoogleFonts.poppins()),
                          value: gender,
                          groupValue: tempGender,
                          onChanged: (FilterGenderPref? value) {
                            if (value != null) {
                              stfSetState(() {
                                print(
                                    "[MiniDialog stfSetState] Updating tempGender from $tempGender to $value");
                                tempGender = value;
                              });
                            }
                          },
                          activeColor: const Color(0xFF8B5CF6),
                          contentPadding: EdgeInsets.zero);
                    }).toList());
                break;
              case FilterField.ageMin:
              case FilterField.ageMax:
                title = "Age Range";
                editorContent =
                    Column(mainAxisSize: MainAxisSize.min, children: [
                  RangeSlider(
                      values: tempAgeRange,
                      min: 18,
                      max: 70,
                      divisions: 52,
                      labels: RangeLabels(tempAgeRange.start.round().toString(),
                          tempAgeRange.end.round().toString()),
                      activeColor: const Color(0xFF8B5CF6),
                      inactiveColor: const Color(0xFF8B5CF6).withOpacity(0.3),
                      onChanged: (RangeValues values) {
                        stfSetState(() {
                          if (values.start <= values.end) {
                            print(
                                "[MiniDialog stfSetState] Updating tempAgeRange from $tempAgeRange to $values");
                            tempAgeRange = values;
                          }
                        });
                      }),
                  Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: Text(
                          "${tempAgeRange.start.round()} - ${tempAgeRange.end.round()} years",
                          style: GoogleFonts.poppins(
                              color: Colors.grey[600], fontSize: 14)))
                ]);
                break;
              case FilterField.radiusKm:
                title = "Distance Radius";
                editorContent =
                    Column(mainAxisSize: MainAxisSize.min, children: [
                  Slider(
                      value: tempRadius,
                      min: 1,
                      max: 500,
                      divisions: 499,
                      label: "${tempRadius.round()} km",
                      activeColor: const Color(0xFF8B5CF6),
                      inactiveColor: const Color(0xFF8B5CF6).withOpacity(0.3),
                      onChanged: (double value) {
                        stfSetState(() {
                          print(
                              "[MiniDialog stfSetState] Updating tempRadius from $tempRadius to $value");
                          tempRadius = value;
                        });
                      }),
                  Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: Text("${tempRadius.round()} km",
                          style: GoogleFonts.poppins(
                              color: Colors.grey[600], fontSize: 14)))
                ]);
                break;
              case FilterField.activeToday:
                title = "Activity";
                editorContent = SwitchListTile(
                    title:
                        Text("Active Today Only", style: GoogleFonts.poppins()),
                    value: tempActive,
                    activeColor: const Color(0xFF8B5CF6),
                    contentPadding: EdgeInsets.zero,
                    onChanged: (bool value) {
                      stfSetState(() {
                        print(
                            "[MiniDialog stfSetState] Updating tempActive from $tempActive to $value");
                        tempActive = value;
                      });
                    });
                break;
            }
            return AlertDialog(
                title: Text(title,
                    style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
                contentPadding: const EdgeInsets.fromLTRB(20, 20, 20, 0),
                content: editorContent,
                actions: <Widget>[
                  TextButton(
                      child: Text('Cancel',
                          style: GoogleFonts.poppins(color: Colors.grey)),
                      onPressed: () => Navigator.of(dialogContext).pop()),
                  TextButton(
                      child: Text('Apply',
                          style: GoogleFonts.poppins(
                              color: const Color(0xFF8B5CF6),
                              fontWeight: FontWeight.w600)),
                      onPressed: () async {
                        bool valueChanged = false;
                        switch (filterType) {
                          case FilterField.whoYouWantToSee:
                            valueChanged = (initialGender != tempGender);
                            if (valueChanged)
                              filterNotifier.updateSingleFilter(
                                  tempGender, filterType);
                            break;
                          case FilterField.ageMin:
                          case FilterField.ageMax:
                            valueChanged = (initialAgeRange.start.round() !=
                                    tempAgeRange.start.round() ||
                                initialAgeRange.end.round() !=
                                    tempAgeRange.end.round());
                            if (valueChanged) {
                              filterNotifier.updateSingleFilter(
                                  tempAgeRange.start.round(),
                                  FilterField.ageMin);
                              filterNotifier.updateSingleFilter(
                                  tempAgeRange.end.round(), FilterField.ageMax);
                            }
                            break;
                          case FilterField.radiusKm:
                            valueChanged =
                                (initialRadius.round() != tempRadius.round());
                            if (valueChanged)
                              filterNotifier.updateSingleFilter(
                                  tempRadius.round(), filterType);
                            break;
                          case FilterField.activeToday:
                            valueChanged = (initialActive != tempActive);
                            if (valueChanged)
                              filterNotifier.updateSingleFilter(
                                  tempActive, filterType);
                            break;
                        }
                        if (valueChanged) {
                          changesMade = true;
                          print(
                              "[HomeScreen] Mini-editor change confirmed for $filterType.");
                        } else {
                          print(
                              "[HomeScreen] Mini-editor no change detected for $filterType.");
                        }
                        Navigator.of(dialogContext).pop();
                      })
                ],
                actionsPadding:
                    const EdgeInsets.symmetric(horizontal: 15, vertical: 10));
          });
        });
    if (changesMade && mounted) {
      print("[HomeScreen] Mini-filter changed. Saving current state via API.");
      await Future.delayed(const Duration(milliseconds: 50));
      final bool saveSuccess = await filterNotifier.saveCurrentFilterState();
      if (!saveSuccess && mounted) {
        _showErrorSnackbar("Failed to save filter change.");
      }
    } else if (!changesMade) {
      print("[HomeScreen] No changes made in mini-filter editor, not saving.");
    }
  }

  List<Widget> _buildFilterChips(FilterSettings filters) {
    /* ... keep existing implementation ... */
    List<Widget> chips = [];
    chips.add(_buildFilterChip(
        Icons.wc_rounded,
        filters.whoYouWantToSee?.value.replaceFirst(
                filters.whoYouWantToSee!.value[0],
                filters.whoYouWantToSee!.value[0].toUpperCase()) ??
            FilterSettings.defaultGenderPref.value.replaceFirst(
                FilterSettings.defaultGenderPref.value[0],
                FilterSettings.defaultGenderPref.value[0].toUpperCase()),
        FilterField.whoYouWantToSee,
        () => _showMiniFilterEditor(FilterField.whoYouWantToSee)));
    chips.add(_buildFilterChip(
        Icons.cake_outlined,
        '${filters.ageMin ?? FilterSettings.defaultAgeMin}-${filters.ageMax ?? FilterSettings.defaultAgeMax}',
        FilterField.ageMin,
        () => _showMiniFilterEditor(FilterField.ageMin)));
    chips.add(_buildFilterChip(
        Icons.social_distance_outlined,
        '${filters.radiusKm ?? FilterSettings.defaultRadius} km',
        FilterField.radiusKm,
        () => _showMiniFilterEditor(FilterField.radiusKm)));
    bool activeTodayValue =
        filters.activeToday ?? FilterSettings.defaultActiveToday;
    chips.add(_buildFilterChip(
        activeTodayValue
            ? Icons.access_time_filled_rounded
            : Icons.access_time_rounded,
        activeTodayValue ? 'Active Today' : 'Active: Any',
        FilterField.activeToday,
        () => _showMiniFilterEditor(FilterField.activeToday)));
    return chips;
  }

  Widget _buildFilterChip(
      IconData icon, String label, FilterField type, VoidCallback onTap) {
    /* ... keep existing implementation ... */
    const Color themeColor = Color(0xFF8B5CF6);
    const Color themeBgColor = Color(0xFFEDE9FE);
    const Color themeTextColor = themeColor;
    return Padding(
        padding: const EdgeInsets.only(right: 8.0),
        child: GestureDetector(
            onTap: onTap,
            child: Chip(
                avatar: Icon(icon, size: 16, color: themeColor),
                label: Text(label),
                labelStyle: GoogleFonts.poppins(
                    fontSize: 12,
                    color: themeTextColor,
                    fontWeight: FontWeight.w500),
                backgroundColor: themeBgColor,
                padding:
                    const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
                materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                visualDensity:
                    const VisualDensity(horizontal: 0.0, vertical: -2),
                side: BorderSide.none,
                elevation: 0.5,
                shadowColor: themeColor.withOpacity(0.2))));
  }

  // --- ADDED: _callReportRepository ---
  Future<bool> _callReportRepository(
      int targetUserId, ReportReason reason) async {
    // Check if user needs to complete profile first
    final authStatus = ref.read(authProvider).authStatus;
    if (authStatus == AuthStatus.onboarding2) {
      _showCompleteProfileDialog();
      return false;
    }
    // Prevent multiple interactions
    if (_isInteracting) return false;
    setState(() => _isInteracting = true);
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();
    bool success = false;
    try {
      success = await ref.read(likeRepositoryProvider).reportUser(
            targetUserId: targetUserId,
            reason: reason,
          );
      if (success && mounted) {
        _showSnackbar("Report submitted successfully.", isError: false);
        _removeTopCard(); // Remove the card after reporting
      } else if (!success && mounted && ref.read(errorProvider) == null) {
        errorNotifier.setError(AppError.server("Failed to submit report."));
        _showErrorSnackbar("Failed to submit report.");
      }
    } on ApiException catch (e) {
      if (mounted) errorNotifier.setError(AppError.server(e.message));
      _showErrorSnackbar(e.message);
    } catch (e) {
      if (mounted)
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
    return success;
  }
  // --- END ADDED ---

  @override
  Widget build(BuildContext context) {
    // ... (keep existing build setup) ...
    final feedState = ref.watch(feedProvider);
    final filters = ref.watch(filterProvider);
    ref.listen<HomeFeedState>(feedProvider, (_, next) {
      if (mounted && _feedProfiles != next.profiles) {
        setState(() {
          _feedProfiles = next.profiles;
          print(
              "[HomeScreen Listener] Updated local _feedProfiles. Count: ${_feedProfiles.length}");
        });
      }
    });
    final error = feedState.error ?? ref.watch(errorProvider);
    final isLoadingFeed = feedState.isLoading && !feedState.hasFetchedOnce;
    final bool hasProfilesToShow = _feedProfiles.isNotEmpty;

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text("Discover",
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 0,
        automaticallyImplyLeading: false,
        actions: [
          IconButton(
              icon: const Icon(Icons.tune_rounded, color: Color(0xFF8B5CF6)),
              tooltip: "Filters",
              onPressed: _openFilterDialog)
        ],
      ),
      body: Column(
        children: [
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 12.0, vertical: 10.0),
            child: Container(
                color: Colors.transparent,
                height: 34,
                child: SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    physics: const BouncingScrollPhysics(),
                    child: Row(children: _buildFilterChips(filters)))),
          ),
          Expanded(
            child: Stack(
              alignment: Alignment.center,
              children: [
                if (isLoadingFeed)
                  const CircularProgressIndicator(color: Color(0xFF8B5CF6))
                else if (error != null && !hasProfilesToShow)
                  _buildErrorState(error)
                else if (!hasProfilesToShow)
                  _buildEmptyState()
                else
                  _buildProfileCardAtIndex(0),
                if (_isInteracting)
                  Positioned.fill(
                      child: Container(
                          color: Colors.white.withOpacity(0.5),
                          child: const Center(
                              child: CircularProgressIndicator(
                                  color: Color(0xFF8B5CF6))))),
              ],
            ),
          ),
        ],
      ),
    );
  }

  // --- Modified _buildProfileCardAtIndex ---
  Widget _buildProfileCardAtIndex(int index) {
    if (index >= 0 && index < _feedProfiles.length) {
      final currentProfile = _feedProfiles[index];
      return HomeProfileCard(
        key: ValueKey(currentProfile.id),
        profile: currentProfile,
        performLikeApiCall: (
            {required contentType,
            required contentIdentifier,
            required interactionType,
            comment}) async {
          if (currentProfile.id == null) return false;
          return await _callLikeRepository(
              targetUserId: currentProfile.id!,
              contentType: contentType,
              contentIdentifier: contentIdentifier,
              interactionType: interactionType,
              comment: comment);
        },
        performDislikeApiCall: () async {
          if (currentProfile.id == null) return false;
          return await _callDislikeRepository(currentProfile.id!);
        },
        // --- ADDED: Pass Report Callback ---
        performReportApiCall: ({required reason}) async {
          if (currentProfile.id == null) return false;
          return await _callReportRepository(currentProfile.id!, reason);
        },
        // --- END ADDED ---
        onInteractionComplete: _removeTopCard,
      );
    }
    return Container(
        alignment: Alignment.center,
        child: Text("No more profiles.", style: GoogleFonts.poppins()));
  }

  // --- _buildEmptyState, _buildErrorState (keep as is) ---
  Widget _buildEmptyState() {
    /* ... keep existing implementation ... */
    return LayoutBuilder(builder: (context, constraints) {
      return SingleChildScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          child: ConstrainedBox(
              constraints: BoxConstraints(minHeight: constraints.maxHeight),
              child: Center(
                  child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                    Icon(Icons.people_outline_rounded,
                        size: 80, color: Colors.grey[400]),
                    const SizedBox(height: 20),
                    Text("That's everyone for now!",
                        style: GoogleFonts.poppins(
                            fontSize: 18, color: Colors.grey[600])),
                    const SizedBox(height: 10),
                    Text("Adjust your filters or check back later.",
                        textAlign: TextAlign.center,
                        style: GoogleFonts.poppins(
                            fontSize: 14, color: Colors.grey[500])),
                    const SizedBox(height: 20),
                    ElevatedButton.icon(
                        icon: const Icon(Icons.refresh_rounded, size: 18),
                        label: const Text("Refresh Feed"),
                        style: ElevatedButton.styleFrom(
                            foregroundColor: Colors.white,
                            backgroundColor: const Color(0xFF8B5CF6),
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(20)),
                            padding: const EdgeInsets.symmetric(
                                horizontal: 20, vertical: 10)),
                        onPressed: () => _fetchFeed(force: true))
                  ]))));
    });
  }

  Widget _buildErrorState(AppError error) {
    /* ... keep existing implementation ... */
    return LayoutBuilder(builder: (context, constraints) {
      return SingleChildScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          child: ConstrainedBox(
              constraints: BoxConstraints(minHeight: constraints.maxHeight),
              child: Center(
                  child: Padding(
                      padding: const EdgeInsets.all(20.0),
                      child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.error_outline_rounded,
                                size: 60, color: Colors.redAccent[100]),
                            const SizedBox(height: 20),
                            Text("Oops! Something went wrong",
                                style: GoogleFonts.poppins(
                                    fontSize: 18,
                                    fontWeight: FontWeight.w600,
                                    color: Colors.grey[700]),
                                textAlign: TextAlign.center),
                            const SizedBox(height: 10),
                            Text(error.message,
                                style: GoogleFonts.poppins(
                                    fontSize: 14, color: Colors.grey[600]),
                                textAlign: TextAlign.center),
                            const SizedBox(height: 20),
                            ElevatedButton.icon(
                                icon:
                                    const Icon(Icons.refresh_rounded, size: 18),
                                label: const Text("Retry"),
                                style: ElevatedButton.styleFrom(
                                    foregroundColor: Colors.white,
                                    backgroundColor: const Color(0xFF8B5CF6),
                                    shape: RoundedRectangleBorder(
                                        borderRadius:
                                            BorderRadius.circular(20)),
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 30, vertical: 12)),
                                onPressed: () => _fetchFeed(force: true))
                          ])))));
    });
  }
} // End of _HomeScreenState



================================================
File: views/hometown.dart
================================================
// File: lib/views/hometown.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/job.dart'; // Keep for onboarding flow

class HometownScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const HometownScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<HometownScreen> createState() => _HometownScreenState();
}

class _HometownScreenState extends ConsumerState<HometownScreen> {
  final TextEditingController _hometownController = TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _hometownController.text = ref.read(userProvider).hometown ?? '';
    }
    // Add listener to enable/disable Done button
    _hometownController.addListener(() {
      if (widget.isEditing) setState(() {});
    });
  }

  @override
  void dispose() {
    _hometownController.dispose();
    super.dispose();
  }

  void _handleNext() {
    String? hometown;
    if (_hometownController.text.trim().isNotEmpty) {
      hometown = _hometownController.text.trim();
    } else {
      hometown = null; // Explicitly set to null if empty
    }
    ref.read(userProvider.notifier).updateHometown(hometown);

    if (widget.isEditing) {
      print("[HometownScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[HometownScreen] Onboarding next: Job.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const JobTitleScreen()));
    }
  }

  void _handleSkipOrClear() {
    FocusScope.of(context).unfocus();
    _hometownController.clear(); // Clear text field
    ref
        .read(userProvider.notifier)
        .updateHometown(null); // Update provider to null
    if (widget.isEditing) {
      print("[HometownScreen] Clearing field and popping back.");
      Navigator.of(context).pop(); // Pop back immediately after clearing
    } else {
      // Original onboarding skip navigation
      print("[HometownScreen] Skipping to Job.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const JobTitleScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    // Determine if Done button should be enabled in Edit mode
    final bool canProceedEditing =
        widget.isEditing && _hometownController.text.trim().isNotEmpty;

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      IconButton(
                        // Keep original icon for onboarding
                        icon: const Icon(Icons.home_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {}, // No action needed here
                      ),

                    Text(
                      widget.isEditing ? "Edit Hometown" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    // Show "Done" in edit mode, "Skip" in onboarding
                    if (widget.isEditing)
                      TextButton(
                        onPressed:
                            _handleNext, // Always enabled, saves empty as null
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color:
                                const Color(0xFF8B5CF6), // Always enabled color
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      TextButton(
                        onPressed: _handleSkipOrClear, // Use unified handler
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                              fontSize: 16, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),

              // Question Text
              Text(
                widget.isEditing
                    ? "Edit your hometown"
                    : "Where's your home\ntown?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),

              SizedBox(height: screenSize.height * 0.05),

              // Text Field
              Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                child: TextField(
                  controller: _hometownController,
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    color: Colors.black87,
                  ),
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    hintText: "e.g., New Delhi",
                    hintStyle: GoogleFonts.poppins(
                      fontSize: 22,
                      color: Colors.grey.shade500,
                    ),
                    border: const UnderlineInputBorder(
                      borderSide: BorderSide(color: Colors.grey, width: 1.0),
                    ),
                    focusedBorder: const UnderlineInputBorder(
                      borderSide:
                          BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                    ),
                    // Add clear button in edit mode if text exists
                    suffixIcon: widget.isEditing &&
                            _hometownController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, color: Colors.grey),
                            onPressed: () {
                              _hometownController.clear();
                              // Optionally update provider immediately on clear
                              // ref.read(userProvider.notifier).updateHometown(null);
                            },
                          )
                        : null,
                  ),
                ),
              ),

              const Spacer(),

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: GestureDetector(
                      onTap: _handleNext, // Always enabled for onboarding
                      child: Container(
                        width: 70,
                        height: 70,
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(35),
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/job.dart
================================================
// File: lib/views/job.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/study.dart'; // Keep for onboarding flow

class JobTitleScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const JobTitleScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<JobTitleScreen> createState() => _JobTitleScreenState();
}

class _JobTitleScreenState extends ConsumerState<JobTitleScreen> {
  final TextEditingController _jobTitleController = TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _jobTitleController.text = ref.read(userProvider).jobTitle ?? '';
    }
    // Add listener to enable/disable Done button in edit mode if needed
    _jobTitleController.addListener(() {
      if (widget.isEditing) setState(() {});
    });
  }

  @override
  void dispose() {
    _jobTitleController.dispose();
    super.dispose();
  }

  void _handleNext() {
    String? jobTitle;
    if (_jobTitleController.text.trim().isNotEmpty) {
      jobTitle = _jobTitleController.text.trim();
    } else {
      jobTitle = null; // Explicitly set to null if empty
    }
    ref.read(userProvider.notifier).updateJobTitle(jobTitle);

    if (widget.isEditing) {
      print("[JobTitleScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[JobTitleScreen] Onboarding next: Study.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const StudyLocationScreen()));
    }
  }

  void _handleSkipOrClear() {
    FocusScope.of(context).unfocus();
    _jobTitleController.clear(); // Clear text field
    ref
        .read(userProvider.notifier)
        .updateJobTitle(null); // Update provider to null
    if (widget.isEditing) {
      print("[JobTitleScreen] Clearing field and popping back.");
      Navigator.of(context).pop(); // Pop back immediately after clearing
    } else {
      // Original onboarding skip navigation
      print("[JobTitleScreen] Skipping to Study.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const StudyLocationScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    // Determine if Done button should be enabled in Edit mode (optional, could always allow saving null)
    // final bool canProceedEditing = widget.isEditing && _jobTitleController.text.trim().isNotEmpty;

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      IconButton(
                        // Keep original icon for onboarding
                        icon: const Icon(Icons.work_outline_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {}, // No action needed here
                      ),

                    Text(
                      widget.isEditing ? "Edit Job Title" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    // Show "Done" in edit mode, "Skip" in onboarding
                    if (widget.isEditing)
                      TextButton(
                        onPressed: _handleNext, // Always enabled
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color:
                                const Color(0xFF8B5CF6), // Always enabled color
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      TextButton(
                        onPressed: _handleSkipOrClear, // Use unified handler
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                              fontSize: 16, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),

              // Question Text
              Text(
                widget.isEditing
                    ? "Edit your job title"
                    : "What's your job\ntitle?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),

              SizedBox(height: screenSize.height * 0.05),

              // Text Field
              Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                child: TextField(
                  controller: _jobTitleController,
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    color: Colors.black87,
                  ),
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    hintText: "e.g., Software Engineer",
                    hintStyle: GoogleFonts.poppins(
                      fontSize: 22,
                      color: Colors.grey.shade500,
                    ),
                    border: const UnderlineInputBorder(
                      borderSide: BorderSide(color: Colors.grey, width: 1.0),
                    ),
                    focusedBorder: const UnderlineInputBorder(
                      borderSide:
                          BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                    ),
                    // Add clear button in edit mode if text exists
                    suffixIcon: widget.isEditing &&
                            _jobTitleController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, color: Colors.grey),
                            onPressed: () {
                              _jobTitleController.clear();
                            },
                          )
                        : null,
                  ),
                ),
              ),

              const Spacer(),

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: GestureDetector(
                      onTap: _handleNext, // Always enabled for onboarding
                      child: Container(
                        width: 70,
                        height: 70,
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(35),
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/liker_profile_screen.dart
================================================
// File: lib/views/liker_profile_screen.dart
import 'dart:math'; // Import math for max function
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/liker_profile_provider.dart';
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/providers/audio_player_provider.dart'; // Import for audio player state
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/utils/app_enums.dart';

class LikerProfileScreen extends ConsumerStatefulWidget {
  final int likerUserId;

  const LikerProfileScreen({super.key, required this.likerUserId});

  @override
  ConsumerState<LikerProfileScreen> createState() => _LikerProfileScreenState();
}

class _LikerProfileScreenState extends ConsumerState<LikerProfileScreen> {
  bool _isInteracting = false; // Local state for loading indicator

  // --- Dislike Handler (Keep as is) ---
  Future<void> _handleDislike() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text("Dislike Profile?", style: GoogleFonts.poppins()),
        content: Text(
            "Are you sure you want to dislike this profile? They won't appear again.",
            style: GoogleFonts.poppins()),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text("Cancel",
                  style: GoogleFonts.poppins(color: Colors.grey))),
          TextButton(
              onPressed: () => Navigator.pop(context, true),
              child: Text("Dislike",
                  style: GoogleFonts.poppins(color: Colors.red))),
        ],
      ),
    );

    if (confirm != true) return;

    if (!mounted) return;
    setState(() => _isInteracting = true);
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();

    try {
      final success = await ref
          .read(likeRepositoryProvider)
          .dislikeUser(dislikedUserId: widget.likerUserId);

      if (success && mounted) {
        ref.invalidate(receivedLikesProvider);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("Profile disliked.", style: GoogleFonts.poppins()),
              backgroundColor: Colors.grey[700]),
        );
        Navigator.of(context).pop();
      } else if (!success && mounted) {
        if (ref.read(errorProvider) == null) {
          errorNotifier.setError(AppError.server("Failed to dislike profile."));
          _showErrorSnackbar("Failed to dislike profile.");
        }
      }
    } on ApiException catch (e) {
      if (mounted) errorNotifier.setError(AppError.server(e.message));
      _showErrorSnackbar(e.message);
    } catch (e) {
      if (mounted)
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
  }

  // --- Like Back Handler (Keep as is) ---
  Future<void> _handleLikeBack() async {
    if (_isInteracting) return;
    if (!mounted) return;
    setState(() => _isInteracting = true);
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();

    try {
      final success = await ref
          .read(likeRepositoryProvider)
          .likeBackUserProfile(likedUserId: widget.likerUserId);

      if (success && mounted) {
        ref.invalidate(receivedLikesProvider);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("It's a Match! 🎉", style: GoogleFonts.poppins()),
              backgroundColor: Colors.green),
        );
        Navigator.of(context).pop();
        // TODO: Optionally navigate to chat screen here?
      } else if (!success && mounted) {
        if (ref.read(errorProvider) == null) {
          errorNotifier.setError(AppError.server("Failed to like back."));
          _showErrorSnackbar("Failed to like back.");
        }
      }
    } on ApiException catch (e) {
      if (mounted) errorNotifier.setError(AppError.server(e.message));
      if (e.statusCode == 409) {
        _showErrorSnackbar("You have already matched or liked this user.");
      } else {
        _showErrorSnackbar(e.message);
      }
    } catch (e) {
      if (mounted)
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
  }

  // --- Error Snackbar Helper (Keep as is) ---
  void _showErrorSnackbar(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).removeCurrentSnackBar();
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message, style: GoogleFonts.poppins()),
        backgroundColor: Colors.redAccent,
        duration: const Duration(seconds: 3),
      ),
    );
  }

  // --- Helper for FAB-style buttons (Keep as is) ---
  Widget _buildLikerActionButton({
    required IconData icon,
    required Color color,
    required Color backgroundColor,
    required VoidCallback? onPressed,
    required String tooltip,
    double size = 60.0,
    double iconSize = 30.0,
  }) {
    return Tooltip(
      message: tooltip,
      child: FloatingActionButton(
        heroTag: tooltip,
        onPressed: onPressed,
        backgroundColor:
            onPressed != null ? backgroundColor : Colors.grey.shade400,
        elevation: onPressed != null ? 4.0 : 0.0,
        child: Icon(
          icon,
          color: onPressed != null ? color : Colors.white70,
          size: iconSize,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(likerProfileProvider(widget.likerUserId));
    final profile = state.profile;
    final likeDetails = state.likeDetails;

    return Scaffold(
      backgroundColor: Colors.white,
      // --- Floating Action Buttons Row (Keep as is) ---
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
      floatingActionButton: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            // Dislike Button (Left)
            _buildLikerActionButton(
              icon: Icons.close_rounded,
              color: Colors.red,
              backgroundColor: Colors.white,
              onPressed: _isInteracting ? null : _handleDislike,
              tooltip: "Dislike",
            ),
            // Like Back Button (Right)
            _buildLikerActionButton(
              icon: Icons.favorite_rounded,
              color: Colors.white,
              backgroundColor: const Color(0xFF8B5CF6),
              onPressed: _isInteracting ? null : _handleLikeBack,
              tooltip: "Like Back",
            ),
          ],
        ),
      ),
      body: _buildBody(context, state, profile, likeDetails, ref),
    );
  }

  Widget _buildBody(
      BuildContext context,
      LikerProfileState state,
      UserProfileData? profile,
      LikeInteractionDetails? likeDetails,
      WidgetRef ref) {
    if (state.isLoading) {
      return const Center(
          child: CircularProgressIndicator(color: Color(0xFF8B5CF6)));
    }

    if (state.error != null) {
      return _buildErrorState(context, state.error!, ref);
    }

    if (profile == null || likeDetails == null) {
      return _buildErrorState(
          context, AppError.generic("Profile data could not be loaded."), ref);
    }

    // --- START: Content Block Generation (Adapted from HomeProfileCard) ---
    final List<dynamic> contentBlocks = [];
    final mediaUrls = profile.mediaUrls ?? [];
    final prompts = profile.prompts;

    contentBlocks.add("header_section");
    contentBlocks.add("like_details_banner");
    if (mediaUrls.isNotEmpty) contentBlocks.add(mediaUrls[0]);
    if (prompts.isNotEmpty) contentBlocks.add(prompts[0]);
    contentBlocks.add("vitals_section");

    int mediaIndex = 1;
    int promptIndex = 1;
    int maxRemaining = max(mediaUrls.length, prompts.length);

    for (int i = 1; i < maxRemaining; i++) {
      if (mediaIndex < mediaUrls.length) {
        contentBlocks.add(mediaUrls[mediaIndex]);
        mediaIndex++;
      }
      if (promptIndex < prompts.length) {
        contentBlocks.add(prompts[promptIndex]);
        promptIndex++;
      }
    }
    if (profile.audioPrompt != null) {
      contentBlocks.add(profile.audioPrompt!);
    }
    // --- END: Content Block Generation ---

    return CustomScrollView(
      slivers: [
        SliverAppBar(
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          elevation: 1,
          pinned: true,
          leading: IconButton(
            icon: Icon(Icons.arrow_back_ios_new,
                color: Colors.grey[700], size: 20),
            onPressed: () => Navigator.of(context).pop(),
          ),
          // --- REMOVED title property ---
          // title: Text(
          //   profile.name ?? 'Profile',
          //   style:
          //       GoogleFonts.poppins(fontWeight: FontWeight.w600, fontSize: 18),
          // ),
          // --- END REMOVED ---
        ),

        SliverPadding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          sliver: SliverList(
            delegate: SliverChildBuilderDelegate(
              (context, index) {
                final item = contentBlocks[index];
                final double topPadding = (index == 0) ? 8.0 : 0;
                final double bottomPadding = 20.0;
                final double horizontalPadding = 12.0;
                Widget contentWidget;

                if (item is String && item == "header_section") {
                  contentWidget = _buildHeaderBlock(profile);
                } else if (item is String && item == "like_details_banner") {
                  if (likeDetails != null) {
                    contentWidget =
                        _buildLikeDetailsBanner(likeDetails, profile);
                  } else {
                    contentWidget = const SizedBox.shrink();
                  }
                } else if (item is String && item.startsWith('http')) {
                  int originalMediaIndex =
                      (profile.mediaUrls ?? []).indexOf(item);
                  if (originalMediaIndex == -1) originalMediaIndex = 0;
                  contentWidget =
                      _buildMediaItem(context, ref, item, originalMediaIndex);
                } else if (item is Prompt) {
                  contentWidget = _buildPromptItem(context, ref, item);
                } else if (item is AudioPromptModel) {
                  contentWidget = _buildAudioItem(context, ref, item);
                } else if (item is String && item == "vitals_section") {
                  contentWidget = _buildVitalsBlock(profile);
                } else {
                  contentWidget = const SizedBox.shrink();
                }

                return Padding(
                  padding: EdgeInsets.fromLTRB(horizontalPadding, topPadding,
                      horizontalPadding, bottomPadding),
                  child: contentWidget,
                );
              },
              childCount: contentBlocks.length,
            ),
          ),
        ),
        SliverToBoxAdapter(
            child: SizedBox(height: 100)), // Ensure space for FABs
      ],
    );
  }

  // --- Error State Widget (unchanged) ---
  Widget _buildErrorState(BuildContext context, AppError error, WidgetRef ref) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(30.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                size: 60, color: Colors.redAccent[100]),
            const SizedBox(height: 20),
            Text(
              "Oops!",
              style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[700]),
            ),
            const SizedBox(height: 10),
            Text(
              error.message,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded, size: 18),
              label: const Text("Retry"),
              style: ElevatedButton.styleFrom(
                foregroundColor: Colors.white,
                backgroundColor: const Color(0xFF8B5CF6),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20)),
                padding:
                    const EdgeInsets.symmetric(horizontal: 30, vertical: 12),
              ),
              onPressed: () => ref
                  .read(likerProfileProvider(widget.likerUserId).notifier)
                  .fetchProfile(),
            ),
            const SizedBox(height: 10),
            TextButton(
              child: const Text("Go Back"),
              style: TextButton.styleFrom(foregroundColor: Colors.grey[600]),
              onPressed: () => Navigator.of(context).pop(),
            )
          ],
        ),
      ),
    );
  }

  // --- START: Copied & Adapted Helper Widgets from HomeProfileCard ---

  Widget _buildHeaderBlock(UserModel profile) {
    final age = profile.age;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '${profile.name ?? 'Name'}${profile.lastName != null && profile.lastName!.isNotEmpty ? ' ${profile.lastName}' : ''}${age != null ? ' • $age' : ''}',
          style: GoogleFonts.poppins(
              fontSize: 26, fontWeight: FontWeight.bold, color: Colors.black87),
        ),
        if (profile.hometown != null && profile.hometown!.isNotEmpty) ...[
          const SizedBox(height: 4),
          Row(
            children: [
              Icon(Icons.location_on_outlined,
                  size: 16, color: Colors.grey[600]),
              const SizedBox(width: 4),
              Text(
                profile.hometown!,
                style:
                    GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
              ),
            ],
          ),
        ]
      ],
    );
  }

  Widget _buildVitalsBlock(UserModel profile) {
    final List<Widget> vitals = [];
    if (profile.height != null && profile.height!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.height, profile.height!));
    }
    if (profile.religiousBeliefs != null) {
      vitals.add(_buildVitalRow(
          Icons.church_outlined, profile.religiousBeliefs!.label));
    }
    if (profile.jobTitle != null && profile.jobTitle!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.work_outline, profile.jobTitle!));
    }
    if (profile.education != null && profile.education!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.school_outlined, profile.education!));
    }
    if (profile.drinkingHabit != null) {
      vitals.add(_buildVitalRow(
          Icons.local_bar_outlined, "Drinks: ${profile.drinkingHabit!.label}"));
    }
    if (profile.smokingHabit != null) {
      vitals.add(_buildVitalRow(Icons.smoking_rooms_outlined,
          "Smokes: ${profile.smokingHabit!.label}"));
    }

    if (vitals.isEmpty) return const SizedBox.shrink();

    return Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        width: double.infinity,
        decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(10),
            border: Border.all(color: Colors.grey[200]!),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 3),
              )
            ]),
        child: Column(
          children: List.generate(vitals.length * 2 - 1, (index) {
            if (index.isEven) {
              return vitals[index ~/ 2];
            } else {
              return Divider(height: 16, thickness: 1, color: Colors.grey[200]);
            }
          }),
        ));
  }

  Widget _buildVitalRow(IconData icon, String label) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6.0),
      child: Row(
        children: [
          Icon(icon, size: 20, color: Colors.grey[600]),
          const SizedBox(width: 12),
          Expanded(
              child: Text(label,
                  style: GoogleFonts.poppins(
                      fontSize: 15, color: Colors.grey[800]))),
        ],
      ),
    );
  }

  Widget _buildMediaItem(
      BuildContext context, WidgetRef ref, String url, int index) {
    bool isVideo = url.toLowerCase().contains('.mp4') ||
        url.toLowerCase().contains('.mov');

    return ClipRRect(
      borderRadius: BorderRadius.circular(10),
      child: AspectRatio(
        aspectRatio: 4 / 5.5,
        child: Container(
          decoration: BoxDecoration(color: Colors.grey[200]),
          child: Stack(
            fit: StackFit.expand,
            children: [
              Image.network(url,
                  fit: BoxFit.cover,
                  loadingBuilder: (ctx, child, prog) => prog == null
                      ? child
                      : Center(
                          child: CircularProgressIndicator(
                              value: prog.expectedTotalBytes != null
                                  ? prog.cumulativeBytesLoaded /
                                      prog.expectedTotalBytes!
                                  : null,
                              color: Colors.grey[400])),
                  errorBuilder: (ctx, err, st) => Center(
                      child: Icon(Icons.image_not_supported_outlined,
                          color: Colors.grey[400], size: 40))),
              if (isVideo)
                Center(
                  child: Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.5),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.play_arrow_rounded,
                        color: Colors.white, size: 30),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPromptItem(BuildContext context, WidgetRef ref, Prompt prompt) {
    if (prompt.answer.trim().isEmpty) return const SizedBox.shrink();

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(10),
          border: Border.all(color: Colors.grey[200]!),
          boxShadow: [
            BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ]),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(prompt.question.label,
              style: GoogleFonts.poppins(
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[600])),
          const SizedBox(height: 10),
          Text(prompt.answer,
              style: GoogleFonts.poppins(
                  fontSize: 20,
                  color: Colors.black87,
                  height: 1.4,
                  fontWeight: FontWeight.w500)),
        ],
      ),
    );
  }

  Widget _buildAudioItem(
      BuildContext context, WidgetRef ref, AudioPromptModel audio) {
    final audioPlayerState = ref.watch(audioPlayerStateProvider);
    final currentPlayingUrl = ref.watch(currentAudioUrlProvider);
    final playerNotifier = ref.read(audioPlayerControllerProvider.notifier);

    final bool isThisPlaying = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.playing;
    final bool isThisLoading = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.loading;
    final bool isThisPaused = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.paused;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey[200]!),
          boxShadow: [
            BoxShadow(
                color: Colors.grey.withOpacity(0.06),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ]),
      child: Row(
        children: [
          InkWell(
            onTap: () {
              if (isThisLoading) return;
              if (isThisPlaying) {
                playerNotifier.pause();
              } else if (isThisPaused) {
                playerNotifier.resume();
              } else {
                playerNotifier.play(audio.audioUrl);
              }
            },
            borderRadius: BorderRadius.circular(24),
            child: Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: const Color(0xFF8B5CF6),
                borderRadius: BorderRadius.circular(24),
                boxShadow: [
                  BoxShadow(
                      color: const Color(0xFF8B5CF6).withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2))
                ],
              ),
              child: isThisLoading
                  ? const Padding(
                      padding: EdgeInsets.all(12.0),
                      child: CircularProgressIndicator(
                          strokeWidth: 2, color: Colors.white))
                  : Icon(
                      isThisPlaying
                          ? Icons.pause_rounded
                          : Icons.play_arrow_rounded,
                      color: Colors.white,
                      size: 28,
                    ),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(audio.prompt.label,
                    style: GoogleFonts.poppins(
                        fontSize: 15,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF1A1A1A))),
                const SizedBox(height: 4),
                Text(
                    isThisLoading
                        ? "Loading..."
                        : isThisPlaying
                            ? "Playing..."
                            : isThisPaused
                                ? "Paused"
                                : "Tap to listen",
                    style: GoogleFonts.poppins(
                        fontSize: 13, color: Colors.grey[600])),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDetailChip(IconData icon, String label, {bool subtle = false}) {
    if (label.isEmpty) return const SizedBox.shrink();
    return Container(
      padding: EdgeInsets.symmetric(
          horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
      decoration: BoxDecoration(
        color: subtle ? Colors.transparent : Colors.grey[100],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
            color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: subtle ? 16 : 18,
            color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6),
          ),
          const SizedBox(width: 6),
          Flexible(
            child: Text(
              label,
              style: GoogleFonts.poppins(
                fontSize: subtle ? 13 : 14,
                fontWeight: FontWeight.w500,
                color: subtle ? Colors.grey.shade700 : Colors.grey[800],
              ),
              overflow: TextOverflow.ellipsis,
              maxLines: 2,
            ),
          ),
        ],
      ),
    );
  }

  // --- END: Copied & Adapted Helper Widgets ---

  // --- Like Details Banner (Corrected Signature and Call) ---
  Widget _buildLikeDetailsBanner(
      LikeInteractionDetails likeDetails, UserProfileData? profile) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
          color:
              likeDetails.isRose ? Colors.purple.shade50 : Colors.blue.shade50,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
              color: likeDetails.isRose
                  ? Colors.purple.shade100
                  : Colors.blue.shade100)),
      child: Row(
        children: [
          Icon(
            likeDetails.isRose ? Icons.star_rounded : Icons.favorite_rounded,
            color: likeDetails.isRose
                ? Colors.purple.shade400
                : Colors.pink.shade300,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              likeDetails.likeComment != null &&
                      likeDetails.likeComment!.isNotEmpty
                  ? '"${likeDetails.likeComment}"'
                  : (likeDetails.isRose
                      ? '${profile?.name ?? "They"} sent you a Rose!'
                      : '${profile?.name ?? "They"} liked your profile!'),
              style: GoogleFonts.poppins(
                fontSize: 14,
                fontWeight: FontWeight.w500,
                fontStyle: (likeDetails.likeComment != null &&
                        likeDetails.likeComment!.isNotEmpty)
                    ? FontStyle.italic
                    : FontStyle.normal,
                color: likeDetails.isRose
                    ? Colors.purple.shade700
                    : Colors.blue.shade700,
              ),
            ),
          ),
        ],
      ),
    );
  }
  // --- END Like Details Banner ---
} // End of State class



================================================
File: views/location.dart
================================================
// File: views/location.dart
import 'package:dtx/models/error_model.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:app_settings/app_settings.dart'; // Keep for opening settings
import '../providers/location_provider.dart';
import '../providers/error_provider.dart';
import '../providers/user_provider.dart'; // Ensure user provider is imported
import 'gender.dart'; // Ensure GenderSelectionScreen is imported

class LocationInputScreen extends ConsumerStatefulWidget {
  const LocationInputScreen({super.key});

  @override
  ConsumerState<LocationInputScreen> createState() =>
      _LocationInputScreenState();
}

class _LocationInputScreenState extends ConsumerState<LocationInputScreen> {
  late final MapController _mapController;

  @override
  void initState() {
    super.initState();
    _mapController = MapController();
    // Fetch location after the first frame is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Only fetch if location isn't already valid in the user state
      // This prevents unnecessary fetches if the user navigates back and forth
      if (!ref.read(userProvider.notifier).isLocationValid()) {
        print("[LocationInputScreen] Initial location fetch triggered.");
        ref.read(locationProvider.notifier).fetchCurrentLocation();
      } else {
        print(
            "[LocationInputScreen] Skipping initial fetch, location already set.");
        // Ensure the map moves to the existing location if needed
        _moveToCurrentLocation();
      }
    });
  }

  void _onMapReady() {
    print("[LocationInputScreen] Map Ready.");
    // It might be safer to set map ready state in the provider
    // ref.read(locationProvider.notifier).setMapReady(true);
    _moveToCurrentLocation();
  }

  void _moveToCurrentLocation() {
    final locationState = ref.read(locationProvider);
    final userLocation =
        ref.read(userProvider); // Get location from user provider

    // Use user provider's location if valid, otherwise use location provider's state
    final LatLng targetLocation = LatLng(
      userLocation.latitude ?? locationState.latitude,
      userLocation.longitude ?? locationState.longitude,
    );

    print("[LocationInputScreen] Moving map to: $targetLocation");
    // Check if mapController is initialized and ready
    // Note: FlutterMap doesn't have a direct 'isReady' flag accessible here easily.
    // We rely on onMapReady having been called implicitly before this might be needed.
    // A small delay could be a workaround if needed, but usually direct call is fine.
    try {
      _mapController.move(targetLocation, _mapController.camera.zoom);
    } catch (e) {
      print(
          "[LocationInputScreen] Error moving map (potentially before ready): $e");
      // Optionally, schedule the move again slightly later
      // Future.delayed(Duration(milliseconds: 100), () => _moveToCurrentLocation());
    }
  }

  // Dialog for location services disabled
  Future<void> _showLocationServiceDialog() async {
    // Prevent showing multiple dialogs
    if (ModalRoute.of(context)?.isCurrent ?? false) {
      print("[LocationInputScreen] Showing Location Service Dialog.");
      return showDialog<void>(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext dialogContext) {
          // Use different context name
          return AlertDialog(
            title: Text('Location Services Required',
                style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
            content: SingleChildScrollView(
              child: ListBody(
                children: <Widget>[
                  Text(
                      'To show you relevant places around you, we need access to your location.',
                      style: GoogleFonts.poppins()),
                  const SizedBox(height: 15),
                  Text(
                      'Please enable location services in your device settings.',
                      style: GoogleFonts.poppins()),
                ],
              ),
            ),
            actions: <Widget>[
              TextButton(
                child: Text('Open Settings',
                    style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6))),
                onPressed: () {
                  Navigator.pop(dialogContext); // Use dialogContext
                  ref.read(locationProvider.notifier).openLocationSettings();
                },
              ),
              TextButton(
                child: Text('Retry',
                    style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6))),
                onPressed: () {
                  Navigator.pop(dialogContext); // Use dialogContext
                  ref.read(errorProvider.notifier).clearError();
                  ref.read(locationProvider.notifier).fetchCurrentLocation();
                },
              ),
            ],
          );
        },
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // Listen to location provider for map center and loading state
    final locationState = ref.watch(locationProvider);
    // Listen to user provider for the marker position (the confirmed location)
    final userState = ref.watch(userProvider);
    final error = ref.watch(errorProvider);

    // Use user's location for the marker if available, otherwise default
    final markerLatLng = LatLng(userState.latitude ?? locationState.latitude,
        userState.longitude ?? locationState.longitude);

    // Show location service dialog if needed after the build phase
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (error?.type == ErrorType.locationService) {
        _showLocationServiceDialog();
      }
    });

    return Scaffold(
      backgroundColor: Colors.white, // Use a clean white background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.04),
              // Progress Indicator (Optional) - Can use a step indicator if preferred
              // Center(child: Text("Step 1 of X", style: GoogleFonts.poppins(color: Colors.grey))),

              SizedBox(height: screenSize.height * 0.03),
              Row(
                children: [
                  Icon(
                    Icons.location_on_outlined,
                    color: const Color(0xFF8B5CF6), // Themed icon color
                    size: 32,
                  ),
                  const SizedBox(width: 10),
                  Text(
                    "Where do you live?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.07,
                      fontWeight: FontWeight.bold,
                      color: const Color(0xFF1A1A1A), // Darker text color
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 10),
              Text(
                "Drag the map to set your approximate location. Only your general area will be shown.",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey.shade600,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              Expanded(
                child: locationState.isLoading && !userState.isLocationValid()
                    ? const Center(
                        child: CircularProgressIndicator(
                        color: Color(0xFF8B5CF6),
                      ))
                    : ClipRRect(
                        // Use ClipRRect for rounded corners
                        borderRadius: BorderRadius.circular(15.0),
                        child: FlutterMap(
                          mapController: _mapController,
                          options: MapOptions(
                            initialCenter:
                                markerLatLng, // Start centered on user/default
                            initialZoom: 14.0,
                            onMapReady: _onMapReady,
                            // Update location provider AND user provider on tap/drag end
                            onTap: (tapPosition, latlng) {
                              print(
                                  "[LocationInputScreen] Map Tapped: $latlng");
                              ref
                                  .read(locationProvider.notifier)
                                  .updateLocation(
                                      latlng.latitude, latlng.longitude);
                            },
                            // Optional: Update on position changed (can be laggy)
                            // onPositionChanged: (position, hasGesture) {
                            //   if (hasGesture) {
                            //     final center = position.center;
                            //     if (center != null) {
                            //       ref.read(locationProvider.notifier)
                            //          .updateLocation(center.latitude, center.longitude);
                            //     }
                            //   }
                            // },
                          ),
                          children: [
                            TileLayer(
                              urlTemplate:
                                  'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                              // Use standard OSM tiles
                              userAgentPackageName:
                                  'com.peeple.dating', // Replace with your app's package name
                            ),
                            MarkerLayer(
                              markers: [
                                Marker(
                                  point:
                                      markerLatLng, // Marker follows user's selected location
                                  width: 50, // Slightly larger marker
                                  height: 50,
                                  child: const Icon(
                                    Icons.location_pin, // Use a pin icon
                                    color: Color(0xFF8B5CF6),
                                    size: 50,
                                  ),
                                ),
                              ],
                            ),
                            // Add a button to re-center on fetched location
                            if (locationState.cachedLatitude != null &&
                                locationState.cachedLongitude != null)
                              Positioned(
                                bottom:
                                    80, // Position above the main next button
                                right: 16,
                                child: FloatingActionButton.small(
                                  // Smaller FAB
                                  heroTag: 'recenter_fab', // Unique heroTag
                                  onPressed: () {
                                    print(
                                        "[LocationInputScreen] Recenter button pressed.");
                                    ref
                                        .read(locationProvider.notifier)
                                        .useCachedLocation();
                                    // Move map after state updates
                                    WidgetsBinding.instance
                                        .addPostFrameCallback(
                                            (_) => _moveToCurrentLocation());
                                  },
                                  backgroundColor: const Color(0xFF8B5CF6),
                                  child: Icon(
                                      locationState.isFetching
                                          ? Icons
                                              .location_searching // Indicate fetching
                                          : Icons.my_location,
                                      color: Colors.white),
                                ),
                              ),
                          ],
                        ),
                      ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              // Show error messages from ErrorProvider
              if (error != null &&
                  error.type !=
                      ErrorType
                          .locationService) // Don't show non-service errors here if dialog handles it
                Padding(
                  padding: const EdgeInsets.only(bottom: 8.0),
                  child: Text(
                    error.message,
                    style: GoogleFonts.poppins(color: Colors.redAccent),
                    textAlign: TextAlign.center,
                  ),
                ),
              // Next Button
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding: const EdgeInsets.only(
                      bottom: 16.0), // Add some bottom padding
                  child: FloatingActionButton(
                    heroTag: 'next_fab', // Unique heroTag
                    onPressed: userState
                            .isLocationValid() // Enable only if location is set
                        ? () {
                            print(
                                "[LocationInputScreen] Next button pressed. Navigating to Gender.");
                            Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const GenderSelectionScreen()));
                          }
                        : null, // Disable button if location is not valid
                    backgroundColor: userState.isLocationValid()
                        ? const Color(0xFF8B5CF6)
                        : Colors.grey.shade400,
                    foregroundColor: Colors.white,
                    child: const Icon(Icons.arrow_forward_rounded),
                  ),
                ),
              ),
              SizedBox(
                  height: screenSize.height * 0.02), // Adjust bottom spacing
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    // Avoid potential errors if _mapController wasn't initialized
    // _mapController?.dispose(); // No need to dispose MapController typically
    super.dispose();
  }
}



================================================
File: views/main_navigation_screen.dart
================================================
// File: lib/views/main_navigation_screen.dart
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/providers/user_provider.dart';
// *** ADDED Import ***
import 'package:dtx/views/matches_screen.dart';
// *** END ADDED ***
import 'package:dtx/views/home.dart';
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/who_liked_you_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
// Removed chat_screen import as we now have MatchesScreen

class MainNavigationScreen extends ConsumerStatefulWidget {
  const MainNavigationScreen({super.key});

  @override
  ConsumerState<MainNavigationScreen> createState() =>
      _MainNavigationScreenState();
}

class _MainNavigationScreenState extends ConsumerState<MainNavigationScreen> {
  int _selectedIndex = 0;

  // *** UPDATED Widget List ***
  static const List<Widget> _widgetOptions = <Widget>[
    HomeScreen(),
    WhoLikedYouScreen(),
    MatchesScreen(), // Changed from ChatPlaceholderScreen
    ProfileScreen(),
  ];
  // *** END UPDATE ***

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      print(
          "[MainNavigationScreen] Post-frame callback: Initiating Likes and Profile fetches if needed.");

      // Fetch Likes only if data is empty (initial load)
      final likesState = ref.read(receivedLikesProvider);
      if (likesState.fullProfiles.isEmpty &&
          likesState.otherLikers.isEmpty &&
          !likesState.isLoading) {
        print(
            "[MainNavigationScreen] Likes data is empty, calling fetchLikes.");
        ref.read(receivedLikesProvider.notifier).fetchLikes();
      } else {
        print(
            "[MainNavigationScreen] Likes data already present or loading, skipping fetchLikes call.");
      }

      // Fetch Profile only if data is missing (initial load)
      final userState = ref.read(userProvider);
      if (userState.name == null && !ref.read(userLoadingProvider)) {
        // Also check userLoadingProvider
        print(
            "[MainNavigationScreen] User profile data is empty, calling fetchProfile.");
        ref.read(userProvider.notifier).fetchProfile();
      } else {
        print(
            "[MainNavigationScreen] User profile data already present or loading, skipping fetchProfile call.");
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: IndexedStack(
          // Use IndexedStack to preserve state of tabs
          index: _selectedIndex,
          children: _widgetOptions,
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        // *** UPDATED Items ***
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(
            icon: Icon(Icons.home_outlined),
            activeIcon: Icon(Icons.home_filled),
            label: 'Discover',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.favorite_border_rounded),
            activeIcon: Icon(Icons.favorite_rounded),
            label: 'Likes',
          ),
          BottomNavigationBarItem(
            // Changed icon and label for Matches/Chat
            icon: Icon(Icons.chat_bubble_outline_rounded),
            activeIcon: Icon(Icons.chat_bubble_rounded),
            label: 'Matches', // Changed label
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person_outline_rounded),
            activeIcon: Icon(Icons.person_rounded),
            label: 'Profile',
          ),
        ],
        // *** END UPDATE ***
        currentIndex: _selectedIndex,
        selectedItemColor: const Color(0xFF8B5CF6),
        unselectedItemColor: Colors.grey[600],
        onTap: _onItemTapped,
        type: BottomNavigationBarType.fixed, // Keep labels visible
        showUnselectedLabels: true,
        backgroundColor: Colors.white,
        elevation: 5.0,
        selectedLabelStyle:
            GoogleFonts.poppins(fontSize: 12, fontWeight: FontWeight.w500),
        unselectedLabelStyle: GoogleFonts.poppins(fontSize: 12),
      ),
    );
  }
}



================================================
File: views/matches_screen.dart
================================================
// lib/views/matches_screen.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/user_model.dart'; // Using UserModel as MatchUser
import 'package:dtx/providers/matches_provider.dart';
import 'package:dtx/views/chat_detail_screen.dart'; // Import ChatDetailScreen
import 'package:dtx/widgets/match_list_tile.dart'; // Import MatchListTile
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class MatchesScreen extends ConsumerStatefulWidget {
  const MatchesScreen({super.key});

  @override
  ConsumerState<MatchesScreen> createState() => _MatchesScreenState();
}

class _MatchesScreenState extends ConsumerState<MatchesScreen> {
  @override
  void initState() {
    super.initState();
    // Fetch matches when the screen loads if not already loaded
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final state = ref.read(matchesProvider);
      if (state.matches.isEmpty && !state.isLoading) {
        print("[MatchesScreen] Initial fetch trigger."); // Log fetch trigger
        ref.read(matchesProvider.notifier).fetchMatches();
      }
    });
  }

  Future<void> _refreshMatches() async {
    print("[MatchesScreen] Refreshing matches."); // Log refresh action
    await ref.read(matchesProvider.notifier).fetchMatches(forceRefresh: true);
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(matchesProvider);

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text('Matches & Chats',
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 1,
        automaticallyImplyLeading: false, // No back button in a tab screen
      ),
      body: RefreshIndicator(
        onRefresh: _refreshMatches,
        color: const Color(0xFF8B5CF6),
        child: _buildBody(state),
      ),
    );
  }

  Widget _buildBody(MatchesState state) {
    if (state.isLoading && state.matches.isEmpty) {
      return const Center(
          child: CircularProgressIndicator(color: Color(0xFF8B5CF6)));
    }

    if (state.error != null && state.matches.isEmpty) {
      return _buildErrorState(state.error!);
    }

    if (state.matches.isEmpty) {
      return _buildEmptyState();
    }

    return ListView.separated(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      itemCount: state.matches.length,
      itemBuilder: (context, index) {
        final match = state.matches[index];
        return MatchListTile(
          matchUser: match,
          onTap: () {
            // *** ADD LOGGING HERE ***
            print(
                "[MatchesScreen onTap] Attempting to navigate to chat for match. User ID: ${match.id}, Name: ${match.name}, Avatar: ${match.firstMediaUrl}");
            // *** END LOGGING ***

            if (match.id == null || match.id == 0) {
              // Added check for 0 ID as well
              print(
                  "[MatchesScreen onTap] ERROR: Invalid User ID detected (${match.id}). Cannot navigate.");
              ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                  content: Text("Cannot open chat: Invalid user ID.")));
              return;
            }
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => ChatDetailScreen(
                  matchUserId: match.id!,
                  matchName: match.name ??
                      'Match', // Default to 'Match' if name is still null after parsing
                  matchAvatarUrl: match.firstMediaUrl,
                ),
              ),
            );
          },
        );
      },
      separatorBuilder: (context, index) => Divider(
        height: 1,
        thickness: 1,
        indent: 80, // Indent divider to align past avatar
        color: Colors.grey[200],
      ),
    );
  }

  Widget _buildEmptyState() {
    // (Keep previous implementation)
    return LayoutBuilder(
      builder: (context, constraints) => SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(30.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.chat_bubble_outline_rounded,
                      size: 70, color: Colors.grey[300]),
                  const SizedBox(height: 20),
                  Text("No Matches Yet",
                      style: GoogleFonts.poppins(
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey[700])),
                  const SizedBox(height: 10),
                  Text("Start liking profiles to find your matches!",
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                          fontSize: 15, color: Colors.grey[500])),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildErrorState(AppError error) {
    // (Keep previous implementation)
    return LayoutBuilder(
      builder: (context, constraints) => SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(30.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline_rounded,
                      size: 60, color: Colors.redAccent[100]),
                  const SizedBox(height: 20),
                  Text(
                    "Oops! Couldn't load matches",
                    style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.grey[700]),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 10),
                  Text(
                    error.message,
                    style: GoogleFonts.poppins(
                        fontSize: 14, color: Colors.grey[600]),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 20),
                  ElevatedButton.icon(
                    icon: const Icon(Icons.refresh_rounded, size: 18),
                    label: const Text("Retry"),
                    style: ElevatedButton.styleFrom(
                      foregroundColor: Colors.white,
                      backgroundColor: const Color(0xFF8B5CF6),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(20)),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 30, vertical: 12),
                    ),
                    onPressed: _refreshMatches,
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/media.dart
================================================
// File: lib/views/media.dart
import 'dart:io';
import 'dart:typed_data'; // Keep if thumbnail generation is used (not shown, but possible)
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/prompt.dart'; // Keep for onboarding flow
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:reorderable_grid_view/reorderable_grid_view.dart';
import 'package:dotted_border/dotted_border.dart';
import 'package:path/path.dart' as p; // Use prefix for path
import 'package:mime/mime.dart'; // Use mime package

import '../models/error_model.dart';
import '../models/media_upload_model.dart'; // Import MediaUploadModel

class MediaPickerScreen extends ConsumerStatefulWidget {
  final bool isEditing;

  const MediaPickerScreen({
    super.key,
    this.isEditing = false,
  });

  @override
  ConsumerState<MediaPickerScreen> createState() => _MediaPickerState();
}

class _MediaPickerState extends ConsumerState<MediaPickerScreen> {
  // Holds String URLs for existing media, MediaUploadModel for new/local files, or null for empty slots.
  List<dynamic> _displayItems = List.filled(6, null);
  bool _isInitialized = false; // Track initialization

  // Keep allowed types
  final Set<String> _allowedImageMime = {
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/jpg'
  };
  final Set<String> _allowedVideoMime = {
    'video/mp4',
    'video/quicktime',
    'video/x-msvideo',
    'video/mpeg',
    'video/3gpp',
    'video/mp2t'
  };
  final Set<String> _allowedImageExtensions = {
    'jpg',
    'jpeg',
    'png',
    'gif',
    'webp',
    'bmp',
    'tiff'
  };
  final Set<String> _allowedVideoExtensions = {
    'mp4',
    'mov',
    'avi',
    'mpeg',
    'mpg',
    '3gp',
    'ts',
    'mkv'
  };

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) => _initializeMedia());
  }

  // *** --- START FIX: Modified Initialization Logic --- ***
  void _initializeMedia() {
    if (_isInitialized && !widget.isEditing)
      return; // Prevent re-init on onboarding if already done
    // Allow re-initialization if entering edit mode again
    print(
        "[MediaPickerScreen] Initializing Media (isEditing: ${widget.isEditing})...");

    final mediaUploadNotifier = ref.read(mediaUploadProvider.notifier);
    final currentUser = ref.read(userProvider);

    // Clear the mediaUploadProvider state ONLY when entering the screen.
    // It tracks *unsaved* local file selections made during THIS session.
    mediaUploadNotifier.state = List.filled(6, null);
    print("[MediaPickerScreen] Cleared mediaUploadProvider state.");

    List<dynamic> tempDisplayItems =
        List.filled(6, null); // Use local temp list

    // Populate based on current user state (URLs or local paths from previous edits)
    final currentIdentifiers = currentUser.mediaUrls ?? [];
    print(
        "[MediaPickerScreen] Populating from userProvider identifiers: $currentIdentifiers");

    for (int i = 0; i < currentIdentifiers.length && i < 6; i++) {
      final identifier = currentIdentifiers[i];
      if (identifier.isNotEmpty) {
        // 1. Check if it's an HTTP URL
        if (identifier.startsWith('http')) {
          tempDisplayItems[i] = identifier; // Store the URL string
          print("  - Slot $i: Existing URL: $identifier");
        }
        // 2. Check if it's a potentially valid local file path
        else if (identifier.contains('/') || identifier.contains('\\')) {
          try {
            final file = File(identifier);
            // IMPORTANT: We cannot call file.exists() synchronously here.
            // Assume if it's a path stored previously, it *was* valid.
            // We'll create a MediaUploadModel optimistically. If the file is
            // deleted later, the UI build (_buildMediaPlaceholder) will handle the error.

            final fileName = p.basename(file.path);
            final mimeType = lookupMimeType(file.path) ??
                'application/octet-stream'; // Default MIME

            tempDisplayItems[i] = MediaUploadModel(
                file: file,
                fileName: fileName,
                fileType: mimeType,
                status: UploadStatus.idle // Local files are initially idle
                );
            print(
                "  - Slot $i: Local File Path (from previous edit): $identifier");
          } catch (e) {
            print(
                "  - Slot $i: Error processing potential path '$identifier': $e. Treating as empty.");
            tempDisplayItems[i] = null;
          }
        }
        // 3. Otherwise, treat as invalid/empty
        else {
          print(
              "  - Slot $i: Invalid identifier '$identifier'. Treating as empty.");
          tempDisplayItems[i] = null;
        }
      }
    }

    // Update local state for UI building
    setState(() {
      _displayItems = tempDisplayItems; // Use the populated temp list
      _isInitialized = true;
      _updateForwardButtonState(); // Update button based on initial state
    });
    print(
        "[MediaPickerScreen] Initialization complete. Display Items: ${_displayItems.map((item) {
      if (item is MediaUploadModel) return "File: ${item.fileName}";
      if (item is String)
        return "URL: ${item.substring(item.length - 10)}"; // Show end of URL
      return 'null';
    }).toList()}");
  }
  // *** --- END FIX --- ***

  @override
  void dispose() {
    super.dispose();
  }

  // *** --- START FIX: Modified _pickMedia --- ***
  Future<void> _pickMedia(int index) async {
    ref.read(errorProvider.notifier).clearError();
    final ImagePicker picker = ImagePicker();
    final XFile? media = await picker.pickMedia();

    if (media != null) {
      final mimeType = media.mimeType?.toLowerCase();
      final fileName = p.basename(media.path);
      final extension =
          p.extension(media.path).toLowerCase().replaceAll('.', '');
      final filePath = media.path.replaceFirst('file://', '');
      final file = File(filePath);

      // Validation...
      final isValidImage = _allowedImageMime.contains(mimeType) ||
          _allowedImageExtensions.contains(extension);
      final isValidVideo = _allowedVideoMime.contains(mimeType) ||
          _allowedVideoExtensions.contains(extension);
      final fileSize = await file.length();
      final isImage = isValidImage;
      final isVideo = isValidVideo;

      if (isImage && fileSize > 10 * 1024 * 1024) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Image is too large. Maximum size is 10 MB."));
        // Don't clear slot here, let validation prevent update below
        return;
      }
      if (isVideo && fileSize > 50 * 1024 * 1024) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Video is too large. Maximum size is 50 MB."));
        return;
      }
      // --- End Basic Validation ---

      // --- First Item Image Validation (using temp state) ---
      final tempDisplayItems = List.from(_displayItems);
      final potentialNewModel = MediaUploadModel(
          file: file,
          fileName: fileName,
          fileType: mimeType ?? (isVideo ? 'video/mp4' : 'image/jpeg'));
      tempDisplayItems[index] =
          potentialNewModel; // Simulate adding the new file

      final firstItem = tempDisplayItems[0];
      bool firstIsImage = false;
      if (firstItem is MediaUploadModel) {
        firstIsImage = firstItem.fileType.startsWith('image/');
      } else if (firstItem is String) {
        final lowerUrl = firstItem.toLowerCase();
        firstIsImage = [
          '.jpg',
          '.jpeg',
          '.png',
          '.gif',
          '.webp',
          '.bmp',
          '.tiff'
        ].any((ext) => lowerUrl.endsWith(ext));
      }

      if (index == 0 && !firstIsImage) {
        await _showErrorDialog(context, isMainImage: true);
        return; // Prevent update if first item isn't image
      }
      // --- End First Item Validation ---

      if (!isValidImage && !isValidVideo) {
        await _showErrorDialog(context);
        return;
      }
      // --- End Format Validation ---

      // If all validations pass, create the final model
      final newModel = MediaUploadModel(
          file: file,
          fileName: fileName,
          fileType: mimeType ??
              (isVideo ? 'video/mp4' : 'image/jpeg'), // Provide fallback MIME
          status: UploadStatus.idle // Initial status
          );

      // Update provider state (only holds NEW files selected in *this* session)
      // Need to copy current provider state and update the specific index
      final currentProviderState =
          List<MediaUploadModel?>.from(ref.read(mediaUploadProvider));
      currentProviderState[index] = newModel;
      ref.read(mediaUploadProvider.notifier).state = currentProviderState;
      print(
          "[MediaPickerScreen] Updated mediaUploadProvider at index $index with ${newModel.fileName}");

      // Update local display state for UI
      setState(() {
        _displayItems[index] = newModel; // Update the display list directly
        _updateForwardButtonState();
      });
      // Signal change if editing
      if (widget.isEditing) {
        ref.read(userProvider.notifier).setMediaChangedFlag(true);
      }
    }
  }
  // *** --- END FIX --- ***

  // *** --- START FIX: Modified _clearSlot --- ***
  void _clearSlot(int index) {
    // Count selected based on the local display list
    final currentCount = _displayItems.where((item) => item != null).length;

    // --- Minimum Items Validation ---
    // Check if clearing this slot would result in less than 3 items
    bool wouldBeLessThanMin =
        (_displayItems[index] != null && currentCount <= 3);
    if (wouldBeLessThanMin) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Minimum of 3 media items required."));
      return;
    }
    // --- End Minimum Items Validation ---

    // --- First Item Image Validation ---
    // Simulate state after clearing to check if first item is still valid
    final tempDisplayItems = List.from(_displayItems);
    tempDisplayItems[index] = null; // Simulate removal

    final firstItemAfterClear = tempDisplayItems[0];
    bool firstIsImageAfterClear = false;
    if (firstItemAfterClear is MediaUploadModel) {
      firstIsImageAfterClear =
          firstItemAfterClear.fileType.startsWith('image/');
    } else if (firstItemAfterClear is String) {
      final lowerUrl = firstItemAfterClear.toLowerCase();
      firstIsImageAfterClear = [
        '.jpg',
        '.jpeg',
        '.png',
        '.gif',
        '.webp',
        '.bmp',
        '.tiff'
      ].any((ext) => lowerUrl.endsWith(ext));
    }

    // If clearing the first item AND there are other items left,
    // but the new first item isn't an image, prevent clearing.
    if (index == 0 && currentCount > 1 && !firstIsImageAfterClear) {
      ref.read(errorProvider.notifier).setError(AppError.validation(
          "Cannot remove the main photo if the next item is not a photo. Reorder first."));
      return;
    }
    // --- End First Item Validation ---

    // --- If validations pass, proceed with clearing ---
    ref.read(errorProvider.notifier).clearError(); // Clear any previous error

    // Check if the item being cleared was a NEWLY added local file in this session
    final itemToClear = _displayItems[index];
    if (itemToClear is MediaUploadModel) {
      // If it was a local file selected in THIS session, remove it from the mediaUploadProvider
      final currentProviderState =
          List<MediaUploadModel?>.from(ref.read(mediaUploadProvider));
      if (index < currentProviderState.length) {
        // Safety check
        currentProviderState[index] = null; // Clear slot in provider state
        ref.read(mediaUploadProvider.notifier).state = currentProviderState;
        print(
            "[MediaPickerScreen] Cleared slot $index in mediaUploadProvider.");
      }
    } else {
      print(
          "[MediaPickerScreen] Cleared slot $index which contained an existing URL or was empty.");
    }

    // Update local state for UI
    setState(() {
      _displayItems[index] = null; // Clear the local display slot
      _updateForwardButtonState();
    });
    // Signal change if editing
    if (widget.isEditing) {
      ref.read(userProvider.notifier).setMediaChangedFlag(true);
    }
  }
  // *** --- END FIX --- ***

  Future<void> _showErrorDialog(BuildContext context,
      {bool isMainImage = false}) async {
    // (Keep as is)
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(isMainImage ? 'Invalid Main Image' : 'Invalid File Type'),
        content: Text(isMainImage
            ? 'Main image must be an image file.\nAllowed formats: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF'
            : 'Allowed formats:\n• Images: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF\n• Videos: MP4, MOV, AVI, MPEG, 3GP, TS, MKV'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  // *** --- START FIX: Modified _reorderMedia --- ***
  void _reorderMedia(int oldGridIndex, int newGridIndex) {
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors

    // Create a mutable copy of the local display list
    List<dynamic> reorderedDisplayItems = List.from(_displayItems);
    final item = reorderedDisplayItems.removeAt(oldGridIndex);
    reorderedDisplayItems.insert(newGridIndex, item);

    // --- VALIDATION: Ensure first slot is an image AFTER reorder ---
    final firstItem = reorderedDisplayItems[0];
    bool firstIsImage = false;
    if (firstItem is MediaUploadModel) {
      firstIsImage = firstItem.fileType.startsWith('image/');
    } else if (firstItem is String) {
      final lowerUrl = firstItem.toLowerCase();
      firstIsImage = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff']
          .any((ext) => lowerUrl.endsWith(ext));
    }

    if (firstItem == null || !firstIsImage) {
      // Also check if first item is null
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("The first item must be a photo."));
      // Do NOT update state if invalid
      return;
    }
    // --- End Validation ---

    // Update local state for UI
    setState(() {
      _displayItems = reorderedDisplayItems;
      _updateForwardButtonState();
    });

    // --- Update mediaUploadProvider state ---
    // Reconstruct the provider state to match the new order,
    // containing only the MediaUploadModels (representing NEW files).
    List<MediaUploadModel?> newProviderState = List.filled(6, null);
    for (int i = 0; i < reorderedDisplayItems.length; i++) {
      if (reorderedDisplayItems[i] is MediaUploadModel) {
        newProviderState[i] = reorderedDisplayItems[i] as MediaUploadModel;
      }
    }
    ref.read(mediaUploadProvider.notifier).state = newProviderState;
    print("[MediaPickerScreen] Reordered. Updated mediaUploadProvider state.");
    // --- End Provider State Update ---

    // Signal change if editing
    if (widget.isEditing) {
      ref.read(userProvider.notifier).setMediaChangedFlag(true);
    }
  }
  // *** --- END FIX --- ***

  // Count selected based on local display list
  int _countSelectedMedia() {
    return _displayItems.where((item) => item != null).length;
  }

  // Update button state based on local display list
  void _updateForwardButtonState() {
    // No need to call setState here as this is called within setState blocks elsewhere
    // Logic to determine button state is moved to the build method.
  }

  // *** --- START FIX: Modified _handleDone --- ***
  void _handleDone() {
    final currentCount = _countSelectedMedia(); // Use local count
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();

    // Validate minimum items
    if (currentCount < 3) {
      errorNotifier
          .setError(AppError.validation("Minimum 3 media items required."));
      return;
    }

    // Validate first item is image (check local display list)
    final firstItem = _displayItems[0];
    bool firstIsImage = false;
    if (firstItem is MediaUploadModel) {
      firstIsImage = firstItem.fileType.startsWith('image/');
    } else if (firstItem is String) {
      final lowerUrl = firstItem.toLowerCase();
      firstIsImage = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff']
          .any((ext) => lowerUrl.endsWith(ext));
    }

    if (firstItem == null || !firstIsImage) {
      // Check for null as well
      errorNotifier
          .setError(AppError.validation("The first item must be a photo."));
      return;
    }

    // If editing, update user provider state with local file paths/URLs
    if (widget.isEditing) {
      List<String> identifiers = [];
      for (final item in _displayItems) {
        // Iterate through local display list
        if (item is MediaUploadModel) {
          identifiers.add(item.file.path); // Add local path
        } else if (item is String) {
          identifiers.add(item); // Add existing URL
        }
        // Null items are skipped, resulting in potentially fewer than 6 items in the final list
      }

      // Update user provider with the final list of identifiers
      ref.read(userProvider.notifier).updateMediaUrls(identifiers);
      // If any local file was picked/reordered/cleared, this flag should be true
      ref
          .read(userProvider.notifier)
          .setMediaChangedFlag(true); // Ensure flag is set if changes were made
      print(
          "[MediaPickerScreen Edit] Updated userProvider state with identifiers: $identifiers. Popping back.");
      Navigator.of(context).pop();
    } else {
      // --- ONBOARDING Flow ---
      // Provider state (mediaUploadProvider) already holds the MediaUploadModels.
      // No further action needed here before navigation.
      print(
          "[MediaPickerScreen Onboarding] Files ready in provider. Navigating to Prompts.");
      Navigator.pushReplacement(
          context,
          MaterialPageRoute(
              builder: (context) => const ProfileAnswersScreen()));
      // --- End ONBOARDING Flow ---
    }
  }
  // *** --- END FIX --- ***

  @override
  Widget build(BuildContext context) {
    // Watch provider only for errors, maybe? Grid uses local state.
    // final providerState = ref.watch(mediaUploadProvider); // Less relevant now
    final errorState = ref.watch(errorProvider);
    final screenSize = MediaQuery.of(context).size;

    // Calculate enabled state within build using local list
    final int selectedCount = _countSelectedMedia();
    bool firstIsImage = true;
    final firstItem = _displayItems[0]; // Check local list
    if (firstItem is MediaUploadModel) {
      firstIsImage = firstItem.fileType.startsWith('image/');
    } else if (firstItem is String) {
      final lowerUrl = firstItem.toLowerCase();
      firstIsImage = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff']
          .any((ext) => lowerUrl.endsWith(ext));
    } else {
      firstIsImage = false; // Cannot proceed if first slot is null
    }

    final bool isForwardButtonEnabled = selectedCount >= 3 && firstIsImage;

    // Show loading if not initialized yet
    if (!_isInitialized) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }

    return Scaffold(
      backgroundColor: const Color(0xFFFAFAFA), // Lighter background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Header (keep as is) ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: Icon(Icons.photo_library_rounded,
                            color: const Color(0xFF8B5CF6), size: 30),
                      ),
                    Text(
                      widget.isEditing ? "Edit Media" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: isForwardButtonEnabled ? _handleDone : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: isForwardButtonEnabled
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---
              SizedBox(height: screenSize.height * 0.02),
              Text(
                widget.isEditing
                    ? "Manage Your Gallery"
                    : "Create Your Gallery",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.07
                      : screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  letterSpacing: -0.5,
                ),
              ),
              Text(
                widget.isEditing
                    ? "Add, remove, or reorder photos/videos (min 3)"
                    : "Select at least 3 photos or videos",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey[600],
                  fontWeight: FontWeight.w500,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(20),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  padding: const EdgeInsets.all(16),
                  child: ReorderableGridView.count(
                    crossAxisCount: 2,
                    mainAxisSpacing: 16,
                    crossAxisSpacing: 16,
                    childAspectRatio: 0.95, // Adjust aspect ratio if needed
                    shrinkWrap: true,
                    physics: const BouncingScrollPhysics(),
                    // *** FIX: Use _displayItems.length ***
                    children: List.generate(_displayItems.length,
                        (index) => _buildMediaPlaceholder(index)),
                    onReorder: _reorderMedia,
                  ),
                ),
              ),
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 8.0),
                  child: Center(
                    child: Text(
                      errorState.message,
                      style:
                          GoogleFonts.poppins(color: Colors.red, fontSize: 14),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
              // --- Bottom Bar (keep as is) ---
              if (!widget.isEditing)
                Container(
                  padding: EdgeInsets.symmetric(
                    vertical: screenSize.height * 0.02,
                    horizontal: screenSize.width * 0.04,
                  ),
                  margin:
                      const EdgeInsets.only(top: 10), // Add margin if needed
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(16),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, -4),
                      ),
                    ],
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "${selectedCount}/6 Selected",
                            style: GoogleFonts.poppins(
                              fontSize: screenSize.width * 0.04,
                              fontWeight: FontWeight.w600,
                              color: const Color(0xFF8B5CF6),
                            ),
                          ),
                          Text(
                            "Minimum 3 required",
                            style: GoogleFonts.poppins(
                              fontSize: screenSize.width * 0.035,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                      GestureDetector(
                        onTap: isForwardButtonEnabled
                            ? _handleDone
                            : null, // Use calculated state
                        child: AnimatedContainer(
                          duration: const Duration(milliseconds: 200),
                          width: 60,
                          height: 60,
                          decoration: BoxDecoration(
                            color: isForwardButtonEnabled
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey[300],
                            borderRadius: BorderRadius.circular(30),
                            boxShadow: isForwardButtonEnabled
                                ? [
                                    BoxShadow(
                                      color: const Color(0xFF8B5CF6)
                                          .withOpacity(0.3),
                                      blurRadius: 8,
                                      offset: const Offset(0, 4),
                                    ),
                                  ]
                                : null,
                          ),
                          child: Icon(
                            Icons.arrow_forward_rounded,
                            color: isForwardButtonEnabled
                                ? Colors.white
                                : Colors.grey[500],
                            size: 28,
                          ),
                        ),
                      )
                    ],
                  ),
                ),
              // --- End Hide Bottom Bar ---
              SizedBox(
                  height: widget.isEditing
                      ? 16
                      : screenSize.height * 0.02), // Adjusted bottom padding
            ],
          ),
        ),
      ),
    );
  }

  // *** --- START FIX: Modified _buildMediaPlaceholder --- ***
  Widget _buildMediaPlaceholder(int index) {
    final item = _displayItems[index]; // Read from local display list
    final key = ValueKey(item is String
        ? item
        : (item as MediaUploadModel?)?.file.path ?? 'empty_$index');

    bool isVideo = false;
    bool isImage = false;
    Widget imageWidget = Container(); // Default empty

    if (item is MediaUploadModel) {
      final file = item.file;
      final mimeType = item.fileType;
      isImage = mimeType.startsWith('image/');
      isVideo = mimeType.startsWith('video/');
      if (isImage) {
        imageWidget = Image.file(file, fit: BoxFit.cover,
            errorBuilder: (_, error, stack) {
          print("Error loading local file ${file.path}: $error");
          return const Icon(Icons.broken_image);
        });
      } else if (isVideo) {
        imageWidget = Container(
            color: Colors.grey[300],
            child: const Center(
                child: Icon(Icons.videocam_outlined,
                    color: Colors.grey, size: 40)));
      }
    } else if (item is String && item.startsWith('http')) {
      final lowerUrl = item.toLowerCase();
      isImage = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff']
          .any((ext) => lowerUrl.endsWith(ext));
      isVideo = ['.mp4', '.mov', '.avi', '.mpeg', '.mpg', '.3gp', '.ts', '.mkv']
          .any((ext) => lowerUrl.endsWith(ext));
      if (isImage) {
        imageWidget = Image.network(item,
            fit: BoxFit.cover,
            loadingBuilder: (ctx, child, prog) => prog == null
                ? child
                : Center(
                    child: CircularProgressIndicator(
                        value: prog.expectedTotalBytes != null
                            ? prog.cumulativeBytesLoaded /
                                prog.expectedTotalBytes!
                            : null,
                        color: Colors.grey[400])),
            errorBuilder: (ctx, err, st) {
              print("Error loading network image $item: $err");
              return Center(
                  child: Icon(Icons.image_not_supported_outlined,
                      color: Colors.grey[400], size: 40));
            });
      } else if (isVideo) {
        imageWidget = Container(
            color: Colors.grey[300],
            child: const Center(
                child: Icon(Icons.videocam_outlined,
                    color: Colors.grey, size: 40)));
      }
    }

    return GestureDetector(
      key: key, // Use the generated key
      onTap: () => _pickMedia(index),
      child: DottedBorder(
        dashPattern: const [6, 3],
        color: index == 0
            ? const Color(0xFF8B5CF6)
            : const Color(0xFF8B5CF6).withOpacity(0.6),
        strokeWidth: 2,
        borderType: BorderType.RRect,
        radius: const Radius.circular(16),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (item != null) // Show image/video placeholder if item exists
                ClipRRect(
                    borderRadius: BorderRadius.circular(16),
                    child: imageWidget),

              if (item == null) // Show Add icon if slot is empty
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        index == 0
                            ? Icons.add_photo_alternate_rounded
                            : Icons.add_rounded,
                        color: const Color(0xFF8B5CF6).withOpacity(0.6),
                        size: 36,
                      ),
                      if (index == 0)
                        Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: Text("Main Photo",
                              style: GoogleFonts.poppins(fontSize: 14)),
                        ),
                    ],
                  ),
                ),
              if (isVideo) // Show video overlay if it's a video
                const Center(
                  child: Icon(Icons.play_circle_fill_rounded,
                      color: Colors.white70, size: 48),
                ),
              // Show remove button if item exists (local or remote)
              if (item != null)
                Positioned(
                  top: 4,
                  right: 4,
                  child: GestureDetector(
                    onTap: () => _clearSlot(index),
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.6),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(Icons.close_rounded,
                          color: Colors.white, size: 16),
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
  // *** --- END FIX --- ***
}

enum MediaType { image, video }



================================================
File: views/name.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/dob.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class NameInputScreen extends ConsumerStatefulWidget {
  const NameInputScreen({super.key});

  @override
  ConsumerState<NameInputScreen> createState() => _NameInputScreenState();
}

class _NameInputScreenState extends ConsumerState<NameInputScreen> {
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;

  @override
  void initState() {
    super.initState();
    final user = ref.read(userProvider);
    _firstNameController = TextEditingController(text: user.name);
    _lastNameController = TextEditingController(text: user.lastName ?? '');
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      child: const Icon(
                        Icons.badge_outlined,
                        size: 28,
                        color: Colors.white,
                      ),
                    ),
                    const SizedBox(width: 10),
                    Text(
                      "What's your name?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width * 0.06,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.04),
                _buildFirstNameInput(error, screenSize),
                SizedBox(height: screenSize.height * 0.03),
                _buildLastNameInput(screenSize),
                const Spacer(),
                _buildNextButton(screenSize, error),
                SizedBox(height: screenSize.height * 0.04),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFirstNameInput(AppError? error, Size screenSize) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          decoration: BoxDecoration(
            border: Border(
              bottom: BorderSide(
                color: error?.type == ErrorType.validation
                    ? Colors.red
                    : Colors.white54,
                width: 1.5,
              ),
            ),
          ),
          child: TextField(
            controller: _firstNameController,
            style: GoogleFonts.poppins(
              fontSize: screenSize.width * 0.05,
              fontWeight: FontWeight.w500,
              color: Colors.white,
            ),
            cursorColor: Colors.white,
            decoration: InputDecoration(
              labelText: "First name (required)",
              labelStyle: GoogleFonts.poppins(
                fontSize: screenSize.width * 0.042,
                color: Colors.white54,
              ),
              border: InputBorder.none,
            ),
            onChanged: (value) => _updateName(value, _lastNameController.text),
          ),
        ),
        if (error?.type == ErrorType.validation)
          Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Text(
              error!.message,
              style: GoogleFonts.poppins(
                color: Colors.redAccent,
                fontSize: screenSize.width * 0.035,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildLastNameInput(Size screenSize) {
    return TextField(
      controller: _lastNameController,
      style: GoogleFonts.poppins(
        fontSize: screenSize.width * 0.05,
        fontWeight: FontWeight.w500,
        color: Colors.white,
      ),
      cursorColor: Colors.white,
      decoration: InputDecoration(
        labelText: "Last name (optional)",
        labelStyle: GoogleFonts.poppins(
          fontSize: screenSize.width * 0.042,
          color: Colors.white54,
        ),
        enabledBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white54, width: 1.5),
        ),
        focusedBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white, width: 2.0),
        ),
      ),
      onChanged: (value) => _updateName(_firstNameController.text, value),
    );
  }

  Widget _buildNextButton(Size screenSize, AppError? error) {
    final isValid = ref.read(userProvider.notifier).isNameValid();

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: error == null && isValid
            ? () => _handleNextButton()
            : null, // Disable button if there are errors
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: error != null || !isValid
              ? Colors.grey.shade400 // Disable button if there are errors
              : Colors.white,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: EdgeInsets.all(16), // Adjusted padding
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24, // Adjusted icon size
          color: error != null || !isValid
              ? Colors.white54 // Change icon color when disabled
              : const Color(0xFF8B5CF6),
        ),
      ),
    );
  }

  void _updateName(String firstName, String lastName) {
    ref.read(userProvider.notifier).updateName(firstName, lastName);
  }

  void _handleNextButton() {
    ref.read(errorProvider.notifier).clearError();
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DateOfBirthScreen()),
    );
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    super.dispose();
  }
}



================================================
File: views/profile_screens.dart
================================================
import 'dart:math';
import 'dart:io';

// Keep necessary imports...
import 'package:dtx/models/media_upload_model.dart';
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/dating_intentions.dart';
import 'package:dtx/views/drinking.dart';
import 'package:dtx/views/height.dart';
import 'package:dtx/views/hometown.dart';
import 'package:dtx/views/job.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/prompt.dart';
import 'package:dtx/views/religion.dart';
import 'package:dtx/views/smoking.dart';
import 'package:dtx/views/study.dart';
import 'package:dtx/views/textpromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:audioplayers/audioplayers.dart'; // Keep for local player
import 'package:path/path.dart' as path; // Import path package
import 'package:mime/mime.dart'; // Import mime package

import 'package:dtx/models/user_model.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/settings_screen.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/service_provider.dart'; // Keep
import 'package:dtx/providers/media_upload_provider.dart'; // Keep
import 'package:dtx/services/api_service.dart'; // Keep
// Import audio player provider for audio playback UI state (Global player, not local)
// Keep import if global player UI is needed elsewhere, but playback uses local _audioPlayer
import 'package:dtx/providers/audio_player_provider.dart';
// Import MediaRepository provider
import 'package:dtx/repositories/media_repository.dart'; // Import MediaRepository

class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  // Retain state for Audio Player, Edit Mode, Saving, Original Data
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isPlaying = false;
  String? _currentAudioUrl;
  bool _isEditing = false;
  bool _isSaving = false;
  UserModel? _originalProfileData; // To store data before editing starts

  @override
  void initState() {
    super.initState();
    // Fetch profile if needed (e.g., if user lands directly here after login)
    // Moved fetching logic primarily to MainNavigationScreen
    _setupLocalAudioPlayerListeners();
  }

  void _setupLocalAudioPlayerListeners() {
    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted) {
        setState(() {
          _isPlaying = state == PlayerState.playing;
          if (state == PlayerState.stopped || state == PlayerState.completed) {
            _currentAudioUrl = null;
          }
        });
      }
    });
    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) {
        setState(() {
          _isPlaying = false;
          _currentAudioUrl = null;
        });
      }
    });
  }

  @override
  void dispose() {
    try {
      if (_audioPlayer.state == PlayerState.playing ||
          _audioPlayer.state == PlayerState.paused) {
        _audioPlayer.stop();
      }
      _audioPlayer.release();
      _audioPlayer.dispose();
    } catch (e) {
      print("Error releasing/disposing local audio player: $e");
    }
    super.dispose();
  }

  // --- Local Audio Control --- (Keep as is)
  Future<void> _playOrPauseAudio(String audioUrl) async {
    if (!mounted) return;
    try {
      final currentState = _audioPlayer.state;
      if (currentState == PlayerState.playing && _currentAudioUrl == audioUrl) {
        await _audioPlayer.pause();
      } else if (currentState == PlayerState.paused &&
          _currentAudioUrl == audioUrl) {
        await _audioPlayer.resume();
      } else {
        if (currentState == PlayerState.playing ||
            currentState == PlayerState.paused) {
          await _audioPlayer.stop();
        }
        await _audioPlayer.setSource(UrlSource(audioUrl));
        await _audioPlayer.resume();
        if (mounted) setState(() => _currentAudioUrl = audioUrl);
      }
    } catch (e) {
      print("Error playing/pausing audio: $e");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error playing audio: ${e.toString()}')));
        setState(() {
          _isPlaying = false;
          _currentAudioUrl = null;
        });
      }
    }
  }

  // --- Edit Mode Handlers (_enterEditMode, _cancelEditMode) ---
  void _enterEditMode() {
    _originalProfileData = ref.read(userProvider); // Store original state
    ref.read(userProvider.notifier).setMediaChangedFlag(false); // Reset flag
    setState(() => _isEditing = true);
  }

  void _cancelEditMode() {
    if (_originalProfileData != null) {
      // Restore state ONLY if media hasn't changed during the edit process
      // If media DID change, it's complex to revert provider state easily,
      // so we might just refetch or accept the userProvider's current state.
      // For simplicity, let's just refetch if media changed.
      if (!ref.read(userProvider).mediaChangedDuringEdit) {
        print("[ProfileScreen] Cancelling edit, restoring original data.");
        ref.read(userProvider.notifier).state = _originalProfileData!;
      } else {
        print("[ProfileScreen] Cancelling edit, media changed, refetching.");
        // Optionally clear the flag before refetching
        ref.read(userProvider.notifier).setMediaChangedFlag(false);
        ref.read(userProvider.notifier).fetchProfile();
      }
    } else {
      print("[ProfileScreen] Cancelling edit, no original data, refetching.");
      ref
          .read(userProvider.notifier)
          .fetchProfile(); // Refetch if original is missing
    }
    ref.read(errorProvider.notifier).clearError(); // Clear any edit errors
    setState(() => _isEditing = false);
  }

  // --- *** UPDATED Save Handler *** ---
  Future<void> _handleSave() async {
    print("[ProfileScreen _handleSave] Starting Save Process...");
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();
    if (!mounted) return;
    setState(() => _isSaving = true); // Show loading indicator

    final userState = ref.read(userProvider);
    final userNotifier = ref.read(userProvider.notifier);
    final mediaRepo = ref.read(mediaRepositoryProvider);
    final userRepo = ref.read(userRepositoryProvider);

    // Use original data for comparison if available, else current state
    final initialMediaUrls =
        _originalProfileData?.mediaUrls ?? userState.mediaUrls ?? [];
    final currentMediaIdentifiers =
        List<String>.from(userState.mediaUrls ?? []); // List from userProvider

    List<String> finalMediaUrls = []; // To store the final list of S3 URLs
    List<Map<String, String>> filesToUploadDetails = [];
    List<MediaUploadModel> fileModelsToUpload = []; // Keep models for S3 upload

    try {
      // --- Identify Files vs Existing URLs ---
      print("[ProfileScreen _handleSave] Identifying files vs URLs...");
      for (int i = 0; i < currentMediaIdentifiers.length; i++) {
        final identifier = currentMediaIdentifiers[i];
        if (identifier.isEmpty) continue; // Skip empty slots

        bool isLocalFile = false;
        File? potentialFile;
        try {
          // Check if it's an absolute path (common on mobile) or relative
          Uri? uri = Uri.tryParse(identifier);
          if (uri != null &&
              !uri.isAbsolute &&
              !identifier.startsWith('http')) {
            // If it's not an absolute URI and not HTTP(S), treat as potential file path
            isLocalFile = true;
          } else if (identifier.startsWith('/')) {
            // Catch explicit absolute paths like /data/user/...
            isLocalFile = true;
          }

          if (isLocalFile) {
            potentialFile = File(identifier);
            // Check existence *only* if it looks like a file path
            isLocalFile = await potentialFile.exists();
          }
        } catch (e) {
          print("Error checking file path '$identifier': $e");
          isLocalFile = false;
        }

        if (isLocalFile && potentialFile != null) {
          print("  - Found Local File at index $i: ${potentialFile.path}");
          final fileName = path.basename(potentialFile.path);
          final mimeType =
              lookupMimeType(potentialFile.path) ?? 'application/octet-stream';
          filesToUploadDetails.add({'filename': fileName, 'type': mimeType});
          // Store the model WITH the file object for later upload
          fileModelsToUpload.add(MediaUploadModel(
            file: potentialFile,
            fileName: fileName,
            fileType: mimeType,
            // presignedUrl will be added later
          ));
        } else if (identifier.startsWith('http')) {
          print("  - Found Existing URL at index $i: $identifier");
          // Add existing URL directly to the final list for now
          // We'll reconstruct the order later
        } else {
          print(
              "  - Warning: Skipping invalid identifier at index $i: $identifier");
        }
      }
      print(
          "[ProfileScreen _handleSave] Files to upload: ${fileModelsToUpload.length}");

      // --- Upload Files if Needed ---
      Map<String, String> uploadedUrlMap =
          {}; // Map original path -> new S3 URL
      if (fileModelsToUpload.isNotEmpty) {
        print(
            "[ProfileScreen _handleSave] Getting presigned URLs for ${fileModelsToUpload.length} files...");
        final presignedUrlsResponse =
            await mediaRepo.getEditPresignedUrls(filesToUploadDetails);

        if (presignedUrlsResponse.length != fileModelsToUpload.length) {
          throw ApiException("Mismatch in number of presigned URLs received.");
        }

        // Prepare models with URLs for upload
        List<Future<bool>> uploadFutures = [];
        for (int i = 0; i < fileModelsToUpload.length; i++) {
          final fileModel = fileModelsToUpload[i];
          final urlData = presignedUrlsResponse.firstWhere(
              (u) =>
                  u['filename'] == fileModel.fileName &&
                  u['type'] == fileModel.fileType,
              orElse: () => throw ApiException(
                  "Could not find presigned URL for ${fileModel.fileName}"));
          final presignedUrl = urlData['url'] as String;

          final modelWithUrl =
              fileModel.copyWith(presignedUrl: () => presignedUrl);
          fileModelsToUpload[i] = modelWithUrl; // Update the model in the list

          print(
              "[ProfileScreen _handleSave] Uploading ${fileModel.fileName}...");
          // Use retryUpload for robustness
          uploadFutures.add(mediaRepo.retryUpload(modelWithUrl).then((success) {
            if (success) {
              // Store mapping from original file path to S3 URL
              uploadedUrlMap[fileModel.file.path] = presignedUrl
                  .split('?')
                  .first; // Store URL without query params
            }
            return success;
          }));
        }

        final uploadResults = await Future.wait(uploadFutures);
        if (uploadResults.any((success) => !success)) {
          // Find which one failed for better logging (optional)
          for (int i = 0; i < uploadResults.length; ++i) {
            if (!uploadResults[i]) {
              print("❌ Upload failed for: ${fileModelsToUpload[i].fileName}");
            }
          }
          throw ApiException("One or more media uploads failed.");
        }
        print("[ProfileScreen _handleSave] All media uploads successful.");
      } else {
        print("[ProfileScreen _handleSave] No new files to upload.");
      }

      // --- Reconstruct Final URL List ---
      print("[ProfileScreen _handleSave] Reconstructing final URL list...");
      for (final identifier in currentMediaIdentifiers) {
        if (identifier.isEmpty) continue;

        if (uploadedUrlMap.containsKey(identifier)) {
          // It was a local file that was successfully uploaded
          final s3Url = uploadedUrlMap[identifier];
          if (s3Url != null) {
            finalMediaUrls.add(s3Url);
            print("  - Adding New URL: $s3Url (from $identifier)");
          } else {
            print(
                "  - Warning: Uploaded file path $identifier not found in URL map.");
          }
        } else if (identifier.startsWith('http')) {
          // It was an existing URL
          finalMediaUrls.add(identifier);
          print("  - Adding Existing URL: $identifier");
        }
        // Skip invalid identifiers already warned about
      }
      print("[ProfileScreen _handleSave] Final URLs: $finalMediaUrls");

      // --- Validate Final Media Count ---
      if (finalMediaUrls.length < 3) {
        throw ApiException(
            "Profile must have at least 3 media items after saving.");
      }

      // --- Prepare PATCH Payload ---
      final latestUserState = ref.read(userProvider); // Read latest state again
      Map<String, dynamic> payload = latestUserState.toJsonForEdit();
      payload['media_urls'] =
          finalMediaUrls; // Use the final reconstructed list

      // Remove non-editable fields just in case
      payload.removeWhere((key, value) => [
            'name',
            'last_name',
            'date_of_birth',
            'latitude',
            'longitude',
            'gender',
            'id',
            'email',
            'phone_number',
            'created_at',
            'verification_status',
            'role',
            'verification_pic'
          ].contains(key));

      print("[ProfileScreen _handleSave] Preparing PATCH payload: $payload");

      // --- Call API ---
      print("[ProfileScreen _handleSave] Calling userRepo.editProfile...");
      final bool success = await userRepo.editProfile(payload);

      if (success) {
        print("[ProfileScreen _handleSave] Profile edit successful.");
        // Update user provider with final URLs and reset flags
        userNotifier.updateMediaUrls(
            finalMediaUrls); // updateMediaUrls now resets the flag internally
        _originalProfileData = ref
            .read(userProvider); // Update original data after successful save

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
                content: Text("Profile updated successfully!"),
                backgroundColor: Colors.green),
          );
          setState(() => _isEditing = false); // Exit edit mode
        }
      } else {
        print(
            "[ProfileScreen _handleSave] Profile edit failed (API returned false).");
        if (mounted && ref.read(errorProvider) == null) {
          errorNotifier
              .setError(AppError.server("Failed to save profile changes."));
        }
      }
    } on ApiException catch (e) {
      print(
          "[ProfileScreen _handleSave] Save failed: API Exception - ${e.message}");
      if (mounted) errorNotifier.setError(AppError.server(e.message));
    } catch (e, stack) {
      print("[ProfileScreen _handleSave] Save failed: Unexpected error - $e");
      print(stack);
      if (mounted) {
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false); // Hide loading indicator
    }
  }
  // --- *** END UPDATED Save Handler *** ---

  // --- Helper Methods --- (Keep capitalizeFirstLetter, _buildTopIconButton, _buildEmptySection, _buildDetailChip, _buildSmallEditButton as is)
  String capitalizeFirstLetter(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }

  Widget _buildTopIconButton({
    required IconData icon,
    required String tooltip,
    required VoidCallback onPressed,
    bool isDisabled = false,
    Color? color,
  }) {
    final iconColor =
        isDisabled ? Colors.grey[400] : (color ?? const Color(0xFF8B5CF6));
    return IconButton(
      icon: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: isDisabled ? Colors.grey[200] : Colors.grey[100],
          borderRadius: BorderRadius.circular(12),
        ),
        child: Icon(icon, color: iconColor, size: 20),
      ),
      tooltip: isDisabled ? null : tooltip,
      onPressed: isDisabled ? null : onPressed,
    );
  }

  Widget _buildEmptySection(
      String title, String message, IconData icon, VoidCallback? onEditTap) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: 30, horizontal: 20),
      margin: const EdgeInsets.symmetric(
          vertical: 16), // Keep margin for consistency
      decoration: BoxDecoration(
          color: Colors.grey[50],
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey[200]!)),
      child: Stack(children: [
        Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(title,
                style: GoogleFonts.poppins(
                    fontSize: 18,
                    fontWeight: FontWeight.w600,
                    color: Colors.grey[800])),
            const SizedBox(height: 16), // Add space below title
            Icon(icon, size: 40, color: Colors.grey[400]),
            const SizedBox(height: 12),
            Text(message,
                textAlign: TextAlign.center,
                style:
                    GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600])),
          ],
        ),
        if (_isEditing && onEditTap != null)
          Positioned(
            top: 8,
            right: 8,
            child: _buildSmallEditButton(
                onPressed: onEditTap, tooltip: 'Add $title'),
          ),
      ]),
    );
  }

  Widget _buildDetailChip(IconData icon, String label, {bool subtle = false}) {
    if (label.isEmpty) return const SizedBox.shrink();
    return Container(
      padding: EdgeInsets.symmetric(
          horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
      decoration: BoxDecoration(
        color: subtle ? Colors.transparent : Colors.grey[100],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
            color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: subtle ? 16 : 18,
            color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6),
          ),
          const SizedBox(width: 6),
          Flexible(
            // Allow text to wrap if needed
            child: Text(
              label,
              style: GoogleFonts.poppins(
                fontSize: subtle ? 13 : 14,
                fontWeight: FontWeight.w500,
                color: subtle ? Colors.grey.shade700 : Colors.grey[800],
              ),
              overflow: TextOverflow.ellipsis, // Prevent long text overflow
              maxLines: 2,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSmallEditButton(
      {required VoidCallback onPressed,
      IconData icon = Icons.edit_outlined,
      String? tooltip = 'Edit'}) {
    return Material(
      color: Colors.white.withOpacity(0.8),
      shape: const CircleBorder(),
      child: InkWell(
        customBorder: const CircleBorder(),
        onTap: onPressed,
        child: Container(
          padding: const EdgeInsets.all(6),
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 3)
            ],
          ),
          child: Icon(icon, color: const Color(0xFF8B5CF6), size: 18),
        ),
      ),
    );
  }
  // --- END Helper Methods ---

  @override
  Widget build(BuildContext context) {
    final user = ref.watch(userProvider);
    final isLoadingProfile = ref.watch(userLoadingProvider);
    // Watch for API errors specifically during save
    final apiError = ref.watch(errorProvider);

    // --- Loading State --- (Keep as is)
    if (isLoadingProfile && user.name == null && !_isEditing) {
      return Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
            title: Text("Profile",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
            backgroundColor: Colors.white,
            foregroundColor: Colors.black,
            elevation: 0,
            automaticallyImplyLeading: false,
            actions: [
              _buildTopIconButton(
                  icon: Icons.edit_outlined,
                  tooltip: 'Edit Profile',
                  onPressed: () {},
                  isDisabled: true),
              const SizedBox(width: 8),
              _buildTopIconButton(
                  icon: Icons.settings_outlined,
                  tooltip: 'Settings',
                  onPressed: () {},
                  isDisabled: true),
              const SizedBox(width: 8),
            ]),
        body: const Center(
            child: CircularProgressIndicator(color: Color(0xFF8B5CF6))),
      );
    }

    // --- Error State (Display non-saving errors) ---
    // Only show general API errors if NOT currently in the saving process
    if (apiError != null && !_isSaving) {
      return Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          title: Text("Profile Error",
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          elevation: 0,
          automaticallyImplyLeading: false,
          actions: [
            _buildTopIconButton(
                icon: Icons.edit_outlined,
                tooltip: 'Edit Profile',
                onPressed: () {},
                isDisabled: true),
            const SizedBox(width: 8),
            _buildTopIconButton(
                icon: Icons.settings_outlined,
                tooltip: 'Settings',
                onPressed: () {},
                isDisabled: true),
            const SizedBox(width: 8),
          ],
        ),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(20.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 50),
                const SizedBox(height: 15),
                Text("Could not load profile",
                    style: GoogleFonts.poppins(
                        fontSize: 18, fontWeight: FontWeight.w600),
                    textAlign: TextAlign.center),
                const SizedBox(height: 8),
                Text(apiError.message,
                    textAlign: TextAlign.center,
                    style: GoogleFonts.poppins(color: Colors.grey[600])),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () {
                    ref.read(errorProvider.notifier).clearError();
                    ref.read(userProvider.notifier).fetchProfile();
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF8B5CF6),
                      foregroundColor: Colors.white),
                  child: const Text("Retry"),
                )
              ],
            ),
          ),
        ),
      );
    }

    // --- Prepare Content Blocks (Logic remains the same) ---
    final List<dynamic> contentBlocks = [];
    final currentMedia = user.mediaUrls ?? [];
    final prompts = user.prompts;

    contentBlocks.add("header_section");

    if (currentMedia.isNotEmpty) {
      // Add the first media item or an empty placeholder if editing
      contentBlocks
          .add({"type": "media", "value": currentMedia[0], "index": 0});
    } else if (_isEditing) {
      contentBlocks.add("empty_media_section");
    }

    if (prompts.isNotEmpty) {
      contentBlocks.add(prompts[0]);
    } else if (_isEditing) {
      contentBlocks.add("empty_prompt_section");
    }

    contentBlocks.add("vitals_section"); // Always add vitals section wrapper

    int mediaIndex = 1;
    int promptIndex = 1;
    // Use max of lengths OR 6/3 if editing to show empty slots potentially
    int maxMediaSlots = _isEditing ? 6 : currentMedia.length;
    int maxPromptSlots = _isEditing ? 3 : prompts.length;
    int maxRemaining = max(maxMediaSlots, maxPromptSlots);

    for (int i = 1; i < maxRemaining; i++) {
      // Add Media (existing or empty slot if editing)
      if (mediaIndex < maxMediaSlots) {
        if (mediaIndex < currentMedia.length) {
          contentBlocks.add({
            "type": "media",
            "value": currentMedia[mediaIndex],
            "index": mediaIndex
          });
        } else if (_isEditing) {
          // Add placeholder for potential add in media picker
          contentBlocks.add({"type": "empty_media_slot", "index": mediaIndex});
        }
        mediaIndex++;
      }
      // Add Prompt (existing or empty slot if editing)
      if (promptIndex < maxPromptSlots) {
        if (promptIndex < prompts.length) {
          contentBlocks.add(prompts[promptIndex]);
        } else if (_isEditing) {
          // Add placeholder for potential add in prompt editor
          contentBlocks
              .add({"type": "empty_prompt_slot", "index": promptIndex});
        }
        promptIndex++;
      }
    }

    // Add Audio Prompt (existing or empty slot if editing)
    if (user.audioPrompt != null) {
      contentBlocks.add(user.audioPrompt!);
    } else if (_isEditing) {
      contentBlocks.add("empty_audio_section");
    }
    // --- End Content Block Preparation ---

    // --- Build UI ---
    return Scaffold(
      backgroundColor: Colors.white,
      body: Stack(// Use Stack for loading overlay
          children: [
        RefreshIndicator(
          color: const Color(0xFF8B5CF6),
          onRefresh: () async {
            if (!_isEditing) {
              ref
                  .read(errorProvider.notifier)
                  .clearError(); // Clear error on refresh
              await ref.read(userProvider.notifier).fetchProfile();
            }
          },
          child: CustomScrollView(
            physics: const BouncingScrollPhysics(
                parent: AlwaysScrollableScrollPhysics()),
            slivers: [
              SliverAppBar(
                pinned: true,
                floating: false,
                elevation: 1,
                backgroundColor: Colors.white,
                foregroundColor: Colors.black,
                automaticallyImplyLeading: false,
                title: Text(_isEditing ? "Edit Profile" : "Profile",
                    style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
                actions: _isEditing
                    ? [
                        /* Save/Cancel Actions */
                        TextButton(
                            onPressed: _isSaving
                                ? null
                                : _cancelEditMode, // Disable during save
                            child: Text("Cancel",
                                style: GoogleFonts.poppins(
                                    color: _isSaving
                                        ? Colors.grey[400]
                                        : Colors.grey))),
                        TextButton(
                            onPressed: _isSaving
                                ? null
                                : _handleSave, // Disable during save
                            child: Text("Save",
                                style: GoogleFonts.poppins(
                                    color: _isSaving
                                        ? Colors.grey[400]
                                        : const Color(0xFF8B5CF6),
                                    fontWeight: FontWeight.bold))),
                        const SizedBox(width: 8),
                      ]
                    : [
                        /* View Mode Actions */
                        _buildTopIconButton(
                            icon: Icons.edit_outlined,
                            tooltip: 'Edit Profile',
                            onPressed: _enterEditMode),
                        const SizedBox(width: 8),
                        _buildTopIconButton(
                            icon: Icons.settings_outlined,
                            tooltip: 'Settings',
                            onPressed: () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const SettingsScreen()))),
                        const SizedBox(width: 8),
                      ],
              ),

              // --- Main Content List ---
              SliverPadding(
                padding: const EdgeInsets.only(top: 8.0),
                sliver: SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      final item = contentBlocks[index];
                      final double bottomPadding = 24.0;
                      final double horizontalPadding = 16.0;
                      Widget contentWidget;

                      // Build content based on type
                      if (item is String && item == "header_section") {
                        contentWidget = _buildHeaderBlock(user);
                      }
                      // Handle Empty Sections (Placeholders shown during edit)
                      else if (item is String &&
                          item == "empty_media_section") {
                        contentWidget = _buildEmptySection(
                            "Photos & Videos",
                            "Add photos and videos!",
                            Icons.add_photo_alternate_outlined,
                            () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const MediaPickerScreen(
                                            isEditing: true))));
                      } else if (item is String &&
                          item == "empty_prompt_section") {
                        contentWidget = _buildEmptySection(
                            "About Me",
                            "Add prompt answers!",
                            Icons.chat_bubble_outline,
                            () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) => ProfileAnswersScreen(
                                        isEditing: true))));
                      } else if (item is String &&
                          item == "empty_audio_section") {
                        contentWidget = _buildEmptySection(
                            "Voice Prompt",
                            "Record a voice prompt!",
                            Icons.mic_none_rounded,
                            () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const VoicePromptScreen(
                                            isEditing: true))));
                      } else if (item is Map &&
                          item["type"] == "empty_media_slot") {
                        contentWidget = _buildEmptyMediaSlot(() =>
                            Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const MediaPickerScreen(
                                            isEditing: true))));
                      } else if (item is Map &&
                          item["type"] == "empty_prompt_slot") {
                        contentWidget = _buildEmptyPromptSlot(
                            item["index"],
                            () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) => TextSelectPromptScreen(
                                        isEditing:
                                            true)))); // Pass index if needed later
                      }

                      // Handle Content Items
                      else if (item is Map && item["type"] == "media") {
                        String displayValue = item["value"];
                        bool isLocalFile = false;
                        // More robust check if it's a local file path vs URL
                        if (!displayValue.startsWith('http') &&
                            (displayValue.contains('/') ||
                                displayValue.contains('\\'))) {
                          // Basic check: Doesn't start with http and contains path separators
                          // A more reliable check might involve trying File(displayValue).exists() but that's async
                          isLocalFile = true;
                        }
                        contentWidget = _buildMediaItem(
                            context, ref, displayValue, item["index"],
                            isLocalFile: isLocalFile);
                      } else if (item is Prompt) {
                        int promptEditIndex = user.prompts
                            .indexWhere((p) => p.question == item.question);
                        contentWidget = _buildPromptItem(item,
                            onEditTap: () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        TextSelectPromptScreen(
                                            isEditing: true,
                                            editIndex: promptEditIndex >= 0
                                                ? promptEditIndex
                                                : null))));
                      } else if (item is AudioPromptModel) {
                        contentWidget = _buildAudioItem(item,
                            onEditTap: () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const VoicePromptScreen(
                                            isEditing: true))));
                      } else if (item is String && item == "vitals_section") {
                        contentWidget = _buildVitalsBlock(user,
                            onEditTap: _navigateToVitalsEditFlow);
                      } else {
                        contentWidget = const SizedBox.shrink();
                      }

                      return Padding(
                        padding: EdgeInsets.fromLTRB(horizontalPadding, 0,
                            horizontalPadding, bottomPadding),
                        child: contentWidget,
                      );
                    },
                    childCount: contentBlocks.length,
                  ),
                ),
              ),
              const SliverToBoxAdapter(child: SizedBox(height: 20)),
            ],
          ),
        ),
        // --- Loading Overlay ---
        if (_isSaving)
          Positioned.fill(
            child: Container(
              color: Colors.black.withOpacity(0.5),
              child: const Center(
                child: CircularProgressIndicator(color: Color(0xFF8B5CF6)),
              ),
            ),
          ),
      ]),
    );
  }

  // --- Block Builder Widgets (Adapted for ProfileScreen) ---

  Widget _buildHeaderBlock(UserModel user) {
    // (Keep as is)
    final age = user.age;
    final capitalizedName =
        user.name != null ? capitalizeFirstLetter(user.name!) : "Your Name";
    final capitalizedLastName =
        user.lastName != null && user.lastName!.isNotEmpty
            ? capitalizeFirstLetter(user.lastName!)
            : "";

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '$capitalizedName $capitalizedLastName ${age != null ? "• $age" : ""}',
          style: GoogleFonts.poppins(
              fontSize: 28,
              fontWeight: FontWeight.w700,
              color: const Color(0xFF1A1A1A),
              height: 1.2),
        ),
        const SizedBox(height: 12),
        Wrap(
          spacing: 10,
          runSpacing: 8,
          children: [
            // Non-editable
            if (user.gender != null)
              _buildDetailChip(Icons.person_outline_rounded, user.gender!.label,
                  subtle: true),
            // Editable - Hometown (Now editable via Vitals flow)
            if (user.hometown != null && user.hometown!.isNotEmpty)
              _buildEditableChip(
                icon: Icons.location_on_outlined,
                label: user.hometown!,
                onEditTap: () => Navigator.push(
                    context,
                    MaterialPageRoute(
                        builder: (context) =>
                            const HometownScreen(isEditing: true))),
                subtle: true, // Keep subtle look
              )
            else if (_isEditing)
              _buildAddChip(
                  label: "Add Hometown",
                  onAddTap: () => Navigator.push(
                      context,
                      MaterialPageRoute(
                          builder: (context) =>
                              const HometownScreen(isEditing: true))),
                  subtle: true),

            // Editable - Dating Intention
            if (user.datingIntention != null)
              _buildEditableChip(
                  icon: Icons.favorite_border_rounded,
                  label: user.datingIntention!.label,
                  onEditTap: () => Navigator.push(
                      context,
                      MaterialPageRoute(
                          builder: (context) =>
                              const DatingIntentionsScreen(isEditing: true))),
                  subtle: true)
            else if (_isEditing)
              _buildAddChip(
                  label: "Add Intention",
                  onAddTap: () => Navigator.push(
                      context,
                      MaterialPageRoute(
                          builder: (context) =>
                              const DatingIntentionsScreen(isEditing: true))),
                  subtle: true),
          ],
        ),
      ],
    );
  }

  // --- Modified Media Item Builder ---
  Widget _buildMediaItem(
      BuildContext context, WidgetRef ref, String urlOrPath, int index,
      {required bool isLocalFile}) {
    bool isVideo = false;
    if (!isLocalFile) {
      // Basic URL check for video extensions
      final lowerUrl = urlOrPath.toLowerCase();
      isVideo = ['.mp4', '.mov', '.avi', '.mpeg', '.mpg', '.3gp', '.ts', '.mkv']
          .any((ext) => lowerUrl.endsWith(ext));
    } else {
      // Use MIME type for local files if possible, fallback to extension
      final mimeType = lookupMimeType(urlOrPath);
      if (mimeType != null) {
        isVideo = mimeType.startsWith('video/');
      } else {
        // Fallback extension check for local files
        String ext = path.basename(urlOrPath).split('.').last.toLowerCase();
        isVideo = ['mp4', 'mov', 'avi', 'mpeg', 'mpg', '3gp', 'ts', 'mkv']
            .contains(ext);
      }
    }

    return ClipRRect(
      borderRadius: BorderRadius.circular(10),
      child: AspectRatio(
        aspectRatio: 4 / 5.5,
        child: Container(
          decoration: BoxDecoration(color: Colors.grey[200]),
          child: Stack(
            fit: StackFit.expand,
            children: [
              // Display Image/Video Thumbnail
              if (isLocalFile)
                Image.file(File(urlOrPath),
                    fit: BoxFit.cover,
                    errorBuilder: (_, __, ___) =>
                        const Icon(Icons.broken_image))
              else
                Image.network(urlOrPath,
                    fit: BoxFit.cover,
                    loadingBuilder: (ctx, child, prog) => prog == null
                        ? child
                        : Center(
                            child: CircularProgressIndicator(
                                value: prog.expectedTotalBytes != null
                                    ? prog.cumulativeBytesLoaded /
                                        prog.expectedTotalBytes!
                                    : null,
                                color: Colors.grey[400])),
                    errorBuilder: (ctx, err, st) => Center(
                        child: Icon(Icons.image_not_supported_outlined,
                            color: Colors.grey[400], size: 40))),
              // Video indicator
              if (isVideo)
                Center(
                  child: Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.5),
                        shape: BoxShape.circle),
                    child: const Icon(Icons.play_arrow_rounded,
                        color: Colors.white, size: 30),
                  ),
                ),

              // *** --- START FIX: Edit Button Condition --- ***
              // Show edit button if _isEditing, regardless of index
              if (_isEditing)
                // *** --- END FIX --- ***
                Positioned(
                  top: 8,
                  right: 8,
                  child: _buildSmallEditButton(
                      icon: Icons.edit, // Use edit icon
                      tooltip: "Edit Media Gallery",
                      onPressed: () async {
                        // Make async
                        // --- ADDED: Clear media provider before navigating ---
                        print(
                            "[ProfileScreen] Clearing mediaUploadProvider before navigating to MediaPickerScreen (Edit).");
                        ref.read(mediaUploadProvider.notifier).state =
                            List.filled(6, null);
                        // --- END ADDED ---
                        await Navigator.push(
                            // Await navigation
                            context,
                            MaterialPageRoute(
                                builder: (context) =>
                                    const MediaPickerScreen(isEditing: true)));
                        // Optional: Force rebuild or state sync after returning?
                        // Not strictly necessary if MediaPickerScreen correctly updates userProvider.
                      }),
                ),
            ],
          ),
        ),
      ),
    );
  }

  // --- NEW: Empty Media Slot ---
  Widget _buildEmptyMediaSlot(VoidCallback onEditTap) {
    return ClipRRect(
      borderRadius: BorderRadius.circular(10),
      child: AspectRatio(
        aspectRatio: 4 / 5.5,
        child: Material(
          color: Colors.grey[100],
          child: InkWell(
            onTap: onEditTap, // Navigate to media picker
            child: Center(
              child: Icon(Icons.add_photo_alternate_outlined,
                  size: 40, color: Colors.grey[400]),
            ),
          ),
        ),
      ),
    );
  }

  // --- NEW: Empty Prompt Slot ---
  Widget _buildEmptyPromptSlot(int index, VoidCallback onEditTap) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
          color: Colors.grey[50],
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey[200]!)),
      child: Material(
        // Wrap with Material for InkWell effect
        color: Colors.transparent,
        child: InkWell(
          onTap: onEditTap, // Navigate to prompt selection/writing
          borderRadius: BorderRadius.circular(16), // Match container radius
          child: Padding(
            // Add padding inside InkWell for content
            padding: const EdgeInsets.symmetric(
                vertical: 20), // Adjust vertical padding
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center, // Center content
              children: [
                Icon(Icons.add_circle_outline,
                    color: Colors.grey[400], size: 24),
                const SizedBox(width: 8),
                Text(
                  "Add prompt #${index + 1}",
                  style: GoogleFonts.poppins(
                      fontSize: 16, color: Colors.grey[600]),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildPromptItem(Prompt prompt, {required VoidCallback onEditTap}) {
    // (Keep as is)
    if (prompt.answer.trim().isEmpty && !_isEditing)
      return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.grey[200]!),
        boxShadow: [
          BoxShadow(
              color: Colors.grey.withOpacity(0.06),
              blurRadius: 10,
              offset: const Offset(0, 3))
        ],
      ),
      child: Stack(
        clipBehavior: Clip.none, // Allow button overflow slightly
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(prompt.question.label,
                  style: GoogleFonts.poppins(
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                      color: const Color(0xFF8B5CF6))),
              const SizedBox(height: 10),
              if (prompt.answer.trim().isNotEmpty)
                Text(prompt.answer,
                    style: GoogleFonts.poppins(
                        fontSize: 16,
                        color: Colors.grey[850],
                        height: 1.5,
                        fontWeight: FontWeight.w500))
              else if (_isEditing)
                Text("Tap edit to add your answer...",
                    style: GoogleFonts.poppins(
                        fontSize: 16,
                        color: Colors.grey[400],
                        fontStyle: FontStyle.italic)),
            ],
          ),
          if (_isEditing) // Show edit button only in edit mode
            Positioned(
              top: -12,
              right: -12,
              child: _buildSmallEditButton(
                  onPressed: onEditTap, tooltip: "Edit Prompt"),
            ),
        ],
      ),
    );
  }

  Widget _buildAudioItem(AudioPromptModel audio,
      {required VoidCallback onEditTap}) {
    // (Keep as is)
    final bool isThisPlaying = _currentAudioUrl == audio.audioUrl && _isPlaying;
    final bool isThisPaused = _currentAudioUrl == audio.audioUrl &&
        !_isPlaying &&
        _audioPlayer.state == PlayerState.paused;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.grey[200]!),
        boxShadow: [
          BoxShadow(
              color: Colors.grey.withOpacity(0.06),
              blurRadius: 10,
              offset: const Offset(0, 3))
        ],
      ),
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          Row(
            children: [
              InkWell(
                onTap: () => _playOrPauseAudio(audio.audioUrl),
                borderRadius: BorderRadius.circular(24),
                child: Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6),
                      borderRadius: BorderRadius.circular(24),
                      boxShadow: [
                        BoxShadow(
                            color: const Color(0xFF8B5CF6).withOpacity(0.3),
                            blurRadius: 8,
                            offset: const Offset(0, 2))
                      ]),
                  child: Icon(
                      isThisPlaying
                          ? Icons.pause_rounded
                          : Icons.play_arrow_rounded,
                      color: Colors.white,
                      size: 28),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(audio.prompt.label,
                        style: GoogleFonts.poppins(
                            fontSize: 15,
                            fontWeight: FontWeight.w500,
                            color: const Color(0xFF1A1A1A))),
                    const SizedBox(height: 4),
                    Text(
                        isThisPlaying
                            ? "Playing..."
                            : (isThisPaused ? "Paused" : "Tap to listen"),
                        style: GoogleFonts.poppins(
                            fontSize: 13, color: Colors.grey[600])),
                  ],
                ),
              ),
            ],
          ),
          if (_isEditing)
            Positioned(
              top: -12,
              right: -12,
              child: _buildSmallEditButton(
                  onPressed: onEditTap, tooltip: "Edit Voice Prompt"),
            ),
        ],
      ),
    );
  }

  Widget _buildVitalsBlock(UserModel user, {required VoidCallback onEditTap}) {
    // (Keep as is)
    final List<Widget> vitals = [];
    if (user.height != null && user.height!.isNotEmpty)
      vitals.add(_buildEditableChip(
          icon: Icons.height_rounded,
          label: user.height!,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const HeightSelectionScreen(isEditing: true)))));
    if (user.religiousBeliefs != null)
      vitals.add(_buildEditableChip(
          icon: Icons.church_outlined,
          label: user.religiousBeliefs!.label,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const ReligionScreen(isEditing: true)))));
    // Editable Job/Edu via this block's edit button
    if (user.jobTitle != null && user.jobTitle!.isNotEmpty)
      vitals.add(_buildEditableChip(
          icon: Icons.work_outline_rounded,
          label: user.jobTitle!,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const JobTitleScreen(isEditing: true)))));
    if (user.education != null && user.education!.isNotEmpty)
      vitals.add(_buildEditableChip(
          icon: Icons.school_outlined,
          label: user.education!,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const StudyLocationScreen(isEditing: true)))));
    // Editable Habits
    if (user.drinkingHabit != null)
      vitals.add(_buildEditableChip(
          icon: Icons.local_bar_outlined,
          label: "Drinks: ${user.drinkingHabit!.label}",
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const DrinkingScreen(isEditing: true)))));
    if (user.smokingHabit != null)
      vitals.add(_buildEditableChip(
          icon: Icons.smoking_rooms_outlined,
          label: "Smokes: ${user.smokingHabit!.label}",
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const SmokingScreen(isEditing: true)))));

    // Add "Add" buttons if editing and field is empty
    if (_isEditing) {
      if (user.height == null || user.height!.isEmpty)
        vitals.add(_buildAddChip(
            label: "Add Height",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const HeightSelectionScreen(isEditing: true)))));
      if (user.religiousBeliefs == null)
        vitals.add(_buildAddChip(
            label: "Add Religion",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const ReligionScreen(isEditing: true)))));
      if (user.jobTitle == null || user.jobTitle!.isEmpty)
        vitals.add(_buildAddChip(
            label: "Add Job",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const JobTitleScreen(isEditing: true)))));
      if (user.education == null || user.education!.isEmpty)
        vitals.add(_buildAddChip(
            label: "Add Education",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const StudyLocationScreen(isEditing: true)))));
      if (user.drinkingHabit == null)
        vitals.add(_buildAddChip(
            label: "Add Drinking Habit",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const DrinkingScreen(isEditing: true)))));
      if (user.smokingHabit == null)
        vitals.add(_buildAddChip(
            label: "Add Smoking Habit",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const SmokingScreen(isEditing: true)))));
    }

    if (vitals.isEmpty && !_isEditing) return const SizedBox.shrink();
    if (vitals.isEmpty && _isEditing)
      return _buildEmptySection("Vitals & Habits", "Add more details!",
          Icons.list_alt_rounded, onEditTap);

    return Container(
        width: double.infinity,
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey[200]!),
          boxShadow: [
            BoxShadow(
                color: Colors.grey.withOpacity(0.06),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ],
        ),
        child: Stack(clipBehavior: Clip.none, children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(
                padding: const EdgeInsets.only(bottom: 12.0),
                child: Text("Vitals & Habits",
                    style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: const Color(0xFF1A1A1A))),
              ),
              Wrap(spacing: 8, runSpacing: 8, children: vitals),
            ],
          ),
          if (_isEditing)
            Positioned(
              top: -12,
              right: -12,
              child: _buildSmallEditButton(
                  onPressed: onEditTap, tooltip: "Edit Vitals"),
            ),
        ]));
  }

  // --- Editable Chip Widget --- (Keep as is)
  Widget _buildEditableChip({
    required IconData icon,
    required String label,
    required VoidCallback onEditTap,
    bool subtle = false,
  }) {
    if (label.isEmpty) return const SizedBox.shrink();
    return InkWell(
      onTap: _isEditing ? onEditTap : null,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
        decoration: BoxDecoration(
          color: subtle ? Colors.transparent : Colors.grey[100],
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
              color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon,
                size: subtle ? 16 : 18,
                color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6)),
            const SizedBox(width: 6),
            Flexible(
                child: Text(label,
                    style: GoogleFonts.poppins(
                        fontSize: subtle ? 13 : 14,
                        fontWeight: FontWeight.w500,
                        color:
                            subtle ? Colors.grey.shade700 : Colors.grey[800]),
                    overflow: TextOverflow.ellipsis)),
            if (_isEditing) ...[
              const SizedBox(width: 6),
              Icon(Icons.edit, size: 14, color: Colors.grey[500]),
            ]
          ],
        ),
      ),
    );
  }

  // --- Add Chip Widget --- (Keep as is)
  Widget _buildAddChip({
    required String label,
    required VoidCallback onAddTap,
    bool subtle = false,
  }) {
    return InkWell(
      onTap: onAddTap,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
        decoration: BoxDecoration(
          color: Colors.transparent,
          borderRadius: BorderRadius.circular(20),
          border:
              Border.all(color: Colors.grey.shade400, style: BorderStyle.solid),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.add_circle_outline,
                size: subtle ? 16 : 18, color: Colors.grey.shade600),
            const SizedBox(width: 6),
            Flexible(
                child: Text(label,
                    style: GoogleFonts.poppins(
                        fontSize: subtle ? 13 : 14,
                        fontWeight: FontWeight.w500,
                        color: Colors.grey.shade700),
                    overflow: TextOverflow.ellipsis)),
          ],
        ),
      ),
    );
  }

  // Helper to navigate to the start of the vitals editing flow (Keep as is)
  void _navigateToVitalsEditFlow() {
    Navigator.push(
        context,
        MaterialPageRoute(
            builder: (context) =>
                const HeightSelectionScreen(isEditing: true)));
  }
} // End of _ProfileScreenState



================================================
File: views/prompt.dart
================================================
// File: lib/views/prompt.dart
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/audioprompt.dart'; // Keep for onboarding flow
// Removed unused audiopromptsselect import
// Removed unused media import
import 'package:dtx/views/textpromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';

class ProfileAnswersScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const ProfileAnswersScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<ProfileAnswersScreen> createState() =>
      _ProfileAnswersScreenState();
}

class _ProfileAnswersScreenState extends ConsumerState<ProfileAnswersScreen> {
  // Removed _isForwardButtonEnabled - logic handled by checking prompt count now

  // --- No need for initState/updateForwardButtonState ---

  void _handlePromptTap(Prompt? prompt, int index) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => TextSelectPromptScreen(
          editIndex: prompt != null ? index : null,
          isEditing: widget.isEditing, // <<< Pass editing flag
        ),
      ),
    ); // No need for .then() as UI updates reactively
  }

  void _handleRemovePrompt(int index) {
    // Add confirmation dialog?
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text("Remove Prompt?"),
        content:
            const Text("Are you sure you want to remove this prompt answer?"),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: const Text("Cancel"),
          ),
          TextButton(
            onPressed: () {
              ref.read(userProvider.notifier).removePromptAtIndex(index);
              Navigator.pop(dialogContext);
            },
            child: const Text("Remove", style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  void _handleNext() {
    final prompts = ref.read(userProvider).prompts;
    // Onboarding requires at least one prompt
    if (!widget.isEditing &&
        prompts.where((p) => p.answer.trim().isNotEmpty).isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text("Please answer at least one prompt.",
              style: GoogleFonts.poppins()),
          backgroundColor: Colors.red[400],
        ),
      );
      return;
    }

    if (widget.isEditing) {
      print("[ProfileAnswersScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[ProfileAnswersScreen] Onboarding next: Audio Prompt.");
      Navigator.pushReplacement(
        // Use replacement for onboarding
        context,
        MaterialPageRoute(builder: (context) => const VoicePromptScreen()),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);
    final prompts = userState.prompts;
    final bool canProceed =
        prompts.where((p) => p.answer.trim().isNotEmpty).isNotEmpty;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: 0, // No back button needed here typically
                  right: 0,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder for onboarding alignment
                      const SizedBox(width: 48),
                    Text(
                      widget.isEditing ? "Edit Prompts" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed:
                            _handleNext, // Always enabled for edit? Or check canProceed? Let's allow saving empty.
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: const Color(0xFF8B5CF6), // Always enabled
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for onboarding
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              const SizedBox(height: 20), // Reduced top space
              Text(
                widget.isEditing ? "Edit Your Prompts" : "Profile Prompts",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? 28
                      : 36, // Slightly smaller title in edit
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 12),
              Text(
                widget.isEditing
                    ? "Tap a prompt to edit or remove it."
                    : "Share three interesting facts about yourself",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 40),
              Expanded(
                child: ListView.separated(
                  itemCount: 3,
                  separatorBuilder: (_, __) => const SizedBox(height: 24),
                  itemBuilder: (context, index) {
                    final prompt =
                        index < prompts.length ? prompts[index] : null;
                    return _buildPromptCard(prompt, index);
                  },
                ),
              ),
              const SizedBox(height: 16),
              // --- Hide Bottom Bar in Edit Mode ---
              if (!widget.isEditing)
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Text(
                      "At least 1 prompt required",
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        color: Colors.grey[600],
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                    _buildForwardButton(canProceed), // Pass enabled state
                  ],
                ),
              // --- End Hide Bottom Bar ---
              SizedBox(
                  height: widget.isEditing ? 16 : 32), // Adjust bottom padding
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPromptCard(Prompt? prompt, int index) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: prompt != null ? const Color(0xFF8B5CF6) : Colors.grey[300]!,
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(16),
          onTap: () => _handlePromptTap(prompt, index),
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        prompt?.question.label ?? "Add a prompt",
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w500,
                          color: prompt != null
                              ? Colors.black87
                              : Colors.grey[700],
                        ),
                      ),
                    ),
                    // Show Edit or Add Icon
                    Icon(
                      prompt != null
                          ? Icons.edit_outlined
                          : Icons.add_circle_outline,
                      color: const Color(0xFF8B5CF6),
                      size: 24,
                    ),
                    // Add Remove Icon if editing and prompt exists
                    if (widget.isEditing && prompt != null) ...[
                      const SizedBox(width: 10),
                      IconButton(
                        icon: Icon(Icons.delete_outline,
                            color: Colors.redAccent.withOpacity(0.7), size: 24),
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                        tooltip: "Remove Prompt",
                        onPressed: () => _handleRemovePrompt(index),
                      ),
                    ]
                  ],
                ),
                if (prompt?.answer.isNotEmpty ?? false) ...[
                  const SizedBox(height: 12),
                  Text(
                    prompt!.answer,
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey[700], // Slightly muted answer color
                      height: 1.4,
                    ),
                    maxLines: 3, // Limit display lines
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  // Onboarding Forward Button
  Widget _buildForwardButton(bool isEnabled) {
    return GestureDetector(
      onTap: isEnabled ? _handleNext : null,
      child: Container(
        width: 70,
        height: 70,
        decoration: BoxDecoration(
          color: isEnabled ? const Color(0xFF8B5CF6) : Colors.grey.shade400,
          borderRadius: BorderRadius.circular(35),
          boxShadow: [
            if (isEnabled)
              BoxShadow(
                color: const Color(0xFF8B5CF6).withOpacity(0.3),
                blurRadius: 12,
                offset: const Offset(0, 4),
              ),
          ],
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          color: isEnabled ? Colors.white : Colors.grey.shade600,
          size: 32,
        ),
      ),
    );
  }
}



================================================
File: views/religion.dart
================================================
// File: lib/views/religion.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/drinking.dart'; // Keep for onboarding flow

class ReligionScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const ReligionScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<ReligionScreen> createState() => _ReligionScreenState();
}

class _ReligionScreenState extends ConsumerState<ReligionScreen> {
  Religion? _selectedReligion; // Local state

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _selectedReligion = ref.read(userProvider).religiousBeliefs;
    }
  }

  void _handleNext() {
    if (_selectedReligion != null) {
      ref.read(userProvider.notifier).updateReligiousBeliefs(_selectedReligion);
      if (widget.isEditing) {
        print("[ReligionScreen] Editing done, popping back.");
        Navigator.of(context).pop();
      } else {
        // Original onboarding navigation
        print("[ReligionScreen] Onboarding next: Drinking.");
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const DrinkingScreen()));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder for alignment in onboarding
                      const SizedBox(
                          width: 48), // Matches IconButton width approx

                    Text(
                      widget.isEditing ? "Edit Religion" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    if (widget.isEditing)
                      TextButton(
                        onPressed:
                            _selectedReligion != null ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: _selectedReligion != null
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for alignment in onboarding
                      const SizedBox(
                          width: 48), // Matches TextButton width approx
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),
              Text(
                widget.isEditing
                    ? "Edit your religious beliefs"
                    : "What are your religious beliefs?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),
              SizedBox(height: screenSize.height * 0.05),
              Wrap(
                spacing: screenSize.width * 0.03,
                runSpacing: screenSize.height * 0.015,
                children: Religion.values
                    .map((religion) =>
                        _buildReligionButton(religion, screenSize))
                    .toList(),
              ),
              const Spacer(),
              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Padding(
                  padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      GestureDetector(
                        onTap: _selectedReligion != null ? _handleNext : null,
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: _selectedReligion != null
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey.shade300,
                            borderRadius: BorderRadius.circular(35),
                          ),
                          child: const Icon(
                            Icons.arrow_forward_rounded,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildReligionButton(Religion religion, Size screenSize) {
    bool isSelected = _selectedReligion == religion; // Use local state
    return GestureDetector(
      onTap: () =>
          setState(() => _selectedReligion = religion), // Update local state
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.015),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
          borderRadius: BorderRadius.circular(25),
          border: Border.all(color: Colors.grey.shade300, width: 1.0),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              religion.label,
              style: GoogleFonts.poppins(
                fontSize: 18,
                fontWeight: FontWeight.w500,
                color: isSelected ? Colors.white : Colors.black87,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/selfie_capture_screen.dart
================================================
// File: views/selfie_capture_screen.dart
import 'dart:async';
import 'dart:io';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/views/verification_pending_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:camera/camera.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class SelfieCaptureScreen extends ConsumerStatefulWidget {
  const SelfieCaptureScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<SelfieCaptureScreen> createState() => _SelfieCaptureScreenState();
}

class _SelfieCaptureScreenState extends ConsumerState<SelfieCaptureScreen>
    with WidgetsBindingObserver {
  CameraController? _cameraController;
  List<CameraDescription> _cameras = [];
  bool _isCameraInitialized = false;
  bool _hasError = false;
  double _aspectRatio = 1.0;
  bool _isUploading = false; // Track uploading state

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initializeCamera();
  }

  Future<void> _initializeCamera() async {
    try {
      _cameras = await availableCameras();
      if (_cameras.isEmpty) throw Exception('No cameras available');

      final frontCamera = _cameras.firstWhere(
        (camera) => camera.lensDirection == CameraLensDirection.front,
        orElse: () => _cameras.first,
      );

      _cameraController = CameraController(
        frontCamera,
        ResolutionPreset.medium,
        enableAudio: false,
      );

      await _cameraController!.initialize();
      
      final previewSize = _cameraController!.value.previewSize!;
      _aspectRatio = previewSize.width / previewSize.height;

      if (mounted) setState(() => _isCameraInitialized = true);
      
    } catch (e) {
      if (mounted) setState(() => _hasError = true);
      print('Camera Error: $e');
    }
  }

  Widget _buildCameraPreview() {
    if (_hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, color: Colors.white, size: 50),
            const SizedBox(height: 20),
            Text(
              'Camera Error',
              style: GoogleFonts.poppins(color: Colors.white, fontSize: 20),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: _initializeCamera,
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF8B5CF6),
              ),
              child: Text(
                'Retry',
                style: GoogleFonts.poppins(color: Colors.white),
              ),
            ),
          ],
        ),
      );
    }

    if (!_isCameraInitialized || _cameraController == null) {
      return const Center(
        child: CircularProgressIndicator(color: Color(0xFF8B5CF6)),
      );
    }

    return AspectRatio(
      aspectRatio: _aspectRatio,
      child: CameraPreview(_cameraController!),
    );
  }

  Future<void> _captureImage() async {
    if (!_isCameraInitialized || _cameraController == null) return;

    try {
      setState(() => _isUploading = true);

      final image = await _cameraController!.takePicture();
      final imageFile = File(image.path);

      // Set verification image in provider
      ref.read(mediaUploadProvider.notifier).setVerificationImage(imageFile);

      // Upload verification image
      final success = await ref.read(mediaUploadProvider.notifier).uploadVerificationImage();

      setState(() => _isUploading = false);

      if (success) {
        // Navigate to verification pending screen
        if (mounted) {
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (context) => const VerificationPendingScreen()),
          );
        }
      } else {
        // Handle upload failure
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to upload verification image. Please try again.')),
        );
      }
    } catch (e) {
      setState(() => _isUploading = false);
      print('Capture Error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Capture Error: ${e.toString()}')),
      );
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _cameraController?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Stack(
          children: [
            Column(
              children: [
                // Header
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.arrow_back, color: Colors.white),
                        onPressed: () => Navigator.pop(context),
                      ),
                      Text(
                        "Take Selfie",
                        style: GoogleFonts.poppins(
                          color: Colors.white,
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
                Expanded(
                  child: _buildCameraPreview(),
                ),
              ],
            ),

            // Loading indicator overlay
            if (_isUploading)
              Container(
                color: Colors.black.withOpacity(0.5),
                child: const Center(
                  child: CircularProgressIndicator(
                    color: Color(0xFF8B5CF6),
                  ),
                ),
              ),
          ],
        ),
      ),
      floatingActionButton: !_isUploading ? FloatingActionButton(
        backgroundColor: const Color(0xFF8B5CF6),
        onPressed: _captureImage,
        child: const Icon(Icons.camera_alt, color: Colors.white),
      ) : null,
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
    );
  }
}



================================================
File: views/settings_screen.dart
================================================
// File: lib/views/settings_screen.dart
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class SettingsScreen extends ConsumerWidget {
  const SettingsScreen({super.key});

  Future<void> _showLogoutConfirmationDialog(
      BuildContext context, WidgetRef ref) async {
    return showDialog<void>(
      context: context,
      barrierDismissible: false, // User must tap button!
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text('Confirm Logout',
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          content: Text('Are you sure you want to log out?',
              style: GoogleFonts.poppins()),
          actions: <Widget>[
            TextButton(
              child: Text('Cancel',
                  style: GoogleFonts.poppins(color: Colors.grey)),
              onPressed: () {
                Navigator.of(dialogContext).pop(); // Close the dialog
              },
            ),
            TextButton(
              child: Text('Logout',
                  style: GoogleFonts.poppins(color: Colors.redAccent)),
              onPressed: () async {
                Navigator.of(dialogContext).pop(); // Close the dialog first
                await _performLogout(context, ref); // Perform logout
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _performLogout(BuildContext context, WidgetRef ref) async {
    print("[SettingsScreen] Performing logout...");
    // Call the logout method from the auth provider
    await ref.read(authProvider.notifier).logout();
    print("[SettingsScreen] Logout complete. Navigating to SignInScreen.");

    // Navigate to the sign-in screen and remove all previous routes
    // Check if context is still valid before navigating
    if (context.mounted) {
      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (context) => const GoogleSignInScreen()),
        (Route<dynamic> route) => false, // Remove all routes
      );
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      backgroundColor: Colors.grey[100], // Light background for settings
      appBar: AppBar(
        title: Text(
          'Settings',
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
        ),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 1,
      ),
      body: ListView(
        padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 16),
        children: [
          // Example Setting (can add more later)
          // ListTile(
          //   leading: Icon(Icons.notifications_outlined, color: Colors.grey[700]),
          //   title: Text('Notifications', style: GoogleFonts.poppins()),
          //   trailing: Icon(Icons.arrow_forward_ios_rounded, size: 16, color: Colors.grey[500]),
          //   onTap: () {
          //     // TODO: Navigate to Notification Settings
          //   },
          // ),
          // Divider(), // Separator

          // Logout Option
          ListTile(
            leading: Icon(Icons.logout_rounded, color: Colors.redAccent[200]),
            title: Text('Logout',
                style: GoogleFonts.poppins(color: Colors.redAccent[200])),
            onTap: () => _showLogoutConfirmationDialog(context, ref),
          ),
          Divider(),
        ],
      ),
    );
  }
}



================================================
File: views/smoking.dart
================================================
// File: lib/views/smoking.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/media.dart'; // Keep for onboarding flow

class SmokingScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const SmokingScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<SmokingScreen> createState() => _SmokingScreenState();
}

class _SmokingScreenState extends ConsumerState<SmokingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedSmokingHabit; // Local state
  // Removed _isOptionSelected
  late AnimationController _controller; // Keep for animations if desired
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );

    // Load initial value if editing
    if (widget.isEditing) {
      _selectedSmokingHabit = ref.read(userProvider).smokingHabit;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleNext() {
    if (_selectedSmokingHabit != null) {
      ref.read(userProvider.notifier).updateSmokingHabit(_selectedSmokingHabit);
      if (widget.isEditing) {
        print("[SmokingScreen] Editing done, popping back.");
        Navigator.of(context).pop();
      } else {
        // Original onboarding navigation
        print("[SmokingScreen] Onboarding next: Media.");
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const MediaPickerScreen()));
      }
    } else {
      if (!widget.isEditing) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content:
                Text("Please select an option", style: GoogleFonts.poppins()),
            backgroundColor: Colors.red[400],
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically
    final bool canProceed = _selectedSmokingHabit != null; // Check local state

    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder icon for onboarding
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: const Icon(Icons.smoking_rooms_rounded,
                            color: Color(0xFF8B5CF6),
                            size: 30), // Slightly smaller
                      ),
                    Text(
                      widget.isEditing ? "Edit Smoking Habit" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canProceed ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for onboarding
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.03),
              Text(
                widget.isEditing ? "Edit your smoking habits" : "Do you smoke?",
                textAlign: TextAlign.left,
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.07
                      : screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  height: 1.1,
                ),
              ),
              if (!widget.isEditing) // Show subtitle only during onboarding
                Text(
                  "Select your smoking habits",
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    color: Colors.grey[600],
                    height: 1.5,
                  ),
                ),
              SizedBox(height: screenSize.height * 0.04),
              Expanded(
                child: ListView.separated(
                  itemCount: DrinkingSmokingHabits.values.length,
                  separatorBuilder: (context, index) =>
                      const SizedBox(height: 12),
                  itemBuilder: (context, index) {
                    final habit = DrinkingSmokingHabits.values[index];
                    return _buildSmokingOptionTile(
                      screenSize: screenSize,
                      title: habit.label,
                      value: habit,
                    );
                  },
                ),
              ),
              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: AnimatedScale(
                      scale: canProceed ? 1.0 : 0.95, // Use local state
                      duration: const Duration(milliseconds: 200),
                      child: GestureDetector(
                        onTap: _handleNext, // Use unified handler
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey.shade300,
                            borderRadius: BorderRadius.circular(35),
                            boxShadow: canProceed
                                ? [
                                    BoxShadow(
                                      color: const Color(0xFF8B5CF6)
                                          .withOpacity(0.3),
                                      blurRadius: 8,
                                      offset: const Offset(0, 4),
                                    ),
                                  ]
                                : null,
                          ),
                          child: Icon(
                            Icons.arrow_forward_rounded,
                            color: canProceed
                                ? Colors.white
                                : Colors.grey.shade600,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSmokingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedSmokingHabit == value; // Use local state

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedSmokingHabit = value; // Update local state
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/splash_screen.dart
================================================
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart'; // Import FilterProvider
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:dtx/views/location.dart';
import 'package:dtx/views/main_navigation_screen.dart'; // Import MainNavigationScreen
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
// Removed FeedType import
// Removed NameInputScreen import
// Removed Home import

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnim;
  late Animation<double> _scaleAnim;
  bool _animationComplete = false;
  bool _statusCheckComplete = false;
  AuthStatus _authStatus = AuthStatus.unknown;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
    _checkAuthStatus();
  }

  void _setupAnimation() {
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );

    _fadeAnim = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.0, 0.8, curve: Curves.easeIn),
      ),
    );

    _scaleAnim = Tween<double>(begin: 0.7, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.elasticOut,
      ),
    );

    _controller.forward();

    Future.delayed(const Duration(milliseconds: 2000), () {
      if (mounted) {
        setState(() {
          _animationComplete = true;
        });
        _navigateIfReady();
      }
    });
  }

  Future<void> _checkAuthStatus() async {
    print('[SplashScreen] Checking Auth Status...');
    try {
      final status = await ref
          .read(authProvider.notifier)
          .checkAuthStatus(updateState: false);
      print('[SplashScreen] Auth Status Check Result: $status');

      if (!mounted) return;

      setState(() {
        _authStatus = status;
        _statusCheckComplete = true;
      });
      _navigateIfReady();
    } catch (e) {
      print('[SplashScreen] Error during Auth Status Check: $e');
      if (!mounted) return;
      setState(() {
        _authStatus = AuthStatus.login; // Default to login on error
        _statusCheckComplete = true;
      });
      _navigateIfReady();
    }
  }

  void _initiateEarlyFetches() {
    print("[SplashScreen] Initiating early data fetches (Filters, HomeFeed).");
    // Don't await, let them run in background
    ref.read(filterProvider.notifier).loadFilters();
    ref.read(feedProvider.notifier).fetchFeed();
  }

  void _navigateIfReady() {
    print(
        '[SplashScreen] Navigate If Ready: Animation Complete=$_animationComplete, Status Check Complete=$_statusCheckComplete, Status=$_authStatus');

    if (_animationComplete && _statusCheckComplete) {
      print('[SplashScreen] Conditions met. Navigating...');
      Widget destination;

      switch (_authStatus) {
        case AuthStatus.home:
        case AuthStatus
              .onboarding2: // Both home and onboarding2 go to main screen
          print('[SplashScreen] Navigating to MainNavigationScreen');
          _initiateEarlyFetches(); // Start loading data needed for MainNavigationScreen
          destination = const MainNavigationScreen();
          break;
        case AuthStatus.onboarding1:
          print('[SplashScreen] Navigating to LocationInputScreen');
          destination = const LocationInputScreen();
          break;
        case AuthStatus.login:
        case AuthStatus.unknown:
        default:
          print('[SplashScreen] Navigating to GoogleSignInScreen');
          destination = const GoogleSignInScreen();
          break;
      }

      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (_) => destination),
      );
    } else {
      print('[SplashScreen] Conditions not met. Waiting...');
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Build method remains largely the same, only navigation logic changed
    final Size screenSize = MediaQuery.of(context).size;
    final double responsiveFontSize = screenSize.width * 0.18;
    final double subtitleFontSize = screenSize.width * 0.04;
    final double bottomPadding = screenSize.height * 0.05;

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF4C1D95), Color(0xFF7C3AED), Color(0xFF8B5CF6)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Stack(
          children: [
            Center(
              child: AnimatedBuilder(
                animation: _controller,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Transform.scale(
                      scale: _scaleAnim.value,
                      child: FittedBox(
                        fit: BoxFit.scaleDown,
                        child: Text(
                          'Peeple',
                          style: GoogleFonts.pacifico(
                            fontSize: responsiveFontSize,
                            color: Colors.white,
                            shadows: [
                              Shadow(
                                color: Colors.black.withOpacity(0.6),
                                blurRadius: 15,
                                offset: const Offset(0, 4),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
            Positioned(
              bottom: bottomPadding,
              left: 0,
              right: 0,
              child: AnimatedBuilder(
                animation: _fadeAnim,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Text(
                      'Connect. Share. Thrive.',
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                        color: Colors.white.withOpacity(0.9),
                        fontSize: subtitleFontSize,
                        fontWeight: FontWeight.w300,
                        letterSpacing: 0.5,
                      ),
                    ),
                  );
                },
              ),
            ),
            if (_animationComplete && !_statusCheckComplete)
              Positioned(
                bottom: bottomPadding + 50,
                left: 0,
                right: 0,
                child: const Center(
                  child: SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(
                      strokeWidth: 2.5,
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/study.dart
================================================
// File: lib/views/study.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/religion.dart'; // Keep for onboarding flow

class StudyLocationScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const StudyLocationScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<StudyLocationScreen> createState() =>
      _StudyLocationScreenState();
}

class _StudyLocationScreenState extends ConsumerState<StudyLocationScreen> {
  final TextEditingController _studyLocationController =
      TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _studyLocationController.text = ref.read(userProvider).education ?? '';
    }
    // Add listener to enable/disable Done button in edit mode if needed
    _studyLocationController.addListener(() {
      if (widget.isEditing) setState(() {});
    });
  }

  @override
  void dispose() {
    _studyLocationController.dispose();
    super.dispose();
  }

  void _handleNext() {
    String? education;
    if (_studyLocationController.text.trim().isNotEmpty) {
      education = _studyLocationController.text.trim();
    } else {
      education = null; // Explicitly set to null if empty
    }
    ref.read(userProvider.notifier).updateEducation(education);

    if (widget.isEditing) {
      print("[StudyLocationScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[StudyLocationScreen] Onboarding next: Religion.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const ReligionScreen()));
    }
  }

  void _handleSkipOrClear() {
    FocusScope.of(context).unfocus();
    _studyLocationController.clear(); // Clear text field
    ref
        .read(userProvider.notifier)
        .updateEducation(null); // Update provider to null
    if (widget.isEditing) {
      print("[StudyLocationScreen] Clearing field and popping back.");
      Navigator.of(context).pop(); // Pop back immediately after clearing
    } else {
      // Original onboarding skip navigation
      print("[StudyLocationScreen] Skipping to Religion.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const ReligionScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      IconButton(
                        // Keep original icon for onboarding
                        icon: const Icon(Icons.school_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {}, // No action needed here
                      ),

                    Text(
                      widget.isEditing ? "Edit Education" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    // Show "Done" in edit mode, "Skip" in onboarding
                    if (widget.isEditing)
                      TextButton(
                        onPressed: _handleNext, // Always enabled
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color:
                                const Color(0xFF8B5CF6), // Always enabled color
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      TextButton(
                        onPressed: _handleSkipOrClear, // Use unified handler
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                              fontSize: 16, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),

              // Question Text
              Text(
                widget.isEditing
                    ? "Edit where you studied"
                    : "Where did you study?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),

              SizedBox(height: screenSize.height * 0.05),

              // Text Field
              Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                child: TextField(
                  controller: _studyLocationController,
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    color: Colors.black87,
                  ),
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    hintText: "e.g., IIT Delhi",
                    hintStyle: GoogleFonts.poppins(
                      fontSize: 22,
                      color: Colors.grey.shade500,
                    ),
                    border: const UnderlineInputBorder(
                      borderSide: BorderSide(color: Colors.grey, width: 1.0),
                    ),
                    focusedBorder: const UnderlineInputBorder(
                      borderSide:
                          BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                    ),
                    // Add clear button in edit mode if text exists
                    suffixIcon: widget.isEditing &&
                            _studyLocationController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, color: Colors.grey),
                            onPressed: () {
                              _studyLocationController.clear();
                            },
                          )
                        : null,
                  ),
                ),
              ),

              const Spacer(),

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: GestureDetector(
                      onTap: _handleNext, // Always enabled for onboarding
                      child: Container(
                        width: 70,
                        height: 70,
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(35),
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/textpromptsselect.dart
================================================
// File: lib/views/textpromptsselect.dart
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Import Riverpod
import 'package:dtx/providers/user_provider.dart'; // Import UserProvider
import 'package:dtx/utils/app_enums.dart';
import 'package:google_fonts/google_fonts.dart'; // Import GoogleFonts

// Change StatefulWidget to ConsumerStatefulWidget
class TextSelectPromptScreen extends ConsumerStatefulWidget {
  final int? editIndex;
  final bool isEditing;

  const TextSelectPromptScreen({
    super.key,
    this.editIndex,
    this.isEditing = false,
  });

  @override
  ConsumerState<TextSelectPromptScreen> createState() =>
      _TextSelectPromptScreenState();
}

// Change State to ConsumerState
class _TextSelectPromptScreenState
    extends ConsumerState<TextSelectPromptScreen> {
  PromptCategory selectedCategory = PromptCategory.storyTime;
  bool showAllPrompts = false;

  List<PromptType> get currentPrompts {
    if (showAllPrompts) {
      return PromptCategory.values
          .expand((category) => category.getPrompts())
          .toList();
    }
    return selectedCategory.getPrompts();
  }

  // Function to check for duplicates
  bool _isDuplicate(PromptType selectedPromptType) {
    final existingPrompts = ref.read(userProvider).prompts;
    for (int i = 0; i < existingPrompts.length; i++) {
      // Skip check if editing the current index
      if (widget.isEditing && widget.editIndex == i) {
        continue;
      }
      if (existingPrompts[i].question == selectedPromptType) {
        return true; // Found a duplicate
      }
    }
    return false; // No duplicate found
  }

  @override
  Widget build(BuildContext context) {
    // Read existing prompts to disable selected ones
    final existingPromptQuestions = ref.watch(userProvider
        .select((user) => user.prompts.map((p) => p.question).toSet()));

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  GestureDetector(
                    onTap: () {
                      setState(() {
                        showAllPrompts = !showAllPrompts;
                      });
                    },
                    child: Text(
                      showAllPrompts ? 'View by Category' : 'View all',
                      style: TextStyle(
                        color: const Color(0xFF8b5cf6),
                        fontSize: 16,
                        fontWeight:
                            showAllPrompts ? FontWeight.bold : FontWeight.w500,
                      ),
                    ),
                  ),
                  Text(
                    'Prompts', // Keep title centered
                    style: GoogleFonts.poppins(
                      // Use GoogleFonts if desired
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () => Navigator.pop(context),
                    child: const Icon(Icons.close),
                  ),
                ],
              ),
            ),
            if (!showAllPrompts)
              SingleChildScrollView(
                // ... Category chips (unchanged) ...
                scrollDirection: Axis.horizontal,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: Row(
                  children: PromptCategory.values.map((category) {
                    final isSelected = category == selectedCategory;
                    return Padding(
                      padding: const EdgeInsets.only(right: 8),
                      child: GestureDetector(
                        onTap: () =>
                            setState(() => selectedCategory = category),
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 20,
                            vertical: 10,
                          ),
                          decoration: BoxDecoration(
                            color: isSelected
                                ? const Color(0xFF8b5cf6)
                                : Colors.white,
                            borderRadius: BorderRadius.circular(20),
                            border: Border.all(
                              color: const Color(0xFF8b5cf6),
                              width: 1,
                            ),
                          ),
                          child: Text(
                            category.label,
                            style: TextStyle(
                              color: isSelected
                                  ? Colors.white
                                  : const Color(0xFF8b5cf6),
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ),
            const SizedBox(height: 16),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: currentPrompts.length,
                itemBuilder: (context, index) {
                  final promptType = currentPrompts[index];
                  final bool isAlreadySelected =
                      existingPromptQuestions.contains(promptType);
                  final bool isEditingThisPrompt = widget.isEditing &&
                      widget.editIndex != null &&
                      ref.read(userProvider).prompts.length >
                          widget.editIndex! &&
                      ref
                              .read(userProvider)
                              .prompts[widget.editIndex!]
                              .question ==
                          promptType;

                  final bool isDisabled = isAlreadySelected &&
                      !isEditingThisPrompt; // Disable if selected elsewhere

                  return GestureDetector(
                    onTap: isDisabled
                        ? null
                        : () async {
                            // Make onTap async
                            final category = promptType.getCategory();
                            // Navigate and wait for result
                            final result = await Navigator.push(
                              // <-- Use await
                              context,
                              MaterialPageRoute(
                                builder: (context) => WriteAnswerScreen(
                                  category: category,
                                  question: promptType,
                                  editIndex: widget.editIndex,
                                  isEditing: widget.isEditing,
                                ),
                              ),
                            );

                            // If NOT editing and WriteAnswerScreen popped with success (true)
                            if (!widget.isEditing &&
                                result == true &&
                                context.mounted) {
                              // Pop this screen (TextSelectPromptScreen) to go back to ProfileAnswersScreen
                              Navigator.pop(context);
                            }
                          },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                      ),
                      child: Text(
                        promptType.label,
                        style: TextStyle(
                          fontSize: 16,
                          // Dim text if disabled
                          color: isDisabled ? Colors.grey[400] : Colors.black87,
                          // Add strike-through if disabled? (Optional)
                          // decoration: isDisabled ? TextDecoration.lineThrough : null,
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/verification_message_screen.dart
================================================

import 'package:dtx/views/home.dart';
import 'package:dtx/views/selfie_capture_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationMessageScreen extends StatelessWidget {
  const VerificationMessageScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40), // Top spacing
              // Illustration or Icon
              Container(
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  shape: BoxShape.circle,
                ),
                child: Center(
                  child: Icon(
                    Icons.verified_user_outlined,
                    size: 100,
                    color: const Color(0xFF8B5CF6),
                  ),
                ),
              ),
              const SizedBox(height: 32),
              // Title
              Text(
                "Profile Verification",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 16),
              // Subtitle/Description
              Text(
                "We are verifying your profile to ensure that no one else can use your photo. This helps us keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),
              const Spacer(), // Pushes the button to the bottom
              // Continue Button
              GestureDetector(
onTap: () {
  // Navigate to HomeScreen
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(builder: (context) => const SelfieCaptureScreen(),
  ));
},
                child: Container(
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 32), // Bottom spacing
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/verification_pending_screen.dart
================================================
// File: views/verification_pending_screen.dart
import 'dart:io';
// Removed FeedType import
// Import MainNavigationScreen
import 'package:dtx/views/main_navigation_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationPendingScreen extends StatelessWidget {
  final File? selfieImage;

  const VerificationPendingScreen({
    Key? key,
    this.selfieImage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              // ... (rest of the build method remains the same until the button) ...
              const SizedBox(height: 40),

              // Selfie preview (keep existing)
              Container(
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: const Color(0xFF8B5CF6),
                    width: 4,
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: const Color(0xFF8B5CF6).withOpacity(0.2),
                      blurRadius: 15,
                      spreadRadius: 5,
                    ),
                  ],
                ),
                child: ClipOval(
                  child: selfieImage != null
                      ? Image.file(
                          selfieImage!,
                          fit: BoxFit.cover,
                        )
                      : Container(
                          color: Colors.grey[200],
                          child: Icon(
                            Icons.person,
                            size: 80,
                            color: Colors.grey[400],
                          ),
                        ),
                ),
              ),
              const SizedBox(height: 32),
              Text(
                "Verification in Progress",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 16),
              Text(
                "We're verifying your profile to ensure no one else can use your photos. This helps keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),
              const SizedBox(height: 24),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 20,
                  vertical: 12,
                ),
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          Color(0xFF8B5CF6),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Text(
                      "Verification in progress",
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF8B5CF6),
                      ),
                    ),
                  ],
                ),
              ),
              const Spacer(),

              // Continue Button - FIXED NAVIGATION
              GestureDetector(
                onTap: () {
                  Navigator.pushAndRemoveUntil(
                    context,
                    MaterialPageRoute(
                      // Navigate to MainNavigationScreen instead of HomeScreen
                      builder: (context) => const MainNavigationScreen(),
                    ),
                    (route) => false, // Remove all previous routes
                  );
                },
                child: Container(
                  /* ... Button container ... */
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue Swiping",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/who_liked_you_screen.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/views/liker_profile_screen.dart';
import 'package:dtx/widgets/basic_liker_profile_card.dart';
import 'package:dtx/widgets/full_liker_profile_card.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class WhoLikedYouScreen extends ConsumerStatefulWidget {
  const WhoLikedYouScreen({super.key});

  @override
  ConsumerState<WhoLikedYouScreen> createState() => _WhoLikedYouScreenState();
}

class _WhoLikedYouScreenState extends ConsumerState<WhoLikedYouScreen> {
  @override
  void initState() {
    super.initState();
    // Fetching is initiated in MainNavigationScreen initState now
  }

  // _navigateToLikerProfile remains the same...
  void _navigateToLikerProfile(int likerUserId) {
    print(
        "[WhoLikedYouScreen] Navigating to profile for liker ID: $likerUserId");
    ref.read(errorProvider.notifier).clearError();
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => LikerProfileScreen(likerUserId: likerUserId),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(receivedLikesProvider);
    // Error watching remains the same
    final generalError = ref.watch(errorProvider);
    final displayError = state.error ?? generalError;

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text("Likes You've Received",
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        elevation: 1,
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        automaticallyImplyLeading: false,
      ),
      body: RefreshIndicator(
        color: const Color(0xFF8B5CF6),
        onRefresh: () async {
          // Clear previous error before refresh if needed
          ref.read(errorProvider.notifier).clearError();
          await ref.read(receivedLikesProvider.notifier).fetchLikes();
        },
        // *** Check isLoading state from the provider ***
        child: state.isLoading // Check the provider's loading state directly
            ? const Center(
                child: CircularProgressIndicator(color: Color(0xFF8B5CF6)))
            : _buildBody(state, displayError), // Pass state and combined error
      ),
    );
  }

  // _buildBody should now assume isLoading is false when called
  Widget _buildBody(ReceivedLikesState state, AppError? error) {
    if (error != null) {
      return _buildErrorState(error.message);
    }

    if (state.fullProfiles.isEmpty && state.otherLikers.isEmpty) {
      return _buildEmptyState();
    }

    // CustomScrollView structure remains the same
    return CustomScrollView(
      slivers: [
        if (state.fullProfiles.isNotEmpty)
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 20, 16, 12),
              child: Text(
                "Recent Likes & Roses",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[800],
                ),
              ),
            ),
          ),
        if (state.fullProfiles.isNotEmpty)
          SliverPadding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            sliver: SliverGrid(
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2,
                crossAxisSpacing: 12,
                mainAxisSpacing: 12,
                childAspectRatio: 0.75,
              ),
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  final liker = state.fullProfiles[index];
                  return FullLikerProfileCard(
                    liker: liker,
                    onTap: () => _navigateToLikerProfile(liker.likerUserId),
                  );
                },
                childCount: state.fullProfiles.length,
              ),
            ),
          ),
        if (state.otherLikers.isNotEmpty)
          SliverToBoxAdapter(
            child: Padding(
              padding: EdgeInsets.fromLTRB(
                  16, state.fullProfiles.isNotEmpty ? 24 : 20, 16, 12),
              child: Text(
                state.fullProfiles.isNotEmpty ? "Older Likes" : "Likes",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[800],
                ),
              ),
            ),
          ),
        if (state.otherLikers.isNotEmpty)
          SliverPadding(
            padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
            sliver: SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  final liker = state.otherLikers[index];
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 10.0),
                    child: BasicLikerProfileCard(
                      liker: liker,
                      onTap: () => _navigateToLikerProfile(liker.likerUserId),
                    ),
                  );
                },
                childCount: state.otherLikers.length,
              ),
            ),
          ),
        const SliverToBoxAdapter(child: SizedBox(height: 20)),
      ],
    );
  }

  // _buildEmptyState and _buildErrorState remain the same
  Widget _buildEmptyState() {
    return LayoutBuilder(
      // Use LayoutBuilder to ensure Center takes full space for scrollable refresh
      builder: (context, constraints) => SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(30.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.favorite_border_rounded,
                      size: 70, color: Colors.grey[300]),
                  const SizedBox(height: 20),
                  Text("No Likes Yet",
                      style: GoogleFonts.poppins(
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey[700])),
                  const SizedBox(height: 10),
                  Text("People who like you will appear here.",
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                          fontSize: 15, color: Colors.grey[500])),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildErrorState(String message) {
    return LayoutBuilder(
      // Use LayoutBuilder for scrollable refresh
      builder: (context, constraints) => SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(30.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline_rounded,
                      size: 60, color: Colors.redAccent[100]),
                  const SizedBox(height: 20),
                  Text("Oops!",
                      style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey[700])),
                  const SizedBox(height: 10),
                  Text(message,
                      style: GoogleFonts.poppins(
                          fontSize: 14, color: Colors.grey[600]),
                      textAlign: TextAlign.center),
                  const SizedBox(height: 20),
                  ElevatedButton.icon(
                    icon: const Icon(Icons.refresh_rounded, size: 18),
                    label: const Text("Retry"),
                    style: ElevatedButton.styleFrom(
                      foregroundColor: Colors.white,
                      backgroundColor: const Color(0xFF8B5CF6),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(20)),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 30, vertical: 12),
                    ),
                    onPressed: () =>
                        ref.read(receivedLikesProvider.notifier).fetchLikes(),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/writeprompt.dart
================================================
// File: lib/views/writeprompt.dart
import 'package:dtx/utils/app_enums.dart';
// Removed unused prompt.dart import
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// Removed unused google_fonts import
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/models/user_model.dart';

class WriteAnswerScreen extends ConsumerStatefulWidget {
  final PromptCategory category;
  final PromptType question;
  final int? editIndex;
  final bool isEditing; // <<< ADDED

  const WriteAnswerScreen({
    super.key,
    required this.category,
    required this.question,
    this.editIndex,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<WriteAnswerScreen> createState() => _WriteAnswerScreenState();
}

class _WriteAnswerScreenState extends ConsumerState<WriteAnswerScreen> {
  late final TextEditingController _answerController;

  @override
  void initState() {
    super.initState();
    _answerController = TextEditingController();
    _loadExistingAnswer();

    // Add listener to update UI when text changes
    _answerController.addListener(() {
      if (mounted) {
        setState(() {}); // Trigger rebuild to enable/disable Done button
      }
    });
  }

  void _loadExistingAnswer() {
    // Load only if editing an *existing* prompt (editIndex is not null)
    if (widget.editIndex != null && widget.isEditing) {
      final prompts = ref.read(userProvider).prompts;
      if (widget.editIndex! < prompts.length) {
        // Check if the question being edited matches the passed question
        // This prevents loading the wrong answer if the user selected a different question for the same slot
        if (prompts[widget.editIndex!].question == widget.question) {
          _answerController.text = prompts[widget.editIndex!].answer;
        } else {
          print(
              "Warning: Editing index ${widget.editIndex} but question changed. Starting fresh.");
        }
      }
    }
  }

  void _saveAnswer() {
    final answerText = _answerController.text.trim();
    bool actionTaken = false; // Flag to check if any action was performed

    if (answerText.isNotEmpty) {
      final newPrompt = Prompt(
        category: widget.category,
        question: widget.question,
        answer: answerText,
      );

      int targetIndex =
          widget.editIndex ?? ref.read(userProvider).prompts.length;

      if (widget.editIndex != null &&
          widget.editIndex! < ref.read(userProvider).prompts.length) {
        ref
            .read(userProvider.notifier)
            .updatePromptAtIndex(widget.editIndex!, newPrompt);
        print("Updated prompt at index: ${widget.editIndex}");
        actionTaken = true;
      } else if (ref.read(userProvider).prompts.length < 3) {
        ref.read(userProvider.notifier).addPrompt(newPrompt);
        print("Added new prompt.");
        actionTaken = true;
      } else {
        print("Error: Cannot add prompt, maximum reached.");
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("You can only have 3 prompts.")));
        return;
      }

      // Navigate back
      if (widget.isEditing) {
        // Pop twice for editing
        int popCount = 0;
        Navigator.of(context).popUntil((route) => popCount++ == 2);
      } else {
        // Onboarding: Pop once and signal success
        Navigator.of(context).pop(true); // <-- Signal success
      }
    } else if (widget.isEditing && widget.editIndex != null) {
      // Handle clearing existing prompt during edit
      print(
          "Removing prompt at index: ${widget.editIndex} due to empty answer.");
      ref.read(userProvider.notifier).removePromptAtIndex(widget.editIndex!);
      actionTaken = true;
      // Pop twice for editing
      int popCount = 0;
      Navigator.of(context).popUntil((route) => popCount++ == 2);
    } else if (!widget.isEditing) {
      // Don't allow saving empty prompt during onboarding if "Done" is pressed
      ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Please enter an answer.")));
      return; // Stay on the screen
    }

    // If no action was taken but user pressed Done (e.g., editing non-existent index with empty text)
    if (!actionTaken) {
      // Just pop back once (likely from TextSelectPromptScreen)
      Navigator.of(context).pop(false); // Signal no change made
    }
  }

  @override
  void dispose() {
    _answerController.dispose(); // Clean up the controller
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final bool canSave = _answerController.text.trim().isNotEmpty;
    // Or, if clearing is allowed via Done button:
    // final bool canSave = true; // Always allow Done, handle empty in _saveAnswer

    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 1,
        centerTitle: true,
        title: Text(
          widget.editIndex != null && widget.isEditing
              ? 'Edit Answer'
              : 'Write Answer', // Dynamic title
          style: const TextStyle(
            color: Colors.black,
            fontSize: 18,
            fontWeight: FontWeight.w700,
          ),
        ),
        leadingWidth: 80,
        leading: GestureDetector(
          onTap: () => Navigator.pop(context), // Always pop back to selection
          child: const Center(
            child: Text(
              'Cancel',
              style: TextStyle(
                color: Color(0xFF8B5CF6),
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ),
        actions: [
          TextButton(
            // Enable based on whether text is present OR if editing an existing prompt (to allow clearing)
            onPressed: canSave || (widget.isEditing && widget.editIndex != null)
                ? _saveAnswer
                : null,
            child: Text(
              'Done',
              style: TextStyle(
                // Adjust color based on combined condition
                color: canSave || (widget.isEditing && widget.editIndex != null)
                    ? const Color(0xFF8B5CF6)
                    : const Color(0xFF8B5CF6).withOpacity(0.5),
                fontSize: 16,
                fontWeight: FontWeight.w700,
              ),
            ),
          ),
        ],
      ),
      body: SingleChildScrollView(
        // Wrap in SingleChildScrollView
        child: Column(
          children: [
            const SizedBox(height: 64),
            Container(
              margin: const EdgeInsets.symmetric(horizontal: 16),
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: const Color(0xFF8B5CF6).withOpacity(0.3),
                  width: 2,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.grey.withOpacity(0.1),
                    spreadRadius: 2,
                    blurRadius: 8,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      widget.question.label,
                      style: const TextStyle(
                        fontSize: 17,
                        fontWeight: FontWeight.w600,
                        color: Colors.black87,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Icon(
                    // Dynamic icon based on action
                    widget.editIndex != null && widget.isEditing
                        ? Icons.edit_note_rounded
                        : Icons.question_answer_outlined,
                    color: const Color(0xFF8B5CF6).withOpacity(0.8),
                    size: 24,
                  ),
                ],
              ),
            ),
            const SizedBox(height: 54),
            Container(
              height: 200,
              margin: const EdgeInsets.symmetric(horizontal: 16),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: const Color(0xFFE5E7EB),
                  width: 1.5,
                ),
              ),
              child: Stack(
                children: [
                  Padding(
                    padding: const EdgeInsets.all(16),
                    child: TextField(
                      controller: _answerController,
                      maxLength: 255,
                      maxLines: null, // Allows multiline input
                      minLines: 5, // Set a minimum line count
                      keyboardType: TextInputType
                          .multiline, // Explicitly set keyboard type
                      textCapitalization:
                          TextCapitalization.sentences, // Capitalize sentences
                      style: const TextStyle(
                        fontSize: 16,
                        color: Colors.black87,
                        height: 1.4,
                      ),
                      decoration: const InputDecoration(
                        border: InputBorder.none,
                        hintText: 'Type your answer here...',
                        hintStyle: TextStyle(
                          color: Color(0xFF94A3B8),
                          fontSize: 16,
                          fontWeight: FontWeight.w400,
                        ),
                        counterText: '', // Hide the default counter
                      ),
                    ),
                  ),
                  Positioned(
                    right: 16,
                    bottom: 16,
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: Colors.grey[100],
                        borderRadius: BorderRadius.circular(6),
                      ),
                      child: Text(
                        // Use characters method for accurate length including newlines
                        '${_answerController.text.characters.length}/255',
                        style: const TextStyle(
                          color: Color(0xFF64748B),
                          fontSize: 13,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 24),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/youtube.dart
================================================
import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:flutter/services.dart'; // Required for Clipboard

// --- Configuration (kept outside the widget for clarity) ---

// Define the necessary YouTube scope
const List<String> _scopes = <String>[
  'https://www.googleapis.com/auth/youtube.readonly',
];

// Instantiate GoogleSignIn with the defined scopes
// You might want to manage this instance more globally in your app
// (e.g., using a service locator or provider) if other parts need it,
// but keeping it here works for a self-contained screen.
final GoogleSignIn _googleSignIn = GoogleSignIn(
  scopes: _scopes,
);

// --- Screen Widget ---

class YoutubeSignInScreen extends StatefulWidget {
  // You can add parameters here if needed, e.g., callbacks for when login succeeds/fails
  // final VoidCallback? onLoginSuccess;
  // final Function(String)? onTokenReceived;

  const YoutubeSignInScreen({
    super.key,
    // this.onLoginSuccess,
    // this.onTokenReceived,
  });

  @override
  State<YoutubeSignInScreen> createState() => _YoutubeSignInScreenState();
}

class _YoutubeSignInScreenState extends State<YoutubeSignInScreen> {
  GoogleSignInAccount? _currentUser;
  String _message = 'Not logged in';
  String? _accessToken; // To store the access token
  bool _isSigningIn = false; // To prevent multiple sign-in attempts
  bool _isFetchingToken = false; // To show progress while getting token

  @override
  void initState() {
    super.initState();

    // Listen for user changes (e.g., sign out from elsewhere or successful sign-in)
    _googleSignIn.onCurrentUserChanged.listen((GoogleSignInAccount? account) {
      // Important: Check if the widget is still mounted before calling setState
      if (mounted) {
        _updateUser(account);
      }
    }).onError((error) {
      // Handle stream errors if necessary
      print("Error listening to user changes: $error");
      if (mounted) {
        setState(() {
          _message = "Error listening for user changes.";
          _currentUser = null;
          _accessToken = null;
        });
      }
    });

    // Try silent sign-in on screen initialization
    // Make sure this doesn't interfere with other login logic in your app
    _googleSignIn.signInSilently().then((account) {
      // No need to call _updateUser here, the listener above will handle it
    }).catchError((err) {
      print('Error during silent sign-in attempt: $err');
      // Don't necessarily show an error here, silent sign-in failing is common
      if (mounted) {
        setState(() {
          _message = 'Not logged in (silent sign-in failed or not available)';
        });
      }
    });
  }

  @override
  void dispose() {
    // It's generally good practice to cancel stream subscriptions,
    // though onCurrentUserChanged might be managed internally by the plugin.
    // If you had custom StreamSubscriptions, you'd cancel them here.
    super.dispose();
  }

  void _updateUser(GoogleSignInAccount? account) async {
    // Check mounted again just to be safe, especially with async operations
    if (!mounted) return;

    setState(() {
      _currentUser = account;
      _accessToken = null; // Reset token when user changes
      _isFetchingToken = account != null; // Start fetching if user is not null
      if (_currentUser != null) {
        _message =
            "Logged in as ${_currentUser!.displayName ?? _currentUser!.email}";
      } else {
        _message = "Not logged in";
      }
    });

    // If user is logged in, print details and get the access token
    if (_currentUser != null) {
      // --- ADDED: Print User Details to Console ---
      print("--- Google User Details ---");
      print(
          "Display Name: ${_currentUser!.displayName ?? 'Not Provided'}"); // Handle potential null display name
      print("Email: ${_currentUser!.email}");
      print("User ID: ${_currentUser!.id}"); // Added User ID as well
      print("---------------------------");
      // --- END ADDED ---

      await _getAccessToken();
    }
  }

  // Function to get the access token
  Future<void> _getAccessToken() async {
    if (_currentUser == null) return;

    // Ensure mounted check before async operation and setState
    if (!mounted) return;

    setState(() {
      _isFetchingToken = true; // Show loading indicator
    });

    try {
      final GoogleSignInAuthentication auth =
          await _currentUser!.authentication;
      if (mounted) {
        // Check again after await
        setState(() {
          _accessToken = auth.accessToken;
          _isFetchingToken = false; // Hide loading indicator
          print("Access Token: $_accessToken"); // Print for debugging
          print("ID Token: ${auth.idToken}"); // Also available
          // Optional: Call a callback if provided via widget constructor
          // widget.onTokenReceived?.call(_accessToken!);
        });
      }
    } catch (err) {
      print('Error getting authentication token: $err');
      if (mounted) {
        // Check again after await
        setState(() {
          _message = 'Error getting token: $err';
          _accessToken = null;
          _isFetchingToken = false; // Hide loading indicator
        });
      }
    }
  }

  // Sign-in function
  Future<void> _handleSignIn() async {
    if (_isSigningIn) return; // Prevent double taps

    if (!mounted) return;
    setState(() {
      _isSigningIn = true;
      _message = "Signing in..."; // Provide feedback
    });

    try {
      // Start the sign-in process
      await _googleSignIn.signIn();
      // The onCurrentUserChanged listener will handle the update upon success.
      // If signIn() returns null (user cancelled), the listener will also get null.
    } catch (error) {
      print('Error signing in: $error');
      if (mounted) {
        // Check after await
        setState(() {
          _message = 'Error signing in: $error';
          _accessToken = null; // Clear token on error
        });
      }
    } finally {
      if (mounted) {
        // Check in finally block
        setState(() {
          _isSigningIn = false; // Allow sign-in attempts again
          // If _currentUser is still null here, sign-in likely failed or was cancelled
          if (_currentUser == null && !_message.startsWith("Error")) {
            _message = "Sign in cancelled or failed.";
          }
        });
      }
    }
  }

  // Sign-out function
  Future<void> _handleSignOut() async {
    if (!mounted) return;

    setState(() {
      _message = "Signing out...";
    });

    try {
      // Disconnect removes permissions, signOut just logs out locally
      await _googleSignIn.disconnect();
      // The onCurrentUserChanged listener handles the UI update.
    } catch (error) {
      print('Error signing out: $error');
      if (mounted) {
        // Check after await
        setState(() {
          // Restore user info if disconnect fails? Or keep logged-out state?
          // Keeping logged-out state might be less confusing.
          _message = 'Error signing out: $error';
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Determine button states
    final bool canSignIn = !_isSigningIn && _currentUser == null;
    final bool canSignOut = _currentUser != null;
    final bool showTokenInfo = _currentUser != null;
    final bool showCopyButton = _accessToken != null;

    return Scaffold(
      // You might want to remove this AppBar if the screen is embedded
      // within another Scaffold that already has one.
      appBar: AppBar(
        title: const Text('YouTube Account Login'),
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment:
                CrossAxisAlignment.center, // Center items horizontally
            children: <Widget>[
              // Display User Info or Status Message
              if (showTokenInfo) ...[
                ListTile(
                  leading: GoogleUserCircleAvatar(identity: _currentUser!),
                  title: Text(_currentUser!.displayName ?? 'No Name'),
                  subtitle: Text(_currentUser!.email),
                  contentPadding: EdgeInsets.zero, // Adjust padding if needed
                ),
                const SizedBox(height: 20),
                const Text("Access Token:",
                    style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 5),
                if (_isFetchingToken)
                  const Padding(
                    padding: EdgeInsets.symmetric(vertical: 10.0),
                    child: CircularProgressIndicator(),
                  )
                else if (_accessToken != null)
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey.shade300),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: SelectableText(
                      _accessToken!,
                      style: const TextStyle(fontSize: 12),
                      textAlign: TextAlign.center,
                      maxLines: 5, // Limit display lines if needed
                      scrollPhysics:
                          const ClampingScrollPhysics(), // Prevent scrolling within text box
                    ),
                  )
                else
                  const Text("Could not retrieve token.",
                      style:
                          TextStyle(color: Colors.red)), // Show if fetch failed
                const SizedBox(height: 10),
                ElevatedButton.icon(
                  icon: const Icon(Icons.copy, size: 16),
                  label: const Text('Copy Token'),
                  onPressed: showCopyButton
                      ? () {
                          Clipboard.setData(ClipboardData(text: _accessToken!));
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text('Access Token Copied!'),
                                duration: Duration(seconds: 2)),
                          );
                        }
                      : null, // Disable button if no token
                ),
              ] else ...[
                // Show Status Message when logged out or during sign-in process
                Text(_message, textAlign: TextAlign.center),
                const SizedBox(height: 20),
              ],

              const Spacer(), // Pushes buttons towards the bottom if desired

              // Sign In / Sign Out Buttons
              if (canSignIn)
                ElevatedButton.icon(
                  icon: const Icon(Icons.login),
                  label: const Text('Sign In with Google'),
                  onPressed: _handleSignIn,
                  style: ElevatedButton.styleFrom(
                      minimumSize:
                          const Size(200, 40)), // Ensure decent button size
                )
              else if (_isSigningIn)
                const CircularProgressIndicator() // Show progress during sign-in action
              else if (canSignOut)
                ElevatedButton.icon(
                  icon: const Icon(Icons.logout),
                  label: const Text('Sign Out & Disconnect'),
                  onPressed: _handleSignOut,
                  style: ElevatedButton.styleFrom(
                      backgroundColor:
                          Colors.redAccent, // Indicate destructive action
                      minimumSize: const Size(200, 40)),
                ),
              const SizedBox(height: 20), // Add some padding at the bottom
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/core/error_handler.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/models/error_model.dart';

class GlobalErrorHandler extends ConsumerWidget {
  final Widget child;
  const GlobalErrorHandler({super.key, required this.child});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final error = ref.watch(errorProvider);

    return Stack(
      children: [
        child,
        if (error != null) _buildErrorOverlay(context, error, ref),
      ],
    );
  }

  Widget _buildErrorOverlay(
      BuildContext context, AppError error, WidgetRef ref) {
    return Positioned.fill(
      child: Material(
        color: Colors.black54,
        child: Center(
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 20),
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  error.message,
                  style: const TextStyle(fontSize: 16),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () =>
                      ref.read(errorProvider.notifier).clearError(),
                  child: const Text('OK'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: widgets/basic_liker_profile_card.dart
================================================
// File: widgets/basic_liker_profile_card.dart
import 'package:dtx/models/like_models.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart'; // For date formatting

class BasicLikerProfileCard extends StatelessWidget {
  final BasicProfileLiker liker;
  final VoidCallback onTap;

  const BasicLikerProfileCard({
    super.key,
    required this.liker,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final timeAgo = liker.likedAt != null
        ? DateFormat.yMd().add_jm().format(liker.likedAt!) // Example format
        : 'Some time ago';

    return InkWell(
      // Make the card tappable
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.grey.shade200),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.03),
              blurRadius: 5,
              offset: const Offset(0, 1),
            )
          ],
        ),
        child: Row(
          children: [
            // Profile Picture Placeholder/Image
            CircleAvatar(
              radius: 25,
              backgroundColor: Colors.grey[200],
              backgroundImage: (liker.firstProfilePicUrl != null)
                  ? NetworkImage(liker.firstProfilePicUrl!)
                  : null,
              child: (liker.firstProfilePicUrl == null)
                  ? Icon(Icons.person, color: Colors.grey[400])
                  : null,
            ),
            const SizedBox(width: 12),
            // Name and Like Info
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    liker.name.isNotEmpty ? liker.name : 'Unknown User',
                    style: GoogleFonts.poppins(
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'Liked you $timeAgo',
                    style: GoogleFonts.poppins(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 8),
            // Rose/Comment Indicators
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                if (liker.isRose)
                  Icon(Icons.star_rounded,
                      color: Colors.purple.shade300, size: 20),
                if (liker.likeComment != null &&
                    liker.likeComment!.isNotEmpty) ...[
                  if (liker.isRose) const SizedBox(width: 4), // Spacing if both
                  Icon(Icons.chat_bubble_outline_rounded,
                      color: Colors.blue.shade300, size: 18),
                ]
              ],
            )
          ],
        ),
      ),
    );
  }
}



================================================
File: widgets/full_liker_profile_card.dart
================================================
// File: widgets/full_liker_profile_card.dart
import 'package:dtx/models/like_models.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart'; // For date formatting

class FullLikerProfileCard extends StatelessWidget {
  // --- FIX: Correct class name ---
  final FullProfileLiker liker;
  // --- END FIX ---
  final VoidCallback onTap;

  const FullLikerProfileCard({
    super.key,
    required this.liker,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final profile = liker.profile;
    final age = profile.age;
    final firstImage = profile.firstMediaUrl;
    final timeAgo = liker.likedAt != null
        ? DateFormat.yMd().add_jm().format(liker.likedAt!) // Example format
        : 'Some time ago';

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(15.0),
      child: Container(
        // Removed fixed height to allow content to define height
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(15.0),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
          image: firstImage != null
              ? DecorationImage(
                  image: NetworkImage(firstImage),
                  fit: BoxFit.cover,
                  onError: (err, st) => print(
                      "Error loading image $firstImage: $err"), // Add error logging
                  colorFilter: ColorFilter.mode(
                    Colors.black.withOpacity(0.3),
                    BlendMode.darken,
                  ),
                )
              : null, // No image if null
          color: firstImage == null
              ? Colors.grey[300]
              : Colors.white, // Placeholder color or white background
        ),
        child: Stack(
          children: [
            // Placeholder Icon if no image
            if (firstImage == null)
              Center(
                  child: Icon(Icons.person, size: 60, color: Colors.grey[500])),

            // Gradient Overlay for text (only if image exists)
            if (firstImage != null)
              Positioned.fill(
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(15.0),
                    gradient: LinearGradient(
                        colors: [
                          Colors.transparent,
                          Colors.black.withOpacity(0.7)
                        ],
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        stops: const [0.4, 1.0]),
                  ),
                ),
              ),

            // Info Text
            Positioned(
              bottom: 12,
              left: 12,
              right: 12,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Name & Age
                  Text(
                    '${profile.name ?? 'Unknown User'}${age != null ? ', $age' : ''}',
                    style: GoogleFonts.poppins(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      // Adjust text color based on background
                      color: firstImage != null ? Colors.white : Colors.black87,
                      shadows: firstImage != null
                          ? [
                              Shadow(
                                  blurRadius: 2,
                                  color: Colors.black.withOpacity(0.7))
                            ]
                          : [],
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),

                  // Like Timestamp
                  Text(
                    'Liked you $timeAgo',
                    style: GoogleFonts.poppins(
                      fontSize: 11,
                      color: firstImage != null
                          ? Colors.white.withOpacity(0.8)
                          : Colors.grey[600],
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),

                  // Comment Preview (if exists)
                  if (liker.likeComment != null &&
                      liker.likeComment!.isNotEmpty) ...[
                    const SizedBox(height: 6),
                    Row(
                      children: [
                        Icon(Icons.chat_bubble_outline_rounded,
                            color: firstImage != null
                                ? Colors.white.withOpacity(0.8)
                                : Colors.blue.shade300,
                            size: 14),
                        const SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            '"${liker.likeComment!}"',
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              fontStyle: FontStyle.italic,
                              color: firstImage != null
                                  ? Colors.white.withOpacity(0.9)
                                  : Colors.black87,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ],
                    ),
                  ],
                ],
              ),
            ),

            // Rose Indicator (Top Right)
            if (liker.isRose)
              Positioned(
                top: 8,
                right: 8,
                child: Container(
                  padding: const EdgeInsets.all(5),
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.5),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(Icons.star_rounded,
                      color: Colors.yellow.shade600, size: 18),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: widgets/home_profile_card.dart
================================================
// File: widgets/home_profile_card.dart
import 'dart:async';
import 'dart:math';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/audio_player_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/providers/user_provider.dart'; // Needed for currentUserGender check in dialog
import 'package:dtx/widgets/report_reason_dialog.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:cached_network_image/cached_network_image.dart';

// Function Type Definitions
typedef PerformLikeApiCall = Future<bool> Function({
  required ContentLikeType contentType,
  required String contentIdentifier,
  required LikeInteractionType interactionType,
  String? comment,
});
typedef PerformDislikeApiCall = Future<bool> Function();
typedef InteractionCompleteCallback = void Function();
typedef PerformReportApiCall = Future<bool> Function(
    {required ReportReason reason});

const int maxCommentLength = 140;

class HomeProfileCard extends ConsumerWidget {
  final UserModel profile;
  final PerformLikeApiCall performLikeApiCall;
  final PerformDislikeApiCall performDislikeApiCall;
  final PerformReportApiCall performReportApiCall;
  final InteractionCompleteCallback onInteractionComplete;

  const HomeProfileCard({
    super.key,
    required this.profile,
    required this.performLikeApiCall,
    required this.performDislikeApiCall,
    required this.performReportApiCall,
    required this.onInteractionComplete,
  });

  // --- Interaction Dialog (Like/Rose/Comment) ---
  Future<void> _showInteractionDialog(
    BuildContext context,
    WidgetRef ref,
    ContentLikeType contentType,
    String contentIdentifier,
    String? previewImageUrl,
  ) async {
    final currentUserGender = ref.read(userProvider).gender;
    final isMale = currentUserGender == Gender.man;
    final FocusNode commentFocusNode = FocusNode();
    final TextEditingController commentController = TextEditingController();
    // Notifier tracks if the comment field allows sending (non-empty for males)
    final ValueNotifier<bool> sendLikeEnabledNotifier =
        ValueNotifier<bool>(!isMale);
    // Notifier tracks if an API call (like/rose) is in progress within the dialog
    final ValueNotifier<bool> _isDialogInteractionActive =
        ValueNotifier<bool>(false);
    VoidCallback? listenerCallback; // To hold the listener function reference

    // Add listener only if the user is male to enable/disable based on comment
    if (isMale) {
      listenerCallback = () {
        // Check if the widget is still mounted and the notifier hasn't been disposed
        if (context.mounted && commentController.hasListeners) {
          try {
            sendLikeEnabledNotifier.value =
                commentController.text.trim().isNotEmpty;
          } catch (e) {
            // Handle cases where the notifier might be disposed prematurely
            print(
                "Error accessing sendLikeEnabledNotifier in listener (might be disposed): $e");
          }
        }
      };
      commentController.addListener(listenerCallback);
    }

    // --- Handle Like/Rose Submission ---
    Future<void> _handleInteraction(LikeInteractionType interactionType) async {
      // Prevent multiple simultaneous submissions
      if (_isDialogInteractionActive.value) return;

      // Safely get comment text
      String comment = "";
      try {
        comment = commentController.text.trim();
      } catch (e) {
        print("Error reading commentController text (already disposed?): $e");
        return; // Cannot proceed if controller is disposed
      }

      // Unfocus text field
      commentFocusNode.unfocus();
      // Short delay allows keyboard to retract smoothly before showing loading
      await Future.delayed(const Duration(milliseconds: 100));

      // Set interaction active state safely
      try {
        _isDialogInteractionActive.value = true;
      } catch (e) {
        print(
            "Error setting _isDialogInteractionActive to true (notifier disposed?): $e");
        return; // Cannot proceed if notifier is disposed
      }

      bool success = false;
      try {
        // Perform the API call passed from the HomeScreen
        success = await performLikeApiCall(
          contentType: contentType,
          contentIdentifier: contentIdentifier,
          interactionType: interactionType,
          comment: comment.isNotEmpty ? comment : null,
        );

        // Close dialog and trigger card removal ONLY on success
        if (success && context.mounted) {
          Navigator.of(context, rootNavigator: true).pop(); // Close dialog
          onInteractionComplete(); // Trigger card removal etc. in HomeScreen
        }
        // Error snackbars/handling is managed within performLikeApiCall (in HomeScreen)
      } finally {
        // Reset interaction state safely, even if API call failed
        try {
          // Check context AND if the value is actually true before setting false
          if (context.mounted && _isDialogInteractionActive.value) {
            _isDialogInteractionActive.value = false;
          }
        } catch (e) {
          print(
              "Error setting _isDialogInteractionActive to false (notifier disposed?): $e");
        }
      }
    }
    // --- End Handle Like/Rose Submission ---

    try {
      // --- Show Dialog ---
      await showDialog<void>(
        context: context,
        barrierDismissible: true, // Allow dismissing by tapping outside
        builder: (BuildContext dialogContext) {
          return AlertDialog(
            contentPadding: const EdgeInsets.all(16),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(20.0),
            ),
            content: SizedBox(
              width: MediaQuery.of(dialogContext).size.width *
                  0.8, // Constrain width
              child: SingleChildScrollView(
                // Allow scrolling if content overflows
                child: Column(
                  mainAxisSize: MainAxisSize.min, // Fit content vertically
                  children: [
                    // Image Preview (if applicable)
                    if (previewImageUrl != null)
                      ClipRRect(
                        borderRadius: BorderRadius.circular(12.0),
                        child: CachedNetworkImage(
                          imageUrl: previewImageUrl,
                          height: 100,
                          width: double.infinity,
                          fit: BoxFit.cover,
                          placeholder: (context, url) => Container(
                            height: 100,
                            color: Colors.grey[200],
                            child: const Center(
                                child: CircularProgressIndicator(
                                    strokeWidth: 2, color: Color(0xAA8B5CF6))),
                          ),
                          errorWidget: (context, url, error) => Container(
                              height: 100,
                              color: Colors.grey[200],
                              child: Icon(Icons.broken_image,
                                  color: Colors.grey[400])),
                        ),
                      ),
                    // Audio Prompt Placeholder (if applicable)
                    if (previewImageUrl == null &&
                        contentType == ContentLikeType.audioPrompt)
                      Container(
                        height: 100,
                        width: double.infinity,
                        decoration: BoxDecoration(
                          color: Colors.grey[100],
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        child: Center(
                            child: Icon(Icons.multitrack_audio_rounded,
                                size: 40, color: Colors.grey[500])),
                      ),
                    // Text Prompt Placeholder (if applicable)
                    if (previewImageUrl == null &&
                        contentType != ContentLikeType.audioPrompt)
                      Container(
                        height: 100,
                        width: double.infinity,
                        decoration: BoxDecoration(
                          color: Colors.grey[100],
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        child: Center(
                            child: Icon(Icons.article_outlined,
                                size: 40, color: Colors.grey[500])),
                      ),

                    const SizedBox(height: 16),

                    // Comment TextField
                    TextField(
                      controller: commentController,
                      focusNode: commentFocusNode,
                      decoration: InputDecoration(
                        hintText: "Add a comment...",
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide: BorderSide(color: Colors.grey.shade300),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide:
                              const BorderSide(color: Color(0xFF8B5CF6)),
                        ),
                        contentPadding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 10),
                        counterText: "", // Hide default counter
                      ),
                      maxLength: maxCommentLength, // Use constant
                      maxLines: 3,
                      minLines: 1,
                      textCapitalization: TextCapitalization.sentences,
                    ),

                    const SizedBox(height: 16),

                    // Action Buttons (Rose/Like)
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        // Rose Button
                        ValueListenableBuilder<bool>(
                          valueListenable: sendLikeEnabledNotifier,
                          builder: (context, isCommentValid, child) {
                            final bool roseButtonEnabled =
                                !isMale || isCommentValid;
                            return ValueListenableBuilder<bool>(
                              valueListenable: _isDialogInteractionActive,
                              builder: (context, isInteractionActive, child) {
                                final bool effectiveEnabled =
                                    roseButtonEnabled && !isInteractionActive;
                                return OutlinedButton.icon(
                                  icon: Icon(
                                    Icons.star_rounded,
                                    color: effectiveEnabled
                                        ? Colors.purple.shade300
                                        : Colors.grey.shade400,
                                    size: 18,
                                  ),
                                  label: Text(
                                    "Send Rose",
                                    style: GoogleFonts.poppins(
                                      fontWeight: FontWeight.w500,
                                      color: effectiveEnabled
                                          ? Colors.purple.shade400
                                          : Colors.grey.shade500,
                                      fontSize: 13,
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                  style: OutlinedButton.styleFrom(
                                    foregroundColor: effectiveEnabled
                                        ? Colors.purple.shade400
                                        : Colors.grey.shade500,
                                    side: BorderSide(
                                      color: effectiveEnabled
                                          ? Colors.purple.shade100
                                          : Colors.grey.shade300,
                                    ),
                                    shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(25),
                                    ),
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 10, horizontal: 12),
                                  ),
                                  onPressed: effectiveEnabled
                                      ? () => _handleInteraction(
                                          LikeInteractionType.rose)
                                      : null,
                                );
                              },
                            );
                          },
                        ),
                        // Like Button
                        ValueListenableBuilder<bool>(
                          valueListenable: sendLikeEnabledNotifier,
                          builder: (context, isCommentValid, child) {
                            final bool likeButtonEnabled =
                                !isMale || isCommentValid;
                            return ValueListenableBuilder<bool>(
                              valueListenable: _isDialogInteractionActive,
                              builder: (context, isInteractionActive, child) {
                                final bool effectiveEnabled =
                                    likeButtonEnabled && !isInteractionActive;
                                return ElevatedButton.icon(
                                  icon: Icon(
                                    Icons.favorite_rounded,
                                    color: effectiveEnabled
                                        ? Colors.white
                                        : Colors.grey.shade400,
                                    size: 18,
                                  ),
                                  label: Text(
                                    "Send Like",
                                    style: GoogleFonts.poppins(
                                      fontWeight: FontWeight.w600,
                                      color: effectiveEnabled
                                          ? Colors.white
                                          : Colors.grey.shade500,
                                      fontSize: 13,
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: effectiveEnabled
                                        ? Colors.pink.shade300
                                        : Colors.grey.shade200,
                                    disabledBackgroundColor:
                                        Colors.grey.shade200,
                                    shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(25),
                                    ),
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 10, horizontal: 12),
                                    elevation: effectiveEnabled ? 2 : 0,
                                  ),
                                  onPressed: effectiveEnabled
                                      ? () => _handleInteraction(
                                          LikeInteractionType.standard)
                                      : null,
                                );
                              },
                            );
                          },
                        ),
                      ],
                    ),

                    // Cancel Button
                    ValueListenableBuilder<bool>(
                      valueListenable: _isDialogInteractionActive,
                      builder: (context, isInteractionActive, child) {
                        return TextButton(
                          child: Text("Cancel",
                              style: GoogleFonts.poppins(
                                  color: isInteractionActive
                                      ? Colors.grey.shade400
                                      : Colors.grey)),
                          onPressed: isInteractionActive
                              ? null // Disable cancel if interaction is active
                              : () => Navigator.of(dialogContext).pop(),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      );
      // --- End Show Dialog ---
    } finally {
      // Safely clean up listeners and controllers
      if (listenerCallback != null) {
        try {
          commentController.removeListener(listenerCallback);
          listenerCallback = null; // Help GC
        } catch (e) {
          print(
              "Error removing commentController listener (already removed?): $e");
        }
      }
      try {
        sendLikeEnabledNotifier.dispose();
      } catch (e) {
        print("Error disposing sendLikeEnabledNotifier: $e");
      }
      try {
        commentController.dispose();
      } catch (e) {
        print("Error disposing commentController: $e");
      }
      try {
        commentFocusNode.dispose();
      } catch (e) {
        print("Error disposing commentFocusNode: $e");
      }
      try {
        _isDialogInteractionActive.dispose();
      } catch (e) {
        print("Error disposing _isDialogInteractionActive: $e");
      }
    }
  }

  // --- Handle Report Action (Shows Reason Dialog) ---
  Future<void> _handleReport(BuildContext context) async {
    // Show the dialog to get the reason
    final selectedReason = await showReportReasonDialog(context);
    if (selectedReason != null) {
      // Call the report API function passed from HomeScreen
      // API call result/error handling is done in HomeScreen
      await performReportApiCall(reason: selectedReason);
      // Card removal is handled by the callback in HomeScreen if report succeeds
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // --- Content Block Generation (No Change) ---
    final List<dynamic> contentBlocks = [];
    final mediaUrls = profile.mediaUrls ?? [];
    final prompts = profile.prompts;
    contentBlocks.add("header_section");
    if (mediaUrls.isNotEmpty)
      contentBlocks.add({"type": "media", "value": mediaUrls[0], "index": 0});
    if (prompts.isNotEmpty) contentBlocks.add(prompts[0]);
    contentBlocks.add("vitals_section");
    int mediaIndex = 1;
    int promptIndex = 1;
    int maxRemaining = max(mediaUrls.length, prompts.length);
    for (int i = 1; i < maxRemaining; i++) {
      if (mediaIndex < mediaUrls.length) {
        contentBlocks
            .add({"type": "media", "value": mediaUrls[mediaIndex], "index": i});
        mediaIndex++;
      }
      if (promptIndex < prompts.length) {
        contentBlocks.add(prompts[promptIndex]);
        promptIndex++;
      }
    }
    if (profile.audioPrompt != null) contentBlocks.add(profile.audioPrompt!);
    // --- End Content Block Generation ---

    return Container(
      color: Colors.white, // Background for the entire card area
      child: Stack(
        // Use Stack to overlay buttons
        children: [
          // Main Scrollable Content
          ListView.builder(
            physics: const ClampingScrollPhysics(), // Prevents overscroll glow
            padding: const EdgeInsets.only(bottom: 80.0), // Space for buttons
            itemCount: contentBlocks.length,
            itemBuilder: (context, index) {
              final item = contentBlocks[index];
              final double topPadding = (index == 0) ? 16.0 : 0;
              final double bottomPadding = 20.0;
              final double horizontalPadding = 12.0;
              Widget contentWidget;

              // Build content blocks based on type
              if (item is String && item == "header_section") {
                contentWidget = _buildHeaderBlock(context, profile);
              } else if (item is Map && item["type"] == "media") {
                contentWidget = _buildMediaItem(
                    context, ref, item["value"] as String, item["index"]);
              } else if (item is Prompt) {
                contentWidget = _buildPromptItem(context, ref, item);
              } else if (item is AudioPromptModel) {
                contentWidget = _buildAudioItem(context, ref, item);
              } else if (item is String && item == "vitals_section") {
                contentWidget = _buildVitalsBlock(profile);
              } else {
                contentWidget = const SizedBox.shrink();
              }

              // Add padding around each block
              return Padding(
                padding: EdgeInsets.fromLTRB(horizontalPadding, topPadding,
                    horizontalPadding, bottomPadding),
                child: contentWidget,
              );
            },
          ),

          // Action Buttons Row (Dislike Only Now)
          Positioned(
            bottom: 15, // Adjust position as needed
            left: 30,
            right: 30, // Ensure it takes full width for spaceBetween
            child: Row(
              // *** MODIFIED: Use spaceBetween and added Dislike Button back ***
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              // *** END MODIFICATION ***
              children: [
                // Dislike Button (Restored)
                _buildActionButton(
                  icon: Icons.close_rounded,
                  color: Colors.redAccent.shade100,
                  onPressed: () async {
                    // Call the dislike API function passed from HomeScreen
                    bool success = await performDislikeApiCall();
                    if (success) {
                      onInteractionComplete(); // Trigger card removal in HomeScreen
                    }
                  },
                  tooltip: "Dislike",
                  size: 55, // Smaller action buttons
                ),
                // Add other buttons here if needed in the future, using spaceBetween
              ],
            ),
          ),
        ],
      ),
    );
  }

  // --- Header Block Builder ---
  Widget _buildHeaderBlock(BuildContext context, UserModel profile) {
    final age = profile.age;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Name and Age (Takes available space)
            Flexible(
              child: Text(
                '${profile.name ?? 'Name'}${age != null ? ', $age' : ''}',
                style: GoogleFonts.poppins(
                  fontSize: 26,
                  fontWeight: FontWeight.bold,
                  color: Colors.black87,
                ),
                softWrap: true,
              ),
            ),
            // More Options Menu Button
            _buildHeaderMenuButton(context), // Use the helper
          ],
        ),
        // Location (remains below the Name/Age/Menu row)
        if (profile.hometown != null && profile.hometown!.isNotEmpty) ...[
          const SizedBox(height: 4),
          Row(
            children: [
              Icon(Icons.location_on_outlined,
                  size: 16, color: Colors.grey[600]),
              const SizedBox(width: 4),
              Text(
                profile.hometown!,
                style:
                    GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
              ),
            ],
          ),
        ],
      ],
    );
  }

  // --- Header Menu Button Helper ---
  Widget _buildHeaderMenuButton(BuildContext context) {
    return PopupMenuButton<String>(
      tooltip: "More options",
      icon: Icon(Icons.more_vert_rounded, color: Colors.grey.shade600),
      padding: EdgeInsets.zero,
      constraints: const BoxConstraints(),
      onSelected: (String result) {
        if (result == 'report') {
          _handleReport(context);
        }
      },
      itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
        PopupMenuItem<String>(
          value: 'report',
          child: ListTile(
            leading: Icon(Icons.flag_outlined, color: Colors.redAccent),
            // *** MODIFIED: Simplified Text ***
            title: Text('Report',
                style: GoogleFonts.poppins(color: Colors.redAccent)),
            // *** END MODIFICATION ***
            dense: true,
            contentPadding: EdgeInsets.symmetric(horizontal: 8.0),
          ),
        ),
      ],
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10.0),
      ),
    );
  }

  // --- Other Helper Methods (_buildVitalsBlock, etc. remain unchanged) ---
  Widget _buildVitalsBlock(UserModel profile) {
    final List<Widget> vitals = [];
    if (profile.height != null && profile.height!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.height, profile.height!));
    }
    if (profile.religiousBeliefs != null) {
      vitals.add(_buildVitalRow(
          Icons.church_outlined, profile.religiousBeliefs!.label));
    }
    if (profile.jobTitle != null && profile.jobTitle!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.work_outline, profile.jobTitle!));
    }
    if (profile.education != null && profile.education!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.school_outlined, profile.education!));
    }
    if (profile.drinkingHabit != null) {
      vitals.add(_buildVitalRow(
          Icons.local_bar_outlined, "Drinks: ${profile.drinkingHabit!.label}"));
    }
    if (profile.smokingHabit != null) {
      vitals.add(_buildVitalRow(Icons.smoking_rooms_outlined,
          "Smokes: ${profile.smokingHabit!.label}"));
    }
    if (vitals.isEmpty) return const SizedBox.shrink();
    return Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        width: double.infinity,
        decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(10),
            boxShadow: [
              BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 10,
                  offset: const Offset(0, 3))
            ]),
        child: Column(
            children: List.generate(vitals.length * 2 - 1, (index) {
          if (index.isEven) {
            return vitals[index ~/ 2];
          } else {
            return Divider(height: 16, thickness: 1, color: Colors.grey[200]);
          }
        })));
  }

  Widget _buildVitalRow(IconData icon, String label) {
    return Padding(
        padding: const EdgeInsets.symmetric(vertical: 6.0),
        child: Row(children: [
          Icon(icon, size: 20, color: Colors.grey[600]),
          const SizedBox(width: 12),
          Expanded(
              child: Text(label,
                  style: GoogleFonts.poppins(
                      fontSize: 15, color: Colors.grey[800]),
                  overflow: TextOverflow.ellipsis))
        ]));
  }

  Widget _buildMediaItem(
      BuildContext context, WidgetRef ref, String url, int index) {
    bool isVideo = url.toLowerCase().contains('.mp4') ||
        url.toLowerCase().contains('.mov') ||
        url.toLowerCase().contains('.avi') ||
        url.toLowerCase().contains('.webm');
    return ClipRRect(
        borderRadius: BorderRadius.circular(10),
        child: AspectRatio(
            aspectRatio: 4 / 5.5,
            child: Container(
                decoration: BoxDecoration(color: Colors.grey[200]),
                child: Stack(fit: StackFit.expand, children: [
                  CachedNetworkImage(
                      imageUrl: url,
                      fit: BoxFit.cover,
                      placeholder: (context, url) => const Center(
                          child: CircularProgressIndicator(
                              strokeWidth: 2.0, color: Color(0xAA8B5CF6))),
                      errorWidget: (context, url, error) => Center(
                          child: Icon(Icons.broken_image_outlined,
                              color: Colors.grey[400], size: 40))),
                  if (isVideo)
                    Center(
                        child: Container(
                            padding: const EdgeInsets.all(10),
                            decoration: BoxDecoration(
                                color: Colors.black.withOpacity(0.5),
                                shape: BoxShape.circle),
                            child: const Icon(Icons.play_arrow_rounded,
                                color: Colors.white, size: 30))),
                  Positioned(
                      bottom: 10,
                      right: 10,
                      child: _buildSmallLikeButton(() => _showInteractionDialog(
                          context,
                          ref,
                          ContentLikeType.media,
                          index.toString(),
                          url)))
                ]))));
  }

  Widget _buildPromptItem(BuildContext context, WidgetRef ref, Prompt prompt) {
    if (prompt.answer.trim().isEmpty) return const SizedBox.shrink();
    return Container(
        width: double.infinity,
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(10),
            boxShadow: [
              BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 10,
                  offset: const Offset(0, 3))
            ]),
        child: Row(crossAxisAlignment: CrossAxisAlignment.start, children: [
          Expanded(
              child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                Text(prompt.question.label,
                    style: GoogleFonts.poppins(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                        color: Colors.grey[600])),
                const SizedBox(height: 10),
                Text(prompt.answer,
                    style: GoogleFonts.poppins(
                        fontSize: 20,
                        color: Colors.black87,
                        height: 1.4,
                        fontWeight: FontWeight.w500))
              ])),
          const SizedBox(width: 12),
          _buildSmallLikeButton(() => _showInteractionDialog(context, ref,
              prompt.category.contentType, prompt.question.value, null))
        ]));
  }

  Widget _buildAudioItem(
      BuildContext context, WidgetRef ref, AudioPromptModel audio) {
    final audioPlayerState = ref.watch(audioPlayerStateProvider);
    final currentPlayingUrl = ref.watch(currentAudioUrlProvider);
    final playerNotifier = ref.read(audioPlayerControllerProvider.notifier);
    final bool isThisPlaying = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.playing;
    final bool isThisLoading = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.loading;
    final bool isThisPaused = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.paused;
    return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: Colors.grey[200]!),
            boxShadow: [
              BoxShadow(
                  color: Colors.grey.withOpacity(0.06),
                  blurRadius: 10,
                  offset: const Offset(0, 3))
            ]),
        child: Row(children: [
          InkWell(
              onTap: () {
                if (isThisLoading) return;
                if (isThisPlaying) {
                  playerNotifier.pause();
                } else if (isThisPaused) {
                  playerNotifier.resume();
                } else {
                  playerNotifier.play(audio.audioUrl);
                }
              },
              borderRadius: BorderRadius.circular(24),
              child: Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6),
                      borderRadius: BorderRadius.circular(24),
                      boxShadow: [
                        BoxShadow(
                            color: const Color(0xFF8B5CF6).withOpacity(0.3),
                            blurRadius: 8,
                            offset: const Offset(0, 2))
                      ]),
                  child: isThisLoading
                      ? const Padding(
                          padding: EdgeInsets.all(12.0),
                          child: CircularProgressIndicator(
                              strokeWidth: 2, color: Colors.white))
                      : Icon(
                          isThisPlaying
                              ? Icons.pause_rounded
                              : Icons.play_arrow_rounded,
                          color: Colors.white,
                          size: 28))),
          const SizedBox(width: 16),
          Expanded(
              child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                Text(audio.prompt.label,
                    style: GoogleFonts.poppins(
                        fontSize: 15,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF1A1A1A))),
                const SizedBox(height: 4),
                Text(
                    isThisLoading
                        ? "Loading..."
                        : isThisPlaying
                            ? "Playing..."
                            : isThisPaused
                                ? "Paused"
                                : "Tap to listen",
                    style: GoogleFonts.poppins(
                        fontSize: 13, color: Colors.grey[600]))
              ])),
          const SizedBox(width: 16),
          _buildSmallLikeButton(() => _showInteractionDialog(
              context, ref, ContentLikeType.audioPrompt, "0", null))
        ]));
  }

  Widget _buildSmallLikeButton(VoidCallback onPressed) {
    return Container(
        width: 40,
        height: 40,
        decoration: BoxDecoration(
            color: Colors.white,
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 5)
            ]),
        child: IconButton(
            padding: EdgeInsets.zero,
            icon: Icon(Icons.favorite_border_rounded,
                color: Colors.pink[200], size: 22),
            tooltip: 'Like this item',
            onPressed: onPressed));
  }

  Widget _buildActionButton(
      {required IconData icon,
      required Color color,
      required VoidCallback onPressed,
      required String tooltip,
      double size = 60.0,
      double iconSize = 30.0}) {
    return Tooltip(
        message: tooltip,
        child: Material(
            color: Colors.white,
            shape: const CircleBorder(),
            elevation: 3.0,
            shadowColor: Colors.black.withOpacity(0.2),
            child: InkWell(
                customBorder: const CircleBorder(),
                onTap: onPressed,
                child: Container(
                    width: size,
                    height: size,
                    decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(
                            color: Colors.grey.shade200, width: 1.0)),
                    child: Icon(icon, color: color, size: iconSize)))));
  }
} // End of HomeProfileCard



================================================
File: widgets/match_list_tile.dart
================================================
// File: lib/widgets/match_list_tile.dart
import 'package:dtx/models/user_model.dart';
import 'package:dtx/utils/date_formatter.dart'; // <-- IMPORT ADDED
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter/foundation.dart'; // For kDebugMode

class MatchListTile extends StatelessWidget {
  final UserModel matchUser;
  final VoidCallback onTap;

  const MatchListTile({
    super.key,
    required this.matchUser,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    // --- ADDED LOGGING ---
    if (kDebugMode) {
      print(
          "[MatchListTile build] UserID: ${matchUser.id}, Name: ${matchUser.name}, isOnline: ${matchUser.isOnline}, lastOnline: ${matchUser.lastOnline}");
    }
    // --- END LOGGING ---

    // Determine subtitle content based on status
    Widget subtitleWidget;
    if (matchUser.isOnline) {
      subtitleWidget = Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.circle, size: 9, color: Colors.green[600]),
          const SizedBox(width: 4),
          Text(
            'Online',
            style: GoogleFonts.poppins(
              color: Colors.green[700],
              fontSize: 13,
              fontWeight: FontWeight.w500, // Make 'Online' slightly bolder
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      );
    } else {
      // Use the formatter function
      final lastSeenText = formatLastSeen(matchUser.lastOnline, short: true);
      subtitleWidget = Text(
        lastSeenText.isNotEmpty ? 'Last seen: $lastSeenText' : '',
        // Using short format from helper
        style: GoogleFonts.poppins(
          color: Colors.grey[600],
          fontSize: 13,
        ),
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      );
    }

    return ListTile(
      contentPadding:
          const EdgeInsets.symmetric(horizontal: 16.0, vertical: 4.0),
      leading: CircleAvatar(
        radius: 28,
        backgroundColor: Colors.grey[200],
        backgroundImage: matchUser.firstMediaUrl != null
            ? NetworkImage(matchUser.firstMediaUrl!)
            : null,
        child: matchUser.firstMediaUrl == null
            ? Icon(Icons.person, size: 30, color: Colors.grey[400])
            : null,
      ),
      title: Text(
        matchUser.name ?? 'Unknown Match',
        style: GoogleFonts.poppins(
          fontWeight: FontWeight.w600,
          fontSize: 16,
        ),
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      subtitle:
          subtitleWidget, // <-- USE THE DYNAMIC SUBTITLE WIDGET CREATED ABOVE
      trailing: Icon(Icons.chevron_right_rounded, color: Colors.grey[400]),
      onTap: onTap,
    );
  }
}



================================================
File: widgets/message_bubble.dart
================================================
// lib/widgets/message_bubble.dart
import 'dart:io';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:dtx/models/chat_message.dart';
import 'package:dtx/providers/audio_player_provider.dart';
import 'package:dtx/providers/conversation_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:path/path.dart' as p;
import 'package:url_launcher/url_launcher.dart';

class MessageBubble extends ConsumerStatefulWidget {
  final ChatMessage message;
  final bool isMe;
  final bool showTail;
  final Function(ChatMessage message) onReplyInitiated;
  // *** ADDED: Parameter for original sender's display name ***
  final String originalSenderDisplayName;
  // *** END ADDED ***

  const MessageBubble({
    Key? key,
    required this.message,
    required this.isMe,
    required this.showTail,
    required this.onReplyInitiated,
    required this.originalSenderDisplayName, // *** ADDED ***
  }) : super(key: key);

  @override
  ConsumerState<MessageBubble> createState() => _MessageBubbleState();
}

class _MessageBubbleState extends ConsumerState<MessageBubble>
    with AutomaticKeepAliveClientMixin {
  @override
  bool get wantKeepAlive => true;

  // --- Helpers (Keep as previously defined) ---
  String getFilenameFromUrl(String? url) {
    if (url == null || url.isEmpty) return "File";
    try {
      final uri = Uri.parse(url);
      String pathSegment = Uri.decodeComponent(uri.pathSegments.last);
      final parts = pathSegment.split('-');
      if (parts.length > 1 &&
          int.tryParse(parts[0]) != null &&
          parts[0].length > 10) {
        return parts.sublist(1).join('-');
      }
      return pathSegment;
    } catch (e) {
      try {
        return p.basename(url);
      } catch (e2) {
        return "File";
      }
    }
  }

  Future<void> _openMedia(BuildContext context, String url) async {
    final Uri uri = Uri.parse(url);
    if (!await canLaunchUrl(uri)) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Could not launch $url')),
        );
      }
      print("Could not launch $uri");
      return;
    }
    try {
      bool launched =
          await launchUrl(uri, mode: LaunchMode.externalApplication);
      if (!launched && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Could not launch $url')),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error launching file: $e')),
        );
      }
      print("Error launching $uri: $e");
    }
  }

  Widget _buildMediaLoadingPlaceholder({required bool isMe}) {
    return const Center(
      child: Padding(
        padding: EdgeInsets.symmetric(vertical: 40.0, horizontal: 40.0),
        child:
            CircularProgressIndicator(strokeWidth: 2, color: Color(0xFF8B5CF6)),
      ),
    );
  }

  Widget _buildMediaErrorPlaceholder({required bool isMe}) {
    return Container(
      color: Colors.grey[isMe ? 700 : 200]?.withOpacity(0.3),
      child: Center(
          child: Icon(Icons.broken_image_outlined,
              color: isMe ? Colors.white60 : Colors.grey[500], size: 40)),
    );
  }
  // --- End Helpers ---

  // --- *** MODIFIED: _buildReplySnippet *** ---
  Widget _buildReplySnippet() {
    final repliedTo = widget.message;
    final textSnippet = repliedTo.repliedMessageTextSnippet;
    final mediaType = repliedTo.repliedMessageMediaType;

    // Use the display name passed from the parent
    final String originalSenderName = widget.originalSenderDisplayName;

    // Define colors based on who sent the *current* message (the reply)
    final Color snippetBgColor = widget.isMe
        ? const Color(0xFF7C3AED)
            .withOpacity(0.8) // Slightly darker purple for own reply snippet
        : Colors.grey.shade200; // Light grey for other's reply snippet
    final Color nameColor = widget.isMe
        ? Colors.white // White name on purple
        : const Color(0xFF7C3AED); // Purple name on grey
    final Color contentColor = widget.isMe
        ? Colors.white.withOpacity(0.9) // Slightly lighter content on purple
        : Colors.black54; // Darker grey content on grey
    final Color indicatorColor = nameColor; // Match indicator to name color

    String contentPreview =
        (textSnippet != null && textSnippet.isNotEmpty) ? textSnippet : '';
    IconData? mediaIcon;

    if (contentPreview.isEmpty) {
      if (mediaType?.startsWith('image/') ?? false) {
        contentPreview = "Photo";
        mediaIcon = Icons.photo_camera_back_outlined;
      } else if (mediaType?.startsWith('video/') ?? false) {
        contentPreview = "Video";
        mediaIcon = Icons.videocam_outlined;
      } else if (mediaType?.startsWith('audio/') ?? false) {
        contentPreview = "Audio";
        mediaIcon = Icons.headphones_outlined;
      } else if (mediaType != null) {
        contentPreview = "File";
        mediaIcon = Icons.attach_file_outlined;
      } else {
        contentPreview = "Original message";
      }
    }

    return Container(
      padding: const EdgeInsets.only(
          left: 8, right: 8, top: 6, bottom: 6), // Adjusted padding
      margin: const EdgeInsets.only(
          bottom: 4,
          left: 1,
          right: 1,
          top: 1), // Add slight margin inside bubble
      decoration: BoxDecoration(
        color: snippetBgColor, // Use dynamic background
        // Apply rounding *only* to top corners if it's the first element
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(14), // Slightly less rounded
          topRight: Radius.circular(14),
        ),
        // Apply the left border indicator
        border: Border(
          left: BorderSide(
            color: indicatorColor, // Use dynamic indicator color
            width: 4, // Slightly thicker indicator
          ),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            originalSenderName, // Use the passed display name
            style: GoogleFonts.poppins(
              color: nameColor, // Use dynamic name color
              fontWeight: FontWeight.w600,
              fontSize: 13, // Slightly larger name
            ),
          ),
          const SizedBox(height: 3), // Adjust spacing
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (mediaIcon != null)
                Icon(mediaIcon,
                    size: 15, color: contentColor), // Slightly larger icon
              if (mediaIcon != null && contentPreview.isNotEmpty)
                const SizedBox(width: 5),
              Flexible(
                child: Text(
                  contentPreview,
                  style: GoogleFonts.poppins(
                    color: contentColor, // Use dynamic content color
                    fontSize: 13,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  // --- *** END MODIFIED *** ---

  @override
  Widget build(BuildContext context) {
    super.build(context);

    final message = widget.message;
    final isMe = widget.isMe;
    final showTail = widget.showTail;

    // --- Log message data (keep) ---
    if (kDebugMode) {
      print("--- Building MessageBubble ---");
      print("  Msg ID: ${message.messageID}");
      print("  Temp ID: ${message.tempId}");
      print("  Is Me: $isMe");
      print("  Show Tail: $showTail");
      print("  Is Media: ${message.isMedia}");
      print("  Text: '${message.messageText}'");
      print("  Media URL: ${message.mediaUrl}");
      print("  Media Type: ${message.mediaType}");
      print("  Status: ${message.status}");
      print("  Is Reply: ${message.isReply}");
      print("  Reply To ID: ${message.replyToMessageID}");
      print("  Replied Sender ID: ${message.repliedMessageSenderID}");
      print("  Replied Snippet: '${message.repliedMessageTextSnippet}'");
      print("  Replied Media Type: ${message.repliedMessageMediaType}");
      print("-----------------------------");
    }
    // --- End Log ---

    final radius = Radius.circular(18.0);
    // *** MODIFIED: Adjust borderRadius based on whether it's a reply ***
    final borderRadius = BorderRadius.only(
      topLeft: message.isReply
          ? const Radius.circular(8)
          : radius, // Less rounded if reply
      topRight: message.isReply
          ? const Radius.circular(8)
          : radius, // Less rounded if reply
      bottomLeft: isMe || !showTail ? radius : Radius.zero,
      bottomRight: !isMe || !showTail ? radius : Radius.zero,
    );
    // *** END MODIFIED ***

    Widget messageContent;
    Widget? statusIcon;

    // Status Icon Logic (no change)
    if (isMe && message.status != ChatMessageStatus.sent) {
      switch (message.status) {
        case ChatMessageStatus.pending:
        case ChatMessageStatus.uploading:
          statusIcon =
              Icon(Icons.access_time_rounded, color: Colors.white70, size: 16);
          break;
        case ChatMessageStatus.failed:
          statusIcon = Tooltip(
            message: message.errorMessage ?? "Failed to send",
            child: Icon(Icons.error_outline_rounded,
                color: Colors.red.shade300, size: 18),
          );
          break;
        case ChatMessageStatus.sent:
          break;
      }
    }

    // Content Rendering Logic (no change needed inside this block)
    if (message.isMedia) {
      // ... (existing media rendering logic - no changes here) ...
      final mediaType = message.mediaType?.toLowerCase() ?? '';
      final String? displayPath =
          (message.localFilePath != null && message.localFilePath!.isNotEmpty)
              ? message.localFilePath
              : message.mediaUrl;
      final bool isUsingLocalFile =
          displayPath == message.localFilePath && message.localFilePath != null;
      final bool isMediaSent = message.status == ChatMessageStatus.sent;

      if (displayPath == null || displayPath.isEmpty) {
        messageContent = Text(
          "[Media Error]",
          style: GoogleFonts.poppins(color: Colors.red, fontSize: 14),
        );
      } else if (mediaType.startsWith('image/')) {
        Widget imageToShow;
        if (isUsingLocalFile) {
          imageToShow = Image.file(File(displayPath),
              key: ValueKey(displayPath),
              fit: BoxFit.contain,
              errorBuilder: (_, __, ___) =>
                  _buildMediaErrorPlaceholder(isMe: isMe));
        } else {
          imageToShow = CachedNetworkImage(
            key: ValueKey(displayPath),
            imageUrl: displayPath,
            fit: BoxFit.contain,
            placeholder: (context, url) =>
                _buildMediaLoadingPlaceholder(isMe: isMe),
            errorWidget: (context, url, error) =>
                _buildMediaErrorPlaceholder(isMe: isMe),
          );
        }
        messageContent = ClipRRect(
          borderRadius: BorderRadius.circular(8.0),
          child: imageToShow,
        );
      } else if (mediaType.startsWith('video/')) {
        messageContent = InkWell(
          onTap: isMediaSent && !isUsingLocalFile
              ? () => _openMedia(context, displayPath)
              : null,
          child: Container(
            /* ... video placeholder ... */ padding: const EdgeInsets.all(10),
            constraints: BoxConstraints(
                maxWidth: MediaQuery.of(context).size.width * 0.65,
                minHeight: 100),
            decoration: BoxDecoration(
                color: Colors.grey[isMe ? 700 : 300],
                borderRadius: BorderRadius.circular(8)),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.videocam_outlined,
                    size: 40, color: isMe ? Colors.white70 : Colors.grey[600]),
                const SizedBox(height: 8),
                Text(
                  getFilenameFromUrl(displayPath),
                  style: GoogleFonts.poppins(
                      fontSize: 12,
                      color: isMe ? Colors.white : Colors.black87),
                  textAlign: TextAlign.center,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Text(
                  isMediaSent ? "Tap to play video" : "Video",
                  style: GoogleFonts.poppins(
                      fontSize: 10,
                      color: isMe ? Colors.white70 : Colors.grey[500]),
                ),
              ],
            ),
          ),
        );
      } else if (mediaType.startsWith('audio/')) {
        final audioPlayerState = ref.watch(audioPlayerStateProvider);
        final currentPlayingUrl = ref.watch(currentAudioUrlProvider);
        final playerNotifier = ref.read(audioPlayerControllerProvider.notifier);
        final bool canPlay = isMediaSent && !isUsingLocalFile;
        final bool isThisLoading = canPlay &&
            currentPlayingUrl == displayPath &&
            audioPlayerState == AudioPlayerState.loading;
        final bool isThisPlaying = canPlay &&
            currentPlayingUrl == displayPath &&
            audioPlayerState == AudioPlayerState.playing;
        final bool isThisPaused = canPlay &&
            currentPlayingUrl == displayPath &&
            audioPlayerState == AudioPlayerState.paused;
        messageContent = Row(
            /* ... audio content ... */ mainAxisSize: MainAxisSize.min,
            children: [
              IconButton(
                icon: isThisLoading
                    ? SizedBox(
                        width: 24,
                        height: 24,
                        child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: isMe ? Colors.white : Color(0xFF8B5CF6)))
                    : Icon(isThisPlaying
                        ? Icons.pause_circle_filled_rounded
                        : Icons.play_circle_fill_rounded),
                color: isMe
                    ? Colors.white
                    : (canPlay ? const Color(0xFF8B5CF6) : Colors.grey[400]),
                iconSize: 36,
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(),
                tooltip: canPlay ? (isThisPlaying ? 'Pause' : 'Play') : 'Audio',
                onPressed: isThisLoading || !canPlay
                    ? null
                    : () {
                        if (isThisPlaying)
                          playerNotifier.pause();
                        else if (isThisPaused)
                          playerNotifier.resume();
                        else
                          playerNotifier.play(displayPath!);
                      },
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  getFilenameFromUrl(displayPath),
                  style: GoogleFonts.poppins(
                      fontSize: 13,
                      color: isMe ? Colors.white : Colors.black87),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 2,
                ),
              ),
            ]);
      } else {
        messageContent = InkWell(
          onTap: isMediaSent && !isUsingLocalFile
              ? () => _openMedia(context, displayPath)
              : null,
          child: Row(
              /* ... generic file content ... */ mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.insert_drive_file_outlined,
                    color: isMe ? Colors.white70 : Colors.grey[600], size: 30),
                const SizedBox(width: 10),
                Expanded(
                  child: Text(
                    getFilenameFromUrl(displayPath),
                    style: GoogleFonts.poppins(
                        fontSize: 13,
                        color: isMe ? Colors.white : Colors.black87),
                    overflow: TextOverflow.ellipsis,
                    maxLines: 2,
                  ),
                ),
              ]),
        );
      }
    } else {
      messageContent = Text(
        message.messageText,
        style: GoogleFonts.poppins(
          color: isMe ? Colors.white : Colors.black87,
          fontSize: 15,
        ),
      );
    }

    // --- Build Final Bubble Structure ---
    return Align(
      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
      child: Dismissible(
        key: Key(message.messageID.toString()),
        direction: DismissDirection.startToEnd,
        confirmDismiss: (direction) async {
          if (kDebugMode)
            print("[MessageBubble] Swiped message ID: ${message.messageID}");
          widget.onReplyInitiated(message);
          return false; // Do not actually dismiss
        },
        background: Container(
          // Simple background, ensures the bubble decoration shows correctly
          decoration: BoxDecoration(
              color: Colors.blue.withOpacity(0.1),
              borderRadius: borderRadius // Match bubble radius
              ),
          padding: const EdgeInsets.symmetric(horizontal: 20),
          alignment: Alignment.centerLeft,
          child: const Icon(Icons.reply, color: Colors.blue),
        ),
        child: Container(
          constraints: BoxConstraints(
            maxWidth: MediaQuery.of(context).size.width * 0.75,
          ),
          margin: EdgeInsets.only(
            top: 4.0,
            bottom: 4.0,
            left: isMe ? 0 : (showTail ? 0 : 10.0),
            right: isMe ? (showTail ? 0 : 10.0) : 0,
          ),
          decoration: BoxDecoration(
            color: isMe ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: borderRadius,
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 3,
                offset: const Offset(0, 1),
              )
            ],
          ),
          child: ClipRRect(
            borderRadius: borderRadius,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // *** Conditionally display reply snippet ***
                if (message.isReply) _buildReplySnippet(),

                // Original content and status icon
                Stack(
                  children: [
                    Padding(
                      // *** MODIFIED: Add extra padding if it's a reply for visual separation ***
                      padding: message.isMedia &&
                              (message.mediaType?.startsWith('image/') ?? false)
                          ? EdgeInsets.zero // No padding for images
                          : EdgeInsets.only(
                              // Add vertical padding conditionally
                              left: 14.0,
                              right: 14.0,
                              top: message.isReply
                                  ? 6.0
                                  : 10.0, // Less top padding if reply
                              bottom: 10.0,
                            ),
                      // *** END MODIFIED ***
                      child: messageContent,
                    ),
                    if (statusIcon != null)
                      Positioned(
                        bottom: 4,
                        right: isMe ? 4 : null,
                        left: isMe ? null : 4,
                        child: statusIcon,
                      ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: widgets/report_reason_dialog.dart
================================================
// File: lib/widgets/report_reason_dialog.dart
import 'package:dtx/utils/app_enums.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

Future<ReportReason?> showReportReasonDialog(BuildContext context) async {
  return await showDialog<ReportReason>(
    context: context,
    builder: (BuildContext dialogContext) {
      ReportReason? selectedReason; // Local state for the dialog
      return StatefulBuilder(
        // Use StatefulBuilder for local state update
        builder: (context, setState) {
          return AlertDialog(
            title: Text("Report User",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
            contentPadding:
                const EdgeInsets.fromLTRB(24, 20, 24, 0), // Adjust padding
            content: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: ReportReason.values.map((reason) {
                  return RadioListTile<ReportReason>(
                    title: Text(reason.label, style: GoogleFonts.poppins()),
                    value: reason,
                    groupValue: selectedReason,
                    onChanged: (ReportReason? value) {
                      setState(() {
                        // Use the setState from StatefulBuilder
                        selectedReason = value;
                      });
                    },
                    activeColor: const Color(0xFF8B5CF6),
                    contentPadding: EdgeInsets.zero,
                  );
                }).toList(),
              ),
            ),
            actions: <Widget>[
              TextButton(
                child: Text('Cancel',
                    style: GoogleFonts.poppins(color: Colors.grey)),
                onPressed: () => Navigator.of(dialogContext)
                    .pop(null), // Return null on cancel
              ),
              TextButton(
                child: Text('Submit Report',
                    style: GoogleFonts.poppins(color: Colors.redAccent)),
                // Enable button only if a reason is selected
                onPressed: selectedReason == null
                    ? null
                    : () => Navigator.of(dialogContext).pop(selectedReason),
              ),
            ],
          );
        },
      );
    },
  );
}


