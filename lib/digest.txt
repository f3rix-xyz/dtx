Directory structure:
└── lib/
    ├── main.dart
    ├── models/
    │   ├── auth_model.dart
    │   ├── error_model.dart
    │   ├── feed_models.dart
    │   ├── like_models.dart
    │   ├── location_model.dart
    │   ├── media_upload_model.dart
    │   └── user_model.dart
    ├── providers/
    │   ├── audio_player_provider.dart
    │   ├── audio_upload_provider.dart
    │   ├── auth_provider.dart
    │   ├── error_provider.dart
    │   ├── liker_profile_provider.dart
    │   ├── location_provider.dart
    │   ├── media_upload_provider.dart
    │   ├── recieved_likes_provider.dart
    │   ├── service_provider.dart
    │   └── user_provider.dart
    ├── repositories/
    │   ├── auth_repository.dart
    │   ├── auth_status_repository.dart
    │   ├── like_repository.dart
    │   ├── media_repository.dart
    │   └── user_repository.dart
    ├── services/
    │   ├── api_service.dart
    │   └── http_service.dart
    ├── utils/
    │   ├── app_enums.dart
    │   ├── env_config.dart
    │   └── token_storage.dart
    ├── views/
    │   ├── audioprompt.dart
    │   ├── audiopromptsselect.dart
    │   ├── dating_intentions.dart
    │   ├── dob.dart
    │   ├── drinking.dart
    │   ├── gender.dart
    │   ├── google_sign_in_screen.dart
    │   ├── height.dart
    │   ├── home.dart
    │   ├── hometown.dart
    │   ├── job.dart
    │   ├── liker_profile_screen.dart
    │   ├── location.dart
    │   ├── media.dart
    │   ├── name.dart
    │   ├── profile_screens.dart
    │   ├── prompt.dart
    │   ├── religion.dart
    │   ├── selfie_capture_screen.dart
    │   ├── settings_screen.dart
    │   ├── smoking.dart
    │   ├── splash_screen.dart
    │   ├── study.dart
    │   ├── textpromptsselect.dart
    │   ├── verification_message_screen.dart
    │   ├── verification_pending_screen.dart
    │   ├── who_liked_you_screen.dart
    │   ├── writeprompt.dart
    │   ├── youtube.dart
    │   └── core/
    │       └── error_handler.dart
    └── widgets/
        ├── basic_liker_profile_card.dart
        ├── full_liker_profile_card.dart
        ├── home_profile_card.dart
        └── quick_profile_card.dart

================================================
File: main.dart
================================================
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/gender.dart';
import 'package:dtx/views/height.dart';
import 'package:dtx/views/home.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/prompt.dart';
import 'package:flutter/material.dart';
import 'package:dtx/views/splash_screen.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

void main() async {
  // Ensure Flutter is initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Load environment variables
  await dotenv.load(fileName: ".env");

  runApp(
    // Adding ProviderScope at the root of the app
    const ProviderScope(
      child: MyApp(),
    ),
  );
}

// Change StatelessWidget to ConsumerWidget to use Riverpod
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp(
      title: 'DTX',
      debugShowCheckedModeBanner: false, // Optional: removes debug banner
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // You can add more theme configurations here
      ),
      // You can change the home screen here based on your flow
      // For example, start with PhoneInputScreen for authentication flow
      home: const SplashScreen(),
    );
  }
}



================================================
File: models/auth_model.dart
================================================
// File: models/auth_model.dart

// --- UPDATED ENUM ---
enum AuthStatus {
  login, // Needs to log in (no valid token or check failed)
  onboarding1, // Logged in, needs location/gender
  onboarding2, // Logged in, location/gender set, needs main profile details
  home, // Fully authenticated and onboarded
  unknown, // Initial state or error during status check
}
// --- END UPDATED ENUM ---

class AuthState {
  // --- REMOVED FIELDS ---
  // final String? unverifiedPhone;
  // final String? verificationId;
  // final int? resendTimer;
  // --- END REMOVED FIELDS ---

  final bool isLoading;
  final String? error; // Keep error for general auth errors
  final String? jwtToken;
  final AuthStatus authStatus;

  const AuthState({
    this.isLoading = false,
    this.error,
    this.jwtToken,
    this.authStatus = AuthStatus.unknown, // Default to unknown
  });

  AuthState copyWith({
    bool? isLoading,
    String? Function()? error,
    String? Function()? jwtToken, // Function to allow setting null
    AuthStatus? authStatus,
  }) {
    return AuthState(
      isLoading: isLoading ?? this.isLoading,
      error: error != null ? error() : this.error,
      jwtToken: jwtToken != null ? jwtToken() : this.jwtToken,
      authStatus: authStatus ?? this.authStatus,
    );
  }

  // Check if user is considered authenticated (has a token)
  bool get isAuthenticated => jwtToken != null && jwtToken!.isNotEmpty;
}



================================================
File: models/error_model.dart
================================================
enum ErrorType { network, validation, auth, generic, locationService, server }

class AppError {
  final String message;
  final ErrorType type;
  final DateTime timestamp;

  AppError({
    required this.message,
    required this.type,
  }) : timestamp = DateTime.now();

  factory AppError.network(String message) => AppError(
        message: message,
        type: ErrorType.network,
      );

  factory AppError.validation(String message) => AppError(
        message: message,
        type: ErrorType.validation,
      );

  factory AppError.auth(String message) => AppError(
        message: message,
        type: ErrorType.auth,
      );

  factory AppError.locationService(String message) => AppError(
        message: message,
        type: ErrorType.locationService,
      );

  factory AppError.server(String message) => AppError(
        message: message,
        type: ErrorType.server,
      );

  factory AppError.generic(String message) => AppError(
        message: message,
        type: ErrorType.generic, // Use the generic type
      );
}



================================================
File: models/feed_models.dart
================================================
// File: models/feed_models.dart
import 'package:dtx/utils/app_enums.dart'; // For GenderEnum if needed

// --- Base Profile Info (Common fields) ---
// We can reuse UserModel partially, but separate models might be cleaner
// for feed-specific data like distance. Let's define simple ones for now.

class FeedProfile {
  final int id;
  final String? name; // Use String? for null safety
  final String? lastName;
  final DateTime? dateOfBirth;
  final List<String>? mediaUrls;
  final Gender? gender; // Use Gender enum
  // Add other fields displayed on cards if necessary
  final double? distanceKm;

  FeedProfile({
    required this.id,
    this.name,
    this.lastName,
    this.dateOfBirth,
    this.mediaUrls,
    this.gender,
    this.distanceKm,
  });

  // Helper to get the first name safely
  String get firstName => name ?? '';

  // Helper to calculate age
  int? get age {
    if (dateOfBirth == null) return null;
    final now = DateTime.now();
    int age = now.year - dateOfBirth!.year;
    if (now.month < dateOfBirth!.month ||
        (now.month == dateOfBirth!.month && now.day < dateOfBirth!.day)) {
      age--;
    }
    return age < 18 ? null : age; // Return null if under 18 or dob invalid
  }

  // Helper to get the first media URL safely
  String? get firstMediaUrl {
    if (mediaUrls != null &&
        mediaUrls!.isNotEmpty &&
        mediaUrls![0].isNotEmpty) {
      return mediaUrls![0];
    }
    return null;
  }

  // Factory constructor to parse common fields from API response map
  // Note: Backend uses pgtype which marshals to {"Type": value, "Valid": bool}
  factory FeedProfile.fromJson(Map<String, dynamic> json) {
    DateTime? parseDate(dynamic dateField) {
      if (dateField is Map &&
          dateField['Valid'] == true &&
          dateField['Time'] != null) {
        try {
          return DateTime.parse(dateField['Time'] as String);
        } catch (e) {
          return null;
        }
      }
      return null;
    }

    List<String>? parseMediaUrls(dynamic urls) {
      if (urls is List) {
        return List<String>.from(
            urls.where((item) => item is String && item.isNotEmpty));
      }
      return null;
    }

    Gender? parseGender(dynamic genderField) {
      if (genderField is Map &&
          genderField['Valid'] == true &&
          genderField['GenderEnum'] != null) {
        final genderStr = genderField['GenderEnum'] as String;
        if (genderStr == 'man') return Gender.man;
        if (genderStr == 'woman') return Gender.woman;
      }
      return null;
    }

    return FeedProfile(
      id: json['id'] as int? ?? 0, // Provide default or handle error
      name: (json['name'] is Map && json['name']['Valid'])
          ? json['name']['String'] as String?
          : null,
      lastName: (json['last_name'] is Map && json['last_name']['Valid'])
          ? json['last_name']['String'] as String?
          : null,
      dateOfBirth: parseDate(json['date_of_birth']),
      mediaUrls: parseMediaUrls(json['media_urls']),
      gender: parseGender(json['gender']),
      distanceKm:
          (json['distance_km'] as num?)?.toDouble(), // Safely cast distance
    );
  }
}

// --- Quick Feed Specific Model ---
// Can inherit or compose if more fields are needed later
class QuickFeedProfile extends FeedProfile {
  // Add any fields specific to QuickFeedRow if they exist
  // Currently, it seems GetQuickFeedRow in Go just returns User + distance_km

  QuickFeedProfile({
    required super.id,
    super.name,
    super.lastName,
    super.dateOfBirth,
    super.mediaUrls,
    super.gender,
    super.distanceKm,
  });

  // Factory to create from the specific API response structure
  // Assuming GetQuickFeedRow directly maps to FeedProfile fields
  factory QuickFeedProfile.fromJson(Map<String, dynamic> json) {
    // Directly use the base FeedProfile parser
    return QuickFeedProfile(
      id: json['id'] as int? ?? 0,
      name: (json['name'] is Map && json['name']['Valid'])
          ? json['name']['String'] as String?
          : null,
      lastName: (json['last_name'] is Map && json['last_name']['Valid'])
          ? json['last_name']['String'] as String?
          : null,
      dateOfBirth: FeedProfile.fromJson(json)
          .dateOfBirth, // Reuse base parsing logic for date
      mediaUrls:
          FeedProfile.fromJson(json).mediaUrls, // Reuse base parsing logic
      gender: FeedProfile.fromJson(json).gender, // Reuse base parsing logic
      distanceKm: (json['distance_km'] as num?)?.toDouble(),
    );
  }
}

// --- Home Feed Specific Model ---
class HomeFeedProfile extends FeedProfile {
  // Add other fields returned by GetHomeFeedRow if needed (e.g., prompts, full details)
  // For now, it seems GetHomeFeedRow also just returns User + distance_km
  // If you need prompts etc., add them here and update the factory.

  HomeFeedProfile({
    required super.id,
    super.name,
    super.lastName,
    super.dateOfBirth,
    super.mediaUrls,
    super.gender,
    super.distanceKm,
    // Add other fields here
  });

  // Factory to create from the specific API response structure
  // Assuming GetHomeFeedRow directly maps to FeedProfile fields
  factory HomeFeedProfile.fromJson(Map<String, dynamic> json) {
    // Directly use the base FeedProfile parser
    return HomeFeedProfile(
      id: json['id'] as int? ?? 0,
      name: (json['name'] is Map && json['name']['Valid'])
          ? json['name']['String'] as String?
          : null,
      lastName: (json['last_name'] is Map && json['last_name']['Valid'])
          ? json['last_name']['String'] as String?
          : null,
      dateOfBirth: FeedProfile.fromJson(json)
          .dateOfBirth, // Reuse base parsing logic for date
      mediaUrls:
          FeedProfile.fromJson(json).mediaUrls, // Reuse base parsing logic
      gender: FeedProfile.fromJson(json).gender, // Reuse base parsing logic
      distanceKm: (json['distance_km'] as num?)?.toDouble(),
    );
  }
}



================================================
File: models/like_models.dart
================================================
// File: models/like_models.dart
import 'package:dtx/models/user_model.dart'; // Import UserProfileData definition source
import 'package:dtx/utils/app_enums.dart'; // For GenderEnum if needed
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Only needed if UserProfileData uses Riverpod types directly, unlikely.

// --- Enums (from Phase 8) ---
enum ContentLikeType {
  /* ... */
  media('media'),
  promptStory('prompt_story'),
  promptMytype('prompt_mytype'),
  promptGettingpersonal('prompt_gettingpersonal'),
  promptDatevibes('prompt_datevibes'),
  audioPrompt('audio_prompt');

  final String value;
  const ContentLikeType(this.value);
  static ContentLikeType? fromValue(String? value) {
    if (value == null) return null;
    return ContentLikeType.values.firstWhere((e) => e.value == value,
        orElse: () => ContentLikeType.media);
  }
}

enum LikeInteractionType {
  /* ... */
  standard('standard'),
  rose('rose');

  final String value;
  const LikeInteractionType(this.value);
  static LikeInteractionType? fromValue(String? value) {
    if (value == null) return null;
    return LikeInteractionType.values.firstWhere((e) => e.value == value,
        orElse: () => LikeInteractionType.standard);
  }
}

// --- Custom Exceptions (from Phase 8) ---
class LikeLimitExceededException implements Exception {
  /* ... */ final String message;
  LikeLimitExceededException([this.message = 'Daily like limit reached.']);
  @override
  String toString() => message;
}

class InsufficientRosesException implements Exception {
  /* ... */ final String message;
  InsufficientRosesException([this.message = 'You don\'t have enough Roses.']);
  @override
  String toString() => message;
}

// --- Liker Data Structures ---

// Structure for Full Profile Liker (Matches API Response `full_profiles` item)
class FullProfileLiker {
  final int likerUserId;
  final String? likeComment; // Nullable string
  final bool isRose;
  final DateTime? likedAt; // Parsed timestamp
  final UserProfileData profile; // Embedded full profile data

  FullProfileLiker({
    required this.likerUserId,
    this.likeComment,
    required this.isRose,
    this.likedAt,
    required this.profile,
  });

  factory FullProfileLiker.fromJson(Map<String, dynamic> json) {
    DateTime? parseTimestamp(dynamic ts) {
      if (ts is String) {
        try {
          return DateTime.parse(ts).toLocal();
        } catch (_) {} // Parse and convert to local time
      }
      return null;
    }

    // Safely get comment string
    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        // Handle direct string just in case
        return commentField;
      }
      return null;
    }

    return FullProfileLiker(
      likerUserId: json['liker_user_id'] as int? ?? 0,
      likeComment: getComment(json['like_comment']),
      isRose: json['is_rose'] as bool? ??
          (json['interaction_type'] ==
              'rose'), // Check interaction_type if is_rose missing
      likedAt: parseTimestamp(json['liked_at']),
      // Assuming 'profile' contains the full UserProfileData structure
      profile: UserProfileData.fromJson(
          json['profile'] as Map<String, dynamic>? ?? {}),
    );
  }
}

// Structure for Basic Profile Liker (Matches API Response `other_likers` item)
class BasicProfileLiker {
  final int likerUserId;
  final String name; // Should ideally always have a name
  final String? firstProfilePicUrl; // Nullable string
  final String? likeComment; // Nullable string
  final bool isRose;
  final DateTime? likedAt; // Parsed timestamp

  BasicProfileLiker({
    required this.likerUserId,
    required this.name,
    this.firstProfilePicUrl,
    this.likeComment,
    required this.isRose,
    this.likedAt,
  });

  factory BasicProfileLiker.fromJson(Map<String, dynamic> json) {
    DateTime? parseTimestamp(dynamic ts) {
      if (ts is String) {
        try {
          return DateTime.parse(ts).toLocal();
        } catch (_) {}
      }
      return null;
    }

    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        return commentField;
      }
      return null;
    }

    String? getPicUrl(dynamic urls) {
      if (urls is List && urls.isNotEmpty && urls[0] is String) {
        return urls[0];
      }
      return null;
    }

    String buildName(dynamic nameField, dynamic lastNameField) {
      String firstName = (nameField is Map && nameField['Valid'] == true)
          ? nameField['String'] ?? ''
          : '';
      String lastName = (lastNameField is Map && lastNameField['Valid'] == true)
          ? lastNameField['String'] ?? ''
          : '';
      return '$firstName $lastName'.trim(); // Combine and trim whitespace
    }

    return BasicProfileLiker(
      likerUserId: json['liker_user_id'] as int? ?? 0,
      name: buildName(json['name'], json['last_name']), // Build name safely
      firstProfilePicUrl: getPicUrl(json['media_urls']), // Get first URL safely
      likeComment: getComment(json['like_comment']),
      isRose: json['is_rose'] as bool? ?? (json['interaction_type'] == 'rose'),
      likedAt: parseTimestamp(json['liked_at']),
    );
  }
}

class LikeInteractionDetails {
  final String? likeComment; // Nullable string
  final bool isRose;

  LikeInteractionDetails({
    this.likeComment,
    required this.isRose,
  });

  factory LikeInteractionDetails.fromJson(Map<String, dynamic> json) {
    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        return commentField;
      }
      return null;
    }

    return LikeInteractionDetails(
      likeComment: getComment(
          json['comment']), // Assuming key is 'comment' from GetLikeDetailsRow
      isRose: json['interaction_type'] ==
          LikeInteractionType.rose.value, // Check interaction_type
    );
  }
}

// --- Placeholder for UserProfileData (if not defined elsewhere) ---
// IMPORTANT: Ensure this structure *exactly* matches the one expected
// by FullProfileLiker.fromJson and used in views/profile_screens.dart
// It should contain all fields returned by GET /get-profile.
// For simplicity, re-using UserModel might work if its fromJson handles the /get-profile structure.

class UserProfileData extends UserModel {
  // If UserProfileData needs fields BEYOND UserModel, add them here.
  // Example: final int matchScore;

  UserProfileData({
    // Inherit all fields from UserModel
    super.name,
    super.lastName,
    super.email,
    super.phoneNumber,
    super.dateOfBirth,
    super.latitude,
    super.longitude,
    super.gender,
    super.datingIntention,
    super.height,
    super.hometown,
    super.jobTitle,
    super.education,
    super.religiousBeliefs,
    super.drinkingHabit,
    super.smokingHabit,
    super.mediaUrls,
    super.prompts = const [],
    super.audioPrompt,
    super.verificationStatus,
    super.verificationPic,
    super.role,
    // Add any extra fields here:
    // required this.matchScore,
  });

  factory UserProfileData.fromJson(Map<String, dynamic> json) {
    // Parse UserModel fields using its factory
    final userModel = UserModel.fromJson(json);

    // Parse any additional fields specific to UserProfileData
    // final int score = json['match_score'] as int? ?? 0;

    return UserProfileData(
      name: userModel.name, lastName: userModel.lastName,
      email: userModel.email,
      phoneNumber: userModel.phoneNumber, dateOfBirth: userModel.dateOfBirth,
      latitude: userModel.latitude, longitude: userModel.longitude,
      gender: userModel.gender,
      datingIntention: userModel.datingIntention, height: userModel.height,
      hometown: userModel.hometown,
      jobTitle: userModel.jobTitle, education: userModel.education,
      religiousBeliefs: userModel.religiousBeliefs,
      drinkingHabit: userModel.drinkingHabit,
      smokingHabit: userModel.smokingHabit,
      mediaUrls: userModel.mediaUrls, prompts: userModel.prompts,
      audioPrompt: userModel.audioPrompt,
      verificationStatus: userModel.verificationStatus,
      verificationPic: userModel.verificationPic,
      role: userModel.role,
      // Assign additional fields:
      // matchScore: score,
    );
  }
}



================================================
File: models/location_model.dart
================================================
class LocationState {
  final bool isLoading;
  final bool isFetching;
  final double latitude;
  final double longitude;
  final double? cachedLatitude;
  final double? cachedLongitude;
  final bool isMapReady;

  LocationState({
    this.isLoading = true,
    this.isFetching = false,
    this.latitude = 19.2183, // Default location
    this.longitude = 73.0864,
    this.cachedLatitude,
    this.cachedLongitude,
    this.isMapReady = false,
  });

  LocationState copyWith({
    bool? isLoading,
    bool? isFetching,
    double? latitude,
    double? longitude,
    double? cachedLatitude,
    double? cachedLongitude,
    bool? isMapReady,
  }) {
    return LocationState(
      isLoading: isLoading ?? this.isLoading,
      isFetching: isFetching ?? this.isFetching,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      cachedLatitude: cachedLatitude ?? this.cachedLatitude,
      cachedLongitude: cachedLongitude ?? this.cachedLongitude,
      isMapReady: isMapReady ?? this.isMapReady,
    );
  }
}



================================================
File: models/media_upload_model.dart
================================================

// models/media_upload_model.dart
import 'dart:io';

enum UploadStatus {
  idle,
  inProgress,
  success,
  failed,
}

class MediaUploadModel {
  final File file;
  final String fileName;
  final String fileType;
  final String? presignedUrl;
  final UploadStatus status;
  final String? errorMessage;
  
  MediaUploadModel({
    required this.file,
    required this.fileName,
    required this.fileType,
    this.presignedUrl,
    this.status = UploadStatus.idle,
    this.errorMessage,
  });
  
  MediaUploadModel copyWith({
    File? file,
    String? fileName,
    String? fileType,
    String? Function()? presignedUrl,
    UploadStatus? status,
    String? Function()? errorMessage,
  }) {
    return MediaUploadModel(
      file: file ?? this.file,
      fileName: fileName ?? this.fileName,
      fileType: fileType ?? this.fileType,
      presignedUrl: presignedUrl != null ? presignedUrl() : this.presignedUrl,
      status: status ?? this.status,
      errorMessage: errorMessage != null ? errorMessage() : this.errorMessage,
    );
  }
}



================================================
File: models/user_model.dart
================================================
// File: models/user_model.dart
import 'package:dtx/utils/app_enums.dart';
// No need for 'dart:convert' import here unless used elsewhere in this specific file

// --- Prompt Class ---
class Prompt {
  final PromptCategory category;
  final PromptType question;
  final String answer;

  Prompt({
    required this.category,
    required this.question,
    required this.answer,
  });

  Map<String, dynamic> toJson() => {
        'category': category.value,
        'question': question.value,
        'answer': answer,
      };

  factory Prompt.fromJson(Map<String, dynamic> json) {
    PromptCategory category = PromptCategory.values
        .firstWhere((e) => e.value == json['category'], orElse: () {
      // print("Warning: Unknown prompt category '${json['category']}', defaulting.");
      return PromptCategory.storyTime;
    });
    PromptType question = PromptType.values
        .firstWhere((e) => e.value == json['question'], orElse: () {
      // print("Warning: Unknown prompt question '${json['question']}' for category '${category.value}', defaulting.");
      return category.getPrompts().isNotEmpty
          ? category.getPrompts().first
          : PromptType.twoTruthsAndALie;
    });

    return Prompt(
      category: category,
      question: question,
      answer: json['answer'] ?? '',
    );
  }

  Prompt copyWith({String? answer}) {
    return Prompt(
      category: category,
      question: question,
      answer: answer ?? this.answer,
    );
  }

  @override
  String toString() {
    return 'Prompt(question: ${question.label}, answer: $answer)';
  }
}

// --- AudioPromptModel Class ---
class AudioPromptModel {
  final AudioPrompt prompt;
  final String audioUrl;

  AudioPromptModel({
    required this.prompt,
    required this.audioUrl,
  });

  Map<String, dynamic> toJson() => {
        'prompt': prompt.value,
        'audio_url': audioUrl,
      };

  // --- Factory signature is NON-NULLABLE ---
  factory AudioPromptModel.fromJson(Map<String, dynamic> json) {
    final promptValue =
        json['audio_prompt_question']?['AudioPrompt'] as String?;
    final audioUrlValue = json['audio_prompt_answer']?['String'] as String?;
    final bool isPromptValid =
        json['audio_prompt_question']?['Valid'] as bool? ?? false;
    final bool isUrlValid =
        json['audio_prompt_answer']?['Valid'] as bool? ?? false;

    if (!isPromptValid ||
        !isUrlValid ||
        promptValue == null ||
        audioUrlValue == null) {
      // --- Throw exception for invalid data ---
      throw const FormatException(
          'Invalid or missing audio prompt data in JSON');
    }

    AudioPrompt prompt = AudioPrompt.values
        .firstWhere((e) => e.value == promptValue, orElse: () {
      print("Warning: Unknown audio prompt '$promptValue', defaulting.");
      return AudioPrompt.aBoundaryOfMineIs;
    });

    return AudioPromptModel(
      prompt: prompt,
      audioUrl: audioUrlValue,
    );
  }
}

// --- UserModel Class ---
class UserModel {
  final int? id;
  final String? name;
  final String? lastName;
  final String? phoneNumber;
  final String? email;
  final DateTime? dateOfBirth;
  final double? latitude;
  final double? longitude;
  final Gender? gender;
  final DatingIntention? datingIntention;
  final String? height;
  final String? hometown;
  final String? jobTitle;
  final String? education;
  final Religion? religiousBeliefs;
  final DrinkingSmokingHabits? drinkingHabit;
  final DrinkingSmokingHabits? smokingHabit;
  final List<String>? mediaUrls;
  final List<Prompt> prompts;
  final AudioPromptModel? audioPrompt; // This field remains nullable
  final String? verificationStatus;
  final String? verificationPic;
  final String? role;

  UserModel({
    this.id,
    this.name,
    this.lastName,
    this.phoneNumber,
    this.email,
    this.dateOfBirth,
    this.latitude,
    this.longitude,
    this.gender,
    this.datingIntention,
    this.height,
    this.hometown,
    this.jobTitle,
    this.education,
    this.religiousBeliefs,
    this.drinkingHabit,
    this.smokingHabit,
    this.mediaUrls,
    this.prompts = const [],
    this.audioPrompt,
    this.verificationStatus,
    this.verificationPic,
    this.role,
  });

  int? get age {
    if (dateOfBirth == null) return null;
    final now = DateTime.now();
    int age = now.year - dateOfBirth!.year;
    if (now.month < dateOfBirth!.month ||
        (now.month == dateOfBirth!.month && now.day < dateOfBirth!.day)) {
      age--;
    }
    return age < 18 ? null : age;
  }

  String? get firstMediaUrl {
    if (mediaUrls != null &&
        mediaUrls!.isNotEmpty &&
        mediaUrls![0].isNotEmpty) {
      return mediaUrls![0];
    }
    return null;
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'last_name': lastName,
        'phone_number': phoneNumber,
        'email': email,
        'date_of_birth': dateOfBirth?.toIso8601String().split('T').first,
        'latitude': latitude,
        'longitude': longitude,
        'gender': gender?.value,
        'dating_intention': datingIntention?.value,
        'height': height,
        'hometown': hometown,
        'job_title': jobTitle,
        'education': education,
        'religious_beliefs': religiousBeliefs?.value,
        'drinking_habit': drinkingHabit?.value,
        'smoking_habit': smokingHabit?.value,
        'media_urls': mediaUrls,
        'prompts': prompts.map((prompt) => prompt.toJson()).toList(),
        'audio_prompt': audioPrompt?.toJson(),
        'verification_status': verificationStatus,
        'verification_pic': verificationPic,
        'role': role,
      };

  Map<String, dynamic> toJsonForProfileUpdate() {
    String? formattedDate(DateTime? dt) {
      if (dt == null) return null;
      return "${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')}";
    }

    String? formattedHeight(String? h) {
      return h?.replaceAll("' ", "'");
    }

    final Map<String, dynamic> data = {};
    if (name != null) data['name'] = name;
    data['last_name'] = lastName ?? "";
    if (dateOfBirth != null) data['date_of_birth'] = formattedDate(dateOfBirth);
    if (datingIntention != null)
      data['dating_intention'] = datingIntention!.value;
    if (height != null) data['height'] = formattedHeight(height);
    if (hometown != null) data['hometown'] = hometown;
    if (jobTitle != null) data['job_title'] = jobTitle;
    if (education != null) data['education'] = education;
    if (religiousBeliefs != null)
      data['religious_beliefs'] = religiousBeliefs!.value;
    if (drinkingHabit != null) data['drinking_habit'] = drinkingHabit!.value;
    if (smokingHabit != null) data['smoking_habit'] = smokingHabit!.value;
    if (prompts.isNotEmpty)
      data['prompts'] = prompts.map((p) => p.toJson()).toList();

    return data;
  }

  factory UserModel.fromJson(Map<String, dynamic> json) {
    // --- Helper Functions ---
    String? getString(dynamic field) {
      if (field is Map && field['Valid'] == true && field['String'] != null) {
        return field['String'] as String?;
      } else if (field is String) {
        return field;
      }
      return null;
    }

    String? getEnumString(dynamic field, String key) {
      if (field is Map && field['Valid'] == true && field[key] != null) {
        return field[key] as String?;
      }
      return null;
    }

    DateTime? getDate(dynamic field) {
      if (field is Map && field['Valid'] == true && field['Time'] != null) {
        try {
          String dateStr = field['Time'] as String;
          if (dateStr.contains('T')) {
            return DateTime.parse(dateStr.split('T').first);
          } else {
            return DateTime.parse(dateStr);
          }
        } catch (e) {
          return null;
        }
      } else if (field is String) {
        try {
          if (field.contains('T')) {
            return DateTime.parse(field.split('T').first);
          } else {
            return DateTime.parse(field);
          }
        } catch (e) {
          return null;
        }
      }
      return null;
    }

    double? getDouble(dynamic field) {
      if (field is Map && field['Valid'] == true && field['Float64'] != null) {
        return (field['Float64'] as num?)?.toDouble();
      } else if (field is num) {
        return field.toDouble();
      }
      return null;
    }

    T? parseEnum<T>(List<T> enumValues, dynamic field, String key) {
      final valueStr = getEnumString(field, key);
      if (valueStr != null) {
        try {
          return enumValues.firstWhere(
            (e) => (e as dynamic).value == valueStr,
          );
        } catch (e) {
          return null;
        }
      }
      return null;
    }

    List<String>? getMediaUrls(dynamic field) {
      if (field is List) {
        return List<String>.from(
            field.where((item) => item is String && item.isNotEmpty));
      }
      return null;
    }

    List<Prompt> getPrompts(Map<String, dynamic> json) {
      List<Prompt> parsedPrompts = [];
      if (json['prompts'] is List) {
        final List<dynamic> promptList = json['prompts'];
        // print("[UserModel fromJson] Parsing prompts from top-level 'prompts' field: ${promptList.length} items");
        for (var promptData in promptList) {
          if (promptData is Map<String, dynamic>) {
            try {
              final parsedPrompt = Prompt.fromJson(promptData);
              parsedPrompts.add(parsedPrompt);
              // print("[UserModel fromJson] Successfully parsed prompt: ${parsedPrompt.question.label}");
            } catch (e) {
              // print("[UserModel fromJson] Error parsing prompt from top-level: $e");
            }
          } else {
            // print("[UserModel fromJson] Item in top-level 'prompts' is not a Map: $promptData");
          }
        }
        if (parsedPrompts.isNotEmpty) {
          // print("[UserModel fromJson] Finished parsing from top-level 'prompts'. Count: ${parsedPrompts.length}");
          return parsedPrompts;
        }
      }

      // print("[UserModel fromJson] Top-level 'prompts' not found or empty. Parsing from category fields...");
      final promptKeys = [
        'dateVibesPrompts',
        'gettingPersonalPrompts',
        'myTypePrompts',
        'storyTimePrompts'
      ];
      for (var promptKey in promptKeys) {
        if (json[promptKey] is List) {
          final List<dynamic> promptList = json[promptKey];
          // print("[UserModel fromJson] Parsing prompts from '$promptKey': ${promptList.length} items");
          for (var promptData in promptList) {
            if (promptData is Map<String, dynamic>) {
              try {
                final questionStr = promptData['Question'] as String?;
                final answerStr = promptData['Answer'] as String?;
                if (questionStr != null && answerStr != null) {
                  final questionEnum = PromptType.values.firstWhere(
                      (e) => e.value == questionStr,
                      orElse: () => PromptType.twoTruthsAndALie);
                  parsedPrompts.add(Prompt(
                    category: questionEnum.getCategory(),
                    question: questionEnum,
                    answer: answerStr,
                  ));
                  // print("[UserModel fromJson] Successfully parsed prompt from category field: ${questionEnum.label}");
                } else {
                  // print("[UserModel fromJson] Missing 'Question' or 'Answer' in category prompt data: $promptData");
                }
              } catch (e) {
                // print("[UserModel fromJson] Error parsing prompt from category field '$promptKey': $e");
              }
            } else {
              // print("[UserModel fromJson] Item in '$promptKey' is not a Map: $promptData");
            }
          }
        }
      }
      // print("[UserModel fromJson] Finished parsing from category fields. Count: ${parsedPrompts.length}");
      return parsedPrompts;
    }

    // --- FIX: Use try-catch to handle potential FormatException from AudioPromptModel.fromJson ---
    AudioPromptModel? getAudioPrompt(Map<String, dynamic> json) {
      // print("[UserModel fromJson] Attempting to parse AudioPrompt...");
      // Check if the necessary keys exist and are potentially valid maps
      if (json['audio_prompt_question'] is Map &&
          json['audio_prompt_answer'] is Map) {
        try {
          // Attempt to create the model. This might throw FormatException
          // if the inner factory logic determines data is invalid.
          final audioPrompt = AudioPromptModel.fromJson(json);
          // print("[UserModel fromJson] Successfully parsed AudioPrompt: ${audioPrompt.prompt.label}");
          return audioPrompt;
        } on FormatException catch (e) {
          // Catch the specific exception thrown for invalid data
          // print("[UserModel fromJson] AudioPrompt data was invalid or missing: $e");
          return null; // Return null if parsing failed due to invalid data
        } catch (e) {
          // Catch other potential errors during parsing
          // print("[UserModel fromJson] Unexpected error parsing AudioPrompt: $e");
          return null; // Return null on other errors
        }
      } else {
        //  print("[UserModel fromJson] AudioPrompt keys ('audio_prompt_question', 'audio_prompt_answer') not found or not maps.");
        return null; // Return null if required keys are missing
      }
    }
    // --- END FIX ---

    int? getId(dynamic idField) {
      if (idField is int) return idField;
      if (idField is String) return int.tryParse(idField);
      if (idField is Map &&
          idField['Valid'] == true &&
          idField['Int64'] != null) {
        return (idField['Int64'] as num?)?.toInt();
      }
      return null;
    }

    return UserModel(
      id: getId(json['id']),
      name: getString(json['name']),
      lastName: getString(json['last_name']),
      email: json['email'] as String?,
      phoneNumber: getString(json['phone_number']),
      dateOfBirth: getDate(json['date_of_birth']),
      latitude: getDouble(json['latitude']),
      longitude: getDouble(json['longitude']),
      gender: parseEnum(Gender.values, json['gender'], 'GenderEnum'),
      datingIntention: parseEnum(
          DatingIntention.values, json['dating_intention'], 'DatingIntention'),
      height: getString(json['height']),
      hometown: getString(json['hometown']),
      jobTitle: getString(json['job_title']),
      education: getString(json['education']),
      religiousBeliefs:
          parseEnum(Religion.values, json['religious_beliefs'], 'Religion'),
      drinkingHabit: parseEnum(DrinkingSmokingHabits.values,
          json['drinking_habit'], 'DrinkingSmokingHabits'),
      smokingHabit: parseEnum(DrinkingSmokingHabits.values,
          json['smoking_habit'], 'DrinkingSmokingHabits'),
      mediaUrls: getMediaUrls(json['media_urls']),
      prompts: getPrompts(json),
      audioPrompt: getAudioPrompt(json), // Call the updated helper
      verificationStatus: json['verification_status'] as String?,
      verificationPic: getString(json['verification_pic']),
      role: json['role'] as String?,
    );
  }

  UserModel copyWith({
    int? Function()? id,
    String? Function()? name,
    String? Function()? lastName,
    String? Function()? phoneNumber,
    String? Function()? email,
    DateTime? Function()? dateOfBirth,
    double? Function()? latitude,
    double? Function()? longitude,
    Gender? Function()? gender,
    DatingIntention? Function()? datingIntention,
    String? Function()? height,
    String? Function()? hometown,
    String? Function()? jobTitle,
    String? Function()? education,
    Religion? Function()? religiousBeliefs,
    DrinkingSmokingHabits? Function()? drinkingHabit,
    DrinkingSmokingHabits? Function()? smokingHabit,
    List<String>? Function()? mediaUrls,
    List<Prompt>? prompts,
    AudioPromptModel? Function()? audioPrompt,
    String? Function()? verificationStatus,
    String? Function()? verificationPic,
    String? Function()? role,
  }) {
    return UserModel(
      id: id != null ? id() : this.id,
      name: name != null ? name() : this.name,
      lastName: lastName != null ? lastName() : this.lastName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      email: email != null ? email() : this.email,
      dateOfBirth: dateOfBirth != null ? dateOfBirth() : this.dateOfBirth,
      latitude: latitude != null ? latitude() : this.latitude,
      longitude: longitude != null ? longitude() : this.longitude,
      gender: gender != null ? gender() : this.gender,
      datingIntention:
          datingIntention != null ? datingIntention() : this.datingIntention,
      height: height != null ? height() : this.height,
      hometown: hometown != null ? hometown() : this.hometown,
      jobTitle: jobTitle != null ? jobTitle() : this.jobTitle,
      education: education != null ? education() : this.education,
      religiousBeliefs:
          religiousBeliefs != null ? religiousBeliefs() : this.religiousBeliefs,
      drinkingHabit:
          drinkingHabit != null ? drinkingHabit() : this.drinkingHabit,
      smokingHabit: smokingHabit != null ? smokingHabit() : this.smokingHabit,
      mediaUrls: mediaUrls != null ? mediaUrls() : this.mediaUrls,
      prompts: prompts ?? List.from(this.prompts),
      audioPrompt: audioPrompt != null ? audioPrompt() : this.audioPrompt,
      verificationStatus: verificationStatus != null
          ? verificationStatus()
          : this.verificationStatus,
      verificationPic:
          verificationPic != null ? verificationPic() : this.verificationPic,
      role: role != null ? role() : this.role,
    );
  }

  bool isProfileValid() {
    final dobValid = dateOfBirth != null &&
        DateTime.now().difference(dateOfBirth!).inDays >= (18 * 365.25);
    return name != null &&
        name!.trim().isNotEmpty && // Added check for empty name
        name!.trim().length >= 3 &&
        dobValid &&
        gender != null &&
        datingIntention != null &&
        isLocationValid();
  }

  bool isLocationValid() {
    return latitude != null &&
        longitude != null &&
        latitude != 0.0 && // Consider if 0.0 is valid
        longitude != 0.0;
  }
}



================================================
File: providers/audio_player_provider.dart
================================================

// providers/audio_player_provider.dart
import 'package:audioplayers/audioplayers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

enum AudioPlayerState {
  idle,
  loading,
  playing,
  paused,
  completed,
  error,
}

final audioPlayerStateProvider = StateProvider<AudioPlayerState>((ref) => AudioPlayerState.idle);
final currentAudioUrlProvider = StateProvider<String?>((ref) => null);

final audioPlayerProvider = Provider<AudioPlayer>((ref) {
  final player = AudioPlayer();
  
  player.onPlayerComplete.listen((_) {
    ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.completed;
  });
  
  player.onPlayerStateChanged.listen((state) {
    if (state == PlayerState.playing) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.playing;
    } else if (state == PlayerState.paused) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.paused;
    } else if (state == PlayerState.stopped) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.idle;
    }
  });
  
  // Handle cleanup when the provider is disposed
  ref.onDispose(() {
    player.dispose();
  });
  
  return player;
});

class AudioPlayerNotifier extends StateNotifier<AudioPlayerState> {
  final Ref ref;
  final AudioPlayer _player;
  
  AudioPlayerNotifier(this.ref)
      : _player = ref.read(audioPlayerProvider),
        super(AudioPlayerState.idle);
  
  Future<void> play(String url) async {
    try {
      // If another audio is playing, stop it
      if (state == AudioPlayerState.playing) {
        await _player.stop();
      }
      
      state = AudioPlayerState.loading;
      ref.read(currentAudioUrlProvider.notifier).state = url;
      
      await _player.play(UrlSource(url));
      // State will be updated via listener in audioPlayerProvider
    } catch (e) {
      print("Error playing audio: $e");
      state = AudioPlayerState.error;
    }
  }
  
  Future<void> pause() async {
    if (state == AudioPlayerState.playing) {
      await _player.pause();
      // State will be updated via listener
    }
  }
  
  Future<void> resume() async {
    if (state == AudioPlayerState.paused) {
      await _player.resume();
      // State will be updated via listener
    }
  }
  
  Future<void> stop() async {
    await _player.stop();
    ref.read(currentAudioUrlProvider.notifier).state = null;
    // State will be updated via listener
  }
}

final audioPlayerControllerProvider = StateNotifierProvider<AudioPlayerNotifier, AudioPlayerState>((ref) {
  return AudioPlayerNotifier(ref);
});



================================================
File: providers/audio_upload_provider.dart
================================================
// providers/audio_upload_provider.dart
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../models/user_model.dart';
import '../repositories/media_repository.dart';
import '../utils/app_enums.dart';
import 'error_provider.dart';
import 'service_provider.dart';
import 'user_provider.dart';

final audioUploadProvider = StateNotifierProvider<AudioUploadNotifier, MediaUploadModel?>(
  (ref) {
    print('[AudioUpload] Initializing AudioUploadProvider');
    final mediaRepository = ref.watch(mediaRepositoryProvider);
    return AudioUploadNotifier(ref, mediaRepository);
  },
);

class AudioUploadNotifier extends StateNotifier<MediaUploadModel?> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  AudioPrompt? _selectedPrompt;
  String? _recordingPath;

  // Initialize with null (no audio uploaded yet)
  AudioUploadNotifier(this.ref, this._mediaRepository) : super(null) {
    print('[AudioUpload] AudioUploadNotifier created');
  }

  // Max audio size (10 MB)
  static const int _maxAudioSizeBytes = 10 * 1024 * 1024;

  // Supported audio MIME types
static final Set<String> _supportedAudioTypes = {
  'audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/webm',
  'audio/aac', 'audio/x-m4a', 'audio/x-aiff', 'audio/flac',
  'audio/mp4'  // Add this line to support M4A files
};

  // Save the recording path for later use
  void setRecordingPath(String path) {
    print('[AudioUpload] Setting recording path: $path');
    _recordingPath = path;
  }

  // Prepare audio file with validation
  bool prepareAudioFile() {
    print('[AudioUpload] Preparing audio file');
    print('[AudioUpload] Recording path: $_recordingPath');
    print('[AudioUpload] Selected prompt: ${_selectedPrompt?.value}');
    
    if (_recordingPath == null || _selectedPrompt == null) {
      print('[AudioUpload] ERROR: Missing recording path or prompt');
      return false;
    }
    
    final file = File(_recordingPath!);
    if (!file.existsSync()) {
      print('[AudioUpload] ERROR: File does not exist at path: $_recordingPath');
      return false;
    }
    
    try {
      // Validate file size
      final fileSize = file.lengthSync();
      print('[AudioUpload] File size: ${fileSize / 1024} KB');
      
      if (fileSize > _maxAudioSizeBytes) {
        print('[AudioUpload] ERROR: File too large: ${fileSize / 1024 / 1024} MB (max: ${_maxAudioSizeBytes / 1024 / 1024} MB)');
        ref.read(errorProvider.notifier).setError(
              AppError.validation("Audio is too large. Maximum size is 10 MB."),
            );
        return false;
      }

      // Detect MIME type
      final fileName = path.basename(file.path);
      final mimeType = lookupMimeType(file.path) ?? 'audio/mpeg';
      print('[AudioUpload] Filename: $fileName');
      print('[AudioUpload] MIME type: $mimeType');

      // Validate audio type
      if (!_supportedAudioTypes.contains(mimeType)) {
        print('[AudioUpload] ERROR: Unsupported audio format: $mimeType');
        ref.read(errorProvider.notifier).setError(
              AppError.validation("Unsupported audio format. Please use MP3, WAV, OGG, or other common audio formats."),
            );
        return false;
      }

      // Update state
      print('[AudioUpload] Creating MediaUploadModel');
      state = MediaUploadModel(
        file: file,
        fileName: fileName,
        fileType: mimeType,
        status: UploadStatus.idle,
      );
      
      print('[AudioUpload] Audio file prepared successfully');
      return true;
    } catch (e, stack) {
      print('[AudioUpload] ERROR preparing audio file: $e');
      print('[AudioUpload] Stack trace: $stack');
      return false;
    }
  }

  // Clear audio file
  void clearAudio() {
    print('[AudioUpload] Clearing audio state');
    state = null;
    _recordingPath = null;
    _selectedPrompt = null;
  }

  // Upload audio and save to user profile
  Future<bool> uploadAudioAndSaveToProfile() async {
    print('[AudioUpload] Starting uploadAudioAndSaveToProfile');
    
    if (state == null || _selectedPrompt == null) {
      print('[AudioUpload] State or prompt is null, attempting to prepare file');
      final prepared = prepareAudioFile();
      if (!prepared) {
        print('[AudioUpload] Failed to prepare audio file');
        return false;
      }
    }

    try {
      print('[AudioUpload] Clearing any previous errors');
      ref.read(errorProvider.notifier).clearError();

      // Update state to show upload in progress
      print('[AudioUpload] Setting state to UPLOADING');
      state = state!.copyWith(status: UploadStatus.inProgress);

      // Get presigned URL for audio
      print('[AudioUpload] Getting presigned URL for ${state!.fileName}');
      final presignedUrlResponse = await _mediaRepository.getAudioPresignedUrl(
        state!.fileName,
        state!.fileType,
        _selectedPrompt!,
      );
      
      print('[AudioUpload] Received presigned URL response: ${presignedUrlResponse.toString().substring(0, 100)}...');

      // Update state with presigned URL
      print('[AudioUpload] Updating state with presigned URL');
      state = state!.copyWith(
        presignedUrl: () => presignedUrlResponse['url'],
      );

      // Upload audio to S3
      print('[AudioUpload] Uploading file to S3');
      bool success = await _mediaRepository.uploadFileToS3(state!);
      print('[AudioUpload] Initial upload result: $success');

      // If failed, retry
      if (!success) {
        print('[AudioUpload] Initial upload failed, retrying...');
        success = await _mediaRepository.retryUpload(state!);
        print('[AudioUpload] Retry upload result: $success');
      }

      // Update state with result
      print('[AudioUpload] Setting final upload status: ${success ? "SUCCESS" : "FAILED"}');
      state = state!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload audio',
      );

      if (success) {
        // Create AudioPromptModel
        print('[AudioUpload] Creating AudioPromptModel with prompt: ${_selectedPrompt!.value}');
        final audioPromptModel = AudioPromptModel(
          prompt: _selectedPrompt!,
          audioUrl: presignedUrlResponse['url'],
        );

        // Add to user model
        print('[AudioUpload] Updating user model with audio prompt');
        ref.read(userProvider.notifier).updateAudioPrompt(audioPromptModel);
        print('[AudioUpload] User model updated successfully');
      }

      return success;
    } catch (e, stack) {
      print('[AudioUpload] ERROR during upload: $e');
      print('[AudioUpload] Stack trace: $stack');
      
      if (state != null) {
        state = state!.copyWith(
          status: UploadStatus.failed,
          errorMessage: () => 'Failed to upload audio: ${e.toString()}',
        );
      }
      return false;
    }
  }

  // Get the selected prompt
  AudioPrompt? get selectedPrompt => _selectedPrompt;

  // Set the selected prompt
  void setSelectedPrompt(AudioPrompt prompt) {
    print('[AudioUpload] Setting selected prompt: ${prompt.value}');
    _selectedPrompt = prompt;
  }
}



================================================
File: providers/auth_provider.dart
================================================
// File: providers/auth_provider.dart
import 'package:dtx/models/auth_model.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_sign_in/google_sign_in.dart'; // Import Google Sign-In
import '../models/error_model.dart';
import '../repositories/auth_repository.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import 'error_provider.dart';
import 'service_provider.dart';

// Provider for GoogleSignIn instance
final googleSignInProvider = Provider<GoogleSignIn>((ref) {
  return GoogleSignIn(
    // Add scopes if needed beyond basic profile/email, e.g., for YouTube later
    // scopes: ['email', 'profile', 'https://www.googleapis.com/auth/youtube.readonly'],
    scopes: ['email', 'profile'], // Basic scopes for login
  );
});

final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final authRepository = ref.watch(authRepositoryProvider);
  // No longer need _lastRequestId or _phoneRegex
  return AuthNotifier(ref, authRepository);
});

class AuthNotifier extends StateNotifier<AuthState> {
  final Ref ref;
  final AuthRepository _authRepository;
  // Removed: int _lastRequestId = 0;
  // Removed: static final _phoneRegex = RegExp(r'^[6-9][0-9]{9}$');

  AuthNotifier(this.ref, this._authRepository) : super(const AuthState()) {
    _loadTokenAndCheckStatus(); // Check status upon initialization
  }

  // Combined load and check
  Future<void> _loadTokenAndCheckStatus() async {
    print('[AuthNotifier] Loading token and checking initial status...');
    state = state.copyWith(isLoading: true);
    final token = await TokenStorage.getToken();
    if (token != null && token.isNotEmpty) {
      state = state.copyWith(jwtToken: () => token);
      await checkAuthStatus(updateState: true); // Check status if token exists
    } else {
      print('[AuthNotifier] No token found, setting state to login.');
      // If no token, status is definitely login
      state = state.copyWith(
          isLoading: false, authStatus: AuthStatus.login, jwtToken: () => null);
    }
  }

  /// Checks the current authentication status with the backend.
  /// Updates the provider's state if `updateState` is true.
  Future<AuthStatus> checkAuthStatus({bool updateState = true}) async {
    print('[AuthNotifier checkAuthStatus] Called. updateState: $updateState');
    if (updateState) {
      state = state.copyWith(isLoading: true, error: () => null);
    }

    final token =
        state.jwtToken ?? await TokenStorage.getToken(); // Check state first

    try {
      final backendStatus = await _authRepository.checkAuthStatus(token);
      print(
          '[AuthNotifier checkAuthStatus] Backend status received: $backendStatus');

      if (updateState) {
        state = state.copyWith(
          isLoading: false,
          authStatus: backendStatus,
          // Clear token in state if backend says login is required
          jwtToken: backendStatus == AuthStatus.login
              ? () => null
              : null, // Conditional null set
        );
        if (backendStatus == AuthStatus.login) {
          await TokenStorage.removeToken(); // Also remove from storage
        }
      }
      print(
          '[AuthNotifier checkAuthStatus] Finished. Returning: $backendStatus');
      return backendStatus;
    } catch (e) {
      print('[AuthNotifier checkAuthStatus] Error: $e');
      if (updateState) {
        state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login, // Default to login on error
          error: () => 'Failed to check status: ${e.toString()}',
          jwtToken: () => null, // Clear token on error
        );
        await TokenStorage.removeToken(); // Also remove from storage
      }
      return AuthStatus.login; // Return login on error
    }
  }

  // --- REMOVED METHODS ---
  // Future<bool> verifyPhone(String phone) async { ... }
  // Future<bool> sendOtp(String phoneNumber) async { ... }
  // Future<bool> verifyOtp(String phoneNumber, String otpCode) async { ... }
  // --- END REMOVED METHODS ---

  // --- NEW METHOD: Sign In With Google ---
  Future<AuthStatus> signInWithGoogle() async {
    print('[AuthNotifier signInWithGoogle] Attempting Google Sign-In...');
    state = state.copyWith(isLoading: true, error: () => null);
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors

    try {
      final googleSignIn = ref.read(googleSignInProvider);
      final googleUser = await googleSignIn.signIn(); // Prompts user

      if (googleUser == null) {
        print('[AuthNotifier signInWithGoogle] User cancelled Google Sign-In.');
        state = state.copyWith(isLoading: false, authStatus: AuthStatus.login);
        return AuthStatus.login; // User cancelled
      }

      print(
          '[AuthNotifier signInWithGoogle] Google Sign-In successful for: ${googleUser.email}');
      final googleAuth = await googleUser.authentication;
      final googleAccessToken = googleAuth.accessToken;

      if (googleAccessToken == null) {
        print(
            '[AuthNotifier signInWithGoogle] Failed to get Google Access Token.');
        throw ApiException('Could not retrieve access token from Google.');
      }

      print(
          '[AuthNotifier signInWithGoogle] Verifying Google Access Token with backend...');
      final appJwt = await _authRepository.verifyGoogleToken(googleAccessToken);
      print(
          '[AuthNotifier signInWithGoogle] Backend verification successful. App JWT received.');

      await TokenStorage.saveToken(appJwt);

      // IMPORTANT: After successful login and getting the JWT,
      // immediately check the status with the backend to know the next step.
      state = state.copyWith(jwtToken: () => appJwt); // Temporarily set token
      final finalStatus = await checkAuthStatus(
          updateState: true); // Update state with final status

      print(
          '[AuthNotifier signInWithGoogle] Sign-in process complete. Final Status: $finalStatus');
      return finalStatus; // Return the status determined by checkAuthStatus
    } on ApiException catch (e) {
      print('[AuthNotifier signInWithGoogle] API Exception: ${e.message}');
      state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login,
          error: () => e.message);
      ref.read(errorProvider.notifier).setError(AppError.auth(e.message));
      await logout(); // Clear any potentially saved invalid token
      return AuthStatus.login;
    } catch (e) {
      print(
          '[AuthNotifier signInWithGoogle] Unexpected Error: ${e.toString()}');
      state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login,
          error: () => 'An unexpected error occurred during sign-in.');
      ref.read(errorProvider.notifier).setError(
          AppError.auth("An unexpected error occurred. Please try again."));
      await logout(); // Clear any potentially saved invalid token
      return AuthStatus.login;
    }
  }
  // --- END NEW METHOD ---

  // Logout user
  Future<void> logout() async {
    print('[AuthNotifier] Logging out...');
    try {
      final googleSignIn = ref.read(googleSignInProvider);
      await googleSignIn.signOut(); // Sign out from Google
      await googleSignIn.disconnect(); // Optional: Revoke permissions
    } catch (e) {
      print('[AuthNotifier] Error during Google Sign Out/Disconnect: $e');
      // Decide if you want to proceed with app logout even if Google logout fails
    } finally {
      await TokenStorage.removeToken(); // Remove app token *always*
      state =
          const AuthState(authStatus: AuthStatus.login); // Reset state *always*
      print('[AuthNotifier] Local logout complete.');
    }
  }
}



================================================
File: providers/error_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/error_model.dart';

final errorProvider = StateNotifierProvider<ErrorNotifier, AppError?>((ref) {
  return ErrorNotifier();
});

class ErrorNotifier extends StateNotifier<AppError?> {
  ErrorNotifier() : super(null);

  void setError(AppError error) => state = error;
  void clearError() => state = null;
}



================================================
File: providers/liker_profile_provider.dart
================================================
// File: providers/liker_profile_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State Definition
class LikerProfileState {
  final bool isLoading;
  final UserProfileData? profile;
  final LikeInteractionDetails? likeDetails;
  final AppError? error;

  const LikerProfileState({
    this.isLoading = true, // Start loading
    this.profile,
    this.likeDetails,
    this.error,
  });

  LikerProfileState copyWith({
    bool? isLoading,
    UserProfileData? Function()? profile, // Nullable functions
    LikeInteractionDetails? Function()? likeDetails,
    AppError? Function()? error,
  }) {
    return LikerProfileState(
      isLoading: isLoading ?? this.isLoading,
      profile: profile != null ? profile() : this.profile,
      likeDetails: likeDetails != null ? likeDetails() : this.likeDetails,
      error: error != null ? error() : this.error,
    );
  }
}

// StateNotifier Definition
class LikerProfileNotifier extends StateNotifier<LikerProfileState> {
  final LikeRepository _likeRepository;
  final int _likerUserId;

  LikerProfileNotifier(this._likeRepository, this._likerUserId)
      : super(const LikerProfileState()) {
    fetchProfile(); // Fetch profile on initialization
  }

  Future<void> fetchProfile() async {
    print(
        "[LikerProfileNotifier] Fetching profile for liker ID: $_likerUserId");
    // Don't clear profile/details on refetch, only on error maybe?
    state = state.copyWith(isLoading: true, error: () => null);
    try {
      final result = await _likeRepository.fetchLikerProfile(_likerUserId);
      final profileData = result['profile'] as UserProfileData?;
      final likeDetailsData = result['likeDetails'] as LikeInteractionDetails?;

      if (profileData != null && likeDetailsData != null) {
        print("[LikerProfileNotifier] Fetch successful.");
        state = state.copyWith(
          isLoading: false,
          profile: () => profileData,
          likeDetails: () => likeDetailsData,
          error: () => null,
        );
      } else {
        // This case should ideally be caught by the repository throwing an exception
        print(
            "[LikerProfileNotifier] Fetch failed: Repository returned null data.");
        state = state.copyWith(
            isLoading: false,
            error: () => AppError.server("Failed to load profile data."));
      }
    } on ApiException catch (e) {
      print("[LikerProfileNotifier] API Exception: ${e.message}");
      // Handle 404 Not Found specifically maybe
      if (e.statusCode == 404) {
        state = state.copyWith(
            isLoading: false,
            error: () => AppError.server(
                "Profile not found or you were not liked by this user."));
      } else {
        state = state.copyWith(
            isLoading: false, error: () => AppError.server(e.message));
      }
    } catch (e) {
      print("[LikerProfileNotifier] Unexpected Error: ${e.toString()}");
      state = state.copyWith(
          isLoading: false,
          error: () => AppError.generic("Failed to load profile."));
    }
  }
}

// Provider Definition (.family)
final likerProfileProvider =
    StateNotifierProvider.family<LikerProfileNotifier, LikerProfileState, int>(
        (ref, likerUserId) {
  final likeRepository = ref.watch(likeRepositoryProvider);
  return LikerProfileNotifier(likeRepository, likerUserId);
});



================================================
File: providers/location_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:geolocator/geolocator.dart';
import '../models/error_model.dart';
import '../models/location_model.dart';
import 'error_provider.dart';
import 'user_provider.dart';

final locationProvider =
    StateNotifierProvider<LocationNotifier, LocationState>((ref) {
  return LocationNotifier(ref);
});

class LocationNotifier extends StateNotifier<LocationState> {
  final Ref ref;

  LocationNotifier(this.ref) : super(LocationState());

  void setMapReady(bool ready) {
    state = state.copyWith(isMapReady: ready);
  }

  Future<void> openLocationSettings() async {
    try {
      await Geolocator.openLocationSettings();
    } catch (e) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.network("Failed to open location settings"));
    }
  }

  Future<void> fetchCurrentLocation() async {
    // Clear any existing errors
    ref.read(errorProvider.notifier).clearError();

    // Reset state for fresh fetch
    state = state.copyWith(
      isFetching: true,
      isLoading: true,
      cachedLatitude: null,
      cachedLongitude: null,
    );

    try {
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        ref.read(errorProvider.notifier).setError(
            AppError.locationService("Location services are disabled"));
        state = state.copyWith(isLoading: false);
        return;
      }

      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          ref
              .read(errorProvider.notifier)
              .setError(AppError.validation("Location permissions are denied"));
          state = state.copyWith(isLoading: false);
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Location permissions are permanently denied"));
        state = state.copyWith(isLoading: false);
        return;
      }

      Position position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.high);

      final newLatitude = position.latitude;
      final newLongitude = position.longitude;

      // Update user provider with the location
      ref.read(userProvider.notifier).updateLocation(newLatitude, newLongitude);

      state = state.copyWith(
        latitude: newLatitude,
        longitude: newLongitude,
        cachedLatitude: newLatitude,
        cachedLongitude: newLongitude,
        isLoading: false,
      );
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
          AppError.network("Failed to fetch location: ${e.toString()}"));
      state = state.copyWith(isLoading: false);
    } finally {
      state = state.copyWith(isFetching: false);
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(latitude: latitude, longitude: longitude);
    ref.read(userProvider.notifier).updateLocation(latitude, longitude);
  }

  void useCachedLocation() {
    if (state.cachedLatitude != null && state.cachedLongitude != null) {
      updateLocation(state.cachedLatitude!, state.cachedLongitude!);
    }
  }
}



================================================
File: providers/media_upload_provider.dart
================================================
import 'dart:io';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../repositories/media_repository.dart';
import 'error_provider.dart';
import 'service_provider.dart';

final mediaUploadProvider = StateNotifierProvider<MediaUploadNotifier, List<MediaUploadModel?>>((ref) {
  final mediaRepository = ref.watch(mediaRepositoryProvider);
  return MediaUploadNotifier(ref, mediaRepository);
});

class MediaUploadNotifier extends StateNotifier<List<MediaUploadModel?>> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  
  // Initialize with 6 null slots for media
  MediaUploadNotifier(this.ref, this._mediaRepository) : super(List.filled(6, null));
  
  // File size limits in bytes
  static const int _maxImageSizeBytes = 10 * 1024 * 1024; // 10 MB
  static const int _maxVideoSizeBytes = 50 * 1024 * 1024; // 50 MB

  MediaUploadModel? _verificationImage;

  MediaUploadModel? get verificationImage => _verificationImage;

  void setVerificationImage(File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'image/jpeg';

    final isImage = mimeType.startsWith('image/');

    if (!isImage) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Only image files are allowed."),
      );
      return;
    }

    if (fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }

    // Update state
    _verificationImage = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
  }

  void clearVerificationImage() {
    _verificationImage = null;
  }

  Future<bool> uploadVerificationImage() async {
    if (_verificationImage == null) return false;

    try {
      // Clear any existing errors
      ref.read(errorProvider.notifier).clearError();

      // Get presigned URL
      final presignedUrl = await _mediaRepository.getVerificationPresignedUrl(
        _verificationImage!.fileName,
        _verificationImage!.fileType,
      );

      // Update verification image with presigned URL
      _verificationImage = _verificationImage!.copyWith(
        presignedUrl: () => presignedUrl,
        status: UploadStatus.inProgress,
      );

      // Upload the file
      final success = await _mediaRepository.uploadFileToS3(_verificationImage!);

      // Update status
      _verificationImage = _verificationImage!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload verification image',
      );

      return success;
    } on ApiException catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => e.message,
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.message),
      );
      return false;
    } catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => 'An unexpected error occurred. Please try again.',
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth("An unexpected error occurred. Please try again."),
      );
      return false;
    }
  }
  
  // Add or update media at a specific index
  void setMediaFile(int index, File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'application/octet-stream';
    
    final isImage = mimeType.startsWith('image/');
    final isVideo = mimeType.startsWith('video/');
    
    // Size validation
    if (isImage && fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }
    
    if (isVideo && fileSize > _maxVideoSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Video is too large. Maximum size is 50 MB."),
      );
      return;
    }
    
    // Update state
    final updatedState = [...state];
    updatedState[index] = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
    state = updatedState;
  }
  
  // Remove media at a specific index
  void removeMedia(int index) {
    final updatedState = [...state];
    updatedState[index] = null;
    state = updatedState;
  }
  
  // Get all non-null media items
  List<MediaUploadModel> getMediaItems() {
    return state.whereType<MediaUploadModel>().toList();
  }
  
  // Check if we have minimum required media (3)
  bool hasMinimumMedia() {
    return getMediaItems().length >= 3;
  }
  
  // Upload all media
  Future<bool> uploadAllMedia() async {
    final mediaItems = getMediaItems();
    if (mediaItems.isEmpty) return false;
    
    try {
      // Prepare file details for presigned URL request
      final fileDetails = mediaItems.map((item) => {
        'filename': item.fileName,
        'type': item.fileType,
      }).toList();
      
  print("lauda lassan 2");
      // Get presigned URLs
      final presignedUrlsResponse = await _mediaRepository.getPresignedUrls(fileDetails);
      
      // Update media items with presigned URLs
      final updatedState = [...state];
      for (int i = 0; i < mediaItems.length; i++) {
        final index = state.indexOf(mediaItems[i]);
        if (index >= 0 && index < presignedUrlsResponse.length) {
          updatedState[index] = mediaItems[i].copyWith(
            presignedUrl: () => presignedUrlsResponse[i]['url'],
            status: UploadStatus.inProgress,
          );
        }
      }
      state = updatedState;
      
      // Upload each file
      bool allSucceeded = true;
      for (int i = 0; i < mediaItems.length; i++) {
        final mediaItem = state.firstWhere(
          (item) => item?.fileName == mediaItems[i].fileName,
          orElse: () => null,
        );
        
        if (mediaItem != null) {
          final index = state.indexOf(mediaItem);
          bool success = false;
          
          try {
            success = await _mediaRepository.uploadFileToS3(mediaItem);
          } catch (e) {
            print('Initial upload failed: $e');
            success = false;
          }
          
          // Retry if failed
          if (!success) {
            success = await _mediaRepository.retryUpload(mediaItem);
          }
          
          // Update state with result
          final newUpdatedState = [...state];
          newUpdatedState[index] = mediaItem.copyWith(
            status: success ? UploadStatus.success : UploadStatus.failed,
            errorMessage: success ? () => null : () => 'Failed to upload',
          );
          state = newUpdatedState;
          
          if (!success) allSucceeded = false;
        }
      }
      
      return allSucceeded;
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.toString()),
      );
      return false;
    }
  }
}



================================================
File: providers/recieved_likes_provider.dart
================================================
// File: providers/received_likes_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State definition
class ReceivedLikesState {
  final bool isLoading;
  final List<FullProfileLiker> fullProfiles;
  final List<BasicProfileLiker> otherLikers;
  final AppError? error;

  const ReceivedLikesState({
    this.isLoading = true, // Start in loading state
    this.fullProfiles = const [],
    this.otherLikers = const [],
    this.error,
  });

  ReceivedLikesState copyWith({
    bool? isLoading,
    List<FullProfileLiker>? fullProfiles,
    List<BasicProfileLiker>? otherLikers,
    AppError? Function()? error, // Function to allow setting null
  }) {
    return ReceivedLikesState(
      isLoading: isLoading ?? this.isLoading,
      fullProfiles: fullProfiles ?? this.fullProfiles,
      otherLikers: otherLikers ?? this.otherLikers,
      error: error != null ? error() : this.error,
    );
  }
}

// StateNotifier definition
class ReceivedLikesNotifier extends StateNotifier<ReceivedLikesState> {
  final LikeRepository _likeRepository;

  ReceivedLikesNotifier(this._likeRepository)
      : super(const ReceivedLikesState());

  Future<void> fetchLikes() async {
    print("[ReceivedLikesNotifier] fetchLikes called.");
    // Don't reset lists here, only on success/initial load
    state = state.copyWith(isLoading: true, error: () => null);
    try {
      final result = await _likeRepository.fetchReceivedLikes();
      final fullProfiles = result['full'] as List<FullProfileLiker>? ?? [];
      final otherLikers = result['other'] as List<BasicProfileLiker>? ?? [];
      print(
          "[ReceivedLikesNotifier] fetchLikes success. Full: ${fullProfiles.length}, Other: ${otherLikers.length}");
      state = state.copyWith(
        isLoading: false,
        fullProfiles: fullProfiles,
        otherLikers: otherLikers,
        error: () => null,
      );
    } on ApiException catch (e) {
      print("[ReceivedLikesNotifier] fetchLikes API Exception: ${e.message}");
      state = state.copyWith(
          isLoading: false, error: () => AppError.server(e.message));
    } catch (e) {
      print(
          "[ReceivedLikesNotifier] fetchLikes Unexpected Error: ${e.toString()}");
      state = state.copyWith(
          isLoading: false,
          error: () => AppError.generic("Failed to load likes."));
    }
  }
}

// Provider definition
final receivedLikesProvider =
    StateNotifierProvider<ReceivedLikesNotifier, ReceivedLikesState>((ref) {
  final likeRepository = ref.watch(likeRepositoryProvider);
  return ReceivedLikesNotifier(likeRepository);
});



================================================
File: providers/service_provider.dart
================================================
// File: providers/service_provider.dart
import 'package:dtx/repositories/user_repository.dart';
import 'package:dtx/repositories/media_repository.dart';
import 'package:dtx/repositories/like_repository.dart'; // *** ADDED Import ***
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/api_service.dart';
import '../services/http_service.dart';
import '../repositories/auth_repository.dart';
import '../utils/env_config.dart';

// API Service provider
final apiServiceProvider = Provider<ApiService>((ref) {
  return HttpService(baseUrl: EnvConfig.apiBaseUrl);
});

// Auth Repository provider
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AuthRepository(apiService);
});

// Media Repository provider
final mediaRepositoryProvider = Provider<MediaRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return MediaRepository(apiService, ref);
});

// User Repository provider
final userRepositoryProvider = Provider<UserRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return UserRepository(apiService);
});

// *** ADDED: Like Repository Provider ***
final likeRepositoryProvider = Provider<LikeRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return LikeRepository(apiService);
});
// *** END ADDED ***



================================================
File: providers/user_provider.dart
================================================
// File: providers/user_provider.dart
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:latlong2/latlong.dart'; // Keep if used
import '../models/error_model.dart';
import '../models/user_model.dart';
import '../utils/app_enums.dart';

final userLoadingProvider = StateProvider<bool>((ref) => false);

final userProvider = StateNotifierProvider<UserNotifier, UserModel>((ref) {
  return UserNotifier(ref);
});

class UserNotifier extends StateNotifier<UserModel> {
  final Ref ref;

  UserNotifier(this.ref) : super(UserModel());

  Future<bool> fetchProfile() async {
    // ... (existing fetchProfile logic - no changes needed here for copyWith) ...
    try {
      ref.read(userLoadingProvider.notifier).state = true;
      ref.read(errorProvider.notifier).clearError();

      final userRepository = ref.read(userRepositoryProvider);
      final userModel = await userRepository.fetchUserProfile();

      state = userModel; // Direct assignment from fetch is fine

      ref.read(userLoadingProvider.notifier).state = false;
      return true;
    } on ApiException catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
            AppError.server(e.message), // Use server error type
          );
      return false;
    } catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
            AppError.generic(
                "Failed to load profile: ${e.toString()}"), // Use generic
          );
      return false;
    }
  }

  // --- FIX: Update copyWith calls to use functions for nullable fields ---
  void updateName(String firstName, String? lastName) {
    ref.read(errorProvider.notifier).clearError();
    if (firstName.isEmpty || firstName.trim().length < 3) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("First name must be at least 3 characters"),
          );
      return; // Don't update state if invalid
    }

    state = state.copyWith(
      name: () => firstName.trim(),
      lastName: () =>
          lastName?.trim(), // Pass function returning nullable value
    );
  }

  void updateDateOfBirth(DateTime date) {
    ref.read(errorProvider.notifier).clearError();
    final today = DateTime.now();
    final age = today.difference(date).inDays ~/ 365.25;

    if (date.year < 1900 || date.isAfter(today)) {
      // Also check if date is in future
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Invalid year"));
      return;
    }
    if (age < 18) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("You must be at least 18 years old"));
      return;
    }
    try {
      final validatedDate = DateTime(date.year, date.month, date.day);
      state = state.copyWith(dateOfBirth: () => validatedDate); // Pass function
    } catch (e) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Invalid date combination"));
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(
      latitude: () => latitude, // Pass function
      longitude: () => longitude, // Pass function
    );
  }

  LatLng getCurrentLocation() {
    // Use default values if state is null
    return LatLng(state.latitude ?? 19.2183, state.longitude ?? 73.0864);
  }

  bool isLocationValid() {
    return state.latitude != null &&
        state.longitude != null &&
        state.latitude != 0.0 &&
        state.longitude != 0.0;
  }

  bool isNameValid() => (state.name?.trim().length ?? 0) >= 3;

  void updateDatingIntention(DatingIntention? intention) {
    state = state.copyWith(datingIntention: () => intention); // Pass function
  }

  bool isDatingIntentionSelected() {
    return state.datingIntention != null;
  }

  void updateGender(Gender? gender) {
    state = state.copyWith(gender: () => gender); // Pass function
  }

  bool isGenderSelected() {
    return state.gender != null;
  }

  void updateHeight(String height) {
    // Add basic validation if needed, e.g., regex check
    state = state.copyWith(height: () => height); // Pass function
  }

  bool isHeightSelected() {
    // Check if not null AND not empty
    return state.height != null && state.height!.isNotEmpty;
  }

  void updateHometown(String? hometown) {
    state = state.copyWith(hometown: () => hometown?.trim()); // Pass function
  }

  bool isHometownSelected() {
    return state.hometown != null && state.hometown!.isNotEmpty;
  }

  void updateJobTitle(String? jobTitle) {
    state = state.copyWith(jobTitle: () => jobTitle?.trim()); // Pass function
  }

  void updateEducation(String? education) {
    state = state.copyWith(education: () => education?.trim()); // Pass function
  }

  void updateReligiousBeliefs(Religion? religion) {
    state = state.copyWith(religiousBeliefs: () => religion); // Pass function
  }

  void updateDrinkingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(drinkingHabit: () => habit); // Pass function
  }

  void updateSmokingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(smokingHabit: () => habit); // Pass function
  }

  void addPrompt(Prompt prompt) {
    // Ensure prompt answer is not empty before adding
    if (prompt.answer.trim().isEmpty) return;
    // Prevent adding more than 3 prompts
    if (state.prompts.length >= 3) return;

    final updatedPrompts = List<Prompt>.from(state.prompts)..add(prompt);
    state = state.copyWith(
        prompts: updatedPrompts); // Direct list update is okay for copyWith
  }

  void updatePromptAtIndex(int index, Prompt newPrompt) {
    // Ensure prompt answer is not empty
    if (newPrompt.answer.trim().isEmpty) return;

    final updatedPrompts = List<Prompt>.from(state.prompts);
    if (index >= 0 && index < updatedPrompts.length) {
      updatedPrompts[index] = newPrompt;
      state = state.copyWith(prompts: updatedPrompts);
    }
  }

  // Keep old saveProfile for now, it calls the new repo method via UserModel
  Future<bool> saveProfile() async {
    print("[UserNotifier saveProfile] Called (using deprecated approach).");
    ref.read(userLoadingProvider.notifier).state = true;
    ref.read(errorProvider.notifier).clearError();

    if (!state.isProfileValid()) {
      // Use helper from UserModel
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Please complete all required profile fields."),
          );
      ref.read(userLoadingProvider.notifier).state = false;
      return false;
    }

    try {
      final userRepository = ref.read(userRepositoryProvider);
      // This now internally calls updateProfileDetails with the correct payload
      final success = await userRepository.updateProfile(state);

      ref.read(userLoadingProvider.notifier).state = false;
      if (!success) {
        // Error should be set by the repository/api service layer
        // ref.read(errorProvider.notifier).setError(AppError.server("Failed to save profile."));
      }
      return success;
    } on ApiException catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(AppError.server(e.message));
      return false;
    } catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref
          .read(errorProvider.notifier)
          .setError(AppError.generic("An unexpected error occurred."));
      return false;
    }
  }

  bool isProfileValid() {
    return state.isProfileValid(); // Delegate to UserModel's method
  }

  void updateAudioPrompt(AudioPromptModel? audioPrompt) {
    // Make parameter nullable
    state = state.copyWith(audioPrompt: () => audioPrompt); // Pass function
  }
}



================================================
File: repositories/auth_repository.dart
================================================
// File: repositories/auth_repository.dart
import '../models/auth_model.dart'; // Keep for AuthStatus enum
import '../services/api_service.dart';

class AuthRepository {
  final ApiService _apiService;

  AuthRepository(this._apiService);

  // --- REMOVED METHODS ---
  // Future<bool> sendOtp(String phoneNumber) async { ... }
  // Future<String> verifyOtp(String phoneNumber, String otpCode) async { ... }
  // --- END REMOVED METHODS ---

  // --- NEW METHOD ---
  /// Verifies Google Access Token with the backend and returns the App JWT.
  Future<String> verifyGoogleToken(String googleAccessToken) async {
    final String methodName = 'verifyGoogleToken';
    print('[AuthRepository $methodName] Verifying Google token...');
    try {
      final response = await _apiService.post(
        '/api/auth/google/verify', // Endpoint from API documentation
        body: {'accessToken': googleAccessToken},
      );

      if (response['success'] == true && response['token'] != null) {
        print(
            '[AuthRepository $methodName] Google token verified, got App JWT.');
        return response['token'].toString();
      } else {
        final message = response['message']?.toString() ??
            'Verification failed, no token received.';
        print('[AuthRepository $methodName] Verification failed: $message');
        throw ApiException(
            message); // Throw with message from backend if available
      }
    } on ApiException catch (e) {
      print(
          '[AuthRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      // Re-throw API exceptions to be handled by the provider
      rethrow;
    } catch (e) {
      print('[AuthRepository $methodName] Unexpected Error: ${e.toString()}');
      // Wrap other errors in ApiException
      throw ApiException(
          'An unexpected error occurred during Google verification: ${e.toString()}');
    }
  }
  // --- END NEW METHOD ---

  // Check authentication status - Updated to handle new states
  Future<AuthStatus> checkAuthStatus(String? token) async {
    final String methodName = 'checkAuthStatus';
    print('[AuthRepository $methodName] Starting auth status check.');

    if (token == null || token.isEmpty) {
      print(
          '[AuthRepository $methodName] No token provided, returning login status.');
      return AuthStatus.login;
    }

    try {
      final headers = {'Authorization': 'Bearer $token'};
      print('[AuthRepository $methodName] Making request to /api/auth-status.');
      final response =
          await _apiService.get('/api/auth-status', headers: headers);

      print('[AuthRepository $methodName] Received response: $response');

      if (response['success'] == true && response['status'] != null) {
        final statusString = response['status'].toString().toLowerCase();
        switch (statusString) {
          case 'home':
            print('[AuthRepository $methodName] Status: home');
            return AuthStatus.home;
          case 'onboarding1': // Handle new state
            print('[AuthRepository $methodName] Status: onboarding1');
            return AuthStatus.onboarding1;
          case 'onboarding2': // Handle new state
            print('[AuthRepository $methodName] Status: onboarding2');
            return AuthStatus.onboarding2;
          default:
            // If backend returns an unexpected status, treat as login
            print(
                '[AuthRepository $methodName] Status: unknown ($statusString), defaulting to login.');
            return AuthStatus.login;
        }
      } else {
        // If success is false or status is missing, treat as login needed
        print(
            '[AuthRepository $methodName] API response indicates failure or missing status, returning login.');
        return AuthStatus.login;
      }
    } on ApiException catch (e) {
      // If API returns 401/403 or other errors indicating invalid session, treat as login needed
      print(
          '[AuthRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode}), returning login.');
      return AuthStatus.login;
    } catch (e) {
      print(
          '[AuthRepository $methodName] Unexpected Error: ${e.toString()}, returning unknown.');
      return AuthStatus.unknown; // Indicate an issue occurred during the check
    }
  }
}



================================================
File: repositories/auth_status_repository.dart
================================================
// File: repositories/auth_status_repository.dart
import '../services/api_service.dart';
import '../utils/token_storage.dart';

enum AuthStatus {
  home,       // User authenticated with complete profile
  onboarding, // User authenticated but profile incomplete
  login,      // User not authenticated or invalid token
  unknown     // Error or initial state
}

class AuthStatusRepository {
  final ApiService _apiService;
  
  AuthStatusRepository(this._apiService);
  
  Future<AuthStatus> checkAuthStatus() async {
    try {
      // Get the saved token
      final token = await TokenStorage.getToken();
      
      if (token == null || token.isEmpty) {
        return AuthStatus.login;
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      // Make the API request
      final response = await _apiService.get(
        '/api/auth-status',
        headers: headers,
      );
      
      if (response['success'] == true) {
        final status = response['status']?.toString().toLowerCase();
        
        if (status == 'home') {
          return AuthStatus.home;
        } else if (status == 'onboarding') {
          return AuthStatus.onboarding;
        }
      }
      
      // Default to login if status is not recognized or success is false
      return AuthStatus.login;
    } on ApiException catch (e) {
      print('Auth status check failed: $e');
      // For authentication errors, redirect to login
      return AuthStatus.login;
    } catch (e) {
      print('Unexpected error during auth status check: $e');
      return AuthStatus.unknown;
    }
  }
}



================================================
File: repositories/like_repository.dart
================================================
// File: repositories/like_repository.dart
import '../models/like_models.dart';
import '../models/error_model.dart'; // Import AppError if needed by provider
import '../services/api_service.dart';
import '../utils/token_storage.dart';

class LikeRepository {
  final ApiService _apiService;

  LikeRepository(this._apiService);

  // likeContent(...) method from Phase 8...
  Future<bool> likeContent({
    required int likedUserId,
    required ContentLikeType contentType,
    required String contentIdentifier,
    required LikeInteractionType interactionType,
    String? comment,
  }) async {
    /* ... implementation ... */
    final String methodName = 'likeContent';
    print(
        '[LikeRepository $methodName] Liking UserID: $likedUserId, Type: ${contentType.value}, Identifier: $contentIdentifier, Interaction: ${interactionType.value}');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'liked_user_id': likedUserId,
        'content_type': contentType.value,
        'content_identifier': contentIdentifier,
        'interaction_type': interactionType.value,
        if (comment != null && comment.trim().isNotEmpty)
          'comment': comment.trim(),
      };
      print('[LikeRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/like', body: body, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      /* ... specific exception handling ... */
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      if (e.statusCode == 403) {
        if (e.message.toLowerCase().contains('limit reached'))
          throw LikeLimitExceededException(e.message);
        else if (e.message.toLowerCase().contains('insufficient consumables') ||
            e.message.toLowerCase().contains('rose'))
          throw InsufficientRosesException(e.message);
      }
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while liking content: ${e.toString()}');
    }
  }

  // dislikeUser(...) method from Phase 8...
  Future<bool> dislikeUser({required int dislikedUserId}) async {
    /* ... implementation ... */
    final String methodName = 'dislikeUser';
    print('[LikeRepository $methodName] Disliking UserID: $dislikedUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'disliked_user_id': dislikedUserId};
      print('[LikeRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/dislike', body: body, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while disliking user: ${e.toString()}');
    }
  }

  // --- NEW METHOD: Fetch Received Likes ---
  Future<Map<String, List<dynamic>>> fetchReceivedLikes() async {
    final String methodName = 'fetchReceivedLikes';
    print('[LikeRepository $methodName] Fetching received likes...');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');

      final headers = {'Authorization': 'Bearer $token'};
      final response =
          await _apiService.get('/api/likes/received', headers: headers);
      print('[LikeRepository $methodName] API Response: $response');

      if (response['success'] == true) {
        final List<FullProfileLiker> fullProfiles =
            (response['full_profiles'] as List? ?? [])
                .map((data) =>
                    FullProfileLiker.fromJson(data as Map<String, dynamic>))
                .toList();

        final List<BasicProfileLiker> otherLikers =
            (response['other_likers'] as List? ?? [])
                .map((data) =>
                    BasicProfileLiker.fromJson(data as Map<String, dynamic>))
                .toList();
        print(
            '[LikeRepository $methodName] Parsed ${fullProfiles.length} full, ${otherLikers.length} basic profiles.');
        return {'full': fullProfiles, 'other': otherLikers};
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch received likes.';
        print('[LikeRepository $methodName] Fetch failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while fetching likes: ${e.toString()}');
    }
  }
  // --- END NEW METHOD ---

  Future<Map<String, dynamic>> fetchLikerProfile(int likerUserId) async {
    final String methodName = 'fetchLikerProfile';
    print(
        '[LikeRepository $methodName] Fetching profile for liker ID: $likerUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');

      final headers = {'Authorization': 'Bearer $token'};
      // Construct the endpoint with the path parameter
      final endpoint = '/api/liker-profile/$likerUserId';
      print('[LikeRepository $methodName] Making GET request to: $endpoint');

      final response = await _apiService.get(endpoint, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');

      if (response['success'] == true &&
          response['profile'] != null &&
          response['like_details'] != null) {
        // Ensure the nested data are maps before parsing
        if (response['profile'] is Map<String, dynamic> &&
            response['like_details'] is Map<String, dynamic>) {
          final profileData = UserProfileData.fromJson(
              response['profile'] as Map<String, dynamic>);
          final likeDetailsData = LikeInteractionDetails.fromJson(
              response['like_details'] as Map<String, dynamic>);
          print(
              '[LikeRepository $methodName] Successfully parsed profile and like details.');
          return {'profile': profileData, 'likeDetails': likeDetailsData};
        } else {
          print(
              '[LikeRepository $methodName] Error: Invalid data format in response.');
          throw ApiException('Invalid data format received for liker profile.');
        }
      } else {
        // Handle case where success might be true but data is missing (shouldn't happen ideally)
        final message = response['message']?.toString() ??
            'Failed to fetch liker profile or like details.';
        print('[LikeRepository $methodName] Fetch failed: $message');
        throw ApiException(message,
            statusCode: response['statusCode']
                as int?); // Pass status code if available
      }
    } on ApiException catch (e) {
      // Specific handling for 404 might be useful here if needed by the UI
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while fetching the liker profile: ${e.toString()}');
    }
  }
  // fetchLikerProfile(...) - Will be added in Phase 10
}



================================================
File: repositories/media_repository.dart
================================================
// File: repositories/media_repository.dart
import 'dart:convert';
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/utils/token_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:http_parser/http_parser.dart';
import 'package:path/path.dart' as path;
import '../models/media_upload_model.dart';
import '../services/api_service.dart';

class MediaRepository {
  final ApiService _apiService;
  final Ref? ref;
  
  MediaRepository(this._apiService, [this.ref]);
  
  // Get presigned URLs for uploading files
  Future<List<Map<String, dynamic>>> getPresignedUrls(List<Map<String, String>> fileDetails) async {
    try {
      // Get the token either from the provider or storage
      String? token;
      if (ref != null) {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      }
      
      if (token == null) {
        // Fallback to token storage if not available from provider
        token = await TokenStorage.getToken();
      }
      
      if (token == null) {
        throw ApiException('Authentication token is missing');
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      final response = await _apiService.post(
        '/upload',
        body: {
          'files': fileDetails,
        },
        headers: headers,
      );
      
      if (response['uploads'] != null) {
        return List<Map<String, dynamic>>.from(response['uploads']);
      } else {
        throw ApiException('Failed to get presigned URLs');
      }
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error getting presigned URLs: ${e.toString()}');
    }
  }

  // Get presigned URL for audio upload
  Future<Map<String, dynamic>> getAudioPresignedUrl(String filename, String fileType, AudioPrompt prompt) async {
    try {
      // Get the token either from the provider or storage
      String? token;
      if (ref != null) {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      }
      
      if (token == null) {
        // Fallback to token storage if not available from provider
        token = await TokenStorage.getToken();
      }
      
      if (token == null) {
        throw ApiException('Authentication token is missing');
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      final response = await _apiService.post(
        '/audio',
        body: {
          'filename': filename,
          'type': fileType,
          'prompt': prompt.value,
        },
        headers: headers,
      );
      
      return response;
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error getting audio presigned URL: ${e.toString()}');
    }
  }

    // Get presigned URL for verification photo upload
  Future<String> getVerificationPresignedUrl(String filename, String fileType) async {
    try {
      // Get the token either from the provider or storage
      String? token;
      if (ref != null) {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      }

      if (token == null) {
        // Fallback to token storage if not available from provider
        token = await TokenStorage.getToken();
      }

      if (token == null) {
        throw ApiException('Authentication token is missing');
      }

      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };

      final response = await _apiService.post(
        '/verify',
        body: {
          'filename': filename,
          'type': fileType,
        },
        headers: headers,
      );

      if (response['upload_url'] != null) {
        return response['upload_url'];
      } else {
        throw ApiException('Failed to get verification presigned URL');
      }
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error getting verification presigned URL: ${e.toString()}');
    }
  }
  
  // Upload a file to S3 using presigned URL
// Upload a file to S3 using presigned URL
Future<bool> uploadFileToS3(MediaUploadModel mediaUpload) async {
  if (mediaUpload.presignedUrl == null) {
    throw ApiException('Missing presigned URL for upload');
  }

  final file = mediaUpload.file;
  final contentType = mediaUpload.fileType;
  final filePath = file.path;

  try {
    print('⏫ Starting S3 upload for: ${mediaUpload.fileName}');
    print('📁 File path: $filePath');
    print('📦 Content-Type: $contentType');
    print('📏 File size: ${(await file.length()) / 1024} KB');
    print('🔗 Presigned URL: ${mediaUpload.presignedUrl}');

    final client = HttpClient();
    final request = await client.putUrl(Uri.parse(mediaUpload.presignedUrl!));
    
    // Set headers from curl example
    request.headers.set(HttpHeaders.contentTypeHeader, contentType);
    request.contentLength = await file.length();

    // Add debug headers
    print('📨 Request headers:');
    request.headers.forEach((name, values) {
      print('   $name: ${values.join(', ')}');
    });

    // Pipe file content directly
    final fileStream = file.openRead();
    await request.addStream(fileStream);
    final response = await request.close();

    // Get response details
    final statusCode = response.statusCode;
    final responseHeaders = response.headers;
    final responseBody = await response.transform(utf8.decoder).join();

    print('📩 Upload response:');
    print('   Status: $statusCode');
    print('   Headers:');
    responseHeaders.forEach((name, values) {
      print('     $name: ${values.join(', ')}');
    });
    print('   Body: $responseBody');

    if (statusCode != HttpStatus.ok) {
      print('❌ Upload failed with status $statusCode');
      return false;
    }

    print('✅ Upload successful for ${mediaUpload.fileName}');
    return true;
  } catch (e, stack) {
    print('‼️ Critical upload error: $e');
    print('🛑 Stack trace: $stack');
    return false;
  }
}

  // Retry failed uploads with exponential backoff
  Future<bool> retryUpload(MediaUploadModel mediaUpload, {int maxRetries = 3}) async {
    int retryCount = 0;
    int backoffMs = 1000; // Start with 1 second
    
    while (retryCount < maxRetries) {
      try {
        final success = await uploadFileToS3(mediaUpload);
        if (success) return true;
      } catch (e) {
        print('Retry $retryCount failed: $e');
      }
      
      retryCount++;
      if (retryCount < maxRetries) {
        // Exponential backoff
        await Future.delayed(Duration(milliseconds: backoffMs));
        backoffMs *= 2; // Double the wait time for next retry
      }
    }
    
    return false;
  }
}



================================================
File: repositories/user_repository.dart
================================================
// File: repositories/user_repository.dart
import '../models/feed_models.dart';
import '../models/user_model.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import '../utils/app_enums.dart';

class UserRepository {
  final ApiService _apiService;

  UserRepository(this._apiService);

  // Method to update location and gender (from Phase 3)
  Future<bool> updateLocationGender(
      double lat, double lon, Gender gender) async {
    // ... (Implementation from Phase 3, no changes here) ...
    final String methodName = 'updateLocationGender';
    print(
        '[UserRepository $methodName] Called with lat: $lat, lon: $lon, gender: ${gender.value}');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'latitude': lat,
        'longitude': lon,
        'gender': gender.value,
      };

      print(
          '[UserRepository $methodName] Making POST request to /api/profile/location-gender');
      final response = await _apiService.post(
        '/api/profile/location-gender',
        body: body,
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print(
            '[UserRepository $methodName] Location/Gender update successful.');
        return true;
      } else {
        final message = response['message']?.toString() ??
            'Failed to update location and gender.';
        print(
            '[UserRepository $methodName] Location/Gender update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while updating location/gender: ${e.toString()}');
    }
  }

  // --- METHOD TO UPDATE MAIN PROFILE DETAILS (Phase 5) ---
  /// Updates the main profile details (excluding location/gender) via POST /api/profile.
  /// Expects a Map containing only the fields relevant to this endpoint.
  Future<bool> updateProfileDetails(Map<String, dynamic> profileData) async {
    final String methodName = 'updateProfileDetails';
    print('[UserRepository $methodName] Called.');
    // Remove any lingering null values which might cause issues with JSON encoding or backend validation
    profileData.removeWhere((key, value) => value == null);
    print('[UserRepository $methodName] Payload to send: $profileData');

    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making POST request to /api/profile');
      final response = await _apiService.post(
        '/api/profile', // The endpoint for main profile details
        body: profileData, // Send the prepared data
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print(
            '[UserRepository $methodName] Profile details update successful.');
        return true;
      } else {
        final message = response['message']?.toString() ??
            'Failed to update profile details.';
        print(
            '[UserRepository $methodName] Profile details update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while updating profile details: ${e.toString()}');
    }
  }
  // --- END METHOD ---

  // Fetch Quick Feed (from Phase 4)
  Future<List<QuickFeedProfile>> fetchQuickFeed() async {
    // ... (Implementation from Phase 4) ...
    final String methodName = 'fetchQuickFeed';
    print('[UserRepository $methodName] Called.');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print(
          '[UserRepository $methodName] Making GET request to /api/quickfeed');
      final response =
          await _apiService.get('/api/quickfeed', headers: headers);

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true &&
          response['profiles'] != null &&
          response['profiles'] is List) {
        print('[UserRepository $methodName] Quick feed fetch successful.');
        final profilesList = response['profiles'] as List;
        return profilesList
            .map((profileJson) =>
                QuickFeedProfile.fromJson(profileJson as Map<String, dynamic>))
            .toList();
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch quick feed.';
        print('[UserRepository $methodName] Quick feed fetch failed: $message');
        if (response['success'] == true && response['profiles'] == null) {
          return [];
        }
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while fetching the quick feed: ${e.toString()}');
    }
  }

  // Fetch Home Feed (from Phase 4)
  Future<List<HomeFeedProfile>> fetchHomeFeed() async {
    // ... (Implementation from Phase 4) ...
    final String methodName = 'fetchHomeFeed';
    print('[UserRepository $methodName] Called.');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making GET request to /api/homefeed');
      final response = await _apiService.get('/api/homefeed', headers: headers);

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true &&
          response['profiles'] != null &&
          response['profiles'] is List) {
        print('[UserRepository $methodName] Home feed fetch successful.');
        final profilesList = response['profiles'] as List;
        return profilesList
            .map((profileJson) =>
                HomeFeedProfile.fromJson(profileJson as Map<String, dynamic>))
            .toList();
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch home feed.';
        print('[UserRepository $methodName] Home feed fetch failed: $message');
        if (response['success'] == true && response['profiles'] == null) {
          return [];
        }
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while fetching the home feed: ${e.toString()}');
    }
  }

  // Fetch User Profile (existing)
  Future<UserModel> fetchUserProfile() async {
    // ... (Implementation from Phase 3) ...
    final String methodName = 'fetchUserProfile';
    print('[UserRepository $methodName] Called.');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making GET request to /get-profile');
      final response = await _apiService.get('/get-profile', headers: headers);

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true && response['user'] != null) {
        print('[UserRepository $methodName] Profile fetch successful.');
        if (response['user'] is Map<String, dynamic>) {
          return UserModel.fromJson(response['user'] as Map<String, dynamic>);
        } else {
          print(
              '[UserRepository $methodName] Error: Invalid user data format in response.');
          throw ApiException('Invalid user data format received from server.');
        }
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch user profile.';
        print('[UserRepository $methodName] Profile fetch failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while fetching the profile: ${e.toString()}');
    }
  }

  // Old updateProfile method - Keep for compatibility or remove
  Future<bool> updateProfile(UserModel userModel) async {
    print(
        "[UserRepository updateProfile] Forwarding to updateProfileDetails...");
    // Use the new helper method to generate the correct payload
    Map<String, dynamic> profileData = userModel.toJsonForProfileUpdate();
    return await updateProfileDetails(profileData);
  }
}



================================================
File: services/api_service.dart
================================================

// File: services/api_service.dart
import 'dart:convert';

/// Abstract class defining the API service interface
abstract class ApiService {
  /// Base URL for all API requests
  String get baseUrl;

  /// Makes a GET request to the specified endpoint
  Future<Map<String, dynamic>> get(String endpoint, {Map<String, String>? headers});

  /// Makes a POST request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a PUT request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a DELETE request to the specified endpoint
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  });

  /// Adds authorization token to headers
  Map<String, String> addAuthToken(Map<String, String>? headers, String token);
}

/// Exception thrown when API requests fail
class ApiException implements Exception {
  final String message;
  final int? statusCode;

  ApiException(this.message, {this.statusCode});

  @override
  String toString() => 'ApiException: $message ${statusCode != null ? '(Status code: $statusCode)' : ''}';
}



================================================
File: services/http_service.dart
================================================

// File: services/http_service.dart
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'api_service.dart';

/// Implementation of ApiService using the http package
class HttpService implements ApiService {
  @override
  final String baseUrl;

  HttpService({required this.baseUrl});

  @override
  Map<String, String> addAuthToken(Map<String, String>? headers, String token) {
    final updatedHeaders = {...(headers ?? {})};
    updatedHeaders['Authorization'] = 'Bearer $token';
    print(updatedHeaders);
    return updatedHeaders;
  }

  @override
  Future<Map<String, dynamic>> get(String endpoint, {Map<String, String>? headers}) async {
    try {
      final response = await http.get(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      throw ApiException('Failed to perform GET request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.post(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform POST request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.put(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform PUT request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  }) async {
    try {
      final request = http.Request('DELETE', Uri.parse('$baseUrl$endpoint'));
      
      request.headers.addAll({
        'Content-Type': 'application/json',
        ...?headers,
      });
      
      if (body != null) {
        request.body = json.encode(body);
      }
      
      final streamedResponse = await request.send();
      final response = await http.Response.fromStream(streamedResponse);
      
      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform DELETE request: ${e.toString()}');
    }
  }

  /// Handle the HTTP response and convert to a standardized format
  Map<String, dynamic> _handleResponse(http.Response response) {
    try {
      final responseData = json.decode(response.body) as Map<String, dynamic>;
      
      if (response.statusCode >= 200 && response.statusCode < 300) {
        return responseData;
      } else {
        // Extract only the actual error message from the API response
        String errorMessage;
        
        if (responseData.containsKey('message')) {
          // Use the message directly from the response
          errorMessage = responseData['message'].toString();
        } else if (responseData.containsKey('error')) {
          // Some APIs use 'error' property
          errorMessage = responseData['error'].toString();
        } else {
          // Fallback error message
          errorMessage = 'An error occurred (Status: ${response.statusCode})';
        }
        
        throw ApiException(errorMessage, statusCode: response.statusCode);
      }
    } on FormatException {
      throw ApiException('Invalid response format', statusCode: response.statusCode);
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to process response: ${e.toString()}', statusCode: response.statusCode);
    }
  }
}



================================================
File: utils/app_enums.dart
================================================
// File: lib/utils/app_enums.dart
// --- ADDED: Import ContentLikeType ---
import 'package:dtx/models/like_models.dart';
// --- END ADDED ---

enum Gender {
  man('man', 'Man'),
  woman('woman', 'Woman');
  // Removed bisexual, lesbian, gay based on backend schema update

  final String value;
  final String label;
  const Gender(this.value, this.label);
}

enum DatingIntention {
  lifePartner('lifePartner', 'Life partner'),
  longTerm('longTerm', 'Long-term relationship'),
  longTermOpenShort(
      'longTermOpenShort', 'Long-term, open to short'), // Shortened label
  shortTermOpenLong(
      'shortTermOpenLong', 'Short-term, open to long'), // Shortened label
  shortTerm('shortTerm', 'Short-term relationship'),
  figuringOut('figuringOut', 'Figuring out my dating goals');

  final String value;
  final String label;
  const DatingIntention(this.value, this.label);
}

enum Religion {
  agnostic('agnostic', 'Agnostic'),
  atheist('atheist', 'Atheist'),
  buddhist('buddhist', 'Buddhist'),
  christian('christian', 'Christian'),
  hindu('hindu', 'Hindu'),
  jain('jain', 'Jain'),
  jewish('jewish', 'Jewish'),
  muslim('muslim', 'Muslim'),
  zoroastrian('zoroastrian', 'Zoroastrian'),
  sikh('sikh', 'Sikh'),
  spiritual('spiritual', 'Spiritual');

  final String value;
  final String label;
  const Religion(this.value, this.label);
}

enum DrinkingSmokingHabits {
  yes('yes', 'Yes'),
  sometimes('sometimes', 'Sometimes'),
  no('no', 'No');

  final String value;
  final String label;
  const DrinkingSmokingHabits(this.value, this.label);
}

enum PromptCategory {
  storyTime('storyTime', 'Story time'),
  myType('myType', 'My type'),
  gettingPersonal('gettingPersonal', 'Getting personal'),
  dateVibes('dateVibes', 'Date vibes');

  final String value;
  final String label;
  const PromptCategory(this.value, this.label);

  // --- ADDED: contentType Getter ---
  ContentLikeType get contentType {
    switch (this) {
      case PromptCategory.storyTime:
        return ContentLikeType.promptStory;
      case PromptCategory.myType:
        return ContentLikeType.promptMytype;
      case PromptCategory.gettingPersonal:
        return ContentLikeType.promptGettingpersonal;
      case PromptCategory.dateVibes:
        return ContentLikeType.promptDatevibes;
    }
  }
  // --- END ADDED ---

  List<PromptType> getPrompts() {
    switch (this) {
      case PromptCategory.storyTime:
        return [
          PromptType.twoTruthsAndALie,
          PromptType.worstIdea,
          PromptType.biggestRisk,
          PromptType.biggestDateFail,
          PromptType.neverHaveIEver,
          PromptType.bestTravelStory,
          PromptType.weirdestGift,
          PromptType.mostSpontaneous,
          PromptType.oneThingNeverDoAgain,
        ];
      case PromptCategory.myType:
        return [
          PromptType.nonNegotiable,
          PromptType.hallmarkOfGoodRelationship,
          PromptType.lookingFor,
          PromptType.weirdlyAttractedTo,
          PromptType.allIAskIsThatYou,
          PromptType.wellGetAlongIf,
          PromptType.wantSomeoneWho,
          PromptType.greenFlags,
          PromptType.sameTypeOfWeird,
          PromptType.fallForYouIf,
          PromptType.bragAboutYou,
        ];
      case PromptCategory.gettingPersonal:
        return [
          PromptType.oneThingYouShouldKnow,
          PromptType.loveLanguage,
          PromptType.dorkiestThing,
          PromptType.dontHateMeIf,
          PromptType.geekOutOn,
          PromptType.ifLovingThisIsWrong,
          PromptType.keyToMyHeart,
          PromptType.wontShutUpAbout,
          PromptType.shouldNotGoOutWithMeIf,
          PromptType.whatIfIToldYouThat,
        ];
      case PromptCategory.dateVibes:
        return [
          PromptType.togetherWeCould, PromptType.firstRoundIsOnMeIf,
          PromptType.whatIOrderForTheTable, // Corrected typo in definition
          PromptType.bestSpotInTown, PromptType.bestWayToAskMeOut,
        ];
    }
  }
}

enum PromptType {
  // Story Time
  twoTruthsAndALie('twoTruthsAndALie', 'Two truths and a lie'),
  worstIdea('worstIdea', 'Worst idea I\'ve ever had'),
  biggestRisk('biggestRisk', 'Biggest risk I\'ve taken'),
  biggestDateFail('biggestDateFail', 'My biggest date fail'),
  neverHaveIEver('neverHaveIEver', 'Never have I ever'),
  bestTravelStory('bestTravelStory', 'Best travel story'),
  weirdestGift('weirdestGift', 'Weirdest gift I\'ve given or received'),
  mostSpontaneous('mostSpontaneous', 'Most spontaneous thing I\'ve done'),
  oneThingNeverDoAgain(
      'oneThingNeverDoAgain', 'One thing I\'ll never do again'),
  // My Type
  nonNegotiable('nonNegotiable', 'Something that\'s non-negotiable for me is'),
  hallmarkOfGoodRelationship(
      'hallmarkOfGoodRelationship', 'The hallmark of a good relationship is'),
  lookingFor('lookingFor', 'I\'m looking for'),
  weirdlyAttractedTo('weirdlyAttractedTo', 'I\'m weirdly attracted to'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  wellGetAlongIf('wellGetAlongIf', 'We\'ll get along if'),
  wantSomeoneWho('wantSomeoneWho', 'I want someone who'),
  greenFlags('greenFlags', 'Green flags I look out for'),
  sameTypeOfWeird('sameTypeOfWeird', 'We\'re the same type of weird if'),
  fallForYouIf('fallForYouIf', 'I\'d fall for you if'),
  bragAboutYou('bragAboutYou', 'I\'ll brag about you to my friends if'),
  // Getting Personal
  oneThingYouShouldKnow(
      'oneThingYouShouldKnow', 'The one thing you should know about me is'),
  loveLanguage('loveLanguage', 'My Love Language is'),
  dorkiestThing('dorkiestThing', 'The dorkiest thing about me is'),
  dontHateMeIf('dontHateMeIf', 'Don\'t hate me if I'),
  geekOutOn('geekOutOn', 'I geek out on'),
  ifLovingThisIsWrong('ifLovingThisIsWrong',
      'If loving this is wrong, I don\'t want to be right'),
  keyToMyHeart('keyToMyHeart', 'The key to my heart is'),
  wontShutUpAbout('wontShutUpAbout', 'I won\'t shut up about'),
  shouldNotGoOutWithMeIf(
      'shouldNotGoOutWithMeIf', 'You should *not* go out with me if'),
  whatIfIToldYouThat('whatIfIToldYouThat', 'What if I told you that'),
  // Date Vibes
  togetherWeCould('togetherWeCould', 'Together, we could'),
  firstRoundIsOnMeIf('firstRoundIsOnMeIf', 'First round is on me if'),
  whatIOrderForTheTable('whatIOrderForTheTable',
      'What I order for the table'), // Corrected enum value and label
  bestSpotInTown('bestSpotInTown', 'I know the best spot in town for'),
  bestWayToAskMeOut('bestWayToAskMeOut', 'The best way to ask me out is by');

  final String value;
  final String label;
  const PromptType(this.value, this.label);

  PromptCategory getCategory() {
    for (var category in PromptCategory.values) {
      if (category.getPrompts().contains(this)) {
        return category;
      }
    }
    print("Warning: PromptType '$value' does not belong to a known category.");
    return PromptCategory.storyTime; // Defaulting
  }
}

enum AudioPrompt {
  canWeTalkAbout('canWeTalkAbout', 'Can we talk about?'),
  captionThisPhoto('captionThisPhoto', 'Caption this photo'),
  caughtInTheAct('caughtInTheAct', 'Caught in the act'),
  changeMyMindAbout('changeMyMindAbout', 'Change my mind about'),
  chooseOurFirstDate('chooseOurFirstDate', 'Choose our first date'),
  commentIfYouveBeenHere(
      'commentIfYouveBeenHere', 'Comment if you\'ve been here'),
  cookWithMe('cookWithMe', 'Cook with me'),
  datingMeIsLike('datingMeIsLike', 'Dating me is like'),
  datingMeWillLookLike('datingMeWillLookLike', 'Dating me will look like'),
  doYouAgreeOrDisagreeThat(
      'doYouAgreeOrDisagreeThat', 'Do you agree or disagree that'),
  dontHateMeIfI('dontHateMeIfI', 'Don\'t hate me if I'),
  dontJudgeMe('dontJudgeMe', 'Don\'t judge me'),
  mondaysAmIRight('mondaysAmIRight', 'Mondays... am I right?'),
  aBoundaryOfMineIs('aBoundaryOfMineIs', 'A boundary of mine is'),
  aDailyEssential('aDailyEssential', 'A daily essential'),
  aDreamHomeMustInclude('aDreamHomeMustInclude', 'A dream home must include'),
  aFavouriteMemoryOfMine(
      'aFavouriteMemoryOfMine', 'A favourite memory of mine'),
  aFriendsReviewOfMe('aFriendsReviewOfMe', 'A friend\'s review of me'),
  aLifeGoalOfMine('aLifeGoalOfMine', 'A life goal of mine'),
  aQuickRantAbout('aQuickRantAbout', 'A quick rant about'),
  aRandomFactILoveIs('aRandomFactILoveIs', 'A random fact I love is'),
  aSpecialTalentOfMine('aSpecialTalentOfMine', 'A special talent of mine'),
  aThoughtIRecentlyHadInTheShower('aThoughtIRecentlyHadInTheShower',
      'A thought I recently had in the shower'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  guessWhereThisPhotoWasTaken(
      'guessWhereThisPhotoWasTaken', 'Guess where this photo was taken'),
  helpMeIdentifyThisPhotoBomber(
      'helpMeIdentifyThisPhotoBomber', 'Help me identify this photo bomber'),
  hiFromMeAndMyPet('hiFromMeAndMyPet', 'Hi from me and my pet'),
  howIFightTheSundayScaries(
      'howIFightTheSundayScaries', 'How I fight the Sunday scaries'),
  howHistoryWillRememberMe(
      'howHistoryWillRememberMe', 'How history will remember me'),
  howMyFriendsSeeMe('howMyFriendsSeeMe', 'How my friends see me'),
  howToPronounceMyName('howToPronounceMyName', 'How to pronounce my name'),
  iBeatMyBluesBy('iBeatMyBluesBy', 'I beat my blues by'),
  iBetYouCant('iBetYouCant', 'I bet you can\'t'),
  iCanTeachYouHowTo('iCanTeachYouHowTo', 'I can teach you how to'),
  iFeelFamousWhen('iFeelFamousWhen', 'I feel famous when'),
  iFeelMostSupportedWhen(
      'iFeelMostSupportedWhen', 'I feel most supported when');

  final String value;
  final String label;
  const AudioPrompt(this.value, this.label);
}

enum FeedType { quick, home }



================================================
File: utils/env_config.dart
================================================

// File: utils/env_config.dart
import 'package:flutter_dotenv/flutter_dotenv.dart';

class EnvConfig {
  static String get apiBaseUrl => 
    dotenv.get('API_BASE_URL', fallback: 'http://10.61.67.128:8080');
}



================================================
File: utils/token_storage.dart
================================================

// File: utils/token_storage.dart
import 'package:shared_preferences/shared_preferences.dart';

class TokenStorage {
  static const String _tokenKey = 'auth_token';
  
  // Save the JWT token
  static Future<bool> saveToken(String token) async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.setString(_tokenKey, token);
  }
  
  // Get the stored JWT token
  static Future<String?> getToken() async {
    final prefs = await SharedPreferences.getInstance();
    print(prefs.getString(_tokenKey));
    return prefs.getString(_tokenKey);
  }
  
  // Remove the stored token (for logout)
  static Future<bool> removeToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.remove(_tokenKey);
  }
  
  // Check if a token exists
  static Future<bool> hasToken() async {
    final token = await getToken();
    return token != null && token.isNotEmpty;
  }
}



================================================
File: views/audioprompt.dart
================================================
// File: views/audioprompt.dart
import 'dart:async'; // Import async for Timer
import 'package:dtx/models/error_model.dart'; // Import AppError
import 'package:dtx/models/media_upload_model.dart';
import 'package:dtx/providers/audio_upload_provider.dart';
import 'package:dtx/providers/error_provider.dart'; // Import ErrorProvider
import 'package:dtx/providers/service_provider.dart'; // Import ServiceProvider for repo
import 'package:dtx/services/api_service.dart'; // Import ApiException
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/audiopromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart'; // Import GoogleFonts
import 'package:record/record.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'dart:io';
import '../models/auth_model.dart';
import '../providers/auth_provider.dart';
import '../providers/user_provider.dart';
import '../views/home.dart';

class VoicePromptScreen extends ConsumerStatefulWidget {
  const VoicePromptScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<VoicePromptScreen> createState() => _VoicePromptScreenState();
}

class _VoicePromptScreenState extends ConsumerState<VoicePromptScreen> {
  final AudioRecorder _audioRecorder = AudioRecorder();
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isRecording = false;
  String _recordingTime = "0:00 / 0:30";
  String? _audioPath;
  bool _isPlaying = false;
  DateTime? _startTime;
  Timer? _recordingTimer; // Store timer to cancel it
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    _initializeAudioSession();
    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) {
        setState(() => _isPlaying = false);
      }
    });
    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted && state != PlayerState.playing) {
        // Update UI if player stops for any reason other than pause/resume handled elsewhere
        if (_isPlaying && state != PlayerState.paused) {
          setState(() => _isPlaying = false);
        }
      }
    });
  }

  Future<void> _initializeAudioSession() async {
    print("[VoicePromptScreen] Requesting microphone permission...");
    final status = await Permission.microphone.request();
    print("[VoicePromptScreen] Microphone permission status: $status");
    if (!status.isGranted) {
      if (mounted) {
        // Check if mounted before showing SnackBar
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Microphone permission is required.')),
        );
      }
    }
  }

  Future<void> _startRecording() async {
    if (!await _audioRecorder.hasPermission()) {
      print("[VoicePromptScreen] Start Recording: Permission denied.");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Microphone permission denied.')),
        );
      }
      return;
    }
    // Stop playback if it's ongoing
    if (_isPlaying) {
      await _audioPlayer.stop();
      setState(() => _isPlaying = false);
    }
    // Clear previous path immediately
    setState(() {
      _audioPath = null;
      _recordingTime = "0:00 / 0:30"; // Reset timer display
    });
    ref
        .read(audioUploadProvider.notifier)
        .clearAudio(); // Clear provider state too

    try {
      print("[VoicePromptScreen] Starting recording...");
      final directory = await getApplicationDocumentsDirectory();
      // Ensure the path uses a compatible extension, e.g., .m4a for aacLc
      final newPath =
          '${directory.path}/voice_prompt_${DateTime.now().millisecondsSinceEpoch}.m4a';
      print("[VoicePromptScreen] Recording path set to: $newPath");

      // --- FIX: Use correct AudioEncoder constant (aacLc) ---
      await _audioRecorder.start(
        const RecordConfig(encoder: AudioEncoder.aacLc), // Corrected constant
        path: newPath, // Use the new path directly
      );
      // --- END FIX ---

      _audioPath = newPath; // Set path only after start succeeds
      _startTime = DateTime.now();
      if (!mounted) return;
      setState(() => _isRecording = true);
      print("[VoicePromptScreen] Recording started.");

      // Cancel previous timer if exists
      _recordingTimer?.cancel();
      // Start new timer
      _recordingTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
        // Use Timer here
        if (!_isRecording || !mounted || _startTime == null) {
          timer.cancel();
          return;
        }
        final duration = DateTime.now().difference(_startTime!).inSeconds;
        if (duration >= 30) {
          timer.cancel();
          _stopRecording(); // Auto-stop
          return;
        }
        if (mounted) {
          setState(() {
            _recordingTime = "0:${duration.toString().padLeft(2, '0')} / 0:30";
          });
        }
      });
    } catch (e) {
      print('[VoicePromptScreen] Recording error: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Recording failed: ${e.toString()}')),
        );
        setState(() => _isRecording = false);
      }
    }
  }

  Future<void> _stopRecording() async {
    if (!_isRecording) return;
    _recordingTimer?.cancel(); // Stop the timer

    try {
      final path = await _audioRecorder.stop();
      print('[VoicePromptScreen] Recording stopped. Path from recorder: $path');
      if (path != null) {
        // Verify file exists after stopping
        final file = File(path);
        if (!await file.exists() || await file.length() == 0) {
          print(
              '[VoicePromptScreen] Error: Recording file is missing or empty after stop.');
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                  content: Text('Failed to save recording. Please try again.')),
            );
            setState(() {
              _isRecording = false;
              _audioPath = null; // Clear invalid path
              _recordingTime = "0:00 / 0:30";
            });
          }
          return; // Exit early
        }
        _audioPath = path;
        if (mounted) {
          setState(() {
            _isRecording = false;
            // Recording time is reset visually, actual duration is in the file
          });
          ref.read(audioUploadProvider.notifier).setRecordingPath(_audioPath!);
          print(
              "[VoicePromptScreen] Recording path saved to provider: $_audioPath");
        }
      } else {
        print("[VoicePromptScreen] Stop recording returned null path.");
        if (mounted) {
          setState(() => _isRecording = false);
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Failed to save recording.')),
          );
        }
      }
    } catch (e) {
      print('[VoicePromptScreen] Stop recording error: $e');
      if (mounted) {
        setState(() => _isRecording = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error stopping recording: ${e.toString()}')),
        );
      }
    }
  }

  Future<void> _playRecording() async {
    print("[VoicePromptScreen] Play recording requested. Path: $_audioPath");
    if (_audioPath == null) {
      print("[VoicePromptScreen] Playback Error: Audio path is null.");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Please record your voice first.')),
        );
      }
      return;
    }
    final file = File(_audioPath!);
    if (!await file.exists()) {
      print(
          "[VoicePromptScreen] Playback Error: File does not exist at $_audioPath");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Recording file not found. Please record again.')),
        );
      }
      setState(() => _audioPath = null); // Clear invalid path
      return;
    }
    if (await file.length() == 0) {
      print("[VoicePromptScreen] Playback Error: File is empty at $_audioPath");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Recording file is empty. Please record again.')),
        );
      }
      setState(() => _audioPath = null); // Clear invalid path
      return;
    }

    try {
      if (_isPlaying) {
        print("[VoicePromptScreen] Pausing playback.");
        await _audioPlayer.pause(); // Use pause instead of stop
        if (mounted) setState(() => _isPlaying = false);
      } else {
        // Check if already playing something else, stop first
        if (_audioPlayer.state == PlayerState.playing) {
          await _audioPlayer.stop();
        }
        print("[VoicePromptScreen] Starting playback from: $_audioPath");
        await _audioPlayer.play(DeviceFileSource(_audioPath!));
        // Listener will update state to playing, but set here for immediate feedback maybe?
        if (mounted) setState(() => _isPlaying = true);
      }
    } catch (e) {
      print('[VoicePromptScreen] Playback error: $e');
      if (mounted) {
        setState(() => _isPlaying = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Playback failed: ${e.toString()}')),
        );
      }
    }
  }

  void _selectPrompt() {
    if (_isPlaying) {
      _audioPlayer.pause(); // Pause instead of stop when navigating
      if (mounted) setState(() => _isPlaying = false);
    }
    print("[VoicePromptScreen] Navigating to select audio prompt.");
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const AudioSelectPromptScreen()),
    ).then((_) {
      if (mounted) {
        print(
            "[VoicePromptScreen] Returned from prompt selection. Refreshing UI.");
        setState(() {});
      }
    });
  }

  Future<void> _saveProfileAndNavigate() async {
    print('[VoicePromptScreen] Starting _saveProfileAndNavigate');
    final errorNotifier = ref.read(errorProvider.notifier);
    final authNotifier = ref.read(authProvider.notifier);
    final userNotifier = ref.read(userProvider.notifier); // Get user notifier
    errorNotifier.clearError();

    final selectedPrompt =
        ref.read(audioUploadProvider.notifier).selectedPrompt;
    if (selectedPrompt == null) {
      print('[VoicePromptScreen] Validation Error: No audio prompt selected.');
      errorNotifier
          .setError(AppError.validation("Please select an audio prompt."));
      return;
    }

    // --- Prepare Audio ONLY IF _audioPath is set ---
    bool audioNeedsUpload =
        _audioPath != null && File(_audioPath!).existsSync();
    bool audioPrepared = false;
    MediaUploadModel? audioUploadModel;

    if (audioNeedsUpload) {
      ref
          .read(audioUploadProvider.notifier)
          .setRecordingPath(_audioPath!); // Ensure provider has latest path
      audioPrepared = ref.read(audioUploadProvider.notifier).prepareAudioFile();
      if (!audioPrepared) {
        print('[VoicePromptScreen] Audio file preparation/validation failed.');
        // Error should already be set by the provider
        return;
      }
      audioUploadModel =
          ref.read(audioUploadProvider); // Get the prepared model
      if (audioUploadModel == null) {
        print('[VoicePromptScreen] Error: Audio prepared but model is null.');
        errorNotifier
            .setError(AppError.generic("Error preparing audio model."));
        return;
      }
    } else {
      print('[VoicePromptScreen] No audio recording found or needed.');
      // If audio is optional and not recorded, ensure it's removed from user model before saving profile
      userNotifier
          .updateAudioPrompt(null); // Clear audio prompt if none was recorded
    }
    // --- End Audio Prep ---

    setState(() => _isSaving = true);

    try {
      // 3. Upload Audio (if prepared)
      bool audioUploadedSuccessfully =
          true; // Assume success if no audio needed
      if (audioNeedsUpload && audioPrepared && audioUploadModel != null) {
        print('[VoicePromptScreen] Audio model exists, attempting upload...');
        // The upload provider now updates the user model internally on success
        audioUploadedSuccessfully = await ref
            .read(audioUploadProvider.notifier)
            .uploadAudioAndSaveToProfile();
        if (!audioUploadedSuccessfully) {
          print('[VoicePromptScreen] Audio upload failed.');
          // Error should be set by upload provider
          setState(() => _isSaving = false);
          return;
        }
        print('[VoicePromptScreen] Audio upload successful.');
      } else if (audioNeedsUpload && !audioPrepared) {
        // This case should ideally be caught earlier by prepareAudioFile return value
        print(
            '[VoicePromptScreen] Error: Audio needed upload but was not prepared.');
        errorNotifier.setError(
            AppError.generic("Error preparing audio. Please re-record."));
        setState(() => _isSaving = false);
        return;
      } else {
        print('[VoicePromptScreen] No audio to upload.');
      }

      // 4. Prepare Main Profile Data (user model is already updated by upload provider if needed)
      final userModel =
          ref.read(userProvider); // Read the potentially updated user model
      final profileData = userModel.toJsonForProfileUpdate();
      print('[VoicePromptScreen] Profile data prepared for API: $profileData');

      // 5. Call Repository to Save Profile Details
      final userRepository = ref.read(userRepositoryProvider);
      print(
          '[VoicePromptScreen] Calling userRepository.updateProfileDetails...');
      final profileSaved =
          await userRepository.updateProfileDetails(profileData);

      if (profileSaved) {
        print('[VoicePromptScreen] Profile details saved successfully.');
        // 6. Update Auth Status and Navigate Home
        final finalStatus =
            await authNotifier.checkAuthStatus(updateState: true);
        if (mounted) {
          print(
              '[VoicePromptScreen] Navigating to HomeScreen (Home Feed). Status: $finalStatus');
          // Navigate to home
          Navigator.of(context).pushAndRemoveUntil(
            MaterialPageRoute(
                builder: (_) => const HomeScreen(
                    initialFeedType: FeedType
                        .home)), // Assuming home feed after profile completion
            (route) => false,
          );
        }
      } else {
        print(
            '[VoicePromptScreen] Profile details save failed (API returned false).');
        if (mounted) {
          // Check if error provider already has a more specific error from API
          if (ref.read(errorProvider) == null) {
            errorNotifier.setError(
                AppError.server("Failed to save profile. Please try again."));
          }
        }
      }
    } on ApiException catch (e) {
      print('[VoicePromptScreen] API Exception: ${e.message}');
      if (mounted) errorNotifier.setError(AppError.server(e.message));
    } catch (e) {
      print('[VoicePromptScreen] Unexpected Error: $e');
      if (mounted) {
        errorNotifier.setError(AppError.generic(
            "An unexpected error occurred. Please try again."));
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final selectedPrompt =
        ref.watch(audioUploadProvider.notifier).selectedPrompt;
    final errorState = ref.watch(errorProvider);
    // Use user provider to check if audio prompt is already set
    final existingAudioPrompt = ref.watch(userProvider).audioPrompt;
    final bool canSave = selectedPrompt != null &&
        (_audioPath != null || existingAudioPrompt != null);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 40),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: List.generate(
                    3, // Assuming this is the last step of onboarding part 2
                    (index) => Container(
                          margin: const EdgeInsets.symmetric(horizontal: 4),
                          height: 10,
                          width: 10,
                          decoration: BoxDecoration(
                            color: index < 2 // Example logic
                                ? Colors.grey[300]
                                : const Color(0xFF8b5cf6),
                            shape: BoxShape.circle,
                          ),
                        )),
              ),
              const SizedBox(height: 40),
              Text(
                'Add a Voice Prompt\nto your profile',
                style: GoogleFonts.poppins(
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  height: 1.2,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 12),
              Text(
                "Let potential matches hear your voice!",
                style:
                    GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
              ),
              const SizedBox(height: 32),
              GestureDetector(
                onTap: _selectPrompt,
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: Colors.grey[300]!),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.grey.withOpacity(0.1),
                        blurRadius: 5,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          selectedPrompt?.label ?? 'Select a prompt *',
                          style: GoogleFonts.poppins(
                            color: selectedPrompt != null
                                ? Colors.black87
                                : Colors.grey[600],
                            fontSize: 16,
                            fontWeight: selectedPrompt != null
                                ? FontWeight.w500
                                : FontWeight.normal,
                          ),
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(left: 8),
                        child: Icon(
                          Icons.arrow_drop_down_rounded,
                          color: Colors.grey[800],
                          size: 28,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 24),
              Expanded(
                child: GestureDetector(
                  onTap:
                      _isRecording ? null : _startRecording, // Allow starting
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(24),
                    decoration: BoxDecoration(
                      color: Colors.grey[50],
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(color: Colors.grey[200]!),
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          _recordingTime,
                          style: GoogleFonts.poppins(
                            color: Colors.grey[500],
                            fontSize: 18,
                          ),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          _isRecording
                              ? 'Recording...'
                              : (_audioPath == null
                                  ? 'Tap microphone to start (Max 30s)'
                                  : 'Tap microphone to re-record'),
                          textAlign: TextAlign.center,
                          style: GoogleFonts.poppins(
                            color: Colors.grey[600],
                            fontSize: 16,
                          ),
                        ),
                        const Spacer(),
                        GestureDetector(
                          onTap: _isRecording
                              ? _stopRecording
                              : _startRecording, // Allow stopping too
                          child: Container(
                            padding: const EdgeInsets.all(24),
                            decoration: BoxDecoration(
                              color: _isRecording
                                  ? Colors.redAccent
                                  : const Color(0xFF8b5cf6),
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                  color: (_isRecording
                                          ? Colors.redAccent
                                          : const Color(0xFF8b5cf6))
                                      .withOpacity(0.3),
                                  blurRadius: 10,
                                  offset: const Offset(0, 4),
                                ),
                              ],
                            ),
                            child: Icon(
                              _isRecording
                                  ? Icons.stop_rounded
                                  : Icons.mic_rounded,
                              color: Colors.white,
                              size: 36,
                            ),
                          ),
                        ),
                        const Spacer(),
                        if (_audioPath != null &&
                            File(_audioPath!).existsSync()) // Check exists
                          TextButton.icon(
                            onPressed: _playRecording,
                            style: TextButton.styleFrom(
                              foregroundColor: const Color(0xFF8b5cf6),
                            ),
                            icon: Icon(_isPlaying
                                ? Icons.pause_rounded // Changed to pause icon
                                : Icons.play_arrow_rounded),
                            label: Text(
                              _isPlaying
                                  ? 'Pause'
                                  : 'Play recording', // Changed label
                              style: GoogleFonts.poppins(
                                  fontSize: 16, fontWeight: FontWeight.w500),
                            ),
                          )
                        else
                          const SizedBox(height: 48), // Keep placeholder space
                      ],
                    ),
                  ),
                ),
              ),
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.only(top: 12.0, bottom: 8.0),
                  child: Text(
                    errorState.message,
                    style: GoogleFonts.poppins(
                        color: Colors.redAccent, fontSize: 14),
                    textAlign: TextAlign.center,
                  ),
                ),
              const SizedBox(height: 16),
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding: const EdgeInsets.only(bottom: 24.0),
                  child: _isSaving
                      ? const CircularProgressIndicator(
                          color: Color(0xFF8b5cf6))
                      : FloatingActionButton(
                          heroTag: 'audio_save_fab',
                          onPressed: canSave ? _saveProfileAndNavigate : null,
                          backgroundColor: canSave
                              ? const Color(0xFF8b5cf6)
                              : Colors.grey.shade400,
                          foregroundColor: Colors.white,
                          child: const Icon(Icons.check_rounded),
                        ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    print("[VoicePromptScreen] Disposing screen...");
    _recordingTimer?.cancel(); // Cancel timer on dispose
    try {
      _audioRecorder.dispose();
    } catch (e) {
      print("Error disposing recorder: $e");
    }
    try {
      // Stop player if playing before dispose
      if (_audioPlayer.state == PlayerState.playing ||
          _audioPlayer.state == PlayerState.paused) {
        _audioPlayer.stop();
      }
      _audioPlayer.dispose();
    } catch (e) {
      print("Error disposing player: $e");
    }
    super.dispose();
  }
}



================================================
File: views/audiopromptsselect.dart
================================================
// views/audiopromptsselect.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/providers/audio_upload_provider.dart';

class AudioSelectPromptScreen extends ConsumerWidget {
  const AudioSelectPromptScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentPrompt = ref.watch(audioUploadProvider.notifier).selectedPrompt;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    "Select a Prompt",
                    style: TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () => Navigator.pop(context),
                    child: const Icon(Icons.close, size: 24),
                  ),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                itemCount: AudioPrompt.values.length,
                itemBuilder: (context, index) {
                  final prompt = AudioPrompt.values[index];
                  final isSelected = prompt == currentPrompt;
                  
                  return GestureDetector(
                    onTap: () {
                      ref.read(audioUploadProvider.notifier).setSelectedPrompt(prompt);
                      Navigator.pop(context);
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                        color: isSelected ? const Color(0xFFEDE9FE) : null,
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              prompt.label,
                              style: TextStyle(
                                fontSize: 18,
                                color: isSelected ? const Color(0xFF8B5CF6) : Colors.black87,
                                fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                              ),
                            ),
                          ),
                          if (isSelected)
                            const Icon(
                              Icons.check_circle,
                              color: Color(0xFF8B5CF6),
                            ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dating_intentions.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';
import '../providers/user_provider.dart';
import 'height.dart';

class DatingIntentionsScreen extends ConsumerStatefulWidget {
  const DatingIntentionsScreen({super.key});

  @override
  ConsumerState<DatingIntentionsScreen> createState() =>
      _DatingIntentionsScreenState();
}

class _DatingIntentionsScreenState
    extends ConsumerState<DatingIntentionsScreen> {
  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.02),
                  Text(
                    "What's your dating intention?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.065,
                      fontWeight: FontWeight.bold,
                      color: Colors.black,
                    ),
                  ),
                  SizedBox(height: 65),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                physics: const BouncingScrollPhysics(),
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                itemCount: DatingIntention.values.length,
                itemBuilder: (context, index) {
                  return _buildOption(DatingIntention.values[index]);
                },
              ),
            ),
            Align(
              alignment: Alignment.centerRight,
              child: Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                child: GestureDetector(
                  onTap: userState.datingIntention != null
                      ? () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                                builder: (context) => HeightSelectionScreen()),
                          );
                        }
                      : null,
                  child: Container(
                    width: 56,
                    height: 56,
                    decoration: BoxDecoration(
                      color: userState.datingIntention != null
                          ? const Color(0xFF8B5CF6)
                          : Colors.grey.shade300,
                      shape: BoxShape.circle,
                      boxShadow: [
                        if (userState.datingIntention != null)
                          BoxShadow(
                            color: Colors.black.withOpacity(0.2),
                            spreadRadius: 1,
                            blurRadius: 8,
                          ),
                      ],
                    ),
                    child: Icon(
                      Icons.arrow_forward_rounded,
                      size: 28,
                      color: userState.datingIntention != null
                          ? Colors.white
                          : Colors.grey.shade500,
                    ),
                  ),
                ),
              ),
            ),
            SizedBox(height: screenSize.height * 0.04),
          ],
        ),
      ),
    );
  }

  Widget _buildOption(DatingIntention intention) {
    final bool isSelected =
        ref.watch(userProvider).datingIntention == intention;

    return GestureDetector(
      onTap: () {
        ref.read(userProvider.notifier).updateDatingIntention(intention);
      },
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 16),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.transparent,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade300,
            width: 1.5,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Text(
                intention.label,
                style: GoogleFonts.poppins(
                  fontSize: intention.label.length > 20 ? 14 : 16,
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                  color: isSelected ? Colors.white : Colors.black,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            if (isSelected)
              const Icon(
                Icons.check_circle,
                color: Colors.white,
                size: 24,
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dob.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/dating_intentions.dart';
import 'package:dtx/views/location.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class DateOfBirthScreen extends ConsumerStatefulWidget {
  const DateOfBirthScreen({super.key});

  @override
  ConsumerState<DateOfBirthScreen> createState() => _DateOfBirthScreenState();
}

class _DateOfBirthScreenState extends ConsumerState<DateOfBirthScreen> {
  final TextEditingController _dayController = TextEditingController();
  final TextEditingController _monthController = TextEditingController();
  final TextEditingController _yearController = TextEditingController();

  final FocusNode _dayFocusNode = FocusNode();
  final FocusNode _monthFocusNode = FocusNode();
  final FocusNode _yearFocusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    _dayFocusNode.addListener(() {
      if (!_dayFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _monthFocusNode.addListener(() {
      if (!_monthFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _yearFocusNode.addListener(() {
      if (!_yearFocusNode.hasFocus) {
        _validateInputs();
      }
    });
  }

  @override
  void dispose() {
    _dayController.dispose();
    _monthController.dispose();
    _yearController.dispose();
    _dayFocusNode.dispose();
    _monthFocusNode.dispose();
    _yearFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.1),
                Text(
                  "What's your date of birth?",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.08,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    _buildDateInput(
                      "DD",
                      _dayController,
                      _dayFocusNode,
                      2,
                      _monthFocusNode,
                    ),
                    _buildDateInput(
                      "MM",
                      _monthController,
                      _monthFocusNode,
                      2,
                      _yearFocusNode,
                    ),
                    _buildDateInput(
                      "YYYY",
                      _yearController,
                      _yearFocusNode,
                      4,
                      null,
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.03),
                Text(
                  "We use this to calculate the age on your profile.",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.04,
                    color: Colors.white70,
                  ),
                ),
                if (error?.type == ErrorType.validation)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      error!.message,
                      style: GoogleFonts.poppins(
                        color: Colors.redAccent,
                        fontSize: screenSize.width * 0.035,
                      ),
                    ),
                  ),
                const Spacer(),
                _buildNextButton(screenSize),
                SizedBox(height: screenSize.height * 0.05),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDateInput(
    String hint,
    TextEditingController controller,
    FocusNode focusNode,
    int maxLength,
    FocusNode? nextFocusNode,
  ) {
    return Expanded(
      flex: maxLength == 4 ? 2 : 1,
      child: TextField(
        controller: controller,
        focusNode: focusNode,
        keyboardType: TextInputType.number,
        maxLength: maxLength,
        style: GoogleFonts.poppins(
          fontSize: 24,
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
        decoration: InputDecoration(
          hintText: hint,
          hintStyle: GoogleFonts.poppins(
            fontSize: 24,
            fontWeight: FontWeight.w500,
            color: Colors.white70,
          ),
          counterText: "",
          enabledBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white54, width: 2.0),
          ),
          focusedBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white, width: 2.5),
          ),
        ),
        textAlign: TextAlign.center,
        onChanged: (value) {
          if (value.length == maxLength) {
            focusNode.unfocus();
            if (nextFocusNode != null) {
              FocusScope.of(context).requestFocus(nextFocusNode);
            }
          }
          _validateInputs();
        },
      ),
    );
  }

  void _validateInputs() {
    ref.read(errorProvider.notifier).clearError();
    final day = int.tryParse(_dayController.text) ?? 0;
    final month = int.tryParse(_monthController.text) ?? 0;
    final year = int.tryParse(_yearController.text) ?? 0;

    if (_dayController.text.isEmpty ||
        _monthController.text.isEmpty ||
        _yearController.text.isEmpty) return;

    if (day < 1 || day > 31) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid day"),
          );
      return;
    }

    if (month < 1 || month > 12) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid month"),
          );
      return;
    }

    try {
      final date = DateTime(year, month, day);
      ref.read(userProvider.notifier).updateDateOfBirth(date);
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid date combination"),
          );
    }
  }

  Widget _buildNextButton(Size screenSize) {
    final isValid = _dayController.text.length == 2 &&
        _monthController.text.length == 2 &&
        _yearController.text.length == 4 &&
        ref.read(errorProvider) == null;

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: isValid ? _handleNext : null,
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: isValid ? Colors.white : Colors.grey.shade400,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: const EdgeInsets.all(16),
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24,
          color: isValid ? const Color(0xFF8B5CF6) : Colors.white54,
        ),
      ),
    );
  }

  void _handleNext() {
    final date = DateTime(
      int.parse(_yearController.text),
      int.parse(_monthController.text),
      int.parse(_dayController.text),
    );

    ref.read(userProvider.notifier).updateDateOfBirth(date);
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DatingIntentionsScreen()),
    );
  }
}



================================================
File: views/drinking.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/smoking.dart';

class DrinkingScreen extends ConsumerStatefulWidget {
  const DrinkingScreen({super.key});

  @override
  ConsumerState<DrinkingScreen> createState() => _DrinkingScreenState();
}

class _DrinkingScreenState extends ConsumerState<DrinkingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedDrinkingHabit;
  bool _isOptionSelected = false;
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF8F9FA),
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: const Icon(
                      Icons.local_bar_rounded,
                      color: Color(0xFF8B5CF6),
                      size: 48,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.03),
                  Text(
                    "Do you drink?",
                    textAlign: TextAlign.left,
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.08,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF1A1A1A),
                      height: 1.1,
                    ),
                  ),
                  Text(
                    "Select your drinking habits",
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey[600],
                      height: 1.5,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.04),
                  Expanded(
                    child: ListView.separated(
                      itemCount: DrinkingSmokingHabits.values.length,
                      separatorBuilder: (context, index) =>
                          const SizedBox(height: 12),
                      itemBuilder: (context, index) {
                        final habit = DrinkingSmokingHabits.values[index];
                        return _buildDrinkingOptionTile(
                          screenSize: screenSize,
                          title: habit.label,
                          value: habit,
                        );
                      },
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding:
                          EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: AnimatedScale(
                        scale: _isOptionSelected ? 1.0 : 0.95,
                        duration: const Duration(milliseconds: 200),
                        child: GestureDetector(
                          onTap: () {
                            if (_isOptionSelected) {
                              FocusScope.of(context)
                                  .unfocus(); // Close the keyboard
                              ref
                                  .read(userProvider.notifier)
                                  .updateDrinkingHabit(_selectedDrinkingHabit);
                              Navigator.push(
                                  context,
                                  MaterialPageRoute(
                                      builder: (context) =>
                                          const SmokingScreen()));
                            } else {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(
                                    "Please select an option",
                                    style: GoogleFonts.poppins(),
                                  ),
                                  backgroundColor: Colors.red[400],
                                  behavior: SnackBarBehavior.floating,
                                ),
                              );
                            }
                          },
                          child: Container(
                            width: 70,
                            height: 70,
                            decoration: BoxDecoration(
                              color: _isOptionSelected
                                  ? const Color(0xFF8B5CF6)
                                  : Colors.grey.shade300,
                              borderRadius: BorderRadius.circular(35),
                              boxShadow: _isOptionSelected
                                  ? [
                                      BoxShadow(
                                        color: const Color(0xFF8B5CF6)
                                            .withOpacity(0.3),
                                        blurRadius: 8,
                                        offset: const Offset(0, 4),
                                      ),
                                    ]
                                  : null,
                            ),
                            child: Icon(
                              Icons.arrow_forward_rounded,
                              color: _isOptionSelected
                                  ? Colors.white
                                  : Colors.grey.shade600,
                              size: 32,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildDrinkingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedDrinkingHabit == value;

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedDrinkingHabit = value;
            _isOptionSelected = true;
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/gender.dart
================================================
// File: views/gender.dart
import 'package:dtx/models/auth_model.dart'; // Import AuthStatus
import 'package:dtx/providers/auth_provider.dart'; // Import AuthProvider
import 'package:dtx/services/api_service.dart'; // *** ADDED: Import ApiException ***
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:dtx/views/home.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../models/error_model.dart';
import '../providers/user_provider.dart';
import '../providers/error_provider.dart';
import '../providers/service_provider.dart';

class GenderSelectionScreen extends ConsumerStatefulWidget {
  const GenderSelectionScreen({super.key});

  @override
  ConsumerState<GenderSelectionScreen> createState() =>
      _GenderSelectionScreenState();
}

class _GenderSelectionScreenState extends ConsumerState<GenderSelectionScreen> {
  bool _isSubmitting = false;

  Future<void> _submitLocationAndGender() async {
    final userState = ref.read(userProvider);
    // final userNotifier = ref.read(userProvider.notifier); // *** REMOVED: Unused ***
    final errorNotifier = ref.read(errorProvider.notifier);
    final authNotifier = ref.read(authProvider.notifier);

    errorNotifier.clearError();

    if (userState.latitude == null || userState.longitude == null) {
      errorNotifier.setError(
          AppError.validation("Location data is missing. Please go back."));
      return;
    }
    if (userState.gender == null) {
      errorNotifier.setError(AppError.validation("Please select a gender."));
      return;
    }

    setState(() => _isSubmitting = true);

    try {
      final userRepository = ref.read(userRepositoryProvider);
      final success = await userRepository.updateLocationGender(
        userState.latitude!,
        userState.longitude!,
        userState.gender!,
      );

      if (success) {
        print(
            "[GenderSelectionScreen] Location/Gender submitted successfully.");
        final finalStatus =
            await authNotifier.checkAuthStatus(updateState: true);
        print("[GenderSelectionScreen] Auth status updated to: $finalStatus");

        if (mounted) {
          // Expect onboarding2, navigate to HomeScreen with QuickFeed
          Widget nextScreen = (finalStatus == AuthStatus.onboarding2)
              ? const HomeScreen(initialFeedType: FeedType.quick)
              // If status is somehow already home or login, handle appropriately
              : (finalStatus == AuthStatus.home)
                  ? const HomeScreen(initialFeedType: FeedType.home)
                  : const GoogleSignInScreen(); // Fallback

          Navigator.pushAndRemoveUntil(
            context,
            MaterialPageRoute(builder: (context) => nextScreen),
            (Route<dynamic> route) => false,
          );
        }
      } else {
        print(
            "[GenderSelectionScreen] Location/Gender submission failed (API returned false).");
        // Error should be set by repo/api layer if specific message available
        if (ref.read(errorProvider) == null) {
          // Set a generic one if not already set
          errorNotifier
              .setError(AppError.server("Failed to update location/gender."));
        }
      }
      // *** FIX: Catch specific ApiException ***
    } on ApiException catch (e) {
      print(
          "[GenderSelectionScreen] API Exception during submit: ${e.message}");
      errorNotifier.setError(AppError.server(e.message));
    } catch (e) {
      print(
          "[GenderSelectionScreen] Unexpected error during submit: ${e.toString()}");
      // *** FIX: Use correct AppError constructor ***
      errorNotifier.setError(
          AppError.generic("An unexpected error occurred. Please try again."));
      // *** END FIX ***
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // ... (rest of build method is likely okay, ensure GoogleFonts import) ...
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);
    final errorState = ref.watch(errorProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.03),
              Align(
                alignment: Alignment.topLeft,
                child: IconButton(
                  icon: Icon(Icons.arrow_back_ios_new, color: Colors.grey[600]),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              Text(
                "Which gender best\ndescribes you?",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.075,
                  fontWeight: FontWeight.bold,
                  color: Colors.black,
                  height: 1.2,
                ),
              ),
              SizedBox(height: screenSize.height * 0.05),
              Column(
                children: [Gender.man, Gender.woman]
                    .map((gender) => _buildOption(gender))
                    .toList(),
              ),
              const Spacer(),
              if (errorState != null) // Display any error
                Padding(
                  padding: const EdgeInsets.only(bottom: 10.0),
                  child: Text(
                    errorState.message,
                    style: GoogleFonts.poppins(
                        color: Colors.redAccent, fontSize: 14),
                    textAlign: TextAlign.center,
                  ),
                ),
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding: const EdgeInsets.only(bottom: 20.0),
                  child: _isSubmitting
                      ? const CircularProgressIndicator(
                          color: Color(0xFF8B5CF6))
                      : FloatingActionButton(
                          heroTag: 'gender_next_fab',
                          onPressed: userState.gender != null
                              ? _submitLocationAndGender
                              : null,
                          backgroundColor: userState.gender != null
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey.shade300,
                          foregroundColor: Colors.white,
                          child: const Icon(Icons.arrow_forward_rounded),
                        ),
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOption(Gender gender) {
    // ... (buildOption implementation likely okay) ...
    final bool isSelected = ref.watch(userProvider).gender == gender;
    final errorNotifier = ref.read(errorProvider.notifier);

    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: Material(
        borderRadius: BorderRadius.circular(12),
        color: isSelected ? const Color(0xFFEDE9FE) : Colors.grey.shade50,
        elevation: isSelected ? 1 : 0,
        shadowColor: const Color(0xFF8B5CF6).withOpacity(0.3),
        child: InkWell(
          onTap: () {
            errorNotifier.clearError();
            ref.read(userProvider.notifier).updateGender(gender);
          },
          borderRadius: BorderRadius.circular(12),
          child: Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color:
                    isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade300,
                width: isSelected ? 1.5 : 1,
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  gender.label,
                  style: GoogleFonts.poppins(
                    fontSize: 18,
                    fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
                    color: isSelected
                        ? const Color(0xFF8B5CF6)
                        : Colors.grey.shade800,
                  ),
                ),
                if (isSelected)
                  const Icon(
                    Icons.check_circle_outline_rounded,
                    color: Color(0xFF8B5CF6),
                    size: 24,
                  )
                else
                  Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      border:
                          Border.all(color: Colors.grey.shade400, width: 1.5),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/google_sign_in_screen.dart
================================================
// File: views/google_sign_in_screen.dart
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/utils/app_enums.dart'; // *** ADDED: Import FeedType ***
import 'package:dtx/views/home.dart';
import 'package:dtx/views/location.dart';
import 'package:dtx/views/name.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/models/auth_model.dart';

class GoogleSignInScreen extends ConsumerWidget {
  const GoogleSignInScreen({super.key});

  Future<void> _handleSignIn(BuildContext context, WidgetRef ref) async {
    final status = await ref.read(authProvider.notifier).signInWithGoogle();
    if (!context.mounted) return;

    // --- FIX: Pass initialFeedType to HomeScreen ---
    Widget destination;
    switch (status) {
      case AuthStatus.home:
        destination =
            const HomeScreen(initialFeedType: FeedType.home); // Pass home
        break;
      case AuthStatus.onboarding1:
        destination = const LocationInputScreen();
        break;
      case AuthStatus.onboarding2:
        // If logic dictates going straight to quick feed after step 1:
        destination =
            const HomeScreen(initialFeedType: FeedType.quick); // Pass quick
        // If logic dictates going to step 2 screens first:
        // destination = const NameInputScreen();
        break;
      case AuthStatus.login:
      case AuthStatus.unknown:
        // Default case removed as it's unreachable if all AuthStatus values are handled
        // default:
        // Stay on this screen, error provider handles message
        return; // Don't navigate if sign-in failed or status is unexpected login/unknown
    }
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(builder: (context) => destination),
    );
    // --- END FIX ---
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ... (rest of build method likely okay, ensure GoogleFonts import) ...
    final authState = ref.watch(authProvider);
    final errorState = ref.watch(errorProvider);
    final screenSize = MediaQuery.of(context).size;

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  const Spacer(flex: 2),
                  Text(
                    'Peeple',
                    style: GoogleFonts.pacifico(
                      fontSize: screenSize.width * 0.15,
                      color: Colors.white,
                      shadows: [
                        Shadow(
                          color: Colors.black.withOpacity(0.5),
                          blurRadius: 10,
                          offset: const Offset(2, 2),
                        ),
                      ],
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.03),
                  Text(
                    'Connect Authentically',
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.045,
                      color: Colors.white.withOpacity(0.8),
                      fontWeight: FontWeight.w300,
                    ),
                  ),
                  const Spacer(flex: 3),
                  if (authState.isLoading)
                    const CircularProgressIndicator(color: Colors.white)
                  else
                    ElevatedButton.icon(
                      // Ensure you have 'assets/google_logo.png' or handle missing asset
                      icon: Image.asset('assets/google_logo.png',
                          height: 24.0,
                          errorBuilder: (context, error, stackTrace) =>
                              const Icon(Icons.login, size: 24)),
                      label: Text(
                        'Sign In with Google',
                        style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                            color: Colors.black87),
                      ),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.white,
                        foregroundColor: Colors.black87,
                        minimumSize: const Size(double.infinity, 50),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                      onPressed: () => _handleSignIn(context, ref),
                    ),
                  SizedBox(height: screenSize.height * 0.02),
                  if (errorState != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 15.0),
                      child: Text(
                        errorState.message,
                        textAlign: TextAlign.center,
                        style: GoogleFonts.poppins(
                          color: Colors.redAccent[100],
                          fontSize: 14,
                        ),
                      ),
                    ),
                  const Spacer(flex: 1),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 20.0),
                    child: Text(
                      'By signing in, you agree to our Terms of Service and Privacy Policy.',
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                        fontSize: 12,
                        color: Colors.white.withOpacity(0.6),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/height.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';
import '../providers/user_provider.dart';
import 'hometown.dart';

class HeightSelectionScreen extends ConsumerStatefulWidget {
  const HeightSelectionScreen({super.key});

  @override
  ConsumerState<HeightSelectionScreen> createState() =>
      _HeightSelectionScreenState();
}

class _HeightSelectionScreenState extends ConsumerState<HeightSelectionScreen> {
  String _unit = "FT"; // Default unit is Feet
  int _selectedFeetIndex = 0; // Start at the first index
  int _selectedCmIndex = 30; // Start at 150 cm (index 30)

  // Define the starting and ending points explicitly
  int _startFeet = 4;
  int _startInches = 0;
  int _endFeet = 6;
  int _endInches = 5;

  List<String>? _feetValues; // Declare as nullable
  List<String> _cmValues = List.generate(81, (index) => "${120 + index} cm");

  // Function to convert CM to Feet and Inches string
  String _cmToFeet(int cm) {
    double totalInches = cm * 0.393701;
    int feet = (totalInches / 12).floor();
    int inches =
        (totalInches % 12).round(); // Round inches to nearest whole number
    if (inches == 12) {
      // Handle cases where inches round up to 12
      feet++;
      inches = 0;
    }
    return "$feet' $inches\"";
  }

  @override
  void initState() {
    super.initState();
    _feetValues = List.generate(
      ((_endFeet * 12) + _endInches) - ((_startFeet * 12) + _startInches) + 1,
      (index) {
        int totalInches = ((_startFeet * 12) + _startInches) + index;
        int feet = totalInches ~/ 12;
        int inches = totalInches % 12;
        return "$feet' $inches\"";
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        // Use appropriate values for the current unit
        final List<String> currentValues =
            _unit == "FT" ? _feetValues! : _cmValues;
        int currentIndex =
            _unit == "FT" ? _selectedFeetIndex : _selectedCmIndex;

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4), // Light background
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(
                      height: screenSize.height * 0.06), // Increased spacing

                  // Title
                  Center(
                    child: Text(
                      "How tall are you?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width *
                            0.1, // Increased font size for title
                        fontWeight: FontWeight.w700, // More bold title
                        color: const Color(0xFF333333), // Darker title color
                      ),
                    ),
                  ),

                  SizedBox(
                      height: screenSize.height *
                          0.05), // Increased spacing below title

                  // Height Selector
                  Expanded(
                    child: ListWheelScrollView.useDelegate(
                      itemExtent:
                          70, // Increased item extent for better spacing
                      diameterRatio: 1.3, // Adjusted for better visual
                      physics: const FixedExtentScrollPhysics(),
                      onSelectedItemChanged: (index) {
                        setState(() {
                          if (_unit == "FT") {
                            _selectedFeetIndex = index;
                          } else {
                            _selectedCmIndex = index;
                          }
                          _updateHeight(ref);
                        });
                      },
                      childDelegate: ListWheelChildBuilderDelegate(
                        childCount: currentValues.length,
                        builder: (context, index) {
                          final isSelected = index == currentIndex;
                          return Center(
                            child: Text(
                              currentValues[index],
                              style: GoogleFonts.poppins(
                                fontSize: isSelected
                                    ? 30
                                    : 22, // Larger font sizes for list items
                                fontWeight: isSelected
                                    ? FontWeight.w600
                                    : FontWeight.w400, // Adjusted weight
                                color: isSelected
                                    ? const Color(0xFF8B5CF6)
                                    : Colors.grey
                                        .shade700, // Highlighted selected color, darker unselected
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                  ),

                  SizedBox(
                      height: screenSize.height *
                          0.03), // Reduced spacing above buttons

                  // Unit Toggle Buttons - Improved UI
                  Padding(
                    padding: EdgeInsets.symmetric(
                        horizontal: screenSize.width *
                            0.1), // Add horizontal padding for buttons
                    child: Row(
                      mainAxisAlignment:
                          MainAxisAlignment.spaceAround, // Space buttons evenly
                      children: [
                        _buildUnitButton("FT", screenSize),
                        _buildUnitButton("CM", screenSize),
                      ],
                    ),
                  ),

                  SizedBox(
                      height: screenSize.height *
                          0.04), // Spacing before forward button

                  // Forward Button - More prominent and centered
                  Center(
                    child: GestureDetector(
                      onTap: userState.height != null
                          ? () {
                              Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) => HometownScreen()),
                              );
                            }
                          : null,
                      child: Container(
                        width: 70, // Even larger button
                        height: 70,
                        decoration: BoxDecoration(
                          color: userState.height != null
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey.shade400,
                          borderRadius:
                              BorderRadius.circular(35), // More rounded
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32, // Larger icon
                        ),
                      ),
                    ),
                  ),
                  SizedBox(
                      height:
                          screenSize.height * 0.06), // Increased bottom spacing
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildUnitButton(String unit, Size screenSize) {
    final isSelected = _unit == unit;
    return GestureDetector(
      onTap: () {
        setState(() {
          _unit = unit;
        });
      },
      child: Container(
        padding: EdgeInsets.symmetric(
            vertical: 12,
            horizontal: screenSize.width * 0.08), // Dynamic horizontal padding
        decoration: BoxDecoration(
          color: isSelected
              ? const Color(0xFF8B5CF6)
              : Colors.white, // White background for unselected
          border: Border.all(color: Colors.grey.shade300), // Subtle border
          borderRadius: BorderRadius.circular(30), // Even more rounded corners
          boxShadow: [
            // Subtle shadow for depth
            BoxShadow(
              color: Colors.grey.withOpacity(0.15),
              spreadRadius: 0,
              blurRadius: 3,
              offset: const Offset(0, 2), // changes position of shadow
            ),
          ],
        ),
        child: Text(
          unit,
          style: GoogleFonts.poppins(
            fontSize: 18, // Larger font size for buttons
            fontWeight: isSelected
                ? FontWeight.w600
                : FontWeight.w500, // Slightly bolder for selected
            color: isSelected
                ? Colors.white
                : const Color(0xFF555555), // Darker text for unselected
          ),
        ),
      ),
    );
  }

  void _updateHeight(WidgetRef ref) {
    String savedHeightFeet;
    String selectedValue = _unit == "FT"
        ? _feetValues![_selectedFeetIndex]
        : _cmValues[_selectedCmIndex];

    if (_unit == "CM") {
      savedHeightFeet =
          _cmToFeet(int.parse(selectedValue.replaceAll(" cm", "")));
    } else {
      savedHeightFeet = selectedValue;
    }

    ref.read(userProvider.notifier).updateHeight(savedHeightFeet);
  }
}



================================================
File: views/home.dart
================================================
// File: views/home.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/providers/user_provider.dart'; // Import UserProvider
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/who_liked_you_screen.dart'; // Import WhoLikedYouScreen
import 'package:dtx/models/feed_models.dart';
import 'package:dtx/widgets/quick_profile_card.dart';
import 'package:dtx/widgets/home_profile_card.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class HomeScreen extends ConsumerStatefulWidget {
  final FeedType initialFeedType;
  const HomeScreen({super.key, required this.initialFeedType});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen>
    with SingleTickerProviderStateMixin {
  // State Variables
  late FeedType _currentFeedType;
  bool _isLoadingFeed = true;
  List<QuickFeedProfile> _quickFeedProfiles = [];
  List<HomeFeedProfile> _homeFeedProfiles = [];
  bool _isInteracting =
      false; // Tracks if a like/dislike API call is in progress

  // Animation Variables
  Offset _dragOffset = Offset.zero;
  double _angle = 0;
  late AnimationController _animationController;
  late Animation<Offset> _slideAnimation;

  @override
  void initState() {
    super.initState();
    _currentFeedType = widget.initialFeedType;
    print("[HomeScreen initState] Initial Feed Type: $_currentFeedType");
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _slideAnimation = Tween<Offset>(begin: Offset.zero, end: Offset.zero)
        .animate(CurvedAnimation(
            parent: _animationController, curve: Curves.easeOut));
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _fetchFeed();
    });
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  // --- Network & State Logic ---

  Future<void> _fetchFeed() async {
    print("[HomeScreen _fetchFeed] Fetching feed for type: $_currentFeedType");
    if (!mounted) return;
    setState(() {
      _isLoadingFeed = true;
      _dragOffset = Offset.zero;
      _angle = 0;
      _animationController.reset();
      _quickFeedProfiles = [];
      _homeFeedProfiles = [];
      _isInteracting = false; /* Reset interaction lock */
    });
    ref.read(errorProvider.notifier).clearError();
    try {
      final repo = ref.read(userRepositoryProvider);
      if (_currentFeedType == FeedType.quick) {
        final profiles = await repo.fetchQuickFeed();
        if (!mounted) return;
        setState(() {
          _quickFeedProfiles = profiles;
          _isLoadingFeed = false;
        });
        print(
            "[HomeScreen _fetchFeed] Quick Feed loaded: ${profiles.length} profiles.");
      } else {
        final profiles = await repo.fetchHomeFeed();
        if (!mounted) return;
        setState(() {
          _homeFeedProfiles = profiles;
          _isLoadingFeed = false;
        });
        print(
            "[HomeScreen _fetchFeed] Home Feed loaded: ${profiles.length} profiles.");
      }
    } on ApiException catch (e) {
      print("[HomeScreen _fetchFeed] API Exception: ${e.message}");
      if (!mounted) return;
      setState(() => _isLoadingFeed = false);
      ref.read(errorProvider.notifier).setError(AppError.server(e.message));
    } catch (e) {
      print("[HomeScreen _fetchFeed] Unexpected Error: ${e.toString()}");
      if (!mounted) return;
      setState(() => _isLoadingFeed = false);
      ref
          .read(errorProvider.notifier)
          .setError(AppError.generic("Failed to load feed. Please try again."));
    }
  }

  void _animateCardOut(double endX) {
    print("[HomeScreen _animateCardOut] Animating card out to X: $endX");
    _slideAnimation = Tween<Offset>(begin: Offset.zero, end: Offset(endX, 0.0))
        .animate(CurvedAnimation(
            parent: _animationController, curve: Curves.easeOut));
    _animationController.forward().then((_) {
      if (mounted) {
        print(
            "[HomeScreen _animateCardOut] Animation complete. Removing card.");
        // IMPORTANT: Set state *once* after animation
        setState(() {
          if (_currentFeedType == FeedType.home &&
              _homeFeedProfiles.isNotEmpty) {
            _homeFeedProfiles.removeAt(0);
          } else if (_currentFeedType == FeedType.quick &&
              _quickFeedProfiles.isNotEmpty) {
            _quickFeedProfiles.removeAt(0);
          }
          // Reset visual state for the next card
          _dragOffset = Offset.zero;
          _angle = 0;
          _animationController.reset();
          // Interaction lock (_isInteracting) is reset in the finally block of the interaction handlers

          // Check if more profiles need fetching
          _checkAndFetchMoreProfilesIfNeeded();
        });
      }
    });
  }

  void _checkAndFetchMoreProfilesIfNeeded() {
    if (_currentFeedType == FeedType.home &&
        !_isLoadingFeed &&
        _homeFeedProfiles.length < 3) {
      print(
          "[HomeScreen] Low on home profiles (${_homeFeedProfiles.length}), fetching more...");
      _fetchFeed();
    }
  }

  // --- Interaction Handlers ---

  // Main handler for swipe gestures or main Like/Dislike buttons
  Future<void> _handleSwipeOrButton(bool liked) async {
    print(
        "[HomeScreen _handleSwipeOrButton] Action: Liked=$liked, FeedType=$_currentFeedType");
    if (_currentFeedType == FeedType.quick) {
      _showCompleteProfileDialog();
      return;
    }

    if (_homeFeedProfiles.isEmpty || _isInteracting) return;

    final targetProfile = _homeFeedProfiles[0];

    if (liked) {
      // Default like action (e.g., like first media) - Comment dialog handled in card/specific like handler
      await _performLike(targetProfile.id, ContentLikeType.media, "0", null,
          LikeInteractionType.standard);
    } else {
      await _performDislike(targetProfile.id);
    }
  }

  // Handles the API call for liking content (standard or rose)
  Future<void> _performLike(
    int targetUserId,
    ContentLikeType contentType,
    String contentIdentifier,
    String? comment, // Comment is passed from HomeProfileCard's logic
    LikeInteractionType interactionType,
  ) async {
    if (_isInteracting) return;
    print(
        "[HomeScreen _performLike] User: $targetUserId, Type: $contentType, ID: $contentIdentifier, Interaction: $interactionType, Comment: ${comment ?? 'N/A'}");
    setState(() => _isInteracting = true);
    final errorNotifier = ref.read(errorProvider.notifier);
    errorNotifier.clearError();
    bool success = false;

    try {
      final likeRepo = ref.read(likeRepositoryProvider);
      // Comment requirement logic is now handled within HomeProfileCard's trigger methods
      success = await likeRepo.likeContent(
        likedUserId: targetUserId,
        contentType: contentType,
        contentIdentifier: contentIdentifier,
        interactionType: interactionType,
        comment: comment, // Pass the comment directly
      );
      print("[HomeScreen _performLike] API Success: $success");

      if (success) {
        _animateCardOut(1.5); // Animate right on like/rose
      } else {
        if (ref.read(errorProvider) == null) {
          errorNotifier.setError(
              AppError.server("Could not send ${interactionType.value}."));
        }
      }
    } on LikeLimitExceededException catch (e) {
      errorNotifier.setError(AppError.validation(e.message));
      _showErrorSnackbar(e.message);
    } on InsufficientRosesException catch (e) {
      errorNotifier.setError(AppError.validation(e.message));
      _showErrorSnackbar(e.message);
    } on ApiException catch (e) {
      errorNotifier.setError(AppError.server(e.message));
    } catch (e) {
      errorNotifier.setError(AppError.generic("An unexpected error occurred."));
    } finally {
      // Reset interaction lock ONLY IF animation hasn't started OR if no success
      // Animation completion handles removal and state reset otherwise
      if (mounted && !success) {
        setState(() => _isInteracting = false);
      } else if (mounted &&
          _animationController.isAnimating == false &&
          success) {
        // Fallback if animation didn't start for some reason but call was successful
        // This path should ideally not be hit if _animateCardOut is called on success
        print(
            "[HomeScreen _performLike] Warning: Like successful but animation didn't trigger state reset.");
        setState(() => _isInteracting = false);
      }
      // Note: _isInteracting will naturally be false after the animation finishes and setState runs in _animateCardOut's .then() block
    }
  }

  // Handles the API call for sending a rose
  Future<void> _performSendRose(int targetUserId, String? comment) async {
    // Simply calls _performLike with the correct interaction type
    await _performLike(
        targetUserId,
        ContentLikeType
            .media, // Default target for a rose (can be changed in card if needed)
        "0", // Default target identifier
        comment, // Pass comment from card's dialog
        LikeInteractionType.rose);
  }

  // Handles the API call for disliking
  Future<void> _performDislike(int targetUserId) async {
    if (_isInteracting) return;
    print("[HomeScreen _performDislike] User: $targetUserId");
    setState(() => _isInteracting = true);
    final errorNotifier = ref.read(errorProvider.notifier);
    errorNotifier.clearError();
    bool success = false;

    try {
      final likeRepo = ref.read(likeRepositoryProvider);
      success = await likeRepo.dislikeUser(dislikedUserId: targetUserId);
      print("[HomeScreen _performDislike] API Success: $success");

      if (success) {
        _animateCardOut(-1.5); // Animate left on dislike
      } else {
        if (ref.read(errorProvider) == null) {
          errorNotifier.setError(AppError.server("Could not dislike profile."));
        }
      }
    } on ApiException catch (e) {
      errorNotifier.setError(AppError.server(e.message));
    } catch (e) {
      errorNotifier.setError(AppError.generic("An unexpected error occurred."));
    } finally {
      if (mounted && !success) {
        setState(() => _isInteracting = false);
      }
      // Reset logic handled by _animateCardOut on success
    }
  }

  // --- UI Helper Methods ---

  void _showCompleteProfileDialog() {
    print("[HomeScreen _showCompleteProfileDialog] Showing dialog.");
    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
          title: Text(
            "Complete Your Profile",
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
          ),
          content: Text(
            "Finish setting up your profile to start liking and matching!",
            style: GoogleFonts.poppins(),
          ),
          actions: <Widget>[
            TextButton(
              child:
                  Text("Later", style: GoogleFonts.poppins(color: Colors.grey)),
              onPressed: () => Navigator.of(dialogContext).pop(),
            ),
            TextButton(
              child: Text(
                "Complete Profile",
                style: GoogleFonts.poppins(
                    color: const Color(0xFF8B5CF6),
                    fontWeight: FontWeight.w600),
              ),
              onPressed: () {
                Navigator.of(dialogContext).pop();
                print(
                    "[HomeScreen _showCompleteProfileDialog] Navigating to NameInputScreen.");
                Navigator.push(
                  context,
                  MaterialPageRoute(
                      builder: (context) => const NameInputScreen()),
                );
              },
            ),
          ],
        );
      },
    );
  }

  void _showErrorSnackbar(String message) {
    ScaffoldMessenger.of(context)
        .removeCurrentSnackBar(); // Remove previous snackbar first
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message, style: GoogleFonts.poppins()),
        backgroundColor: Colors.redAccent,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  void _onPanUpdate(DragUpdateDetails details) {
    if (_animationController.isAnimating || _isInteracting) return;
    setState(() {
      _dragOffset += details.delta;
      _angle = (_dragOffset.dx / (MediaQuery.of(context).size.width * 0.5))
          .clamp(-0.4, 0.4);
    });
  }

  void _onPanEnd(DragEndDetails details) {
    if (_animationController.isAnimating || _isInteracting) return;
    final screenSize = MediaQuery.of(context).size;
    final requiredDragDistance = screenSize.width * 0.35;
    if (_dragOffset.dx.abs() < requiredDragDistance) {
      setState(() {
        _dragOffset = Offset.zero;
        _angle = 0;
      });
      return;
    }
    final bool liked = _dragOffset.dx > 0;
    _handleSwipeOrButton(liked);
  }

  void _navigateToProfile() {
    print("[HomeScreen _navigateToProfile] Navigating to ProfileScreen.");
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const ProfileScreen()),
    );
  }

  void _navigateToLikes() {
    print("[HomeScreen _navigateToLikes] Navigating to WhoLikedYouScreen.");
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const WhoLikedYouScreen()),
    );
  }

  // --- Build Method ---
  @override
  Widget build(BuildContext context) {
    final error = ref.watch(errorProvider);
    // Determine available profiles based on current feed type
    final profilesAvailable = _currentFeedType == FeedType.quick
        ? _quickFeedProfiles
        : _homeFeedProfiles;
    final bool hasProfilesToShow = profilesAvailable.isNotEmpty;

    print(
        "[HomeScreen build] FeedType: $_currentFeedType, Loading: $_isLoadingFeed, HasProfiles: $hasProfilesToShow, Interacting: $_isInteracting, Error: ${error?.message}");

    return Scaffold(
      backgroundColor: Colors.grey[100],
      body: SafeArea(
        child: Column(
          children: [
            // Top Bar
            Container(
              padding:
                  const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
              decoration: BoxDecoration(
                color: Colors.white,
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.05),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text("Peeple",
                      style: GoogleFonts.pacifico(
                        fontSize: 24,
                        color: const Color(0xFF8B5CF6),
                        fontWeight: FontWeight.w500,
                      )),
                  Row(
                    children: [
                      _buildTopBarIcon(Icons.person_outline_rounded, "Profile",
                          _navigateToProfile),
                      const SizedBox(width: 16),
                      _buildTopBarIcon(Icons.favorite_border_rounded, "Likes",
                          _navigateToLikes), // Updated Likes Icon & Nav
                      // Consider adding chat icon here too if needed
                      // const SizedBox(width: 16),
                      // _buildTopBarIcon(Icons.chat_bubble_outline_rounded, "Messages", () { /* TODO */ }),
                    ],
                  ),
                ],
              ),
            ),

            // Feed Area
            Expanded(
              child: _isLoadingFeed
                  ? const Center(
                      child:
                          CircularProgressIndicator(color: Color(0xFF8B5CF6)))
                  : error != null
                      ? _buildErrorState(error) // Handles API/Generic errors
                      : !hasProfilesToShow
                          ? _buildEmptyState() // Handles empty feed
                          : Stack(
                              alignment: Alignment.center,
                              children: [
                                // Next Card (Underneath)
                                if (profilesAvailable.length > 1 &&
                                    !_isInteracting)
                                  Positioned(
                                    top: 10,
                                    child: Transform.scale(
                                      scale: 0.95,
                                      child: Opacity(
                                        opacity: 0.7,
                                        child: _buildProfileCardAtIndex(1),
                                      ),
                                    ),
                                  ), // Build card at index 1
                                // Top Card Stack (Card + Interaction Loader)
                                Stack(
                                  children: [
                                    AnimatedBuilder(
                                      animation: _animationController,
                                      builder: (context, child) {
                                        final combinedOffset = _dragOffset +
                                            _slideAnimation.value *
                                                MediaQuery.of(context)
                                                    .size
                                                    .width;
                                        return Transform.translate(
                                          offset: combinedOffset,
                                          child: Transform.rotate(
                                            angle: _angle,
                                            child: child,
                                          ),
                                        );
                                      },
                                      // Build card at index 0
                                      child: GestureDetector(
                                        onPanUpdate: _onPanUpdate,
                                        onPanEnd: _onPanEnd,
                                        child: Padding(
                                          padding: const EdgeInsets.fromLTRB(
                                              16, 16, 16, 32),
                                          child: _buildProfileCardAtIndex(0),
                                        ),
                                      ),
                                    ),
                                    // Interaction Loader
                                    if (_isInteracting &&
                                        !_animationController.isAnimating)
                                      Positioned.fill(
                                          child: Container(
                                        decoration: BoxDecoration(
                                            color:
                                                Colors.black.withOpacity(0.1),
                                            borderRadius: BorderRadius.circular(
                                                20) /* Match card radius */),
                                        child: const Center(
                                            child: CircularProgressIndicator(
                                                color: Color(0xFF8B5CF6))),
                                      )),
                                  ],
                                ),
                              ],
                            ),
            ),

            // Action Buttons
            if (hasProfilesToShow && !_isLoadingFeed)
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 20),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    _buildActionButton(
                        Icons.close,
                        Colors.red.shade400,
                        _isInteracting
                            ? null
                            : () => _handleSwipeOrButton(false)), // Dislike
                    // _buildActionButton(Icons.star_border_rounded, Colors.blue.shade400, _isInteracting ? null : () {}), // Super Like (optional)
                    _buildActionButton(
                        Icons.favorite_border_rounded,
                        Colors.green.shade400,
                        _isInteracting
                            ? null
                            : () => _handleSwipeOrButton(true)), // Like
                  ],
                ),
              )
            else
              const SizedBox(height: 90), // Reserve space
          ],
        ),
      ),
    );
  }

  // Helper to build the correct profile card based on index and feed type
  Widget _buildProfileCardAtIndex(int indexInList) {
    if (_currentFeedType == FeedType.quick) {
      // Ensure index is valid for quick feed
      if (indexInList >= 0 && indexInList < _quickFeedProfiles.length) {
        print(
            "[HomeScreen _buildProfileCardAtIndex] Building QuickProfileCard for index $indexInList");
        return QuickProfileCard(profile: _quickFeedProfiles[indexInList]);
      }
    } else {
      // FeedType.home
      // Ensure index is valid for home feed
      if (indexInList >= 0 && indexInList < _homeFeedProfiles.length) {
        print(
            "[HomeScreen _buildProfileCardAtIndex] Building HomeProfileCard for index $indexInList");
        final currentProfile = _homeFeedProfiles[indexInList];
        return HomeProfileCard(
          profile: currentProfile,
          // Pass the specific like/rose handlers
          onLikeContent: (type, identifier, comment) {
            _performLike(currentProfile.id, type, identifier, comment,
                LikeInteractionType.standard);
          },
          onSendRose: (comment) {
            _performSendRose(currentProfile.id, comment);
          },
        );
      }
    }
    // Fallback if index is out of bounds
    print(
        "[HomeScreen _buildProfileCardAtIndex] Error: Index $indexInList out of bounds for feed type $_currentFeedType.");
    return Container(
        margin: const EdgeInsets.fromLTRB(16, 16, 16, 32), // Match padding
        decoration: BoxDecoration(
            color: Colors.grey[200], borderRadius: BorderRadius.circular(20)),
        child: const Center(child: Text("Error loading profile")));
  }

  // --- Other Helper Widgets ---
  Widget _buildTopBarIcon(
      IconData icon, String tooltip, VoidCallback onPressed) {
    /* ... */ return Container(
      margin: const EdgeInsets.all(4),
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 5,
            offset: const Offset(0, 1),
          ),
        ],
      ),
      child: IconButton(
        icon: Icon(icon, color: const Color(0xFF8B5CF6), size: 22),
        tooltip: tooltip,
        onPressed: onPressed,
        splashRadius: 20,
        padding: EdgeInsets.zero,
        constraints: const BoxConstraints(),
      ),
    );
  }

  Widget _buildActionButton(
      IconData icon, Color color, VoidCallback? onPressed) {
    /* ... */ return InkWell(
      onTap: onPressed,
      borderRadius: BorderRadius.circular(35),
      child: Container(
        width: 70,
        height: 70,
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: Colors.white,
          border: onPressed == null
              ? Border.all(color: Colors.grey.shade300, width: 1.5)
              : null,
          boxShadow: onPressed == null
              ? []
              : [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 10,
                    spreadRadius: 1,
                    offset: const Offset(0, 2),
                  ),
                ],
        ),
        child: Icon(icon,
            color: onPressed == null ? Colors.grey.shade400 : color, size: 35),
      ),
    );
  }

  Widget _buildEmptyState() {
    /* ... */ return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.people_outline_rounded, size: 80, color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "That's everyone for now!",
            style: GoogleFonts.poppins(fontSize: 18, color: Colors.grey[600]),
          ),
          const SizedBox(height: 10),
          Text(
            _currentFeedType == FeedType.quick
                ? "Complete your profile to see more!"
                : "Check back later for new profiles.",
            textAlign: TextAlign.center,
            style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[500]),
          ),
          const SizedBox(height: 20),
          ElevatedButton.icon(
            icon: const Icon(Icons.refresh_rounded, size: 18),
            label: const Text("Refresh Feed"),
            style: ElevatedButton.styleFrom(
              foregroundColor: Colors.white,
              backgroundColor: const Color(0xFF8B5CF6),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20)),
              padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
            ),
            onPressed: _fetchFeed,
          ),
          if (_currentFeedType == FeedType.quick) ...[
            const SizedBox(height: 15),
            OutlinedButton(
              child: const Text("Complete Profile"),
              style: OutlinedButton.styleFrom(
                foregroundColor: const Color(0xFF8B5CF6),
                side: const BorderSide(color: Color(0xFF8B5CF6)),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20)),
                padding:
                    const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
              ),
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                      builder: (context) => const NameInputScreen()),
                );
              },
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildErrorState(AppError error) {
    /* ... */ return Center(
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                size: 60, color: Colors.redAccent[100]),
            const SizedBox(height: 20),
            Text(
              "Oops! Something went wrong",
              style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[700]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 10),
            Text(
              error.message,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded, size: 18),
              label: const Text("Retry"),
              style: ElevatedButton.styleFrom(
                foregroundColor: Colors.white,
                backgroundColor: const Color(0xFF8B5CF6),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20)),
                padding:
                    const EdgeInsets.symmetric(horizontal: 30, vertical: 12),
              ),
              onPressed: _fetchFeed,
            ),
          ],
        ),
      ),
    );
  }
} // End _HomeScreenState



================================================
File: views/hometown.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/job.dart';

class HometownScreen extends ConsumerStatefulWidget {
  const HometownScreen({super.key});

  @override
  ConsumerState<HometownScreen> createState() => _HometownScreenState();
}

class _HometownScreenState extends ConsumerState<HometownScreen> {
  final TextEditingController _hometownController = TextEditingController();

  @override
  void dispose() {
    _hometownController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4),
          body: SafeArea(
            child: Padding(
              padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),

                  // Top Navigation Bar with Skip Button
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      IconButton(
                        icon: Icon(
                          Icons.home_rounded,
                          color: const Color(0xFF8B5CF6),
                          size: 32,
                        ),
                        onPressed: () {
                          // Handle home button action
                        },
                      ),
                      // Skip Button - Top Right
                      TextButton(
                        onPressed: () {
                          ref.read(userProvider.notifier).updateHometown(null);
                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const JobTitleScreen())
                          );
                        },
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600, // Subdued color
                          padding: EdgeInsets.zero, // Remove default padding
                          minimumSize: Size.zero, // Make button size adjust to text
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap, // Reduce tap target size
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                            fontSize: 16, // Smaller font size than title
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),

                  SizedBox(height: screenSize.height * 0.07),

                  // Question Text
                  Text(
                    "Where's your home\ntown?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.1,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF333333),
                      height: 1.1,
                    ),
                  ),

                  SizedBox(height: screenSize.height * 0.05),

                  // Text Field
                  Padding(
                    padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                    child: TextField(
                      controller: _hometownController,
                      style: GoogleFonts.poppins(
                        fontSize: 22,
                        color: Colors.black87,
                      ),
                      decoration: InputDecoration(
                        hintText: "Udaipur",
                        hintStyle: GoogleFonts.poppins(
                          fontSize: 22,
                          color: Colors.grey.shade500,
                        ),
                        border: const UnderlineInputBorder(
                          borderSide: BorderSide(color: Colors.grey, width: 1.0),
                        ),
                        focusedBorder: const UnderlineInputBorder(
                          borderSide: BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                        ),
                      ),
                    ),
                  ),

                  const Spacer(),

                  // Forward Button
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: GestureDetector(
                        onTap: () {
                          String? hometown; // Changed to String? to allow null
                          if (_hometownController.text.isNotEmpty) {
                            hometown = _hometownController.text;
                            ref.read(userProvider.notifier).updateHometown(hometown);
                          } else {
                            hometown = null; // Set to null if text field is empty
                          }

                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const JobTitleScreen())
                          );
                        },
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: const Color(0xFF8B5CF6),
                            borderRadius: BorderRadius.circular(35),
                          ),
                          child: const Icon(
                            Icons.arrow_forward_rounded,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}



================================================
File: views/job.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/study.dart';

class JobTitleScreen extends ConsumerStatefulWidget {
  const JobTitleScreen({super.key});

  @override
  ConsumerState<JobTitleScreen> createState() => _JobTitleScreenState();
}

class _JobTitleScreenState extends ConsumerState<JobTitleScreen> {
  final TextEditingController _jobTitleController = TextEditingController();

  @override
  void dispose() {
    _jobTitleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4),
          body: SafeArea(
            child: Padding(
              padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),

                  // Top Navigation Bar with Skip Button
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.person_rounded, color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {
                          // Handle home button action
                        },
                      ),
                      // Skip Button - Top Right
                      TextButton(
                        onPressed: () {
                          ref.read(userProvider.notifier).updateJobTitle(null);
                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const StudyLocationScreen())
                          );
                        },
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),

                  SizedBox(height: screenSize.height * 0.07),

                  // Question Text
                  Text(
                    "What's your job title?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.1,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF333333),
                      height: 1.1,
                    ),
                  ),

                  SizedBox(height: screenSize.height * 0.05),

                  // Text Field
                  Padding(
                    padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                    child: TextField(
                      controller: _jobTitleController,
                      style: GoogleFonts.poppins(
                        fontSize: 22,
                        color: Colors.black87,
                      ),
                      decoration: InputDecoration(
                        hintText: "SDE",
                        hintStyle: GoogleFonts.poppins(
                          fontSize: 22,
                          color: Colors.grey.shade500,
                        ),
                        border: const UnderlineInputBorder(
                          borderSide: BorderSide(color: Colors.grey, width: 1.0),
                        ),
                        focusedBorder: const UnderlineInputBorder(
                          borderSide: BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                        ),
                      ),
                    ),
                  ),

                  const Spacer(),

                  // Forward Button
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: GestureDetector(
                        onTap: () {
                          String? jobTitle;
                          if (_jobTitleController.text.isNotEmpty) {
                            jobTitle = _jobTitleController.text;
                            ref.read(userProvider.notifier).updateJobTitle(jobTitle);
                          } else {
                            jobTitle = null;
                          }

                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const StudyLocationScreen())
                          );
                        },
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: const Color(0xFF8B5CF6),
                            borderRadius: BorderRadius.circular(35),
                          ),
                          child: const Icon(
                            Icons.arrow_forward_rounded,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}



================================================
File: views/liker_profile_screen.dart
================================================
// File: views/liker_profile_screen.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/liker_profile_provider.dart';
import 'package:dtx/views/profile_screens.dart'; // Re-use ProfileScreen's building blocks (Keep for reference, but structure is replicated)
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

// --- ADDED IMPORTS ---
import 'package:dtx/models/user_model.dart';
import 'package:dtx/utils/app_enums.dart'; // For Gender enum etc. if needed in helpers
// --- END ADDED ---

class LikerProfileScreen extends ConsumerWidget {
  final int likerUserId;

  const LikerProfileScreen({super.key, required this.likerUserId});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watch the specific provider instance for this liker's ID
    final state = ref.watch(likerProfileProvider(likerUserId));
    final profile = state.profile;
    final likeDetails = state.likeDetails;

    return Scaffold(
      backgroundColor: Colors.white,
      body: _buildBody(context, state, profile, likeDetails, ref),
    );
  }

  Widget _buildBody(
      BuildContext context,
      LikerProfileState state,
      UserProfileData? profile,
      LikeInteractionDetails? likeDetails,
      WidgetRef ref) {
    if (state.isLoading) {
      return const Center(
          child: CircularProgressIndicator(color: Color(0xFF8B5CF6)));
    }

    if (state.error != null) {
      return _buildErrorState(context, state.error!, ref); // Pass context
    }

    if (profile == null || likeDetails == null) {
      return _buildErrorState(
          context,
          AppError.generic("Profile data could not be loaded."),
          ref); // Pass context
    }

    // --- If data loaded successfully ---
    return CustomScrollView(
      slivers: [
        SliverAppBar(
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          elevation: 1,
          pinned: true,
          leading: IconButton(
            icon: Icon(Icons.arrow_back_ios_new,
                color: Colors.grey[700], size: 20),
            onPressed: () => Navigator.of(context).pop(),
          ),
          title: Text(
            // --- FIX: Use profile.name ---
            profile.name ?? 'Profile',
            // --- END FIX ---
            style:
                GoogleFonts.poppins(fontWeight: FontWeight.w600, fontSize: 18),
          ),
          actions: [
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: IconButton(
                icon: const Icon(Icons.message_outlined,
                    color: Color(0xFF8B5CF6)),
                tooltip: "Send Message",
                onPressed: () {
                  // --- FIX: Use profile.id ---
                  print("Navigate to chat with user ${profile.id}");
                  // --- END FIX ---
                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                      content:
                          Text('Chat functionality not yet implemented.')));
                },
              ),
            )
          ],
        ),

        // --- Like Details Banner ---
        SliverToBoxAdapter(
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            margin: const EdgeInsets.all(16),
            decoration: BoxDecoration(
                color: likeDetails.isRose
                    ? Colors.purple.shade50
                    : Colors.blue.shade50,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                    color: likeDetails.isRose
                        ? Colors.purple.shade100
                        : Colors.blue.shade100)),
            child: Row(
              children: [
                Icon(
                  likeDetails.isRose
                      ? Icons.star_rounded
                      : Icons.favorite_rounded,
                  color: likeDetails.isRose
                      ? Colors.purple.shade400
                      : Colors.pink.shade300,
                  size: 24,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    likeDetails.likeComment != null &&
                            likeDetails.likeComment!.isNotEmpty
                        ? '"${likeDetails.likeComment}"' // Show comment if exists
                        : (likeDetails.isRose
                            ? 'Sent you a Rose!'
                            : 'Liked your profile!'), // Default message
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                      fontStyle: (likeDetails.likeComment != null &&
                              likeDetails.likeComment!.isNotEmpty)
                          ? FontStyle.italic
                          : FontStyle.normal,
                      color: likeDetails.isRose
                          ? Colors.purple.shade700
                          : Colors.blue.shade700,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),

        // --- Profile Content ---
        SliverPadding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          sliver: SliverList(
            delegate: SliverChildListDelegate([
              _buildProfileHeader(profile),
              const SizedBox(height: 24),
              _buildMediaGallery(
                  context, profile.mediaUrls ?? []), // Pass context
              const SizedBox(height: 32),
              if (profile.datingIntention != null)
                _buildInfoSection(
                    "Looking for", profile.datingIntention!.label),
              const SizedBox(height: 24),
              _buildPromptSection(profile.prompts),
              const SizedBox(height: 32),
              if (profile.audioPrompt != null)
                _buildAudioPrompt(
                    context, profile.audioPrompt!), // Pass context
              const SizedBox(height: 32),
              _buildPersonalDetailsSection(profile),
              const SizedBox(height: 40), // Bottom padding
            ]),
          ),
        ),
      ],
    );
  }

  // --- Error State Widget ---
  Widget _buildErrorState(BuildContext context, AppError error, WidgetRef ref) {
    // Added context
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(30.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                size: 60, color: Colors.redAccent[100]),
            const SizedBox(height: 20),
            Text(
              "Oops!",
              style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[700]),
            ),
            const SizedBox(height: 10),
            Text(
              error.message,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded, size: 18),
              label: const Text("Retry"),
              style: ElevatedButton.styleFrom(
                foregroundColor: Colors.white,
                backgroundColor: const Color(0xFF8B5CF6),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20)),
                padding:
                    const EdgeInsets.symmetric(horizontal: 30, vertical: 12),
              ),
              onPressed: () => ref
                  .read(likerProfileProvider(likerUserId).notifier)
                  .fetchProfile(),
            ),
            const SizedBox(height: 10),
            TextButton(
              child: const Text("Go Back"),
              style: TextButton.styleFrom(foregroundColor: Colors.grey[600]),
              onPressed: () => Navigator.of(context).pop(),
            )
          ],
        ),
      ),
    );
  }

  // --- Replicated/Adapted Widgets ---

  Widget _buildProfileHeader(UserProfileData user) {
    // --- FIX: Use user.age getter ---
    final age = user.age;
    // --- END FIX ---
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          // --- FIX: Use user.name and check lastName ---
          '${user.name ?? ''}${user.lastName != null && user.lastName!.isNotEmpty ? ' ${user.lastName}' : ''}${age != null ? ' • $age' : ''}',
          // --- END FIX ---
          style: GoogleFonts.poppins(
            fontSize: 36, // Slightly smaller if too large
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
            height: 1.2,
          ),
        ),
        const SizedBox(height: 8),
        if (user.gender != null ||
            (user.hometown != null && user.hometown!.isNotEmpty))
          Wrap(
            spacing: 8,
            runSpacing: 4,
            children: [
              if (user.gender != null)
                _buildDetailChip(Icons.person_outline, user.gender!.label,
                    subtle: true),
              if (user.hometown != null && user.hometown!.isNotEmpty)
                _buildDetailChip(Icons.location_on_outlined, user.hometown!,
                    subtle: true),
            ],
          ),
      ],
    );
  }

  Widget _buildMediaGallery(BuildContext context, List<String> images) {
    // Added context
    if (images.isEmpty) return const SizedBox.shrink();

    return Container(
      height: MediaQuery.of(context).size.height * 0.4, // Responsive height
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: images.length,
        itemBuilder: (context, index) {
          return Container(
            width: MediaQuery.of(context).size.width * 0.6, // Responsive width
            margin: EdgeInsets.only(right: index == images.length - 1 ? 0 : 10),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              color: Colors.grey[200],
            ),
            child: ClipRRect(
              // Clip the image
              borderRadius: BorderRadius.circular(12),
              child: Image.network(
                images[index],
                fit: BoxFit.cover,
                loadingBuilder: (context, child, progress) {
                  if (progress == null) return child;
                  return Center(
                      child: CircularProgressIndicator(
                          value: progress.expectedTotalBytes != null
                              ? progress.cumulativeBytesLoaded /
                                  progress.expectedTotalBytes!
                              : null,
                          color: Color(0xFF8B5CF6)));
                },
                errorBuilder: (context, error, stackTrace) {
                  print("Error loading image: ${images[index]} - $error");
                  return Center(
                      child: Icon(Icons.broken_image, color: Colors.grey[400]));
                },
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildInfoSection(String title, String content) {
    // Check if content is not empty before building
    if (content.isEmpty) return const SizedBox.shrink();
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 12.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: GoogleFonts.poppins(
              fontSize: 14,
              fontWeight: FontWeight.w500,
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 4),
          Text(
            content,
            style: GoogleFonts.poppins(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: const Color(0xFF1A1A1A),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPromptSection(List<Prompt> prompts) {
    if (prompts.isEmpty) return const SizedBox.shrink();
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          "About Me",
          style: GoogleFonts.poppins(
            fontSize: 20,
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
          ),
        ),
        const SizedBox(height: 16),
        ...prompts.map((prompt) => _buildPromptCard(prompt)).toList(),
      ],
    );
  }

  Widget _buildPromptCard(Prompt prompt) {
    // Check if answer is not empty before building
    if (prompt.answer.isEmpty) return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey[200]!),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            prompt.question.label,
            style: GoogleFonts.poppins(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: const Color(0xFF8B5CF6),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            prompt.answer,
            style: GoogleFonts.poppins(
              fontSize: 14,
              color: const Color(0xFF1A1A1A),
              height: 1.4,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAudioPrompt(BuildContext context, AudioPromptModel audio) {
    // Added context
    // Simple display, no playback logic here for now
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          "Voice Prompt",
          style: GoogleFonts.poppins(
            fontSize: 20,
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
          ),
        ),
        const SizedBox(height: 16),
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.grey[50],
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.grey[200]!),
          ),
          child: Row(
            children: [
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6),
                  borderRadius: BorderRadius.circular(24),
                ),
                child: const Icon(
                  Icons.graphic_eq, // Use a different icon for display only
                  color: Colors.white,
                  size: 28,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Text(
                  audio.prompt.label,
                  style: GoogleFonts.poppins(
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                    color: const Color(0xFF1A1A1A),
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildPersonalDetailsSection(UserProfileData user) {
    final details = <Widget>[];
    // Add checks for empty strings as well
    if (user.height != null && user.height!.isNotEmpty)
      details.add(_buildDetailChip(Icons.height, "Height: ${user.height}"));
    if (user.religiousBeliefs != null)
      details.add(_buildDetailChip(
          Icons.church_outlined, user.religiousBeliefs!.label));
    if (user.jobTitle != null && user.jobTitle!.isNotEmpty)
      details.add(_buildDetailChip(Icons.work_outline, user.jobTitle!));
    if (user.education != null && user.education!.isNotEmpty)
      details.add(_buildDetailChip(Icons.school_outlined, user.education!));
    if (user.drinkingHabit != null)
      details.add(_buildDetailChip(
          Icons.local_bar_outlined, user.drinkingHabit!.label));
    if (user.smokingHabit != null)
      details.add(_buildDetailChip(
          Icons.smoking_rooms_outlined, user.smokingHabit!.label));

    if (details.isEmpty) return const SizedBox.shrink();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          "Personal Details",
          style: GoogleFonts.poppins(
            fontSize: 20,
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
          ),
        ),
        const SizedBox(height: 16),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: details,
        ),
      ],
    );
  }

  Widget _buildDetailChip(IconData icon, String label, {bool subtle = false}) {
    // Check if label is empty
    if (label.isEmpty) return const SizedBox.shrink();
    return Container(
      padding: EdgeInsets.symmetric(
          horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
      decoration: BoxDecoration(
        color: subtle ? Colors.transparent : Colors.grey[100],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
            color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: subtle ? 16 : 18,
            color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6),
          ),
          const SizedBox(width: 6),
          Flexible(
            // Allow text to wrap if needed
            child: Text(
              label,
              style: GoogleFonts.poppins(
                fontSize: subtle ? 13 : 14,
                fontWeight: FontWeight.w500,
                color: subtle ? Colors.grey.shade700 : Colors.grey[800],
              ),
              overflow: TextOverflow.ellipsis, // Prevent long text overflow
              maxLines: 2,
            ),
          ),
        ],
      ),
    );
  }
}



================================================
File: views/location.dart
================================================
// File: views/location.dart
import 'package:dtx/models/error_model.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:app_settings/app_settings.dart'; // Keep for opening settings
import '../providers/location_provider.dart';
import '../providers/error_provider.dart';
import '../providers/user_provider.dart'; // Ensure user provider is imported
import 'gender.dart'; // Ensure GenderSelectionScreen is imported

class LocationInputScreen extends ConsumerStatefulWidget {
  const LocationInputScreen({super.key});

  @override
  ConsumerState<LocationInputScreen> createState() =>
      _LocationInputScreenState();
}

class _LocationInputScreenState extends ConsumerState<LocationInputScreen> {
  late final MapController _mapController;

  @override
  void initState() {
    super.initState();
    _mapController = MapController();
    // Fetch location after the first frame is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Only fetch if location isn't already valid in the user state
      // This prevents unnecessary fetches if the user navigates back and forth
      if (!ref.read(userProvider.notifier).isLocationValid()) {
        print("[LocationInputScreen] Initial location fetch triggered.");
        ref.read(locationProvider.notifier).fetchCurrentLocation();
      } else {
        print(
            "[LocationInputScreen] Skipping initial fetch, location already set.");
        // Ensure the map moves to the existing location if needed
        _moveToCurrentLocation();
      }
    });
  }

  void _onMapReady() {
    print("[LocationInputScreen] Map Ready.");
    // It might be safer to set map ready state in the provider
    // ref.read(locationProvider.notifier).setMapReady(true);
    _moveToCurrentLocation();
  }

  void _moveToCurrentLocation() {
    final locationState = ref.read(locationProvider);
    final userLocation =
        ref.read(userProvider); // Get location from user provider

    // Use user provider's location if valid, otherwise use location provider's state
    final LatLng targetLocation = LatLng(
      userLocation.latitude ?? locationState.latitude,
      userLocation.longitude ?? locationState.longitude,
    );

    print("[LocationInputScreen] Moving map to: $targetLocation");
    // Check if mapController is initialized and ready
    // Note: FlutterMap doesn't have a direct 'isReady' flag accessible here easily.
    // We rely on onMapReady having been called implicitly before this might be needed.
    // A small delay could be a workaround if needed, but usually direct call is fine.
    try {
      _mapController.move(targetLocation, _mapController.camera.zoom);
    } catch (e) {
      print(
          "[LocationInputScreen] Error moving map (potentially before ready): $e");
      // Optionally, schedule the move again slightly later
      // Future.delayed(Duration(milliseconds: 100), () => _moveToCurrentLocation());
    }
  }

  // Dialog for location services disabled
  Future<void> _showLocationServiceDialog() async {
    // Prevent showing multiple dialogs
    if (ModalRoute.of(context)?.isCurrent ?? false) {
      print("[LocationInputScreen] Showing Location Service Dialog.");
      return showDialog<void>(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext dialogContext) {
          // Use different context name
          return AlertDialog(
            title: Text('Location Services Required',
                style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
            content: SingleChildScrollView(
              child: ListBody(
                children: <Widget>[
                  Text(
                      'To show you relevant places around you, we need access to your location.',
                      style: GoogleFonts.poppins()),
                  const SizedBox(height: 15),
                  Text(
                      'Please enable location services in your device settings.',
                      style: GoogleFonts.poppins()),
                ],
              ),
            ),
            actions: <Widget>[
              TextButton(
                child: Text('Open Settings',
                    style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6))),
                onPressed: () {
                  Navigator.pop(dialogContext); // Use dialogContext
                  ref.read(locationProvider.notifier).openLocationSettings();
                },
              ),
              TextButton(
                child: Text('Retry',
                    style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6))),
                onPressed: () {
                  Navigator.pop(dialogContext); // Use dialogContext
                  ref.read(errorProvider.notifier).clearError();
                  ref.read(locationProvider.notifier).fetchCurrentLocation();
                },
              ),
            ],
          );
        },
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // Listen to location provider for map center and loading state
    final locationState = ref.watch(locationProvider);
    // Listen to user provider for the marker position (the confirmed location)
    final userState = ref.watch(userProvider);
    final error = ref.watch(errorProvider);

    // Use user's location for the marker if available, otherwise default
    final markerLatLng = LatLng(userState.latitude ?? locationState.latitude,
        userState.longitude ?? locationState.longitude);

    // Show location service dialog if needed after the build phase
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (error?.type == ErrorType.locationService) {
        _showLocationServiceDialog();
      }
    });

    return Scaffold(
      backgroundColor: Colors.white, // Use a clean white background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.04),
              // Progress Indicator (Optional) - Can use a step indicator if preferred
              // Center(child: Text("Step 1 of X", style: GoogleFonts.poppins(color: Colors.grey))),

              SizedBox(height: screenSize.height * 0.03),
              Row(
                children: [
                  Icon(
                    Icons.location_on_outlined,
                    color: const Color(0xFF8B5CF6), // Themed icon color
                    size: 32,
                  ),
                  const SizedBox(width: 10),
                  Text(
                    "Where do you live?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.07,
                      fontWeight: FontWeight.bold,
                      color: const Color(0xFF1A1A1A), // Darker text color
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 10),
              Text(
                "Drag the map to set your approximate location. Only your general area will be shown.",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey.shade600,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              Expanded(
                child: locationState.isLoading && !userState.isLocationValid()
                    ? const Center(
                        child: CircularProgressIndicator(
                        color: Color(0xFF8B5CF6),
                      ))
                    : ClipRRect(
                        // Use ClipRRect for rounded corners
                        borderRadius: BorderRadius.circular(15.0),
                        child: FlutterMap(
                          mapController: _mapController,
                          options: MapOptions(
                            initialCenter:
                                markerLatLng, // Start centered on user/default
                            initialZoom: 14.0,
                            onMapReady: _onMapReady,
                            // Update location provider AND user provider on tap/drag end
                            onTap: (tapPosition, latlng) {
                              print(
                                  "[LocationInputScreen] Map Tapped: $latlng");
                              ref
                                  .read(locationProvider.notifier)
                                  .updateLocation(
                                      latlng.latitude, latlng.longitude);
                            },
                            // Optional: Update on position changed (can be laggy)
                            // onPositionChanged: (position, hasGesture) {
                            //   if (hasGesture) {
                            //     final center = position.center;
                            //     if (center != null) {
                            //       ref.read(locationProvider.notifier)
                            //          .updateLocation(center.latitude, center.longitude);
                            //     }
                            //   }
                            // },
                          ),
                          children: [
                            TileLayer(
                              urlTemplate:
                                  'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                              // Use standard OSM tiles
                              userAgentPackageName:
                                  'com.peeple.dating', // Replace with your app's package name
                            ),
                            MarkerLayer(
                              markers: [
                                Marker(
                                  point:
                                      markerLatLng, // Marker follows user's selected location
                                  width: 50, // Slightly larger marker
                                  height: 50,
                                  child: const Icon(
                                    Icons.location_pin, // Use a pin icon
                                    color: Color(0xFF8B5CF6),
                                    size: 50,
                                  ),
                                ),
                              ],
                            ),
                            // Add a button to re-center on fetched location
                            if (locationState.cachedLatitude != null &&
                                locationState.cachedLongitude != null)
                              Positioned(
                                bottom:
                                    80, // Position above the main next button
                                right: 16,
                                child: FloatingActionButton.small(
                                  // Smaller FAB
                                  heroTag: 'recenter_fab', // Unique heroTag
                                  onPressed: () {
                                    print(
                                        "[LocationInputScreen] Recenter button pressed.");
                                    ref
                                        .read(locationProvider.notifier)
                                        .useCachedLocation();
                                    // Move map after state updates
                                    WidgetsBinding.instance
                                        .addPostFrameCallback(
                                            (_) => _moveToCurrentLocation());
                                  },
                                  backgroundColor: const Color(0xFF8B5CF6),
                                  child: Icon(
                                      locationState.isFetching
                                          ? Icons
                                              .location_searching // Indicate fetching
                                          : Icons.my_location,
                                      color: Colors.white),
                                ),
                              ),
                          ],
                        ),
                      ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              // Show error messages from ErrorProvider
              if (error != null &&
                  error.type !=
                      ErrorType
                          .locationService) // Don't show non-service errors here if dialog handles it
                Padding(
                  padding: const EdgeInsets.only(bottom: 8.0),
                  child: Text(
                    error.message,
                    style: GoogleFonts.poppins(color: Colors.redAccent),
                    textAlign: TextAlign.center,
                  ),
                ),
              // Next Button
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding: const EdgeInsets.only(
                      bottom: 16.0), // Add some bottom padding
                  child: FloatingActionButton(
                    heroTag: 'next_fab', // Unique heroTag
                    onPressed: userState
                            .isLocationValid() // Enable only if location is set
                        ? () {
                            print(
                                "[LocationInputScreen] Next button pressed. Navigating to Gender.");
                            Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const GenderSelectionScreen()));
                          }
                        : null, // Disable button if location is not valid
                    backgroundColor: userState.isLocationValid()
                        ? const Color(0xFF8B5CF6)
                        : Colors.grey.shade400,
                    foregroundColor: Colors.white,
                    child: const Icon(Icons.arrow_forward_rounded),
                  ),
                ),
              ),
              SizedBox(
                  height: screenSize.height * 0.02), // Adjust bottom spacing
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    // Avoid potential errors if _mapController wasn't initialized
    // _mapController?.dispose(); // No need to dispose MapController typically
    super.dispose();
  }
}



================================================
File: views/media.dart
================================================
import 'dart:io';
import 'dart:typed_data';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/views/religion.dart';
import 'package:dtx/views/prompt.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:get_thumbnail_video/video_thumbnail.dart'; // Updated package
import 'package:reorderable_grid_view/reorderable_grid_view.dart';
import 'package:dotted_border/dotted_border.dart';
import 'package:get_thumbnail_video/index.dart';

import '../models/error_model.dart'; // NEW import

class MediaPickerScreen extends ConsumerStatefulWidget {
  const MediaPickerScreen({super.key});

  @override
  ConsumerState<MediaPickerScreen> createState() => _MediaPickerState();
}

class _MediaPickerState extends ConsumerState<MediaPickerScreen> {
  late List<MediaFile> _selectedMedia;
  late List<UniqueKey> _itemKeys;
  bool _isForwardButtonEnabled = false;
  final _thumbnailCache = <String, Uint8List>{};
  bool _isUploading = false; // Add this new variable

  final Set<String> _allowedImageMime = {
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/jpg'
  };

  final Set<String> _allowedVideoMime = {
    'video/mp4',
    'video/quicktime',
    'video/x-msvideo',
    'video/mpeg',
    'video/3gpp',
    'video/mp2t'
  };

  final Set<String> _allowedImageExtensions = {
    'jpg',
    'jpeg',
    'png',
    'gif',
    'webp',
    'bmp',
    'tiff'
  };

  final Set<String> _allowedVideoExtensions = {
    'mp4',
    'mov',
    'avi',
    'mpeg',
    'mpg',
    '3gp',
    'ts',
    'mkv'
  };

  @override
  void initState() {
    super.initState();
    _selectedMedia = List.generate(
        6, (index) => MediaFile(file: null, type: MediaType.image));
    _itemKeys = List.generate(6, (index) => UniqueKey());
  }

  @override
  void dispose() {
    _thumbnailCache.clear();
    super.dispose();
  }

Future<void> _pickMedia(int index) async {
  final ImagePicker picker = ImagePicker();
  final XFile? media = await picker.pickMedia();

  if (media != null) {
    final mimeType = media.mimeType?.toLowerCase();
    final extension = media.path.split('.').last.toLowerCase();
    final filePath = media.path.replaceFirst('file://', '');
    final file = File(filePath);
    
    final isValidImage = _allowedImageMime.contains(mimeType) || 
                       _allowedImageExtensions.contains(extension);
    final isValidVideo = _allowedVideoMime.contains(mimeType) || 
                       _allowedVideoExtensions.contains(extension);
    // Check file size
    final fileSize = await file.length();
    final isImage = _allowedImageMime.contains(mimeType) ||
        _allowedImageExtensions.contains(extension);
    final isVideo = _allowedVideoMime.contains(mimeType) ||
        _allowedVideoExtensions.contains(extension);
        
    // Size validation (10MB for images, 50MB for videos)
    if (isImage && fileSize > 10 * 1024 * 1024) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      _clearInvalidInput(index);
      return;
    }
    
    if (isVideo && fileSize > 50 * 1024 * 1024) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Video is too large. Maximum size is 50 MB."),
      );
      _clearInvalidInput(index);
      return;
    }

    // Existing validation logic...
    if (index == 0 && !isValidImage) {
      await _showErrorDialog(context, isMainImage: true);
      _clearInvalidInput(index);
      return;
    }

    if (!isValidImage && !isValidVideo) {
      await _showErrorDialog(context);
      _clearInvalidInput(index);
      return;
    }

    setState(() {
      _selectedMedia[index] = MediaFile(
        file: File(filePath),
        type: isValidVideo ? MediaType.video : MediaType.image,
      );
      _updateForwardButtonState();
    });
  }
}

  Future<void> _showErrorDialog(BuildContext context,
      {bool isMainImage = false}) async {
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(isMainImage ? 'Invalid Main Image' : 'Invalid File Type'),
        content: Text(isMainImage
            ? 'Main image must be an image file.\nAllowed formats: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF'
            : 'Allowed formats:\n• Images: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF\n• Videos: MP4, MOV, AVI, MPEG, 3GP, TS, MKV'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _clearInvalidInput(int index) {
    setState(() {
      _selectedMedia[index] = MediaFile(file: null, type: MediaType.image);
      _updateForwardButtonState();
    });
  }

  void _reorderMedia(int oldIndex, int newIndex) {
    if (oldIndex == 0 || newIndex == 0) return;

    setState(() {
      final MediaFile item = _selectedMedia.removeAt(oldIndex);
      final UniqueKey key = _itemKeys.removeAt(oldIndex);

      if (oldIndex < newIndex) newIndex -= 1;

      _selectedMedia.insert(newIndex, item);
      _itemKeys.insert(newIndex, key);
    });
  }

  void _updateForwardButtonState() {
    int selectedCount =
        _selectedMedia.where((media) => media.file != null).length;
    setState(() {
      _isForwardButtonEnabled = selectedCount >= 3;
    });
  }

  @override
  Widget build(BuildContext context) {
    final errorState = ref.watch(errorProvider);
    final screenSize = MediaQuery.of(context).size;

    return Scaffold(
      backgroundColor: const Color(0xFFFAFAFA), // Lighter background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.03),
              // Enhanced header section
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Icon(
                  Icons.photo_library_rounded,
                  color: const Color(0xFF8B5CF6),
                  size: 48,
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              // Enhanced title
              Text(
                "Create Your Gallery",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  letterSpacing: -0.5,
                ),
              ),
              // Enhanced subtitle
              Text(
                "Select at least 3 photos or videos",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey[600],
                  fontWeight: FontWeight.w500,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              // Enhanced grid view
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(20),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  padding: const EdgeInsets.all(16),
                  child: ReorderableGridView.count(
                    crossAxisCount: 2,
                    mainAxisSpacing: 16,
                    crossAxisSpacing: 16,
                    childAspectRatio: 0.95,
                    shrinkWrap: true,
                    physics: const BouncingScrollPhysics(),
                    children: List.generate(
                        6, (index) => _buildMediaPlaceholder(index)),
                    onReorder: _reorderMedia,
                  ),
                ),
              ),
              // Add this right below the Expanded widget containing the grid view
if (ref.watch(errorProvider) != null)
  Padding(
    padding: const EdgeInsets.symmetric(vertical: 8.0),
    child: Text(
      ref.watch(errorProvider)!.message,
      style: GoogleFonts.poppins(
        color: Colors.red,
        fontSize: 14,
      ),
    ),
  ),

              // Enhanced bottom section
              Container(
                padding: EdgeInsets.symmetric(
                  vertical: screenSize.height * 0.02,
                  horizontal: screenSize.width * 0.04,
                ),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.05),
                      blurRadius: 10,
                      offset: const Offset(0, -4),
                    ),
                  ],
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          "${_selectedMedia.where((media) => media.file != null).length}/6 Selected",
                          style: GoogleFonts.poppins(
                            fontSize: screenSize.width * 0.04,
                            fontWeight: FontWeight.w600,
                            color: const Color(0xFF8B5CF6),
                          ),
                        ),
                        Text(
                          "Minimum 3 required",
                          style: GoogleFonts.poppins(
                            fontSize: screenSize.width * 0.035,
                            color: Colors.grey[600],
                          ),
                        ),
                      ],
                    ),
                    // Enhanced forward button
GestureDetector(
  onTap: () async {
    if (_isForwardButtonEnabled && !_isUploading) {
      setState(() {
        _isUploading = true;
      });
      
      // Transfer selected media to the upload provider
      for (int i = 0; i < _selectedMedia.length; i++) {
        if (_selectedMedia[i].file != null) {
          final file = _selectedMedia[i].file!;
          final fileName = file.path.split('/').last;
          final fileType = _selectedMedia[i].type == MediaType.image 
              ? 'image/jpeg' 
              : 'video/mp4';
          
          ref.read(mediaUploadProvider.notifier).setMediaFile(i, file);
        }
      }
      
      // Start upload process
      final success = await ref.read(mediaUploadProvider.notifier).uploadAllMedia();
      
      setState(() {
        _isUploading = false;
      });
      
      if (success) {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => const ProfileAnswersScreen(),
          ),
        );
      }
    }
  },
  child: AnimatedContainer(
    duration: const Duration(milliseconds: 200),
    width: 60,
    height: 60,
    decoration: BoxDecoration(
      color: _isForwardButtonEnabled && !_isUploading
          ? const Color(0xFF8B5CF6)
          : Colors.grey[300],
      borderRadius: BorderRadius.circular(30),
      boxShadow: _isForwardButtonEnabled && !_isUploading
          ? [
              BoxShadow(
                color: const Color(0xFF8B5CF6).withOpacity(0.3),
                blurRadius: 8,
                offset: const Offset(0, 4),
              ),
            ]
          : null,
    ),
    child: _isUploading 
        ? const CircularProgressIndicator(color: Colors.white)
        : Icon(
            Icons.arrow_forward_rounded,
            color: _isForwardButtonEnabled ? Colors.white : Colors.grey[500],
            size: 28,
          ),
  ),
)
                  ],
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMediaPlaceholder(int index) {
    final media = _selectedMedia[index];
    return GestureDetector(
      key: _itemKeys[index],
      onTap: () => _pickMedia(index),
      child: DottedBorder(
        dashPattern: const [6, 3],
        color: index == 0
            ? const Color(0xFF8B5CF6)
            : const Color(0xFF8B5CF6).withOpacity(0.6),
        strokeWidth: 2,
        borderType: BorderType.RRect,
        radius: const Radius.circular(16),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (media.file != null)
                media.type == MediaType.image
                    ? ClipRRect(
                        borderRadius: BorderRadius.circular(16),
                        child: Image.file(
                          media.file!,
                          fit: BoxFit.cover,
                        ),
                      )
                    : VideoThumbnailWidget(
                        file: media.file!,
                        cache: _thumbnailCache,
                      ),
              if (media.file == null)
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        index == 0
                            ? Icons.add_photo_alternate_rounded
                            : Icons.add_rounded,
                        color: const Color(0xFF8B5CF6).withOpacity(0.6),
                        size: 36,
                      ),
                      if (index == 0)
                        Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: Text(
                            "Main Photo",
                            style: GoogleFonts.poppins(fontSize: 14),
                          ),
                        ),
                    ],
                  ),
                ),
              if (media.type == MediaType.video && media.file != null)
                Container(
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      begin: Alignment.bottomCenter,
                      end: Alignment.topCenter,
                      colors: [
                        Colors.black.withOpacity(0.6),
                        Colors.transparent,
                      ],
                    ),
                  ),
                ),
              if (media.type == MediaType.video && media.file != null)
                const Center(
                  child: Icon(
                    Icons.play_circle_fill_rounded,
                    color: Colors.white,
                    size: 48,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class MediaFile {
  final File? file;
  final MediaType type;

  MediaFile({this.file, required this.type});
}

enum MediaType { image, video }

class VideoThumbnailWidget extends StatefulWidget {
  final File file;
  final Map<String, Uint8List> cache;

  const VideoThumbnailWidget({
    super.key,
    required this.file,
    required this.cache,
  });

  @override
  State<VideoThumbnailWidget> createState() => _VideoThumbnailWidgetState();
}

class _VideoThumbnailWidgetState extends State<VideoThumbnailWidget> {
  Uint8List? _thumbnail;

  @override
  void initState() {
    super.initState();
    _loadThumbnail();
  }

  Future<void> _loadThumbnail() async {
    final filePath = widget.file.path;
    if (widget.cache.containsKey(filePath)) {
      setState(() {
        _thumbnail = widget.cache[filePath];
      });
      return;
    }

    final thumbnail = await VideoThumbnail.thumbnailData(
      video: filePath,
      quality: 100,
    );

    if (thumbnail != null) {
      widget.cache[filePath] = thumbnail;
      setState(() {
        _thumbnail = thumbnail;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return _thumbnail != null
        ? ClipRRect(
            borderRadius: BorderRadius.circular(16),
            child: Image.memory(
              _thumbnail!,
              fit: BoxFit.cover,
            ),
          )
        : const Center(
            child: CircularProgressIndicator(),
          );
  }
}



================================================
File: views/name.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/dob.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class NameInputScreen extends ConsumerStatefulWidget {
  const NameInputScreen({super.key});

  @override
  ConsumerState<NameInputScreen> createState() => _NameInputScreenState();
}

class _NameInputScreenState extends ConsumerState<NameInputScreen> {
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;

  @override
  void initState() {
    super.initState();
    final user = ref.read(userProvider);
    _firstNameController = TextEditingController(text: user.name);
    _lastNameController = TextEditingController(text: user.lastName ?? '');
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      child: const Icon(
                        Icons.badge_outlined,
                        size: 28,
                        color: Colors.white,
                      ),
                    ),
                    const SizedBox(width: 10),
                    Text(
                      "What's your name?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width * 0.06,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.04),
                _buildFirstNameInput(error, screenSize),
                SizedBox(height: screenSize.height * 0.03),
                _buildLastNameInput(screenSize),
                const Spacer(),
                _buildNextButton(screenSize, error),
                SizedBox(height: screenSize.height * 0.04),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFirstNameInput(AppError? error, Size screenSize) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          decoration: BoxDecoration(
            border: Border(
              bottom: BorderSide(
                color: error?.type == ErrorType.validation
                    ? Colors.red
                    : Colors.white54,
                width: 1.5,
              ),
            ),
          ),
          child: TextField(
            controller: _firstNameController,
            style: GoogleFonts.poppins(
              fontSize: screenSize.width * 0.05,
              fontWeight: FontWeight.w500,
              color: Colors.white,
            ),
            cursorColor: Colors.white,
            decoration: InputDecoration(
              labelText: "First name (required)",
              labelStyle: GoogleFonts.poppins(
                fontSize: screenSize.width * 0.042,
                color: Colors.white54,
              ),
              border: InputBorder.none,
            ),
            onChanged: (value) => _updateName(value, _lastNameController.text),
          ),
        ),
        if (error?.type == ErrorType.validation)
          Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Text(
              error!.message,
              style: GoogleFonts.poppins(
                color: Colors.redAccent,
                fontSize: screenSize.width * 0.035,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildLastNameInput(Size screenSize) {
    return TextField(
      controller: _lastNameController,
      style: GoogleFonts.poppins(
        fontSize: screenSize.width * 0.05,
        fontWeight: FontWeight.w500,
        color: Colors.white,
      ),
      cursorColor: Colors.white,
      decoration: InputDecoration(
        labelText: "Last name (optional)",
        labelStyle: GoogleFonts.poppins(
          fontSize: screenSize.width * 0.042,
          color: Colors.white54,
        ),
        enabledBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white54, width: 1.5),
        ),
        focusedBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white, width: 2.0),
        ),
      ),
      onChanged: (value) => _updateName(_firstNameController.text, value),
    );
  }

  Widget _buildNextButton(Size screenSize, AppError? error) {
    final isValid = ref.read(userProvider.notifier).isNameValid();

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: error == null && isValid
            ? () => _handleNextButton()
            : null, // Disable button if there are errors
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: error != null || !isValid
              ? Colors.grey.shade400 // Disable button if there are errors
              : Colors.white,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: EdgeInsets.all(16), // Adjusted padding
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24, // Adjusted icon size
          color: error != null || !isValid
              ? Colors.white54 // Change icon color when disabled
              : const Color(0xFF8B5CF6),
        ),
      ),
    );
  }

  void _updateName(String firstName, String lastName) {
    ref.read(userProvider.notifier).updateName(firstName, lastName);
  }

  void _handleNextButton() {
    ref.read(errorProvider.notifier).clearError();
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DateOfBirthScreen()),
    );
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    super.dispose();
  }
}



================================================
File: views/profile_screens.dart
================================================
// File: lib/views/profile_screens.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:dtx/models/user_model.dart'; // Keep this import
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart'; // Import if needed for helpers

// --- ADDED: Import Settings Screen ---
import 'package:dtx/views/settings_screen.dart';
// --- END ADDED ---

class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isPlaying = false;
  String? _currentAudioUrl;
  final PageController _pageController = PageController();
  int _currentImageIndex = 0;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Check if profile data is already loaded, maybe skip fetch if recent?
      // For simplicity, fetching every time ensures freshness.
      ref.read(userProvider.notifier).fetchProfile();
    });

    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted) {
        setState(() {
          _isPlaying = state == PlayerState.playing;
        });
      }
    });

    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) {
        setState(() {
          _isPlaying = false;
          // Optionally reset _currentAudioUrl here if needed
          // _currentAudioUrl = null;
        });
      }
    });
  }

  @override
  void dispose() {
    _audioPlayer.dispose();
    _pageController.dispose();
    super.dispose();
  }

  String capitalizeFirstLetter(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }

  Future<void> _playOrPauseAudio(String audioUrl) async {
    if (!mounted) return; // Ensure widget is still mounted

    try {
      final currentState = _audioPlayer.state;

      if (currentState == PlayerState.playing && _currentAudioUrl == audioUrl) {
        await _audioPlayer.pause();
        // Listener will update _isPlaying
      } else if (currentState == PlayerState.paused &&
          _currentAudioUrl == audioUrl) {
        await _audioPlayer.resume();
        // Listener will update _isPlaying
      } else {
        // Stop previous playback if different URL or stopped state
        if (currentState == PlayerState.playing ||
            currentState == PlayerState.paused) {
          await _audioPlayer.stop();
        }
        // Start new playback
        await _audioPlayer.setSource(UrlSource(audioUrl)); // Prepare source
        await _audioPlayer.resume(); // Start playing
        if (mounted) {
          setState(() {
            _currentAudioUrl = audioUrl;
            // _isPlaying will be updated by the listener
          });
        }
      }
    } catch (e) {
      print("Error playing/pausing audio: $e");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error playing audio: ${e.toString()}')),
        );
        // Reset state on error
        setState(() {
          _isPlaying = false;
          _currentAudioUrl = null;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = ref.watch(userProvider);
    final isLoading = ref.watch(userLoadingProvider);

    // Show loading indicator only if fetching initially (user.name is null)
    if (isLoading && user.name == null) {
      return Scaffold(
        backgroundColor: Colors.white,
        body: Center(
          child: CircularProgressIndicator(
            color: const Color(0xFF8B5CF6),
          ),
        ),
      );
    }

    // Use getters for age and name formatting
    final age = user.age;
    final capitalizedName =
        user.name != null ? capitalizeFirstLetter(user.name!) : null;
    final capitalizedLastName =
        user.lastName != null && user.lastName!.isNotEmpty
            ? capitalizeFirstLetter(user.lastName!)
            : null;

    return Scaffold(
      backgroundColor: Colors.white,
      body: RefreshIndicator(
        color: const Color(0xFF8B5CF6),
        onRefresh: () => ref.read(userProvider.notifier).fetchProfile(),
        child: CustomScrollView(
          physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics()), // Ensure refresh works
          slivers: [
            SliverToBoxAdapter(
              child: SizedBox(height: MediaQuery.of(context).padding.top + 16),
            ),
            SliverPadding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              sliver: SliverList(
                delegate: SliverChildListDelegate([
                  // Top Buttons Row
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      // Back button (Optional - depends on navigation flow)
                      // IconButton(
                      //   icon: Container( /* ... Back button container ... */ ),
                      //   onPressed: () => Navigator.of(context).pop(),
                      // ),

                      // Spacer if no back button
                      const Spacer(), // Pushes buttons to the right

                      // Edit Button
                      _buildTopIconButton(
                        icon: Icons.edit_outlined,
                        tooltip: 'Edit Profile',
                        onPressed: () {
                          // TODO: Navigate to Edit Profile Screen
                          print("Edit Profile Tapped");
                          ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(
                                  content:
                                      Text("Edit Profile (Not Implemented)")));
                        },
                      ),

                      const SizedBox(width: 8), // Spacing between buttons

                      // --- ADDED: Settings Button ---
                      _buildTopIconButton(
                        icon: Icons.settings_outlined,
                        tooltip: 'Settings',
                        onPressed: () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                                builder: (context) => const SettingsScreen()),
                          );
                        },
                      ),
                      // --- END ADDED ---
                    ],
                  ),

                  _buildProfileHeader(
                      capitalizedName, capitalizedLastName, age, user),
                  const SizedBox(height: 24),
                  _buildMediaGallery(user.mediaUrls ?? []),
                  const SizedBox(height: 32),

                  if (user.datingIntention != null)
                    _buildInfoSection(
                        "Looking for", user.datingIntention!.label),

                  const SizedBox(height: 24),
                  _buildPromptSection(user.prompts),
                  const SizedBox(height: 32),

                  if (user.audioPrompt != null)
                    _buildAudioPrompt(user.audioPrompt!),

                  const SizedBox(height: 32),
                  _buildPersonalDetailsSection(user),
                  const SizedBox(height: 40), // Bottom padding
                ]),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Helper for top icon buttons for consistency
  Widget _buildTopIconButton(
      {required IconData icon,
      required String tooltip,
      required VoidCallback onPressed}) {
    return IconButton(
      icon: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: Colors.grey[100],
          borderRadius: BorderRadius.circular(12),
        ),
        child: Icon(
          icon,
          color: const Color(0xFF8B5CF6),
          size: 20,
        ),
      ),
      tooltip: tooltip,
      onPressed: onPressed,
    );
  }

  Widget _buildProfileHeader(
      String? name, String? lastName, int? age, UserModel user) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '${name ?? "Your Name"} ${lastName ?? ""} ${age != null ? "• $age" : ""}', // Provide default for name
          style: GoogleFonts.poppins(
            fontSize: 32, // Adjusted font size
            fontWeight: FontWeight.w700, // Bold
            color: const Color(0xFF1A1A1A),
            height: 1.2,
          ),
        ),
        const SizedBox(height: 12),
        // Themed divider
        Container(
          width: 50,
          height: 3,
          decoration: BoxDecoration(
              color: const Color(0xFF8B5CF6),
              borderRadius: BorderRadius.circular(1.5)),
        ),
        const SizedBox(height: 16),
        if (user.gender != null ||
            (user.hometown != null && user.hometown!.isNotEmpty))
          Wrap(
            spacing: 10, // Adjusted spacing
            runSpacing: 8,
            children: [
              if (user.gender != null)
                _buildDetailChip(
                    Icons.person_outline_rounded, user.gender!.label,
                    subtle: true),
              if (user.hometown != null && user.hometown!.isNotEmpty)
                _buildDetailChip(Icons.location_on_outlined, user.hometown!,
                    subtle: true),
            ],
          ),
      ],
    );
  }

  Widget _buildMediaGallery(List<String> images) {
    if (images.isEmpty) {
      return _buildEmptySection(
        "Photos & Videos",
        "Add photos and videos to show off your personality!",
        Icons.add_photo_alternate_outlined,
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          height: MediaQuery.of(context).size.height * 0.5, // Responsive height
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(24),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.08), // Softer shadow
                blurRadius: 15,
                offset: const Offset(0, 5),
              ),
            ],
          ),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(24),
            child: Stack(
              children: [
                PageView.builder(
                  controller: _pageController,
                  itemCount: images.length,
                  onPageChanged: (index) {
                    if (mounted) {
                      // Check mounted before setState
                      setState(() {
                        _currentImageIndex = index;
                      });
                    }
                  },
                  itemBuilder: (context, index) {
                    // Basic check if it's a video URL (you might need a more robust check)
                    bool isVideo =
                        images[index].toLowerCase().contains('.mp4') ||
                            images[index].toLowerCase().contains(
                                '.mov'); // Add other video extensions if needed

                    return Container(
                      color: Colors.grey[200],
                      child: Stack(
                        fit: StackFit.expand,
                        children: [
                          Image.network(
                            images[index],
                            fit: BoxFit.cover,
                            errorBuilder: (context, error, stackTrace) {
                              return Container(
                                color: Colors.grey[200],
                                child: Center(
                                  child: Icon(Icons.broken_image_outlined,
                                      color: Colors.grey[400], size: 48),
                                ),
                              );
                            },
                            loadingBuilder: (context, child, loadingProgress) {
                              if (loadingProgress == null) return child;
                              return Center(
                                child: CircularProgressIndicator(
                                  color: const Color(0xFF8B5CF6),
                                  value: loadingProgress.expectedTotalBytes !=
                                          null
                                      ? loadingProgress.cumulativeBytesLoaded /
                                          loadingProgress.expectedTotalBytes!
                                      : null,
                                ),
                              );
                            },
                          ),
                          // Add play icon overlay for videos
                          if (isVideo)
                            Center(
                              child: Container(
                                padding: const EdgeInsets.all(12),
                                decoration: BoxDecoration(
                                  color: Colors.black.withOpacity(0.5),
                                  shape: BoxShape.circle,
                                ),
                                child: Icon(Icons.play_arrow_rounded,
                                    color: Colors.white, size: 40),
                              ),
                            ),
                        ],
                      ),
                    );
                  },
                ),
                // Gradient overlay (optional, can be removed if play icon is enough)
                // Positioned( /* ... gradient ... */ ),
                // Page indicator dots
                if (images.length > 1)
                  Positioned(
                    bottom: 20,
                    left: 0,
                    right: 0,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: List.generate(
                        images.length,
                        (index) => AnimatedContainer(
                          duration: const Duration(milliseconds: 200),
                          width: _currentImageIndex == index ? 24 : 8,
                          height: 8,
                          margin: const EdgeInsets.symmetric(horizontal: 4),
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(4),
                            color: _currentImageIndex == index
                                ? const Color(0xFF8B5CF6)
                                : Colors.white.withOpacity(0.6),
                          ),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildInfoSection(String title, String content) {
    if (content.isEmpty) return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: 16),
      decoration: BoxDecoration(
        border: Border(
          bottom:
              BorderSide(color: Colors.grey[200]!, width: 1), // Lighter border
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: GoogleFonts.poppins(
              fontSize: 14, // Slightly smaller label
              fontWeight: FontWeight.w500,
              color: Colors.grey[600], // Grey label
            ),
          ),
          const SizedBox(height: 6), // Reduced space
          Text(
            content,
            style: GoogleFonts.poppins(
              fontSize: 16, // Content size
              fontWeight: FontWeight.w500, // Normal weight for content
              color: const Color(0xFF1A1A1A),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPromptSection(List<Prompt> prompts) {
    if (prompts.isEmpty) {
      return _buildEmptySection(
        "About Me",
        "Add prompt answers to share more about yourself!",
        Icons.chat_bubble_outline,
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          // Add padding to section title
          padding: const EdgeInsets.only(top: 16.0, bottom: 8.0),
          child: Text(
            "About Me",
            style: GoogleFonts.poppins(
                fontSize: 20,
                fontWeight: FontWeight.w600,
                color: const Color(0xFF1A1A1A)),
          ),
        ),
        ...prompts.map((prompt) => _buildPromptCard(prompt)).toList(),
      ],
    );
  }

  Widget _buildPromptCard(Prompt prompt) {
    if (prompt.answer.trim().isEmpty) return const SizedBox.shrink();

    return Container(
      width: double.infinity,
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white, // White background for cards
        borderRadius: BorderRadius.circular(16), // More rounded
        border: Border.all(color: Colors.grey[200]!),
        boxShadow: [
          BoxShadow(
              color: Colors.grey.withOpacity(0.06),
              blurRadius: 10,
              offset: const Offset(0, 3)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            prompt.question.label,
            style: GoogleFonts.poppins(
              fontSize: 15, // Adjusted size
              fontWeight: FontWeight.w600,
              color: const Color(0xFF8B5CF6), // Themed question color
            ),
          ),
          const SizedBox(height: 10),
          Text(
            prompt.answer,
            style: GoogleFonts.poppins(
              fontSize: 15, // Adjusted size
              color: Colors.grey[800], // Dark grey for answer
              height: 1.5, // Line height
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAudioPrompt(AudioPromptModel audio) {
    if (audio.audioUrl.isEmpty)
      return const SizedBox.shrink(); // Don't build if URL is empty

    final bool isThisPlaying = _currentAudioUrl == audio.audioUrl && _isPlaying;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          // Add padding to section title
          padding: const EdgeInsets.only(top: 16.0, bottom: 8.0),
          child: Text(
            "Voice Prompt",
            style: GoogleFonts.poppins(
                fontSize: 20,
                fontWeight: FontWeight.w600,
                color: const Color(0xFF1A1A1A)),
          ),
        ),
        GestureDetector(
          onTap: () => _playOrPauseAudio(audio.audioUrl),
          child: Container(
            padding: const EdgeInsets.all(16), // Adjusted padding
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(color: Colors.grey[200]!),
              boxShadow: [
                BoxShadow(
                    color: Colors.grey.withOpacity(0.06),
                    blurRadius: 10,
                    offset: const Offset(0, 3)),
              ],
            ),
            child: Row(
              children: [
                Container(
                  // Play/Pause Button
                  width: 48, height: 48, // Slightly smaller button
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(24), // Fully rounded
                    boxShadow: [
                      BoxShadow(
                          color: const Color(0xFF8B5CF6).withOpacity(0.3),
                          blurRadius: 8,
                          offset: const Offset(0, 2))
                    ],
                  ),
                  child: Icon(
                    isThisPlaying
                        ? Icons.pause_rounded
                        : Icons.play_arrow_rounded,
                    color: Colors.white,
                    size: 28,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  // Prompt Text
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        audio.prompt.label,
                        style: GoogleFonts.poppins(
                            fontSize: 15,
                            fontWeight: FontWeight.w500,
                            color: const Color(0xFF1A1A1A)),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        isThisPlaying ? "Playing..." : "Tap to listen",
                        style: GoogleFonts.poppins(
                            fontSize: 13, color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ),
                // Optional: Add audio wave animation when playing
                // if (isThisPlaying) ... [ /* Animation Widget */ ]
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildPersonalDetailsSection(UserModel user) {
    final details = <Widget>[];
    if (user.height != null && user.height!.isNotEmpty)
      details.add(_buildDetailChip(
          Icons.height_rounded, user.height!)); // Use specific icon
    if (user.religiousBeliefs != null)
      details.add(_buildDetailChip(
          Icons.church_outlined, user.religiousBeliefs!.label));
    if (user.jobTitle != null && user.jobTitle!.isNotEmpty)
      details.add(_buildDetailChip(Icons.work_outline_rounded, user.jobTitle!));
    if (user.education != null && user.education!.isNotEmpty)
      details.add(_buildDetailChip(Icons.school_outlined, user.education!));
    if (user.drinkingHabit != null)
      details.add(_buildDetailChip(Icons.local_bar_outlined,
          "Drinks: ${user.drinkingHabit!.label}")); // Add prefix
    if (user.smokingHabit != null)
      details.add(_buildDetailChip(Icons.smoking_rooms_outlined,
          "Smokes: ${user.smokingHabit!.label}")); // Add prefix

    if (details.isEmpty) return const SizedBox.shrink();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          // Add padding to section title
          padding: const EdgeInsets.only(
              top: 16.0, bottom: 12.0), // Adjusted padding
          child: Text(
            "Vitals & Habits", // Changed title
            style: GoogleFonts.poppins(
                fontSize: 20,
                fontWeight: FontWeight.w600,
                color: const Color(0xFF1A1A1A)),
          ),
        ),
        Wrap(
          // Use Wrap for chips
          spacing: 10, // Horizontal space
          runSpacing: 10, // Vertical space
          children: details,
        ),
      ],
    );
  }

  // Updated Detail Chip
  Widget _buildDetailChip(IconData icon, String label, {bool subtle = false}) {
    if (label.isEmpty) return const SizedBox.shrink();
    return Container(
      padding: const EdgeInsets.symmetric(
          horizontal: 14, vertical: 8), // Adjusted padding
      decoration: BoxDecoration(
        color: subtle
            ? Colors.transparent
            : Colors.grey[100], // Use grey[100] for non-subtle
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
            color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min, // Important for Wrap
        children: [
          Icon(
            icon,
            size: subtle ? 16 : 18,
            color: subtle
                ? Colors.grey.shade600
                : const Color(0xFF8B5CF6), // Use theme color
          ),
          const SizedBox(width: 8),
          Flexible(
            // Allow text to wrap if needed within the chip
            child: Text(
              label,
              style: GoogleFonts.poppins(
                fontSize: subtle ? 13 : 14,
                fontWeight: FontWeight.w500,
                color: subtle ? Colors.grey.shade700 : Colors.grey[800],
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptySection(String title, String message, IconData icon) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(
          vertical: 30, horizontal: 20), // More vertical padding
      margin: const EdgeInsets.symmetric(vertical: 16), // Vertical margin
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.grey[200]!),
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Padding(
            // Add padding to section title
            padding: const EdgeInsets.only(bottom: 16.0),
            child: Text(title,
                style: GoogleFonts.poppins(
                    fontSize: 18,
                    fontWeight: FontWeight.w600,
                    color: Colors.grey[800])),
          ),
          Icon(icon, size: 40, color: Colors.grey[400]),
          const SizedBox(height: 12),
          Text(
            message,
            textAlign: TextAlign.center,
            style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
          ),
          // Optional: Add an "Add" button
          // const SizedBox(height: 16),
          // ElevatedButton.icon(
          //   onPressed: () { /* TODO: Action to add content */ },
          //   icon: Icon(Icons.add_circle_outline_rounded, size: 18),
          //   label: Text("Add Now"),
          //   style: ElevatedButton.styleFrom(
          //      foregroundColor: const Color(0xFF8B5CF6), backgroundColor: Colors.white, elevation: 0,
          //      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: Colors.grey[300]!)),
          //   ),
          // )
        ],
      ),
    );
  }
}



================================================
File: views/prompt.dart
================================================
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/audiopromptsselect.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/textpromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';

class ProfileAnswersScreen extends ConsumerStatefulWidget {
  const ProfileAnswersScreen({super.key});

  @override
  ConsumerState<ProfileAnswersScreen> createState() =>
      _ProfileAnswersScreenState();
}

class _ProfileAnswersScreenState extends ConsumerState<ProfileAnswersScreen> {
  bool _isForwardButtonEnabled = false;

  void _updateForwardButtonState() {
    final userState = ref.watch(userProvider);
    final prompts = userState.prompts;
    bool hasValidPrompt =
        prompts.any((prompt) => prompt.answer.trim().isNotEmpty);
    setState(() {
      _isForwardButtonEnabled = hasValidPrompt;
    });
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _updateForwardButtonState();
    });
  }

  void _handlePromptTap(Prompt? prompt, int index) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => TextSelectPromptScreen(
          editIndex: prompt != null ? index : null,
        ),
      ),
    ).then((_) => _updateForwardButtonState());
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);
    final prompts = userState.prompts;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 40),
              Text(
                "Profile Prompts",
                style: GoogleFonts.poppins(
                  fontSize: 36,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 12),
              Text(
                "Share three interesting facts about yourself",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 40),
              Expanded(
                child: ListView.separated(
                  itemCount: 3,
                  separatorBuilder: (_, __) => const SizedBox(height: 24),
                  itemBuilder: (context, index) {
                    final prompt =
                        index < prompts.length ? prompts[index] : null;
                    return _buildPromptCard(prompt, index);
                  },
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Text(
                    "At least 1 prompt required",
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      color: Colors.grey[600],
                      fontStyle: FontStyle.italic,
                    ),
                  ),
                  _buildForwardButton(),
                ],
              ),
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPromptCard(Prompt? prompt, int index) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: prompt != null ? const Color(0xFF8B5CF6) : Colors.grey[300]!,
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(16),
          onTap: () => _handlePromptTap(prompt, index),
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        prompt?.question.label ?? "Add a prompt",
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                    Icon(
                      prompt != null ? Icons.edit : Icons.add,
                      color: const Color(0xFF8B5CF6),
                      size: 24,
                    ),
                  ],
                ),
                if (prompt?.answer.isNotEmpty ?? false) ...[
                  const SizedBox(height: 12),
                  Text(
                    prompt!.answer,
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildForwardButton() {
    return GestureDetector(
      onTap: _isForwardButtonEnabled
          ? () => Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const VoicePromptScreen(),
                ),
              )
          : null,
      child: Container(
        width: 70,
        height: 70,
        decoration: BoxDecoration(
          color: _isForwardButtonEnabled
              ? const Color(0xFF8B5CF6)
              : Colors.grey.shade400,
          borderRadius: BorderRadius.circular(35),
          boxShadow: [
            BoxShadow(
              color: const Color(0xFF8B5CF6).withOpacity(0.3),
              blurRadius: 12,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          color: _isForwardButtonEnabled ? Colors.white : Colors.grey.shade600,
          size: 32,
        ),
      ),
    );
  }
}



================================================
File: views/religion.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/drinking.dart';

class ReligionScreen extends ConsumerStatefulWidget {
  const ReligionScreen({super.key});

  @override
  ConsumerState<ReligionScreen> createState() => _ReligionScreenState();
}

class _ReligionScreenState extends ConsumerState<ReligionScreen> {
  Religion? _selectedReligion;

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4),
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const SizedBox(width: 32),
                      const SizedBox(width: 48),
                    ],
                  ),
                  SizedBox(height: screenSize.height * 0.07),
                  Text(
                    "What are your religious beliefs?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.1,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF333333),
                      height: 1.1,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.05),
                  Wrap(
                    spacing: screenSize.width * 0.03,
                    runSpacing: screenSize.height * 0.015,
                    children: Religion.values
                        .map((religion) =>
                            _buildReligionButton(religion, screenSize))
                        .toList(),
                  ),
                  const Spacer(),
                  Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        GestureDetector(
                          onTap: _selectedReligion != null
                              ? () {
                                  FocusScope.of(context)
                                      .unfocus(); // Close the keyboard
                                  ref
                                      .read(userProvider.notifier)
                                      .updateReligiousBeliefs(
                                          _selectedReligion);
                                  Navigator.push(
                                      context,
                                      MaterialPageRoute(
                                          builder: (context) =>
                                              const DrinkingScreen()));
                                }
                              : null,
                          child: Container(
                            width: 70,
                            height: 70,
                            decoration: BoxDecoration(
                              color: _selectedReligion != null
                                  ? const Color(0xFF8B5CF6)
                                  : Colors.grey.shade300,
                              borderRadius: BorderRadius.circular(35),
                            ),
                            child: const Icon(
                              Icons.arrow_forward_rounded,
                              color: Colors.white,
                              size: 32,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildReligionButton(Religion religion, Size screenSize) {
    bool isSelected = _selectedReligion == religion;
    return GestureDetector(
      onTap: () => setState(() => _selectedReligion = religion),
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.015),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
          borderRadius: BorderRadius.circular(25),
          border: Border.all(color: Colors.grey.shade300, width: 1.0),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              religion.label,
              style: GoogleFonts.poppins(
                fontSize: 18,
                fontWeight: FontWeight.w500,
                color: isSelected ? Colors.white : Colors.black87,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/selfie_capture_screen.dart
================================================
// File: views/selfie_capture_screen.dart
import 'dart:async';
import 'dart:io';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/views/verification_pending_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:camera/camera.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class SelfieCaptureScreen extends ConsumerStatefulWidget {
  const SelfieCaptureScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<SelfieCaptureScreen> createState() => _SelfieCaptureScreenState();
}

class _SelfieCaptureScreenState extends ConsumerState<SelfieCaptureScreen>
    with WidgetsBindingObserver {
  CameraController? _cameraController;
  List<CameraDescription> _cameras = [];
  bool _isCameraInitialized = false;
  bool _hasError = false;
  double _aspectRatio = 1.0;
  bool _isUploading = false; // Track uploading state

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initializeCamera();
  }

  Future<void> _initializeCamera() async {
    try {
      _cameras = await availableCameras();
      if (_cameras.isEmpty) throw Exception('No cameras available');

      final frontCamera = _cameras.firstWhere(
        (camera) => camera.lensDirection == CameraLensDirection.front,
        orElse: () => _cameras.first,
      );

      _cameraController = CameraController(
        frontCamera,
        ResolutionPreset.medium,
        enableAudio: false,
      );

      await _cameraController!.initialize();
      
      final previewSize = _cameraController!.value.previewSize!;
      _aspectRatio = previewSize.width / previewSize.height;

      if (mounted) setState(() => _isCameraInitialized = true);
      
    } catch (e) {
      if (mounted) setState(() => _hasError = true);
      print('Camera Error: $e');
    }
  }

  Widget _buildCameraPreview() {
    if (_hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, color: Colors.white, size: 50),
            const SizedBox(height: 20),
            Text(
              'Camera Error',
              style: GoogleFonts.poppins(color: Colors.white, fontSize: 20),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: _initializeCamera,
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF8B5CF6),
              ),
              child: Text(
                'Retry',
                style: GoogleFonts.poppins(color: Colors.white),
              ),
            ),
          ],
        ),
      );
    }

    if (!_isCameraInitialized || _cameraController == null) {
      return const Center(
        child: CircularProgressIndicator(color: Color(0xFF8B5CF6)),
      );
    }

    return AspectRatio(
      aspectRatio: _aspectRatio,
      child: CameraPreview(_cameraController!),
    );
  }

  Future<void> _captureImage() async {
    if (!_isCameraInitialized || _cameraController == null) return;

    try {
      setState(() => _isUploading = true);

      final image = await _cameraController!.takePicture();
      final imageFile = File(image.path);

      // Set verification image in provider
      ref.read(mediaUploadProvider.notifier).setVerificationImage(imageFile);

      // Upload verification image
      final success = await ref.read(mediaUploadProvider.notifier).uploadVerificationImage();

      setState(() => _isUploading = false);

      if (success) {
        // Navigate to verification pending screen
        if (mounted) {
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (context) => const VerificationPendingScreen()),
          );
        }
      } else {
        // Handle upload failure
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to upload verification image. Please try again.')),
        );
      }
    } catch (e) {
      setState(() => _isUploading = false);
      print('Capture Error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Capture Error: ${e.toString()}')),
      );
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _cameraController?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Stack(
          children: [
            Column(
              children: [
                // Header
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.arrow_back, color: Colors.white),
                        onPressed: () => Navigator.pop(context),
                      ),
                      Text(
                        "Take Selfie",
                        style: GoogleFonts.poppins(
                          color: Colors.white,
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
                Expanded(
                  child: _buildCameraPreview(),
                ),
              ],
            ),

            // Loading indicator overlay
            if (_isUploading)
              Container(
                color: Colors.black.withOpacity(0.5),
                child: const Center(
                  child: CircularProgressIndicator(
                    color: Color(0xFF8B5CF6),
                  ),
                ),
              ),
          ],
        ),
      ),
      floatingActionButton: !_isUploading ? FloatingActionButton(
        backgroundColor: const Color(0xFF8B5CF6),
        onPressed: _captureImage,
        child: const Icon(Icons.camera_alt, color: Colors.white),
      ) : null,
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
    );
  }
}



================================================
File: views/settings_screen.dart
================================================
// File: lib/views/settings_screen.dart
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class SettingsScreen extends ConsumerWidget {
  const SettingsScreen({super.key});

  Future<void> _showLogoutConfirmationDialog(
      BuildContext context, WidgetRef ref) async {
    return showDialog<void>(
      context: context,
      barrierDismissible: false, // User must tap button!
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text('Confirm Logout',
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          content: Text('Are you sure you want to log out?',
              style: GoogleFonts.poppins()),
          actions: <Widget>[
            TextButton(
              child: Text('Cancel',
                  style: GoogleFonts.poppins(color: Colors.grey)),
              onPressed: () {
                Navigator.of(dialogContext).pop(); // Close the dialog
              },
            ),
            TextButton(
              child: Text('Logout',
                  style: GoogleFonts.poppins(color: Colors.redAccent)),
              onPressed: () async {
                Navigator.of(dialogContext).pop(); // Close the dialog first
                await _performLogout(context, ref); // Perform logout
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _performLogout(BuildContext context, WidgetRef ref) async {
    print("[SettingsScreen] Performing logout...");
    // Call the logout method from the auth provider
    await ref.read(authProvider.notifier).logout();
    print("[SettingsScreen] Logout complete. Navigating to SignInScreen.");

    // Navigate to the sign-in screen and remove all previous routes
    // Check if context is still valid before navigating
    if (context.mounted) {
      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (context) => const GoogleSignInScreen()),
        (Route<dynamic> route) => false, // Remove all routes
      );
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      backgroundColor: Colors.grey[100], // Light background for settings
      appBar: AppBar(
        title: Text(
          'Settings',
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
        ),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 1,
      ),
      body: ListView(
        padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 16),
        children: [
          // Example Setting (can add more later)
          // ListTile(
          //   leading: Icon(Icons.notifications_outlined, color: Colors.grey[700]),
          //   title: Text('Notifications', style: GoogleFonts.poppins()),
          //   trailing: Icon(Icons.arrow_forward_ios_rounded, size: 16, color: Colors.grey[500]),
          //   onTap: () {
          //     // TODO: Navigate to Notification Settings
          //   },
          // ),
          // Divider(), // Separator

          // Logout Option
          ListTile(
            leading: Icon(Icons.logout_rounded, color: Colors.redAccent[200]),
            title: Text('Logout',
                style: GoogleFonts.poppins(color: Colors.redAccent[200])),
            onTap: () => _showLogoutConfirmationDialog(context, ref),
          ),
          Divider(),
        ],
      ),
    );
  }
}



================================================
File: views/smoking.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/media.dart';

class SmokingScreen extends ConsumerStatefulWidget {
  const SmokingScreen({super.key});

  @override
  ConsumerState<SmokingScreen> createState() => _SmokingScreenState();
}

class _SmokingScreenState extends ConsumerState<SmokingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedSmokingHabit;
  bool _isOptionSelected = false;
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF8F9FA),
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: const Icon(
                      Icons.smoking_rooms_rounded,
                      color: Color(0xFF8B5CF6),
                      size: 48,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.03),
                  Text(
                    "Do you smoke?",
                    textAlign: TextAlign.left,
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.08,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF1A1A1A),
                      height: 1.1,
                    ),
                  ),
                  Text(
                    "Select your smoking habits",
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey[600],
                      height: 1.5,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.04),
                  Expanded(
                    child: ListView.separated(
                      itemCount: DrinkingSmokingHabits.values.length,
                      separatorBuilder: (context, index) =>
                          const SizedBox(height: 12),
                      itemBuilder: (context, index) {
                        final habit = DrinkingSmokingHabits.values[index];
                        return _buildSmokingOptionTile(
                          screenSize: screenSize,
                          title: habit.label,
                          value: habit,
                        );
                      },
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding:
                          EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: AnimatedScale(
                        scale: _isOptionSelected ? 1.0 : 0.95,
                        duration: const Duration(milliseconds: 200),
                        child: GestureDetector(
                          onTap: () {
                            if (_isOptionSelected) {
                              FocusScope.of(context)
                                  .unfocus(); // Close the keyboard
                              ref
                                  .read(userProvider.notifier)
                                  .updateSmokingHabit(_selectedSmokingHabit);
                              Navigator.push(
                                  context,
                                  MaterialPageRoute(
                                      builder: (context) =>
                                          const MediaPickerScreen()));
                            } else {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(
                                    "Please select an option",
                                    style: GoogleFonts.poppins(),
                                  ),
                                  backgroundColor: Colors.red[400],
                                  behavior: SnackBarBehavior.floating,
                                ),
                              );
                            }
                          },
                          child: Container(
                            width: 70,
                            height: 70,
                            decoration: BoxDecoration(
                              color: _isOptionSelected
                                  ? const Color(0xFF8B5CF6)
                                  : Colors.grey.shade300,
                              borderRadius: BorderRadius.circular(35),
                              boxShadow: _isOptionSelected
                                  ? [
                                      BoxShadow(
                                        color: const Color(0xFF8B5CF6)
                                            .withOpacity(0.3),
                                        blurRadius: 8,
                                        offset: const Offset(0, 4),
                                      ),
                                    ]
                                  : null,
                            ),
                            child: Icon(
                              Icons.arrow_forward_rounded,
                              color: _isOptionSelected
                                  ? Colors.white
                                  : Colors.grey.shade600,
                              size: 32,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildSmokingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedSmokingHabit == value;

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedSmokingHabit = value;
            _isOptionSelected = true;
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/splash_screen.dart
================================================
// File: views/splash_screen.dart
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/utils/app_enums.dart'; // Import FeedType
import 'package:dtx/views/google_sign_in_screen.dart'; // Import Google Sign-In screen
import 'package:dtx/views/home.dart';
import 'package:dtx/views/location.dart'; // Import location screen for onboarding1
import 'package:dtx/views/name.dart'; // Import name screen for onboarding2 start
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

// Remove Phone/OTP imports if they exist
// import 'package:dtx/views/phone.dart';
// import 'package:dtx/views/youtube.dart'; // Remove if replaced by GoogleSignInScreen

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnim;
  late Animation<double> _scaleAnim;
  // late Animation<double> _rotateAnim; // Rotate animation can be removed if not desired
  bool _animationComplete = false;
  bool _statusCheckComplete = false;
  AuthStatus _authStatus = AuthStatus.unknown;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
    _checkAuthStatus(); // Start checking auth status immediately
  }

  void _setupAnimation() {
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500), // Slightly faster maybe?
    );

    _fadeAnim = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve:
            const Interval(0.0, 0.8, curve: Curves.easeIn), // Fade in earlier
      ),
    );

    _scaleAnim = Tween<double>(begin: 0.7, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.elasticOut, // Keep the bounce effect
      ),
    );

    // _rotateAnim = Tween<double>(begin: -0.1, end: 0).animate( // Simple rotate
    //   CurvedAnimation(
    //     parent: _controller,
    //     curve: Curves.elasticOut,
    //   ),
    // );

    _controller.forward();

    // Mark animation as complete
    // Use a shorter delay, navigation depends more on auth check now
    Future.delayed(const Duration(milliseconds: 2000), () {
      if (mounted) {
        setState(() {
          _animationComplete = true;
        });
        _navigateIfReady();
      }
    });
  }

  // --- UPDATED: Auth Check Logic ---
  Future<void> _checkAuthStatus() async {
    print('[SplashScreen] Checking Auth Status...');
    try {
      // Perform the check without updating AuthProvider's state directly from here
      final status = await ref.read(authProvider.notifier).checkAuthStatus(
          updateState: false); // Key change: updateState: false

      print('[SplashScreen] Auth Status Check Result: $status');

      // Ensure widget is still mounted before updating state and navigating
      if (!mounted) return;

      setState(() {
        _authStatus = status;
        _statusCheckComplete = true;
      });
      _navigateIfReady(); // Attempt navigation now that status is known
    } catch (e) {
      print('[SplashScreen] Error during Auth Status Check: $e');
      if (!mounted) return;
      // If check fails, assume login is needed
      setState(() {
        _authStatus = AuthStatus.login;
        _statusCheckComplete = true;
      });
      _navigateIfReady(); // Attempt navigation even on error (to login)
    }
  }
  // --- END UPDATED ---

  // --- UPDATED: Navigation Logic ---
  void _navigateIfReady() {
    print(
        '[SplashScreen] Navigate If Ready: Animation Complete=$_animationComplete, Status Check Complete=$_statusCheckComplete, Status=$_authStatus');
    // Only navigate if *both* animation has played sufficiently and status check is done
    if (_animationComplete && _statusCheckComplete) {
      print('[SplashScreen] Conditions met. Navigating...');
      Widget destination;

      switch (_authStatus) {
        case AuthStatus.home:
          print('[SplashScreen] Navigating to HomeScreen (Home Feed)');
          // We will need to modify HomeScreen to accept this parameter
          destination = const HomeScreen(initialFeedType: FeedType.home);
          break;
        case AuthStatus.onboarding1:
          print(
              '[SplashScreen] Navigating to LocationInputScreen (Onboarding Step 1)');
          destination = const LocationInputScreen();
          break;
        case AuthStatus.onboarding2:
          print('[SplashScreen] Navigating to HomeScreen (Quick Feed)');
          // Navigate to HomeScreen but tell it to load the Quick Feed
          destination = const HomeScreen(initialFeedType: FeedType.quick);
          break;
        case AuthStatus.login:
        case AuthStatus.unknown:
        default:
          print('[SplashScreen] Navigating to GoogleSignInScreen (Login)');
          destination =
              const GoogleSignInScreen(); // Navigate to Google Sign In
          break;
      }

      // Use pushReplacement to prevent user going back to splash screen
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (_) => destination),
      );
    } else {
      print('[SplashScreen] Conditions not met. Waiting...');
    }
  }
  // --- END UPDATED ---

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final Size screenSize = MediaQuery.of(context).size;
    final double responsiveFontSize = screenSize.width * 0.18; // Adjusted size
    final double subtitleFontSize = screenSize.width * 0.04; // Adjusted size
    final double bottomPadding = screenSize.height * 0.05;

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF4C1D95), Color(0xFF7C3AED), Color(0xFF8B5CF6)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Stack(
          children: [
            Center(
              child: AnimatedBuilder(
                animation: _controller,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Transform.scale(
                      scale: _scaleAnim.value,
                      // Removed Rotate Transform for simplicity unless needed
                      // child: Transform.rotate(
                      //   angle: _rotateAnim.value,
                      child: FittedBox(
                        // Ensures text fits if screen is small
                        fit: BoxFit.scaleDown,
                        child: Text(
                          'Peeple',
                          style: GoogleFonts.pacifico(
                            fontSize: responsiveFontSize,
                            color: Colors.white,
                            shadows: [
                              Shadow(
                                color: Colors.black
                                    .withOpacity(0.6), // Darker shadow
                                blurRadius: 15,
                                offset:
                                    const Offset(0, 4), // Slightly more offset
                              ),
                            ],
                          ),
                        ),
                      ),
                      // ),
                    ),
                  );
                },
              ),
            ),
            // Subtitle remains similar
            Positioned(
              bottom: bottomPadding,
              left: 0,
              right: 0,
              child: AnimatedBuilder(
                animation: _fadeAnim,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Text(
                      'Connect. Share. Thrive.',
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                        // Use Poppins for consistency maybe?
                        color: Colors.white.withOpacity(0.9),
                        fontSize: subtitleFontSize,
                        fontWeight: FontWeight.w300,
                        letterSpacing: 0.5, // Add slight spacing
                      ),
                    ),
                  );
                },
              ),
            ),
            // Loading indicator if waiting for auth check after animation
            if (_animationComplete && !_statusCheckComplete)
              Positioned(
                bottom: bottomPadding + 50, // Position above subtitle
                left: 0,
                right: 0,
                child: const Center(
                  child: SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(
                      strokeWidth: 2.5,
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/study.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/religion.dart';

class StudyLocationScreen extends ConsumerStatefulWidget {
  const StudyLocationScreen({super.key});

  @override
  ConsumerState<StudyLocationScreen> createState() =>
      _StudyLocationScreenState();
}

class _StudyLocationScreenState extends ConsumerState<StudyLocationScreen> {
  final TextEditingController _studyLocationController =
      TextEditingController();

  @override
  void dispose() {
    _studyLocationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4),
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),

                  // Top Navigation Bar with Skip Button
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.school_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {
                          // Handle home button action
                        },
                      ),
                      // Skip Button - Top Right
                      TextButton(
                        onPressed: () {
                          FocusScope.of(context)
                              .unfocus(); // Close the keyboard
                          ref.read(userProvider.notifier).updateEducation(null);
                          Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) =>
                                      const ReligionScreen()));
                        },
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),

                  SizedBox(height: screenSize.height * 0.07),

                  // Question Text
                  Text(
                    "Where did you study?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.1,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF333333),
                      height: 1.1,
                    ),
                  ),

                  SizedBox(height: screenSize.height * 0.05),

                  // Text Field
                  Padding(
                    padding: EdgeInsets.symmetric(
                        horizontal: screenSize.width * 0.02),
                    child: TextField(
                      controller: _studyLocationController,
                      style: GoogleFonts.poppins(
                        fontSize: 22,
                        color: Colors.black87,
                      ),
                      decoration: InputDecoration(
                        hintText: "your college",
                        hintStyle: GoogleFonts.poppins(
                          fontSize: 22,
                          color: Colors.grey.shade500,
                        ),
                        border: const UnderlineInputBorder(
                          borderSide:
                              BorderSide(color: Colors.grey, width: 1.0),
                        ),
                        focusedBorder: const UnderlineInputBorder(
                          borderSide:
                              BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                        ),
                      ),
                    ),
                  ),

                  const Spacer(),

                  // Forward Button
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding:
                          EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: GestureDetector(
                        onTap: () {
                          FocusScope.of(context)
                              .unfocus(); // Close the keyboard

                          String? education;
                          if (_studyLocationController.text.isNotEmpty) {
                            education = _studyLocationController.text;
                            ref
                                .read(userProvider.notifier)
                                .updateEducation(education);
                          } else {
                            education = null;
                          }

                          Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) =>
                                      const ReligionScreen()));
                        },
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: const Color(0xFF8B5CF6),
                            borderRadius: BorderRadius.circular(35),
                          ),
                          child: const Icon(
                            Icons.arrow_forward_rounded,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}



================================================
File: views/textpromptsselect.dart
================================================
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';

class TextSelectPromptScreen extends StatefulWidget {
  final int? editIndex;

  const TextSelectPromptScreen({
    super.key,
    this.editIndex,
  });

  @override
  State<TextSelectPromptScreen> createState() => _TextSelectPromptScreenState();
}

class _TextSelectPromptScreenState extends State<TextSelectPromptScreen> {
  PromptCategory selectedCategory = PromptCategory.storyTime;
  bool showAllPrompts = false;
  PromptType? selectedPrompt;

  List<PromptType> get currentPrompts {
    if (showAllPrompts) {
      return PromptCategory.values
          .expand((category) => category.getPrompts())
          .toList();
    }
    return selectedCategory.getPrompts();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  GestureDetector(
                    onTap: () {
                      setState(() {
                        showAllPrompts = !showAllPrompts;
                      });
                    },
                    child: Text(
                      'View all',
                      style: TextStyle(
                        color: const Color(0xFF8b5cf6),
                        fontSize: 16,
                        fontWeight:
                            showAllPrompts ? FontWeight.bold : FontWeight.w500,
                      ),
                    ),
                  ),
                  const Text(
                    'Prompts',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () => Navigator.pop(context),
                    child: const Icon(Icons.close),
                  ),
                ],
              ),
            ),
            if (!showAllPrompts)
              SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: Row(
                  children: PromptCategory.values.map((category) {
                    final isSelected = category == selectedCategory;
                    return Padding(
                      padding: const EdgeInsets.only(right: 8),
                      child: GestureDetector(
                        onTap: () =>
                            setState(() => selectedCategory = category),
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 20,
                            vertical: 10,
                          ),
                          decoration: BoxDecoration(
                            color: isSelected
                                ? const Color(0xFF8b5cf6)
                                : Colors.white,
                            borderRadius: BorderRadius.circular(20),
                            border: Border.all(
                              color: const Color(0xFF8b5cf6),
                              width: 1,
                            ),
                          ),
                          child: Text(
                            category.label,
                            style: TextStyle(
                              color: isSelected
                                  ? Colors.white
                                  : const Color(0xFF8b5cf6),
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ),
            const SizedBox(height: 16),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: currentPrompts.length,
                itemBuilder: (context, index) {
                  final promptType = currentPrompts[index];
                  return GestureDetector(
                    onTap: () {
                      final category = promptType.getCategory();
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => WriteAnswerScreen(
                            category: category,
                            question: promptType,
                            editIndex: widget.editIndex,
                          ),
                        ),
                      );
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                      ),
                      child: Text(
                        promptType.label,
                        style: const TextStyle(
                          fontSize: 16,
                          color: Colors.black87,
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/verification_message_screen.dart
================================================

import 'package:dtx/views/home.dart';
import 'package:dtx/views/selfie_capture_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationMessageScreen extends StatelessWidget {
  const VerificationMessageScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40), // Top spacing
              // Illustration or Icon
              Container(
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  shape: BoxShape.circle,
                ),
                child: Center(
                  child: Icon(
                    Icons.verified_user_outlined,
                    size: 100,
                    color: const Color(0xFF8B5CF6),
                  ),
                ),
              ),
              const SizedBox(height: 32),
              // Title
              Text(
                "Profile Verification",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 16),
              // Subtitle/Description
              Text(
                "We are verifying your profile to ensure that no one else can use your photo. This helps us keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),
              const Spacer(), // Pushes the button to the bottom
              // Continue Button
              GestureDetector(
onTap: () {
  // Navigate to HomeScreen
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(builder: (context) => const SelfieCaptureScreen(),
  ));
},
                child: Container(
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 32), // Bottom spacing
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/verification_pending_screen.dart
================================================
// File: views/verification_pending_screen.dart
import 'dart:io';
import 'package:dtx/utils/app_enums.dart'; // *** ADDED: Import FeedType ***
import 'package:dtx/views/home.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationPendingScreen extends StatelessWidget {
  final File? selfieImage; // Keep if you are passing the image

  const VerificationPendingScreen({
    Key? key,
    this.selfieImage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40),

              // Selfie preview (keep existing)
              Container(
                /* ... Selfie preview container ... */
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: const Color(0xFF8B5CF6),
                    width: 4,
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: const Color(0xFF8B5CF6).withOpacity(0.2),
                      blurRadius: 15,
                      spreadRadius: 5,
                    ),
                  ],
                ),
                child: ClipOval(
                  child: selfieImage != null
                      ? Image.file(
                          selfieImage!,
                          fit: BoxFit.cover,
                        )
                      : Container(
                          color: Colors.grey[200],
                          child: Icon(
                            Icons.person,
                            size: 80,
                            color: Colors.grey[400],
                          ),
                        ),
                ),
              ),

              const SizedBox(height: 32),

              // Title (keep existing)
              Text(
                "Verification in Progress",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),

              const SizedBox(height: 16),

              // Description (keep existing)
              Text(
                "We're verifying your profile to ensure no one else can use your photos. This helps keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),

              const SizedBox(height: 24),

              // Status indicator (keep existing)
              Container(
                /* ... Status indicator container ... */
                padding: const EdgeInsets.symmetric(
                  horizontal: 20,
                  vertical: 12,
                ),
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          Color(0xFF8B5CF6),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Text(
                      "Verification in progress",
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF8B5CF6),
                      ),
                    ),
                  ],
                ),
              ),

              const Spacer(),

              // Continue Button
              GestureDetector(
                onTap: () {
                  Navigator.pushAndRemoveUntil(
                    context,
                    MaterialPageRoute(
                      // *** FIX: Pass initialFeedType ***
                      builder: (context) =>
                          const HomeScreen(initialFeedType: FeedType.home),
                      // *** END FIX ***
                    ),
                    (route) => false,
                  );
                },
                child: Container(
                  /* ... Button container ... */
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue Swiping",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),

              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/who_liked_you_screen.dart
================================================
// File: views/who_liked_you_screen.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/views/liker_profile_screen.dart'; // Import Liker Profile Screen
import 'package:dtx/widgets/basic_liker_profile_card.dart';
import 'package:dtx/widgets/full_liker_profile_card.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class WhoLikedYouScreen extends ConsumerStatefulWidget {
  const WhoLikedYouScreen({super.key});

  @override
  ConsumerState<WhoLikedYouScreen> createState() => _WhoLikedYouScreenState();
}

class _WhoLikedYouScreenState extends ConsumerState<WhoLikedYouScreen> {
  @override
  void initState() {
    super.initState();
    // Fetch likes when the screen initializes
    // Use addPostFrameCallback to avoid calling during build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      print("[WhoLikedYouScreen] Initial fetch triggered.");
      ref.read(receivedLikesProvider.notifier).fetchLikes();
    });
  }

  // Function to handle tapping on a liker card
  void _navigateToLikerProfile(int likerUserId) {
    print(
        "[WhoLikedYouScreen] Navigating to profile for liker ID: $likerUserId");
    // Clear any previous error before navigating
    ref.read(errorProvider.notifier).clearError();
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => LikerProfileScreen(likerUserId: likerUserId),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(receivedLikesProvider);
    final error = ref.watch(errorProvider); // Watch general errors too

    return Scaffold(
      backgroundColor: Colors.grey[50], // Light background
      appBar: AppBar(
        title: Text(
          "Likes You've Received",
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
        ),
        elevation: 1,
        backgroundColor: Colors.white,
        foregroundColor: Colors.black, // Back button color
      ),
      body: RefreshIndicator(
        color: const Color(0xFF8B5CF6), // Themed refresh indicator
        onRefresh: () => ref.read(receivedLikesProvider.notifier).fetchLikes(),
        child: _buildBody(state, error),
      ),
    );
  }

  Widget _buildBody(ReceivedLikesState state, AppError? generalError) {
    if (state.isLoading &&
        state.fullProfiles.isEmpty &&
        state.otherLikers.isEmpty) {
      return const Center(
          child: CircularProgressIndicator(color: Color(0xFF8B5CF6)));
    }

    // Display provider-specific error first
    if (state.error != null) {
      return _buildErrorState(state.error!.message);
    }
    // Display general error if provider error is null
    if (generalError != null) {
      return _buildErrorState(generalError.message);
    }

    if (state.fullProfiles.isEmpty && state.otherLikers.isEmpty) {
      return _buildEmptyState();
    }

    // Use CustomScrollView for combining different list types
    return CustomScrollView(
      slivers: [
        // Section Header for Full Profiles
        if (state.fullProfiles.isNotEmpty)
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 20, 16, 12),
              child: Text(
                "Recent Likes & Roses", // Or just "Likes"
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[800],
                ),
              ),
            ),
          ),

        // Grid for Full Profiles
        if (state.fullProfiles.isNotEmpty)
          SliverPadding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            sliver: SliverGrid(
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2, // Two columns
                crossAxisSpacing: 12,
                mainAxisSpacing: 12,
                childAspectRatio: 0.75, // Adjust aspect ratio as needed
              ),
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  final liker = state.fullProfiles[index];
                  return FullLikerProfileCard(
                    liker: liker,
                    onTap: () => _navigateToLikerProfile(liker.likerUserId),
                  );
                },
                childCount: state.fullProfiles.length,
              ),
            ),
          ),

        // Section Header for Other Likers
        if (state.otherLikers.isNotEmpty)
          SliverToBoxAdapter(
            child: Padding(
              padding: EdgeInsets.fromLTRB(
                  16,
                  state.fullProfiles.isNotEmpty ? 24 : 20,
                  16,
                  12), // Adjust top padding
              child: Text(
                state.fullProfiles.isNotEmpty
                    ? "Older Likes"
                    : "Likes", // Adjust title
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[800],
                ),
              ),
            ),
          ),

        // List for Other Likers
        if (state.otherLikers.isNotEmpty)
          SliverPadding(
            padding: const EdgeInsets.fromLTRB(16, 0, 16, 16), // Add padding
            sliver: SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  final liker = state.otherLikers[index];
                  return Padding(
                    padding: const EdgeInsets.only(
                        bottom: 10.0), // Spacing between basic cards
                    child: BasicLikerProfileCard(
                      liker: liker,
                      onTap: () => _navigateToLikerProfile(liker.likerUserId),
                    ),
                  );
                },
                childCount: state.otherLikers.length,
              ),
            ),
          ),
        // Add some bottom padding
        const SliverToBoxAdapter(child: SizedBox(height: 20)),
      ],
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(30.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.favorite_border_rounded,
                size: 70, color: Colors.grey[300]),
            const SizedBox(height: 20),
            Text(
              "No Likes Yet",
              style: GoogleFonts.poppins(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[700]),
            ),
            const SizedBox(height: 10),
            Text(
              "Keep swiping! Someone is bound to like you soon.",
              textAlign: TextAlign.center,
              style: GoogleFonts.poppins(fontSize: 15, color: Colors.grey[500]),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildErrorState(String message) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(30.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                size: 60, color: Colors.redAccent[100]),
            const SizedBox(height: 20),
            Text(
              "Oops!",
              style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[700]),
            ),
            const SizedBox(height: 10),
            Text(
              message,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded, size: 18),
              label: const Text("Retry"),
              style: ElevatedButton.styleFrom(
                foregroundColor: Colors.white,
                backgroundColor: const Color(0xFF8B5CF6),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20)),
                padding:
                    const EdgeInsets.symmetric(horizontal: 30, vertical: 12),
              ),
              onPressed: () =>
                  ref.read(receivedLikesProvider.notifier).fetchLikes(),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/writeprompt.dart
================================================
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/prompt.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/models/user_model.dart';

class WriteAnswerScreen extends ConsumerStatefulWidget {
  final PromptCategory category;
  final PromptType question;
  final int? editIndex;

  const WriteAnswerScreen({
    super.key,
    required this.category,
    required this.question,
    this.editIndex,
  });

  @override
  ConsumerState<WriteAnswerScreen> createState() => _WriteAnswerScreenState();
}

class _WriteAnswerScreenState extends ConsumerState<WriteAnswerScreen> {
  late final TextEditingController _answerController;

  @override
  void initState() {
    super.initState();
    _answerController = TextEditingController();
    _loadExistingAnswer();

    // Add listener to update UI when text changes
    _answerController.addListener(() {
      setState(() {}); // This triggers a rebuild when text changes
    });
  }

  void _loadExistingAnswer() {
    if (widget.editIndex != null) {
      final prompts = ref.read(userProvider).prompts;
      if (widget.editIndex! < prompts.length) {
        _answerController.text = prompts[widget.editIndex!].answer;
      }
    }
  }

  void _saveAnswer() {
    if (_answerController.text.trim().isNotEmpty) {
      final newPrompt = Prompt(
        category: widget.category,
        question: widget.question,
        answer: _answerController.text.trim(),
      );

      if (widget.editIndex != null) {
        ref.read(userProvider.notifier).updatePromptAtIndex(
              widget.editIndex!,
              newPrompt,
            );
      } else {
        ref.read(userProvider.notifier).addPrompt(newPrompt);
      }

                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const ProfileAnswersScreen()
                          ));
    }
  }

  @override
  void dispose() {
    _answerController.dispose(); // Clean up the controller
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 1,
        centerTitle: true,
        title: const Text(
          'Write Answer',
          style: TextStyle(
            color: Colors.black,
            fontSize: 18,
            fontWeight: FontWeight.w700,
          ),
        ),
        leadingWidth: 80,
        leading: GestureDetector(
          onTap: () => Navigator.pop(context),
          child: const Center(
            child: Text(
              'Cancel',
              style: TextStyle(
                color: Color(0xFF8B5CF6),
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed:
                _answerController.text.trim().isNotEmpty ? _saveAnswer : null,
            child: Text(
              'Done',
              style: TextStyle(
                color: _answerController.text.trim().isNotEmpty
                    ? const Color(0xFF8B5CF6)
                    : const Color(0xFF8B5CF6).withOpacity(0.5),
                fontSize: 16,
                fontWeight: FontWeight.w700,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          const SizedBox(height: 64),
          Container(
            margin: const EdgeInsets.symmetric(horizontal: 16),
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: const Color(0xFF8B5CF6).withOpacity(0.3),
                width: 2,
              ),
              boxShadow: [
                BoxShadow(
                  color: Colors.grey.withOpacity(0.1),
                  spreadRadius: 2,
                  blurRadius: 8,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: Text(
                    widget.question.label,
                    style: const TextStyle(
                      fontSize: 17,
                      fontWeight: FontWeight.w600,
                      color: Colors.black87,
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Icon(
                  Icons.edit_rounded,
                  color: const Color(0xFF8B5CF6).withOpacity(0.8),
                  size: 24,
                ),
              ],
            ),
          ),
          const SizedBox(height: 54),
          Container(
            height: 200,
            margin: const EdgeInsets.symmetric(horizontal: 16),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: const Color(0xFFE5E7EB),
                width: 1.5,
              ),
            ),
            child: Stack(
              children: [
                Padding(
                  padding: const EdgeInsets.all(16),
                  child: TextField(
                    controller: _answerController,
                    maxLength: 255,
                    maxLines: null,
                    style: const TextStyle(
                      fontSize: 16,
                      color: Colors.black87,
                      height: 1.4,
                    ),
                    decoration: const InputDecoration(
                      border: InputBorder.none,
                      hintText: 'Type your answer here...',
                      hintStyle: TextStyle(
                        color: Color(0xFF94A3B8),
                        fontSize: 16,
                        fontWeight: FontWeight.w400,
                      ),
                      counterText: '',
                    ),
                  ),
                ),
                Positioned(
                  right: 16,
                  bottom: 16,
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.grey[100],
                      borderRadius: BorderRadius.circular(6),
                    ),
                    child: Text(
                      '${_answerController.text.length}/255',
                      style: const TextStyle(
                        color: Color(0xFF64748B),
                        fontSize: 13,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),
        ],
      ),
    );
  }
}



================================================
File: views/youtube.dart
================================================
import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:flutter/services.dart'; // Required for Clipboard

// --- Configuration (kept outside the widget for clarity) ---

// Define the necessary YouTube scope
const List<String> _scopes = <String>[
  'https://www.googleapis.com/auth/youtube.readonly',
];

// Instantiate GoogleSignIn with the defined scopes
// You might want to manage this instance more globally in your app
// (e.g., using a service locator or provider) if other parts need it,
// but keeping it here works for a self-contained screen.
final GoogleSignIn _googleSignIn = GoogleSignIn(
  scopes: _scopes,
);

// --- Screen Widget ---

class YoutubeSignInScreen extends StatefulWidget {
  // You can add parameters here if needed, e.g., callbacks for when login succeeds/fails
  // final VoidCallback? onLoginSuccess;
  // final Function(String)? onTokenReceived;

  const YoutubeSignInScreen({
    super.key,
    // this.onLoginSuccess,
    // this.onTokenReceived,
  });

  @override
  State<YoutubeSignInScreen> createState() => _YoutubeSignInScreenState();
}

class _YoutubeSignInScreenState extends State<YoutubeSignInScreen> {
  GoogleSignInAccount? _currentUser;
  String _message = 'Not logged in';
  String? _accessToken; // To store the access token
  bool _isSigningIn = false; // To prevent multiple sign-in attempts
  bool _isFetchingToken = false; // To show progress while getting token

  @override
  void initState() {
    super.initState();

    // Listen for user changes (e.g., sign out from elsewhere or successful sign-in)
    _googleSignIn.onCurrentUserChanged.listen((GoogleSignInAccount? account) {
      // Important: Check if the widget is still mounted before calling setState
      if (mounted) {
        _updateUser(account);
      }
    }).onError((error) {
      // Handle stream errors if necessary
      print("Error listening to user changes: $error");
      if (mounted) {
        setState(() {
          _message = "Error listening for user changes.";
          _currentUser = null;
          _accessToken = null;
        });
      }
    });

    // Try silent sign-in on screen initialization
    // Make sure this doesn't interfere with other login logic in your app
    _googleSignIn.signInSilently().then((account) {
      // No need to call _updateUser here, the listener above will handle it
    }).catchError((err) {
      print('Error during silent sign-in attempt: $err');
      // Don't necessarily show an error here, silent sign-in failing is common
      if (mounted) {
        setState(() {
          _message = 'Not logged in (silent sign-in failed or not available)';
        });
      }
    });
  }

  @override
  void dispose() {
    // It's generally good practice to cancel stream subscriptions,
    // though onCurrentUserChanged might be managed internally by the plugin.
    // If you had custom StreamSubscriptions, you'd cancel them here.
    super.dispose();
  }

  void _updateUser(GoogleSignInAccount? account) async {
    // Check mounted again just to be safe, especially with async operations
    if (!mounted) return;

    setState(() {
      _currentUser = account;
      _accessToken = null; // Reset token when user changes
      _isFetchingToken = account != null; // Start fetching if user is not null
      if (_currentUser != null) {
        _message =
            "Logged in as ${_currentUser!.displayName ?? _currentUser!.email}";
      } else {
        _message = "Not logged in";
      }
    });

    // If user is logged in, print details and get the access token
    if (_currentUser != null) {
      // --- ADDED: Print User Details to Console ---
      print("--- Google User Details ---");
      print(
          "Display Name: ${_currentUser!.displayName ?? 'Not Provided'}"); // Handle potential null display name
      print("Email: ${_currentUser!.email}");
      print("User ID: ${_currentUser!.id}"); // Added User ID as well
      print("---------------------------");
      // --- END ADDED ---

      await _getAccessToken();
    }
  }

  // Function to get the access token
  Future<void> _getAccessToken() async {
    if (_currentUser == null) return;

    // Ensure mounted check before async operation and setState
    if (!mounted) return;

    setState(() {
      _isFetchingToken = true; // Show loading indicator
    });

    try {
      final GoogleSignInAuthentication auth =
          await _currentUser!.authentication;
      if (mounted) {
        // Check again after await
        setState(() {
          _accessToken = auth.accessToken;
          _isFetchingToken = false; // Hide loading indicator
          print("Access Token: $_accessToken"); // Print for debugging
          print("ID Token: ${auth.idToken}"); // Also available
          // Optional: Call a callback if provided via widget constructor
          // widget.onTokenReceived?.call(_accessToken!);
        });
      }
    } catch (err) {
      print('Error getting authentication token: $err');
      if (mounted) {
        // Check again after await
        setState(() {
          _message = 'Error getting token: $err';
          _accessToken = null;
          _isFetchingToken = false; // Hide loading indicator
        });
      }
    }
  }

  // Sign-in function
  Future<void> _handleSignIn() async {
    if (_isSigningIn) return; // Prevent double taps

    if (!mounted) return;
    setState(() {
      _isSigningIn = true;
      _message = "Signing in..."; // Provide feedback
    });

    try {
      // Start the sign-in process
      await _googleSignIn.signIn();
      // The onCurrentUserChanged listener will handle the update upon success.
      // If signIn() returns null (user cancelled), the listener will also get null.
    } catch (error) {
      print('Error signing in: $error');
      if (mounted) {
        // Check after await
        setState(() {
          _message = 'Error signing in: $error';
          _accessToken = null; // Clear token on error
        });
      }
    } finally {
      if (mounted) {
        // Check in finally block
        setState(() {
          _isSigningIn = false; // Allow sign-in attempts again
          // If _currentUser is still null here, sign-in likely failed or was cancelled
          if (_currentUser == null && !_message.startsWith("Error")) {
            _message = "Sign in cancelled or failed.";
          }
        });
      }
    }
  }

  // Sign-out function
  Future<void> _handleSignOut() async {
    if (!mounted) return;

    setState(() {
      _message = "Signing out...";
    });

    try {
      // Disconnect removes permissions, signOut just logs out locally
      await _googleSignIn.disconnect();
      // The onCurrentUserChanged listener handles the UI update.
    } catch (error) {
      print('Error signing out: $error');
      if (mounted) {
        // Check after await
        setState(() {
          // Restore user info if disconnect fails? Or keep logged-out state?
          // Keeping logged-out state might be less confusing.
          _message = 'Error signing out: $error';
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Determine button states
    final bool canSignIn = !_isSigningIn && _currentUser == null;
    final bool canSignOut = _currentUser != null;
    final bool showTokenInfo = _currentUser != null;
    final bool showCopyButton = _accessToken != null;

    return Scaffold(
      // You might want to remove this AppBar if the screen is embedded
      // within another Scaffold that already has one.
      appBar: AppBar(
        title: const Text('YouTube Account Login'),
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment:
                CrossAxisAlignment.center, // Center items horizontally
            children: <Widget>[
              // Display User Info or Status Message
              if (showTokenInfo) ...[
                ListTile(
                  leading: GoogleUserCircleAvatar(identity: _currentUser!),
                  title: Text(_currentUser!.displayName ?? 'No Name'),
                  subtitle: Text(_currentUser!.email),
                  contentPadding: EdgeInsets.zero, // Adjust padding if needed
                ),
                const SizedBox(height: 20),
                const Text("Access Token:",
                    style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 5),
                if (_isFetchingToken)
                  const Padding(
                    padding: EdgeInsets.symmetric(vertical: 10.0),
                    child: CircularProgressIndicator(),
                  )
                else if (_accessToken != null)
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey.shade300),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: SelectableText(
                      _accessToken!,
                      style: const TextStyle(fontSize: 12),
                      textAlign: TextAlign.center,
                      maxLines: 5, // Limit display lines if needed
                      scrollPhysics:
                          const ClampingScrollPhysics(), // Prevent scrolling within text box
                    ),
                  )
                else
                  const Text("Could not retrieve token.",
                      style:
                          TextStyle(color: Colors.red)), // Show if fetch failed
                const SizedBox(height: 10),
                ElevatedButton.icon(
                  icon: const Icon(Icons.copy, size: 16),
                  label: const Text('Copy Token'),
                  onPressed: showCopyButton
                      ? () {
                          Clipboard.setData(ClipboardData(text: _accessToken!));
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text('Access Token Copied!'),
                                duration: Duration(seconds: 2)),
                          );
                        }
                      : null, // Disable button if no token
                ),
              ] else ...[
                // Show Status Message when logged out or during sign-in process
                Text(_message, textAlign: TextAlign.center),
                const SizedBox(height: 20),
              ],

              const Spacer(), // Pushes buttons towards the bottom if desired

              // Sign In / Sign Out Buttons
              if (canSignIn)
                ElevatedButton.icon(
                  icon: const Icon(Icons.login),
                  label: const Text('Sign In with Google'),
                  onPressed: _handleSignIn,
                  style: ElevatedButton.styleFrom(
                      minimumSize:
                          const Size(200, 40)), // Ensure decent button size
                )
              else if (_isSigningIn)
                const CircularProgressIndicator() // Show progress during sign-in action
              else if (canSignOut)
                ElevatedButton.icon(
                  icon: const Icon(Icons.logout),
                  label: const Text('Sign Out & Disconnect'),
                  onPressed: _handleSignOut,
                  style: ElevatedButton.styleFrom(
                      backgroundColor:
                          Colors.redAccent, // Indicate destructive action
                      minimumSize: const Size(200, 40)),
                ),
              const SizedBox(height: 20), // Add some padding at the bottom
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/core/error_handler.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/models/error_model.dart';

class GlobalErrorHandler extends ConsumerWidget {
  final Widget child;
  const GlobalErrorHandler({super.key, required this.child});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final error = ref.watch(errorProvider);

    return Stack(
      children: [
        child,
        if (error != null) _buildErrorOverlay(context, error, ref),
      ],
    );
  }

  Widget _buildErrorOverlay(
      BuildContext context, AppError error, WidgetRef ref) {
    return Positioned.fill(
      child: Material(
        color: Colors.black54,
        child: Center(
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 20),
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  error.message,
                  style: const TextStyle(fontSize: 16),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () =>
                      ref.read(errorProvider.notifier).clearError(),
                  child: const Text('OK'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: widgets/basic_liker_profile_card.dart
================================================
// File: widgets/basic_liker_profile_card.dart
import 'package:dtx/models/like_models.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart'; // For date formatting

class BasicLikerProfileCard extends StatelessWidget {
  final BasicProfileLiker liker;
  final VoidCallback onTap;

  const BasicLikerProfileCard({
    super.key,
    required this.liker,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final timeAgo = liker.likedAt != null
        ? DateFormat.yMd().add_jm().format(liker.likedAt!) // Example format
        : 'Some time ago';

    return InkWell(
      // Make the card tappable
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.grey.shade200),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.03),
              blurRadius: 5,
              offset: const Offset(0, 1),
            )
          ],
        ),
        child: Row(
          children: [
            // Profile Picture Placeholder/Image
            CircleAvatar(
              radius: 25,
              backgroundColor: Colors.grey[200],
              backgroundImage: (liker.firstProfilePicUrl != null)
                  ? NetworkImage(liker.firstProfilePicUrl!)
                  : null,
              child: (liker.firstProfilePicUrl == null)
                  ? Icon(Icons.person, color: Colors.grey[400])
                  : null,
            ),
            const SizedBox(width: 12),
            // Name and Like Info
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    liker.name.isNotEmpty ? liker.name : 'Unknown User',
                    style: GoogleFonts.poppins(
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'Liked you $timeAgo',
                    style: GoogleFonts.poppins(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 8),
            // Rose/Comment Indicators
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                if (liker.isRose)
                  Icon(Icons.star_rounded,
                      color: Colors.purple.shade300, size: 20),
                if (liker.likeComment != null &&
                    liker.likeComment!.isNotEmpty) ...[
                  if (liker.isRose) const SizedBox(width: 4), // Spacing if both
                  Icon(Icons.chat_bubble_outline_rounded,
                      color: Colors.blue.shade300, size: 18),
                ]
              ],
            )
          ],
        ),
      ),
    );
  }
}



================================================
File: widgets/full_liker_profile_card.dart
================================================
// File: widgets/full_liker_profile_card.dart
import 'package:dtx/models/like_models.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart'; // For date formatting

class FullLikerProfileCard extends StatelessWidget {
  // --- FIX: Correct class name ---
  final FullProfileLiker liker;
  // --- END FIX ---
  final VoidCallback onTap;

  const FullLikerProfileCard({
    super.key,
    required this.liker,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final profile = liker.profile;
    final age = profile.age;
    final firstImage = profile.firstMediaUrl;
    final timeAgo = liker.likedAt != null
        ? DateFormat.yMd().add_jm().format(liker.likedAt!) // Example format
        : 'Some time ago';

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(15.0),
      child: Container(
        // Removed fixed height to allow content to define height
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(15.0),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
          image: firstImage != null
              ? DecorationImage(
                  image: NetworkImage(firstImage),
                  fit: BoxFit.cover,
                  onError: (err, st) => print(
                      "Error loading image $firstImage: $err"), // Add error logging
                  colorFilter: ColorFilter.mode(
                    Colors.black.withOpacity(0.3),
                    BlendMode.darken,
                  ),
                )
              : null, // No image if null
          color: firstImage == null
              ? Colors.grey[300]
              : Colors.white, // Placeholder color or white background
        ),
        child: Stack(
          children: [
            // Placeholder Icon if no image
            if (firstImage == null)
              Center(
                  child: Icon(Icons.person, size: 60, color: Colors.grey[500])),

            // Gradient Overlay for text (only if image exists)
            if (firstImage != null)
              Positioned.fill(
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(15.0),
                    gradient: LinearGradient(
                        colors: [
                          Colors.transparent,
                          Colors.black.withOpacity(0.7)
                        ],
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        stops: const [0.4, 1.0]),
                  ),
                ),
              ),

            // Info Text
            Positioned(
              bottom: 12,
              left: 12,
              right: 12,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Name & Age
                  Text(
                    '${profile.name ?? 'Unknown User'}${age != null ? ', $age' : ''}',
                    style: GoogleFonts.poppins(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      // Adjust text color based on background
                      color: firstImage != null ? Colors.white : Colors.black87,
                      shadows: firstImage != null
                          ? [
                              Shadow(
                                  blurRadius: 2,
                                  color: Colors.black.withOpacity(0.7))
                            ]
                          : [],
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),

                  // Like Timestamp
                  Text(
                    'Liked you $timeAgo',
                    style: GoogleFonts.poppins(
                      fontSize: 11,
                      color: firstImage != null
                          ? Colors.white.withOpacity(0.8)
                          : Colors.grey[600],
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),

                  // Comment Preview (if exists)
                  if (liker.likeComment != null &&
                      liker.likeComment!.isNotEmpty) ...[
                    const SizedBox(height: 6),
                    Row(
                      children: [
                        Icon(Icons.chat_bubble_outline_rounded,
                            color: firstImage != null
                                ? Colors.white.withOpacity(0.8)
                                : Colors.blue.shade300,
                            size: 14),
                        const SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            '"${liker.likeComment!}"',
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              fontStyle: FontStyle.italic,
                              color: firstImage != null
                                  ? Colors.white.withOpacity(0.9)
                                  : Colors.black87,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ],
                    ),
                  ],
                ],
              ),
            ),

            // Rose Indicator (Top Right)
            if (liker.isRose)
              Positioned(
                top: 8,
                right: 8,
                child: Container(
                  padding: const EdgeInsets.all(5),
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.5),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(Icons.star_rounded,
                      color: Colors.yellow.shade600, size: 18),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: widgets/home_profile_card.dart
================================================
// File: widgets/home_profile_card.dart
import 'package:dtx/models/feed_models.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/providers/audio_player_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/providers/user_provider.dart'; // Make sure this is imported
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

// Function Type Definitions
typedef LikeContentCallback = void Function(
    ContentLikeType type, String identifier, String? comment);
typedef SendRoseCallback = void Function(String? comment);

// State Provider for media index
final _currentMediaIndexProvider = StateProvider.autoDispose<int>((ref) => 0);

class HomeProfileCard extends ConsumerWidget {
  final HomeFeedProfile profile;
  final LikeContentCallback onLikeContent;
  final SendRoseCallback onSendRose;

  // Assume profile data might be incomplete; provide default empty lists/nulls
  List<Prompt> get prompts =>
      (profile as dynamic).prompts as List<Prompt>? ??
      []; // Adjust based on actual structure if different
  AudioPromptModel? get audioPrompt => (profile as dynamic).audioPrompt
      as AudioPromptModel?; // Adjust cast if needed

  const HomeProfileCard({
    super.key,
    required this.profile,
    required this.onLikeContent,
    required this.onSendRose,
  });

  void _triggerStandardLike(BuildContext context, WidgetRef ref,
      ContentLikeType type, String identifier) async {
    print("[HomeProfileCard] Standard Like tapped for $type:$identifier");
    final currentUser = ref.read(userProvider);
    final bool isMale = currentUser.gender == Gender.man;
    print(
        "[HomeProfileCard] Current user gender: ${currentUser.gender?.value ?? 'Unknown'}, IsMale: $isMale");

    String? comment;
    bool proceedWithLike = false;

    comment = await _showCommentDialog(context, isOptional: !isMale);

    if (isMale) {
      if (comment != null && comment.isNotEmpty) {
        proceedWithLike = true;
        print("[HomeProfileCard] Male user provided required comment.");
      } else {
        print(
            "[HomeProfileCard] Male user cancelled or left comment empty. Like aborted.");
      }
    } else {
      proceedWithLike = true;
      print(
          "[HomeProfileCard] Female user like attempt. Comment: ${comment ?? 'None'}. Proceeding.");
    }

    if (proceedWithLike) {
      onLikeContent(type, identifier, comment);
    }
  }

  void _triggerRoseLike(BuildContext context, WidgetRef ref) async {
    print("[HomeProfileCard] Rose tapped for user ${profile.id}");
    String? comment = await _showCommentDialog(context, isOptional: true);
    onSendRose(comment);
  }

  Future<String?> _showCommentDialog(BuildContext context,
      {bool isOptional = false}) async {
    final TextEditingController commentController = TextEditingController();
    String title =
        isOptional ? "Add a Comment? (Optional)" : "Add a Comment (Required)";
    ValueNotifier<bool> sendEnabledNotifier = ValueNotifier<bool>(isOptional);

    if (!isOptional) {
      commentController.addListener(() {
        sendEnabledNotifier.value = commentController.text.trim().isNotEmpty;
      });
    }

    return showDialog<String>(
      context: context,
      barrierDismissible: isOptional,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
          title: Text(title,
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          content: TextField(
            controller: commentController,
            decoration: InputDecoration(
              hintText: "Your comment...",
              border:
                  OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
              counterText: "",
            ),
            maxLength: 140,
            maxLines: 3,
            minLines: 1,
            autofocus: true,
            onChanged: (text) {
              if (!isOptional) {
                sendEnabledNotifier.value = text.trim().isNotEmpty;
              }
            },
          ),
          actions: <Widget>[
            TextButton(
              child: Text("Cancel",
                  style: GoogleFonts.poppins(color: Colors.grey)),
              onPressed: () => Navigator.of(dialogContext).pop(null),
            ),
            ValueListenableBuilder<bool>(
              valueListenable: sendEnabledNotifier,
              builder: (context, isEnabled, child) {
                return TextButton(
                  child: Text("Send",
                      style: GoogleFonts.poppins(
                          color:
                              isEnabled ? const Color(0xFF8B5CF6) : Colors.grey,
                          fontWeight: FontWeight.w600)),
                  onPressed: isEnabled
                      ? () => Navigator.of(dialogContext)
                          .pop(commentController.text.trim())
                      : null,
                );
              },
            ),
          ],
        );
      },
    ).whenComplete(() {
      if (!isOptional) {
        // Safely remove listener if it was added
        try {
          commentController.removeListener(() {});
        } catch (e) {}
      }
      sendEnabledNotifier.dispose();
      commentController.dispose();
    });
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final age = profile.age;
    final mediaUrls = profile.mediaUrls ?? [];
    final screenWidth = MediaQuery.of(context).size.width;
    final audioState = ref.watch(audioPlayerControllerProvider);
    final currentPlayerUrl = ref.watch(currentAudioUrlProvider);
    final currentMediaIndex = ref.watch(_currentMediaIndexProvider);

    // Access prompts and audio from the actual profile object
    // Handle potential null or incorrect type casting safely
    final List<Prompt> profilePrompts =
        (profile is UserModel) ? (profile as UserModel).prompts : [];
    final AudioPromptModel? profileAudio =
        (profile is UserModel) ? (profile as UserModel).audioPrompt : null;

    return Card(
      clipBehavior: Clip.antiAlias,
      elevation: 5,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      margin: EdgeInsets.zero, // Let the parent Stack handle padding/margin
      child: SingleChildScrollView(
        physics:
            const NeverScrollableScrollPhysics(), // Prevent card itself from scrolling
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Media Gallery
            if (mediaUrls.isNotEmpty)
              SizedBox(
                // Adjust height dynamically or use AspectRatio if needed
                height: MediaQuery.of(context).size.height *
                    0.6, // Example: 60% of screen height
                child: Stack(
                  alignment: Alignment.bottomCenter,
                  children: [
                    PageView.builder(
                      itemCount: mediaUrls.length,
                      onPageChanged: (index) {
                        ref.read(_currentMediaIndexProvider.notifier).state =
                            index;
                      },
                      itemBuilder: (context, index) {
                        return Container(
                          color: Colors.grey[200],
                          child: Image.network(
                            mediaUrls[index],
                            fit: BoxFit.cover,
                            errorBuilder: (ctx, err, st) => Center(
                                child: Icon(Icons.broken_image_outlined,
                                    size: 60, color: Colors.grey[400])),
                            loadingBuilder: (ctx, child, progress) =>
                                progress == null
                                    ? child
                                    : Center(
                                        child: CircularProgressIndicator(
                                            value: progress
                                                        .expectedTotalBytes !=
                                                    null
                                                ? progress
                                                        .cumulativeBytesLoaded /
                                                    progress.expectedTotalBytes!
                                                : null,
                                            color: const Color(0xFF8B5CF6))),
                          ),
                        );
                      },
                    ),
                    // Gradient, Like/Rose buttons, Name/Age/Distance, Page Indicator (remain the same)
                    Positioned.fill(
                      child: Container(
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [
                              Colors.transparent,
                              Colors.black.withOpacity(0.8)
                            ],
                            begin: Alignment.topCenter,
                            end: Alignment.bottomCenter,
                            stops: const [0.6, 1.0],
                          ),
                        ),
                      ),
                    ),
                    Positioned(
                      top: 12 +
                          MediaQuery.of(context)
                              .padding
                              .top, // Adjust for status bar
                      right: 12,
                      child: _buildLikeButton(context, ref,
                          isLiked:
                              false, // Determine actual like status if needed
                          onTap: () => _triggerStandardLike(
                              context,
                              ref,
                              ContentLikeType.media,
                              currentMediaIndex.toString())),
                    ),
                    Positioned(
                      bottom: 12,
                      right: 12,
                      child: InkWell(
                        onTap: () => _triggerRoseLike(context, ref),
                        borderRadius: BorderRadius.circular(25),
                        child: Container(
                          padding: const EdgeInsets.all(10),
                          decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle),
                          child: Icon(Icons.star_rounded,
                              color: Colors.yellow.shade600, size: 28),
                        ),
                      ),
                    ),
                    Positioned(
                      bottom: 15,
                      left: 15,
                      right: 70,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            '${profile.name ?? 'User'}${age != null ? ', $age' : ''}',
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: GoogleFonts.poppins(
                                fontSize: 28,
                                fontWeight: FontWeight.bold,
                                color: Colors.white,
                                shadows: [
                                  Shadow(
                                      blurRadius: 3,
                                      color: Colors.black.withOpacity(0.6))
                                ]),
                          ),
                          const SizedBox(height: 5),
                          if (profile.distanceKm != null)
                            Row(
                              children: [
                                Icon(Icons.location_on_outlined,
                                    color: Colors.white.withOpacity(0.9),
                                    size: 16),
                                const SizedBox(width: 4),
                                Text(
                                    '${profile.distanceKm?.toStringAsFixed(1)} km away',
                                    style: GoogleFonts.poppins(
                                        fontSize: 14,
                                        color: Colors.white.withOpacity(0.9))),
                              ],
                            ),
                        ],
                      ),
                    ),
                    if (mediaUrls.length > 1)
                      Positioned(
                        bottom: 8.0,
                        left: 0,
                        right: 0,
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: List.generate(
                              mediaUrls.length,
                              (index) => AnimatedContainer(
                                    duration: const Duration(milliseconds: 200),
                                    width: currentMediaIndex == index ? 12 : 8,
                                    height: 8,
                                    margin: const EdgeInsets.symmetric(
                                        horizontal: 3),
                                    decoration: BoxDecoration(
                                        borderRadius: BorderRadius.circular(4),
                                        color: currentMediaIndex == index
                                            ? const Color(0xFF8B5CF6)
                                            : Colors.white.withOpacity(0.5)),
                                  )),
                        ),
                      ),
                  ],
                ),
              )
            else
              Container(
                // Placeholder if no media
                height: MediaQuery.of(context).size.height * 0.6,
                color: Colors.grey[200],
                child: Center(
                    child: Icon(Icons.person_outline,
                        size: 100, color: Colors.grey[400])),
              ),

            // Prompts Section
            if (profilePrompts.isNotEmpty)
              Padding(
                padding: const EdgeInsets.fromLTRB(16, 20, 16, 12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: profilePrompts
                      .map((p) => _buildPromptWidget(context, ref, p))
                      .toList(),
                ),
              ),

            // Audio Prompt Section
            if (profileAudio != null)
              Padding(
                padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
                child: _buildAudioWidget(
                    context, ref, profileAudio, audioState, currentPlayerUrl),
              ),

            // Fallback spacing if no prompts/audio
            if (profilePrompts.isEmpty && profileAudio == null)
              const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }

  Widget _buildLikeButton(BuildContext context, WidgetRef ref,
      {required bool isLiked, required VoidCallback onTap}) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.4),
          shape: BoxShape.circle,
        ),
        child: Icon(
          isLiked ? Icons.favorite_rounded : Icons.favorite_border_rounded,
          color: isLiked ? Colors.redAccent : Colors.white,
          size: 24,
        ),
      ),
    );
  }

  Widget _buildPromptWidget(
      BuildContext context, WidgetRef ref, Prompt prompt) {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.grey[100],
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200, width: 1),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  prompt.question.label,
                  style: GoogleFonts.poppins(
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                    color: const Color(0xFF8B5CF6),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  prompt.answer,
                  style: GoogleFonts.poppins(
                    fontSize: 15,
                    color: Colors.grey[800],
                    height: 1.4,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 8),
          _buildLikeButton(
            context,
            ref,
            isLiked: false, // Determine actual like status if needed
            // --- FIX: Use category.contentType getter ---
            onTap: () => _triggerStandardLike(context, ref,
                prompt.category.contentType, prompt.question.value),
            // --- END FIX ---
          ),
        ],
      ),
    );
  }

  Widget _buildAudioWidget(
      BuildContext context,
      WidgetRef ref,
      AudioPromptModel audio,
      AudioPlayerState audioState,
      String? currentPlayerUrl) {
    final bool isThisPlaying = currentPlayerUrl == audio.audioUrl &&
        audioState == AudioPlayerState.playing;
    final bool isThisLoading = currentPlayerUrl == audio.audioUrl &&
        audioState == AudioPlayerState.loading;
    final bool isThisPaused = currentPlayerUrl == audio.audioUrl &&
        audioState == AudioPlayerState.paused;
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.grey[100],
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200, width: 1),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            audio.prompt.label,
            style: GoogleFonts.poppins(
                fontSize: 14,
                fontWeight: FontWeight.w600,
                color: const Color(0xFF8B5CF6)),
          ),
          const SizedBox(height: 12),
          Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              InkWell(
                onTap: () {
                  if (isThisLoading) return;
                  final playerNotifier =
                      ref.read(audioPlayerControllerProvider.notifier);
                  if (isThisPlaying)
                    playerNotifier.pause();
                  else if (isThisPaused)
                    playerNotifier.resume();
                  else
                    playerNotifier.play(audio.audioUrl);
                },
                borderRadius: BorderRadius.circular(25),
                child: Container(
                  width: 50,
                  height: 50,
                  decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6).withOpacity(0.15),
                      shape: BoxShape.circle),
                  child: isThisLoading
                      ? const Padding(
                          padding: EdgeInsets.all(12.0),
                          child: CircularProgressIndicator(
                              strokeWidth: 2, color: Color(0xFF8B5CF6)))
                      : Icon(
                          isThisPlaying
                              ? Icons.pause_rounded
                              : Icons.play_arrow_rounded,
                          color: const Color(0xFF8B5CF6),
                          size: 30),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: SizedBox(
                  // Use SizedBox for defined height
                  height: 30,
                  child: Center(
                      child: Text(
                          isThisPlaying
                              ? "Playing..."
                              : isThisPaused
                                  ? "Paused"
                                  : "Tap to play",
                          style: GoogleFonts.poppins(color: Colors.grey[600]))),
                ),
              ),
              const SizedBox(width: 8),
              _buildLikeButton(
                context, ref,
                isLiked: false, // Determine actual like status if needed
                onTap: () => _triggerStandardLike(
                    context,
                    ref,
                    ContentLikeType.audioPrompt,
                    "0"), // Assuming "0" as identifier for the single audio prompt
              ),
            ],
          ),
        ],
      ),
    );
  }
} // End of HomeProfileCard



================================================
File: widgets/quick_profile_card.dart
================================================
// File: widgets/quick_profile_card.dart
import 'package:dtx/models/feed_models.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class QuickProfileCard extends StatelessWidget {
  final QuickFeedProfile profile;

  const QuickProfileCard({super.key, required this.profile});

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final age = profile.age; // Use the calculated age getter

    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade300, width: 1),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Image Placeholder
          Expanded(
            child: Container(
              decoration: BoxDecoration(
                color: Colors.grey[200], // Placeholder color
                borderRadius:
                    const BorderRadius.vertical(top: Radius.circular(12)),
              ),
              child: Center(
                child: Icon(
                  Icons.person_outline,
                  size: screenSize.width * 0.2,
                  color: Colors.grey[400],
                ),
              ),
            ),
          ),
          // Info Section
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Name and Age (Wireframe style)
                Container(
                  height: 20, // Simulate text height
                  width: screenSize.width * 0.3, // Simulate text width
                  decoration: BoxDecoration(
                      color: Colors.grey[300],
                      borderRadius: BorderRadius.circular(4)),
                ),
                const SizedBox(height: 6),
                // Distance (Wireframe style)
                if (profile.distanceKm != null)
                  Container(
                    height: 16, // Simulate text height
                    width: screenSize.width * 0.2, // Simulate text width
                    decoration: BoxDecoration(
                        color: Colors.grey[200],
                        borderRadius: BorderRadius.circular(4)),
                  )
                else // Fallback if distance is null
                  Container(
                    height: 16,
                    width: screenSize.width * 0.2,
                    decoration: BoxDecoration(
                        color: Colors.grey[200],
                        borderRadius: BorderRadius.circular(4)),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}


