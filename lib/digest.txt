Directory structure:
└── lib/
    ├── main.dart
    ├── models/
    │   ├── auth_model.dart
    │   ├── error_model.dart
    │   ├── feed_models.dart
    │   ├── filter_model.dart
    │   ├── like_models.dart
    │   ├── location_model.dart
    │   ├── media_upload_model.dart
    │   └── user_model.dart
    ├── providers/
    │   ├── audio_player_provider.dart
    │   ├── audio_upload_provider.dart
    │   ├── auth_provider.dart
    │   ├── error_provider.dart
    │   ├── feed_provider.dart
    │   ├── filter_provider.dart
    │   ├── liker_profile_provider.dart
    │   ├── location_provider.dart
    │   ├── media_upload_provider.dart
    │   ├── recieved_likes_provider.dart
    │   ├── service_provider.dart
    │   └── user_provider.dart
    ├── repositories/
    │   ├── auth_repository.dart
    │   ├── auth_status_repository.dart
    │   ├── filter_repository.dart
    │   ├── like_repository.dart
    │   ├── media_repository.dart
    │   └── user_repository.dart
    ├── services/
    │   ├── api_service.dart
    │   └── http_service.dart
    ├── utils/
    │   ├── app_enums.dart
    │   ├── env_config.dart
    │   └── token_storage.dart
    ├── views/
    │   ├── audioprompt.dart
    │   ├── audiopromptsselect.dart
    │   ├── chat_screen.dart
    │   ├── dating_intentions.dart
    │   ├── dob.dart
    │   ├── drinking.dart
    │   ├── filter_settings_dialog.dart
    │   ├── gender.dart
    │   ├── google_sign_in_screen.dart
    │   ├── height.dart
    │   ├── home.dart
    │   ├── hometown.dart
    │   ├── job.dart
    │   ├── liker_profile_screen.dart
    │   ├── location.dart
    │   ├── main_navigation_screen.dart
    │   ├── media.dart
    │   ├── name.dart
    │   ├── profile_screens.dart
    │   ├── prompt.dart
    │   ├── religion.dart
    │   ├── selfie_capture_screen.dart
    │   ├── settings_screen.dart
    │   ├── smoking.dart
    │   ├── splash_screen.dart
    │   ├── study.dart
    │   ├── textpromptsselect.dart
    │   ├── verification_message_screen.dart
    │   ├── verification_pending_screen.dart
    │   ├── who_liked_you_screen.dart
    │   ├── writeprompt.dart
    │   ├── youtube.dart
    │   └── core/
    │       └── error_handler.dart
    └── widgets/
        ├── basic_liker_profile_card.dart
        ├── full_liker_profile_card.dart
        └── home_profile_card.dart

================================================
File: main.dart
================================================
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/gender.dart';
import 'package:dtx/views/height.dart';
import 'package:dtx/views/home.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/prompt.dart';
import 'package:flutter/material.dart';
import 'package:dtx/views/splash_screen.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

void main() async {
  // Ensure Flutter is initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Load environment variables
  await dotenv.load(fileName: ".env");

  runApp(
    // Adding ProviderScope at the root of the app
    const ProviderScope(
      child: MyApp(),
    ),
  );
}

// Change StatelessWidget to ConsumerWidget to use Riverpod
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp(
      title: 'DTX',
      debugShowCheckedModeBanner: false, // Optional: removes debug banner
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // You can add more theme configurations here
      ),
      // You can change the home screen here based on your flow
      // For example, start with PhoneInputScreen for authentication flow
      home: const SplashScreen(),
    );
  }
}



================================================
File: models/auth_model.dart
================================================
// File: models/auth_model.dart

// --- UPDATED ENUM ---
enum AuthStatus {
  login, // Needs to log in (no valid token or check failed)
  onboarding1, // Logged in, needs location/gender
  onboarding2, // Logged in, location/gender set, needs main profile details
  home, // Fully authenticated and onboarded
  unknown, // Initial state or error during status check
}
// --- END UPDATED ENUM ---

class AuthState {
  // --- REMOVED FIELDS ---
  // final String? unverifiedPhone;
  // final String? verificationId;
  // final int? resendTimer;
  // --- END REMOVED FIELDS ---

  final bool isLoading;
  final String? error; // Keep error for general auth errors
  final String? jwtToken;
  final AuthStatus authStatus;

  const AuthState({
    this.isLoading = false,
    this.error,
    this.jwtToken,
    this.authStatus = AuthStatus.unknown, // Default to unknown
  });

  AuthState copyWith({
    bool? isLoading,
    String? Function()? error,
    String? Function()? jwtToken, // Function to allow setting null
    AuthStatus? authStatus,
  }) {
    return AuthState(
      isLoading: isLoading ?? this.isLoading,
      error: error != null ? error() : this.error,
      jwtToken: jwtToken != null ? jwtToken() : this.jwtToken,
      authStatus: authStatus ?? this.authStatus,
    );
  }

  // Check if user is considered authenticated (has a token)
  bool get isAuthenticated => jwtToken != null && jwtToken!.isNotEmpty;
}



================================================
File: models/error_model.dart
================================================
enum ErrorType { network, validation, auth, generic, locationService, server }

class AppError {
  final String message;
  final ErrorType type;
  final DateTime timestamp;

  AppError({
    required this.message,
    required this.type,
  }) : timestamp = DateTime.now();

  factory AppError.network(String message) => AppError(
        message: message,
        type: ErrorType.network,
      );

  factory AppError.validation(String message) => AppError(
        message: message,
        type: ErrorType.validation,
      );

  factory AppError.auth(String message) => AppError(
        message: message,
        type: ErrorType.auth,
      );

  factory AppError.locationService(String message) => AppError(
        message: message,
        type: ErrorType.locationService,
      );

  factory AppError.server(String message) => AppError(
        message: message,
        type: ErrorType.server,
      );

  factory AppError.generic(String message) => AppError(
        message: message,
        type: ErrorType.generic, // Use the generic type
      );
}



================================================
File: models/feed_models.dart
================================================
import 'package:dtx/utils/app_enums.dart';

// --- REMOVED QuickFeedProfile ---

// --- FeedProfile (Kept for potential reuse, but not directly used by HomeScreen anymore) ---
// Consider removing if truly unused later.
class FeedProfile {
  final int id;
  final String? name;
  final String? lastName;
  final DateTime? dateOfBirth;
  final List<String>? mediaUrls;
  final Gender? gender;
  final double? distanceKm;

  FeedProfile({
    required this.id,
    this.name,
    this.lastName,
    this.dateOfBirth,
    this.mediaUrls,
    this.gender,
    this.distanceKm,
  });

  String get firstName => name ?? '';

  int? get age {
    if (dateOfBirth == null) return null;
    final now = DateTime.now();
    int age = now.year - dateOfBirth!.year;
    if (now.month < dateOfBirth!.month ||
        (now.month == dateOfBirth!.month && now.day < dateOfBirth!.day)) {
      age--;
    }
    return age < 18 ? null : age;
  }

  String? get firstMediaUrl {
    if (mediaUrls != null &&
        mediaUrls!.isNotEmpty &&
        mediaUrls![0].isNotEmpty) {
      return mediaUrls![0];
    }
    return null;
  }

  factory FeedProfile.fromJson(Map<String, dynamic> json) {
    DateTime? parseDate(dynamic dateField) {
      if (dateField is Map &&
          dateField['Valid'] == true &&
          dateField['Time'] != null) {
        try {
          return DateTime.parse(dateField['Time'] as String);
        } catch (e) {
          return null;
        }
      } else if (dateField is String) {
        // Handle direct string date
        try {
          return DateTime.parse(dateField);
        } catch (e) {
          return null;
        }
      }
      return null;
    }

    List<String>? parseMediaUrls(dynamic urls) {
      if (urls is List) {
        return List<String>.from(
            urls.where((item) => item is String && item.isNotEmpty));
      }
      return null;
    }

    Gender? parseGender(dynamic genderField) {
      String? genderStr;
      if (genderField is Map &&
          genderField['Valid'] == true &&
          genderField['GenderEnum'] != null) {
        genderStr = genderField['GenderEnum'] as String?;
      } else if (genderField is String) {
        genderStr = genderField;
      }

      if (genderStr != null) {
        if (genderStr == 'man') return Gender.man;
        if (genderStr == 'woman') return Gender.woman;
      }
      return null;
    }

    return FeedProfile(
      id: json['id'] as int? ?? 0,
      name: (json['name'] is Map && json['name']['Valid'])
          ? json['name']['String'] as String?
          : json['name'] as String?, // Handle direct string
      lastName: (json['last_name'] is Map && json['last_name']['Valid'])
          ? json['last_name']['String'] as String?
          : json['last_name'] as String?, // Handle direct string
      dateOfBirth: parseDate(json['date_of_birth']),
      mediaUrls: parseMediaUrls(json['media_urls']),
      gender: parseGender(json['gender']),
      distanceKm: (json['distance_km'] as num?)?.toDouble(),
    );
  }
}



================================================
File: models/filter_model.dart
================================================
// lib/models/filter_model.dart
import 'package:dtx/utils/app_enums.dart'; // For Gender enum (ensure correct import if needed)

// --- NEW: Enum for Gender Preference in Filters ---
// Aligns with backend Go enum values ('man', 'woman')
enum FilterGenderPref {
  man('man'),
  woman('woman');

  final String value;
  const FilterGenderPref(this.value);

  // Helper to convert string from API/JSON back to enum
  static FilterGenderPref? fromValue(String? value) {
    if (value == null) return null;
    try {
      return FilterGenderPref.values.firstWhere(
        (e) => e.value.toLowerCase() == value.toLowerCase(),
      );
    } catch (e) {
      return null; // Return null if value doesn't match any enum
    }
  }
}
// --- END NEW ---

class FilterSettings {
  final int? userId; // Keep user ID if needed to associate filters
  final FilterGenderPref? whoYouWantToSee; // Updated type
  final int? radiusKm;
  final bool? activeToday;
  final int? ageMin;
  final int? ageMax;
  final DateTime? createdAt; // Optional: For informational purposes
  final DateTime? updatedAt; // Optional: For informational purposes

  // Define default values (you might want to adjust these)
  static const FilterGenderPref defaultGenderPref = FilterGenderPref.woman;
  static const int defaultRadius = 50; // e.g., 50 km
  static const bool defaultActiveToday = false;
  static const int defaultAgeMin = 18;
  static const int defaultAgeMax = 55;

  const FilterSettings({
    this.userId,
    this.whoYouWantToSee = defaultGenderPref, // Default to show women
    this.radiusKm = defaultRadius,
    this.activeToday = defaultActiveToday,
    this.ageMin = defaultAgeMin,
    this.ageMax = defaultAgeMax,
    this.createdAt,
    this.updatedAt,
  });

  // Check if the current settings are the default ones
  bool get isDefault {
    return whoYouWantToSee == defaultGenderPref &&
        radiusKm == defaultRadius &&
        activeToday == defaultActiveToday &&
        ageMin == defaultAgeMin &&
        ageMax == defaultAgeMax;
  }

  // copyWith method for immutability
  FilterSettings copyWith({
    int? userId,
    FilterGenderPref? Function()? whoYouWantToSee, // Use nullable functions
    int? Function()? radiusKm,
    bool? Function()? activeToday,
    int? Function()? ageMin,
    int? Function()? ageMax,
    DateTime? createdAt, // Optional: For informational purposes
    DateTime? updatedAt, // Optional: For informational purposes
  }) {
    return FilterSettings(
      userId: userId ?? this.userId,
      whoYouWantToSee:
          whoYouWantToSee != null ? whoYouWantToSee() : this.whoYouWantToSee,
      radiusKm: radiusKm != null ? radiusKm() : this.radiusKm,
      activeToday: activeToday != null ? activeToday() : this.activeToday,
      ageMin: ageMin != null ? ageMin() : this.ageMin,
      ageMax: ageMax != null ? ageMax() : this.ageMax,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  // Convert to JSON for API requests (align keys with backend)
  Map<String, dynamic> toJsonForApi() {
    final Map<String, dynamic> data = {};
    // Only include fields that are non-null or should be sent
    if (whoYouWantToSee != null)
      data['whoYouWantToSee'] = whoYouWantToSee!.value;
    if (radiusKm != null) data['radius'] = radiusKm;
    if (activeToday != null) data['activeToday'] = activeToday;
    if (ageMin != null) data['ageMin'] = ageMin;
    if (ageMax != null) data['ageMax'] = ageMax;
    return data;
  }

  // Factory to parse from JSON API response
  factory FilterSettings.fromJson(Map<String, dynamic> json) {
    // Helper to safely parse nullable integers from potential pgtype structure
    int? parseInt(dynamic field) {
      if (field is Map &&
          field['Valid'] == true &&
          field['Int32'] != null &&
          field['Int32'] is num) {
        return (field['Int32'] as num).toInt();
      }
      // Handle direct int case if backend sends it sometimes
      if (field is int) return field;
      return null;
    }

    // Helper to safely parse gender preference from potential pgtype structure
    FilterGenderPref? parseGenderPref(dynamic field) {
      if (field is Map &&
          field['Valid'] == true &&
          field['GenderEnum'] != null) {
        return FilterGenderPref.fromValue(field['GenderEnum'] as String?);
      }
      // Handle direct string case
      if (field is String) {
        return FilterGenderPref.fromValue(field);
      }
      return null;
    }

    DateTime? parseDateTime(String? dateString) {
      if (dateString == null) return null;
      try {
        return DateTime.parse(dateString);
      } catch (_) {
        return null; // Return null if parsing fails
      }
    }

    // Adapt the keys ('WhoYouWantToSee', 'RadiusKm', etc.) to match your exact API response structure
    // Use the helpers for nullable fields
    final FilterGenderPref? parsedGender =
        parseGenderPref(json['WhoYouWantToSee']); // Check API response key case
    final int? parsedRadius =
        parseInt(json['RadiusKm']); // Check API response key case
    final int? parsedAgeMin =
        parseInt(json['AgeMin']); // Check API response key case
    final int? parsedAgeMax =
        parseInt(json['AgeMax']); // Check API response key case
    // Assuming 'ActiveToday' is sent as a direct boolean or pgtype.Bool
    final bool? parsedActive = (json['ActiveToday'] is Map &&
            json['ActiveToday']['Valid'] == true)
        ? json['ActiveToday']['Bool'] as bool?
        : (json['ActiveToday'] is bool ? json['ActiveToday'] as bool? : null);

    return FilterSettings(
      userId: json['UserID'], // Assume UserID is directly available
      whoYouWantToSee: parsedGender ??
          FilterSettings.defaultGenderPref, // Fallback to default
      radiusKm: parsedRadius ?? FilterSettings.defaultRadius,
      activeToday: parsedActive ?? FilterSettings.defaultActiveToday,
      ageMin: parsedAgeMin ?? FilterSettings.defaultAgeMin,
      ageMax: parsedAgeMax ?? FilterSettings.defaultAgeMax,
      createdAt: parseDateTime(json['CreatedAt'] as String?),
      updatedAt: parseDateTime(json['UpdatedAt'] as String?),
    );
  }
}



================================================
File: models/like_models.dart
================================================
// File: models/like_models.dart
import 'package:dtx/models/user_model.dart'; // Import UserProfileData definition source
import 'package:dtx/utils/app_enums.dart'; // For GenderEnum if needed
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Only needed if UserProfileData uses Riverpod types directly, unlikely.

// --- Enums (from Phase 8) ---
enum ContentLikeType {
  media('media'),
  promptStory('prompt_story'),
  promptMytype('prompt_mytype'),
  promptGettingpersonal('prompt_gettingpersonal'),
  promptDatevibes('prompt_datevibes'),
  audioPrompt('audio_prompt'),
  profile('profile'); // <<<--- ADDED THIS LINE

  final String value;
  const ContentLikeType(this.value);

  // --- UPDATED fromValue for robustness ---
  static ContentLikeType? fromValue(String? value) {
    if (value == null) return null;
    try {
      // Find the enum value matching the string
      return ContentLikeType.values.firstWhere((e) => e.value == value);
    } catch (e) {
      // Handle cases where the string doesn't match any enum value
      print("Warning: Unknown ContentLikeType value '$value'");
      return null; // Return null if not found
    }
  }
  // --- END UPDATED fromValue ---
}

enum LikeInteractionType {
  standard('standard'),
  rose('rose');

  final String value;
  const LikeInteractionType(this.value);
  static LikeInteractionType? fromValue(String? value) {
    if (value == null) return null;
    try {
      // Added try-catch for robustness
      return LikeInteractionType.values.firstWhere((e) => e.value == value);
    } catch (e) {
      print("Warning: Unknown LikeInteractionType value '$value'");
      return null; // Return null if not found
    }
    // Original: return LikeInteractionType.values.firstWhere((e) => e.value == value, orElse: () => LikeInteractionType.standard);
  }
}

// --- Custom Exceptions (from Phase 8) ---
class LikeLimitExceededException implements Exception {
  final String message;
  LikeLimitExceededException([this.message = 'Daily like limit reached.']);
  @override
  String toString() => message;
}

class InsufficientRosesException implements Exception {
  final String message;
  InsufficientRosesException([this.message = 'You don\'t have enough Roses.']);
  @override
  String toString() => message;
}

// --- Liker Data Structures ---

// Structure for Full Profile Liker (Matches API Response `full_profiles` item)
class FullProfileLiker {
  final int likerUserId;
  final String? likeComment; // Nullable string
  final bool isRose;
  final DateTime? likedAt; // Parsed timestamp
  final UserProfileData profile; // Embedded full profile data

  FullProfileLiker({
    required this.likerUserId,
    this.likeComment,
    required this.isRose,
    this.likedAt,
    required this.profile,
  });

  factory FullProfileLiker.fromJson(Map<String, dynamic> json) {
    DateTime? parseTimestamp(dynamic ts) {
      if (ts is String) {
        try {
          return DateTime.parse(ts).toLocal();
        } catch (_) {} // Parse and convert to local time
      }
      return null;
    }

    // Safely get comment string
    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        // Handle direct string just in case
        return commentField;
      }
      return null;
    }

    // --- UPDATED isRose parsing ---
    bool parseIsRose(dynamic isRoseField, dynamic interactionTypeField) {
      if (isRoseField is bool) {
        return isRoseField; // Prefer direct boolean if present
      }
      // Fallback to checking interaction_type string
      return interactionTypeField == LikeInteractionType.rose.value;
    }
    // --- END UPDATED ---

    return FullProfileLiker(
      likerUserId: json['liker_user_id'] as int? ?? 0,
      likeComment: getComment(json['like_comment']),
      // Use helper to parse isRose
      isRose: parseIsRose(json['is_rose'], json['interaction_type']),
      likedAt: parseTimestamp(json['liked_at']),
      // Assuming 'profile' contains the full UserProfileData structure
      profile: UserProfileData.fromJson(
          json['profile'] as Map<String, dynamic>? ?? {}),
    );
  }
}

// Structure for Basic Profile Liker (Matches API Response `other_likers` item)
class BasicProfileLiker {
  final int likerUserId;
  final String name; // Should ideally always have a name
  final String? firstProfilePicUrl; // Nullable string
  final String? likeComment; // Nullable string
  final bool isRose;
  final DateTime? likedAt; // Parsed timestamp

  BasicProfileLiker({
    required this.likerUserId,
    required this.name,
    this.firstProfilePicUrl,
    this.likeComment,
    required this.isRose,
    this.likedAt,
  });

  factory BasicProfileLiker.fromJson(Map<String, dynamic> json) {
    DateTime? parseTimestamp(dynamic ts) {
      if (ts is String) {
        try {
          return DateTime.parse(ts).toLocal();
        } catch (_) {}
      }
      return null;
    }

    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        return commentField;
      }
      return null;
    }

    String? getPicUrl(dynamic urls) {
      if (urls is List && urls.isNotEmpty && urls[0] is String) {
        return urls[0];
      }
      return null;
    }

    String buildName(dynamic nameField, dynamic lastNameField) {
      String firstName = (nameField is Map && nameField['Valid'] == true)
          ? nameField['String'] ?? ''
          : '';
      String lastName = (lastNameField is Map && lastNameField['Valid'] == true)
          ? lastNameField['String'] ?? ''
          : '';
      return '$firstName $lastName'.trim(); // Combine and trim whitespace
    }

    // --- UPDATED isRose parsing (same as FullProfileLiker) ---
    bool parseIsRose(dynamic isRoseField, dynamic interactionTypeField) {
      if (isRoseField is bool) {
        return isRoseField; // Prefer direct boolean if present
      }
      // Fallback to checking interaction_type string
      return interactionTypeField == LikeInteractionType.rose.value;
    }
    // --- END UPDATED ---

    return BasicProfileLiker(
      likerUserId: json['liker_user_id'] as int? ?? 0,
      name: buildName(json['name'], json['last_name']), // Build name safely
      firstProfilePicUrl: getPicUrl(json['media_urls']), // Get first URL safely
      likeComment: getComment(json['like_comment']),
      // Use helper to parse isRose
      isRose: parseIsRose(json['is_rose'], json['interaction_type']),
      likedAt: parseTimestamp(json['liked_at']),
    );
  }
}

class LikeInteractionDetails {
  final String? likeComment; // Nullable string
  final bool isRose;

  LikeInteractionDetails({
    this.likeComment,
    required this.isRose,
  });

  factory LikeInteractionDetails.fromJson(Map<String, dynamic> json) {
    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        return commentField;
      }
      return null;
    }

    // --- UPDATED isRose parsing (same logic) ---
    bool parseIsRose(dynamic isRoseField, dynamic interactionTypeField) {
      if (isRoseField is bool) {
        return isRoseField; // Prefer direct boolean if present
      }
      // Fallback to checking interaction_type string
      return interactionTypeField == LikeInteractionType.rose.value;
    }
    // --- END UPDATED ---

    return LikeInteractionDetails(
      likeComment: getComment(
          json['comment']), // Assuming key is 'comment' from GetLikeDetailsRow
      // Use helper to parse isRose
      isRose: parseIsRose(json['is_rose'], json['interaction_type']),
    );
  }
}

// --- Placeholder for UserProfileData (ensure consistency) ---
// Re-using UserModel seems appropriate based on current needs
class UserProfileData extends UserModel {
  UserProfileData({
    // Inherit all fields from UserModel
    super.id, // <<< ADDED super.id
    super.name,
    super.lastName,
    super.email,
    super.phoneNumber,
    super.dateOfBirth,
    super.latitude,
    super.longitude,
    super.gender,
    super.datingIntention,
    super.height,
    super.hometown,
    super.jobTitle,
    super.education,
    super.religiousBeliefs,
    super.drinkingHabit,
    super.smokingHabit,
    super.mediaUrls,
    super.prompts = const [],
    super.audioPrompt,
    super.verificationStatus,
    super.verificationPic,
    super.role,
    super.mediaChangedDuringEdit, // <<< ADDED super.mediaChangedDuringEdit
  });

  factory UserProfileData.fromJson(Map<String, dynamic> json) {
    // Parse UserModel fields using its factory
    final userModel = UserModel.fromJson(json);

    return UserProfileData(
      id: userModel.id, // Pass id
      name: userModel.name,
      lastName: userModel.lastName,
      email: userModel.email,
      phoneNumber: userModel.phoneNumber,
      dateOfBirth: userModel.dateOfBirth,
      latitude: userModel.latitude,
      longitude: userModel.longitude,
      gender: userModel.gender,
      datingIntention: userModel.datingIntention,
      height: userModel.height,
      hometown: userModel.hometown,
      jobTitle: userModel.jobTitle,
      education: userModel.education,
      religiousBeliefs: userModel.religiousBeliefs,
      drinkingHabit: userModel.drinkingHabit,
      smokingHabit: userModel.smokingHabit,
      mediaUrls: userModel.mediaUrls,
      prompts: userModel.prompts,
      audioPrompt: userModel.audioPrompt,
      verificationStatus: userModel.verificationStatus,
      verificationPic: userModel.verificationPic,
      role: userModel.role,
      mediaChangedDuringEdit: userModel.mediaChangedDuringEdit, // Pass flag
    );
  }
}



================================================
File: models/location_model.dart
================================================
class LocationState {
  final bool isLoading;
  final bool isFetching;
  final double latitude;
  final double longitude;
  final double? cachedLatitude;
  final double? cachedLongitude;
  final bool isMapReady;

  LocationState({
    this.isLoading = true,
    this.isFetching = false,
    this.latitude = 19.2183, // Default location
    this.longitude = 73.0864,
    this.cachedLatitude,
    this.cachedLongitude,
    this.isMapReady = false,
  });

  LocationState copyWith({
    bool? isLoading,
    bool? isFetching,
    double? latitude,
    double? longitude,
    double? cachedLatitude,
    double? cachedLongitude,
    bool? isMapReady,
  }) {
    return LocationState(
      isLoading: isLoading ?? this.isLoading,
      isFetching: isFetching ?? this.isFetching,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      cachedLatitude: cachedLatitude ?? this.cachedLatitude,
      cachedLongitude: cachedLongitude ?? this.cachedLongitude,
      isMapReady: isMapReady ?? this.isMapReady,
    );
  }
}



================================================
File: models/media_upload_model.dart
================================================

// models/media_upload_model.dart
import 'dart:io';

enum UploadStatus {
  idle,
  inProgress,
  success,
  failed,
}

class MediaUploadModel {
  final File file;
  final String fileName;
  final String fileType;
  final String? presignedUrl;
  final UploadStatus status;
  final String? errorMessage;
  
  MediaUploadModel({
    required this.file,
    required this.fileName,
    required this.fileType,
    this.presignedUrl,
    this.status = UploadStatus.idle,
    this.errorMessage,
  });
  
  MediaUploadModel copyWith({
    File? file,
    String? fileName,
    String? fileType,
    String? Function()? presignedUrl,
    UploadStatus? status,
    String? Function()? errorMessage,
  }) {
    return MediaUploadModel(
      file: file ?? this.file,
      fileName: fileName ?? this.fileName,
      fileType: fileType ?? this.fileType,
      presignedUrl: presignedUrl != null ? presignedUrl() : this.presignedUrl,
      status: status ?? this.status,
      errorMessage: errorMessage != null ? errorMessage() : this.errorMessage,
    );
  }
}



================================================
File: models/user_model.dart
================================================
// File: lib/models/user_model.dart
import 'package:dtx/utils/app_enums.dart';
// No need for 'dart:convert' import here unless used elsewhere in this specific file

// --- Prompt Class --- (No changes needed)
class Prompt {
  final PromptCategory category;
  final PromptType question;
  final String answer;

  Prompt({
    required this.category,
    required this.question,
    required this.answer,
  });

  Map<String, dynamic> toJson() => {
        'category': category.value,
        'question': question.value,
        'answer': answer,
      };

  factory Prompt.fromJson(Map<String, dynamic> json) {
    PromptCategory category = PromptCategory.values
        .firstWhere((e) => e.value == json['category'], orElse: () {
      print(
          "Warning: Unknown prompt category '${json['category']}', defaulting to storyTime.");
      return PromptCategory.storyTime;
    });
    PromptType question = PromptType.values
        .firstWhere((e) => e.value == json['question'], orElse: () {
      print(
          "Warning: Unknown prompt question '${json['question']}' for category '${category.value}', defaulting.");
      return category.getPrompts().isNotEmpty
          ? category.getPrompts().first
          : PromptType.twoTruthsAndALie; // A fallback default
    });

    return Prompt(
      category: category,
      question: question,
      answer: json['answer'] ?? '',
    );
  }

  Prompt copyWith({String? answer}) {
    return Prompt(
      category: category,
      question: question,
      answer: answer ?? this.answer,
    );
  }

  @override
  String toString() {
    return 'Prompt(question: ${question.label}, answer: $answer)';
  }
}

// --- AudioPromptModel Class --- (No changes needed)
class AudioPromptModel {
  final AudioPrompt prompt;
  final String audioUrl; // Renamed from answer for clarity

  AudioPromptModel({
    required this.prompt,
    required this.audioUrl, // Renamed
  });

  // --- UPDATED toJson for PATCH ---
  Map<String, dynamic> toJson() => {
        'question': prompt.value, // Key expected by PATCH
        'answer_url': audioUrl, // Key expected by PATCH
      };
  // --- END UPDATED toJson ---

  factory AudioPromptModel.fromJson(Map<String, dynamic> json) {
    // Parse Question (assuming it's always a map)
    final promptValue =
        json['audio_prompt_question']?['AudioPrompt'] as String?;
    final bool isPromptValid =
        json['audio_prompt_question']?['Valid'] as bool? ?? false;

    if (!isPromptValid || promptValue == null) {
      throw const FormatException(
          'Invalid or missing audio prompt question data in JSON');
    }

    AudioPrompt prompt = AudioPrompt.values
        .firstWhere((e) => e.value == promptValue, orElse: () {
      print(
          "Warning: Unknown audio prompt '$promptValue', defaulting to aBoundaryOfMineIs.");
      return AudioPrompt.aBoundaryOfMineIs;
    });

    // Parse Answer (handle both String and Map)
    String? audioUrlValue;
    dynamic answerField = json['audio_prompt_answer'];

    if (answerField is String) {
      audioUrlValue = answerField;
    } else if (answerField is Map) {
      if (answerField['Valid'] == true && answerField['String'] is String) {
        audioUrlValue = answerField['String'] as String;
      }
    }

    if (audioUrlValue == null || audioUrlValue.isEmpty) {
      throw const FormatException(
          'Invalid or missing audio prompt answer data in JSON');
    }

    return AudioPromptModel(
      prompt: prompt,
      audioUrl: audioUrlValue, // Use renamed field
    );
  }
}

// --- UserModel Class ---
class UserModel {
  final int? id;
  final String? name;
  final String? lastName;
  final String? phoneNumber;
  final String? email;
  final DateTime? dateOfBirth;
  final double? latitude;
  final double? longitude;
  final Gender? gender;
  final DatingIntention? datingIntention;
  final String? height;
  final String? hometown;
  final String? jobTitle;
  final String? education;
  final Religion? religiousBeliefs;
  final DrinkingSmokingHabits? drinkingHabit;
  final DrinkingSmokingHabits? smokingHabit;
  final List<String>? mediaUrls;
  final List<Prompt> prompts;
  final AudioPromptModel? audioPrompt;
  final String? verificationStatus;
  final String? verificationPic;
  final String? role;
  // --- NEW: Internal flag for media changes ---
  final bool mediaChangedDuringEdit; // Track if media screen was edited

  UserModel({
    this.id,
    this.name,
    this.lastName,
    this.phoneNumber,
    this.email,
    this.dateOfBirth,
    this.latitude,
    this.longitude,
    this.gender,
    this.datingIntention,
    this.height,
    this.hometown,
    this.jobTitle,
    this.education,
    this.religiousBeliefs,
    this.drinkingHabit,
    this.smokingHabit,
    this.mediaUrls,
    this.prompts = const [],
    this.audioPrompt,
    this.verificationStatus,
    this.verificationPic,
    this.role,
    this.mediaChangedDuringEdit = false, // Default to false
  });

  int? get age {
    if (dateOfBirth == null) return null;
    final now = DateTime.now();
    int age = now.year - dateOfBirth!.year;
    if (now.month < dateOfBirth!.month ||
        (now.month == dateOfBirth!.month && now.day < dateOfBirth!.day)) {
      age--;
    }
    return age < 18 ? null : age;
  }

  String? get firstMediaUrl {
    if (mediaUrls != null &&
        mediaUrls!.isNotEmpty &&
        mediaUrls![0].isNotEmpty) {
      return mediaUrls![0];
    }
    return null;
  }

  // toJson remains the same (might be useful for other things)
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'last_name': lastName,
        'phone_number': phoneNumber,
        'email': email,
        'date_of_birth': dateOfBirth?.toIso8601String().split('T').first,
        'latitude': latitude,
        'longitude': longitude,
        'gender': gender?.value,
        'dating_intention': datingIntention?.value,
        'height': height,
        'hometown': hometown,
        'job_title': jobTitle,
        'education': education,
        'religious_beliefs': religiousBeliefs?.value,
        'drinking_habit': drinkingHabit?.value,
        'smoking_habit': smokingHabit?.value,
        'media_urls': mediaUrls,
        'prompts': prompts.map((prompt) => prompt.toJson()).toList(),
        // Use AudioPromptModel's toJson which is now formatted for PATCH
        'audio_prompt': audioPrompt?.toJson(),
        'verification_status': verificationStatus,
        'verification_pic': verificationPic,
        'role': role,
      };

  // toJsonForProfileUpdate remains the same (for onboarding step 2 POST)
  Map<String, dynamic> toJsonForProfileUpdate() {
    String? formattedDate(DateTime? dt) {
      if (dt == null) return null;
      return "${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')}";
    }

    String? formattedHeight(String? h) {
      // Height format conversion is likely handled by the backend on POST
      // but we can keep the frontend format consistent if needed.
      return h?.replaceAll("' ", "'"); // Example: ensure single space
    }

    final Map<String, dynamic> data = {};
    if (name != null) data['name'] = name;
    data['last_name'] = lastName ?? ""; // Send empty string if null for POST
    if (dateOfBirth != null) data['date_of_birth'] = formattedDate(dateOfBirth);
    if (datingIntention != null)
      data['dating_intention'] = datingIntention!.value;
    if (height != null) data['height'] = formattedHeight(height);
    if (hometown != null) data['hometown'] = hometown;
    if (jobTitle != null) data['job_title'] = jobTitle;
    if (education != null) data['education'] = education;
    if (religiousBeliefs != null)
      data['religious_beliefs'] = religiousBeliefs!.value;
    if (drinkingHabit != null) data['drinking_habit'] = drinkingHabit!.value;
    if (smokingHabit != null) data['smoking_habit'] = smokingHabit!.value;
    if (prompts.isNotEmpty)
      data['prompts'] = prompts.map((p) => p.toJson()).toList();
    // Note: Audio prompt and media are handled by separate endpoints during initial onboarding POSTs
    return data;
  }

  // --- NEW: toJsonForEdit for PATCH request ---
  Map<String, dynamic> toJsonForEdit() {
    String? formattedHeight(String? h) {
      // Apply formatting consistent with API expectation if needed
      return h?.replaceAll("' ", "'"); // Example
    }

    final Map<String, dynamic> data = {};
    // --- ONLY include fields that are editable and have values ---
    // Non-editable: name, last_name, dob, gender, location
    if (datingIntention != null)
      data['dating_intention'] = datingIntention!.value;
    if (height != null && height!.isNotEmpty)
      data['height'] = formattedHeight(height);
    if (hometown != null && hometown!.isNotEmpty) data['hometown'] = hometown;
    if (jobTitle != null && jobTitle!.isNotEmpty) data['job_title'] = jobTitle;
    if (education != null && education!.isNotEmpty)
      data['education'] = education;
    if (religiousBeliefs != null)
      data['religious_beliefs'] = religiousBeliefs!.value;
    if (drinkingHabit != null) data['drinking_habit'] = drinkingHabit!.value;
    if (smokingHabit != null) data['smoking_habit'] = smokingHabit!.value;

    // Handle optional fields where null means "remove"
    if (hometown == null)
      data['hometown'] = null; // Explicitly set to null if cleared
    if (jobTitle == null) data['job_title'] = null;
    if (education == null) data['education'] = null;

    // Always include prompts, even if empty, to allow removal
    data['prompts'] = prompts.map((p) => p.toJson()).toList();

    // Include audio_prompt only if it exists
    if (audioPrompt != null) {
      data['audio_prompt'] = audioPrompt!.toJson(); // Uses the corrected toJson
    } else {
      // To remove audio prompt, explicitly send null
      data['audio_prompt'] = null;
    }

    // Always include media_urls (even if empty after edit)
    data['media_urls'] = mediaUrls ?? [];

    return data;
  }
  // --- END NEW ---

  // fromJson remains the same
  factory UserModel.fromJson(Map<String, dynamic> json) {
    // --- Helper Functions ---
    String? getString(dynamic field) {
      if (field is Map && field['Valid'] == true && field['String'] != null) {
        return field['String'] as String?;
      } else if (field is String) {
        return field;
      } else if (field is int || field is double) {
        return field.toString();
      }
      return null;
    }

    String? getHeight(dynamic field) {
      if (field is Map && field['Valid'] == true && field['String'] != null) {
        return field['String'] as String?;
      } else if (field is String) {
        // Backend might send "5' 11\"" or "5'11\""
        return field.replaceAll("' ",
            "'"); // Standardize to single space or no space? Check API doc.
      } else if (field is int || field is double) {
        // Convert cm/inches if backend sends numeric height sometimes
        double totalInches = (field as num) * 0.393701;
        int feet = (totalInches / 12).floor();
        int inches = (totalInches % 12).round();
        if (inches == 12) {
          feet++;
          inches = 0;
        }
        return "$feet' $inches\""; // Ensure this format matches API exactly
      }
      return null;
    }

    String? getEnumString(dynamic field, String key) {
      if (field is Map && field['Valid'] == true && field[key] != null) {
        return field[key] as String?;
      } else if (field is String) {
        // Handle direct string enums
        return field;
      }
      return null;
    }

    DateTime? getDate(dynamic field) {
      String? dateStr;
      if (field is Map && field['Valid'] == true && field['Time'] != null) {
        dateStr = field['Time'] as String?;
      } else if (field is String) {
        dateStr = field;
      }
      if (dateStr != null) {
        try {
          if (dateStr.contains('T')) {
            return DateTime.parse(dateStr.split('T').first);
          } else if (RegExp(r'^\d{4}-\d{2}-\d{2}$').hasMatch(dateStr)) {
            return DateTime.parse(dateStr);
          }
        } catch (e) {
          print("Error parsing date: $e, value: $field");
        }
      }
      return null;
    }

    double? getDouble(dynamic field) {
      if (field is Map && field['Valid'] == true && field['Float64'] != null) {
        return (field['Float64'] as num?)?.toDouble();
      } else if (field is num) {
        return field.toDouble();
      }
      return null;
    }

    T? parseEnum<T>(List<T> enumValues, dynamic field, String key) {
      // Use getEnumString which handles both map and direct string
      final valueStr = getEnumString(field, key);
      if (valueStr != null) {
        for (final enumValue in enumValues) {
          try {
            // Assuming enums have a '.value' getter holding the string representation
            if ((enumValue as dynamic).value.toString() == valueStr) {
              return enumValue;
            }
          } catch (e) {
            // This catch block is tricky if enums don't uniformly have '.value'
            // Consider a more robust mapping if enums are inconsistent.
            // print("Error accessing '.value' for enum ${T.toString()} (value: $valueStr): $e");
            // Fallback: Check toString() representation (less reliable)
            if (enumValue.toString().split('.').last == valueStr) {
              // print("Fallback enum match using toString() for $valueStr");
              return enumValue;
            }
          }
        }
        print("Warning: Enum value '$valueStr' not found in ${T.toString()}.");
        return null;
      }
      return null;
    }

    List<String>? getMediaUrls(dynamic field) {
      if (field is List<dynamic>) {
        final urls = field
            .where((item) => item is String && item.isNotEmpty)
            .map((item) => item as String)
            .toList();
        return urls.isNotEmpty ? urls : null;
      } else if (field is List<String>) {
        // Handle case where it's already List<String>
        return field.where((s) => s.isNotEmpty).toList().isNotEmpty
            ? field
            : null;
      }
      return null;
    }

    int? getId(dynamic idField) {
      if (idField is int) {
        return idField;
      }
      if (idField is String) {
        return int.tryParse(idField);
      }
      if (idField is Map &&
          idField['Valid'] == true &&
          idField['Int64'] != null) {
        if (idField['Int64'] is num) {
          return (idField['Int64'] as num).toInt();
        }
      }
      return null;
    }

    List<Prompt> getPrompts(Map<String, dynamic> json) {
      List<Prompt> parsedPrompts = [];
      if (json['prompts'] is List) {
        final List<dynamic> promptList = json['prompts'];
        for (var promptData in promptList) {
          if (promptData is Map<String, dynamic>) {
            try {
              final parsedPrompt = Prompt.fromJson(promptData);
              // Ensure answer is not just whitespace before adding
              if (parsedPrompt.answer.trim().isNotEmpty) {
                parsedPrompts.add(parsedPrompt);
              } else {
                print(
                    "[UserModel fromJson] Skipping prompt with empty answer: ${promptData['question']}");
              }
            } catch (e) {
              print(
                  "[UserModel fromJson] Error parsing prompt: $e, data: $promptData");
            }
          }
        }
      }
      // API allows max 3, but frontend should handle this limit upstream.
      // Here we just parse what's given.
      return parsedPrompts;
    }

    // --- REVISED getAudioPrompt Helper ---
    AudioPromptModel? getAudioPrompt(Map<String, dynamic> json, int? userId) {
      final questionData =
          json['AudioPromptQuestion'] ?? json['audio_prompt_question'];
      final answerData =
          json['AudioPromptAnswer'] ?? json['audio_prompt_answer'];

      // 1. Check Question Validity
      bool isQuestionValid = questionData is Map &&
          questionData['Valid'] == true &&
          questionData['AudioPrompt'] is String &&
          (questionData['AudioPrompt'] as String).isNotEmpty;

      if (!isQuestionValid) return null; // No valid question, no audio prompt

      // 2. Check Answer Validity (String or Valid Map with non-empty String)
      String? audioUrlValue;
      if (answerData is String && answerData.isNotEmpty) {
        audioUrlValue = answerData;
      } else if (answerData is Map &&
          answerData['Valid'] == true &&
          answerData['String'] is String &&
          (answerData['String'] as String).isNotEmpty) {
        audioUrlValue = answerData['String'] as String;
      }

      if (audioUrlValue == null)
        return null; // No valid answer, no audio prompt

      // 3. If BOTH are valid, attempt to create the model using the Factory
      try {
        // The factory now handles the map structure directly
        return AudioPromptModel.fromJson({
          'audio_prompt_question': questionData,
          'audio_prompt_answer': answerData,
        });
      } catch (e) {
        print(
            "[UserModel fromJson getAudioPrompt ID: $userId] Error creating AudioPromptModel: $e");
        print(" -> Question Data: $questionData");
        print(" -> Answer Data: $answerData");
        return null;
      }
    }
    // --- END REVISED getAudioPrompt Helper ---

    // --- Parse using helpers ---
    final int? currentUserId =
        getId(json['id'] ?? json['ID']); // Get ID for logging
    final parsedUser = UserModel(
      id: currentUserId, // Use the extracted ID
      name: getString(json['name'] ?? json['Name']),
      lastName: getString(json['last_name'] ?? json['LastName']),
      email: json['email'] as String? ?? json['Email'] as String?,
      phoneNumber: getString(json['phone_number'] ?? json['PhoneNumber']),
      dateOfBirth: getDate(json['date_of_birth'] ?? json['DateOfBirth']),
      latitude: getDouble(json['latitude'] ?? json['Latitude']),
      longitude: getDouble(json['longitude'] ?? json['Longitude']),
      gender: parseEnum(
          Gender.values, json['gender'] ?? json['Gender'], 'GenderEnum'),
      datingIntention: parseEnum(
          DatingIntention.values,
          json['dating_intention'] ?? json['DatingIntention'],
          'DatingIntention'),
      height: getHeight(json['height'] ?? json['Height']),
      hometown: getString(json['hometown'] ?? json['Hometown']),
      jobTitle: getString(json['job_title'] ?? json['JobTitle']),
      education: getString(json['education'] ?? json['Education']),
      religiousBeliefs: parseEnum(Religion.values,
          json['religious_beliefs'] ?? json['ReligiousBeliefs'], 'Religion'),
      drinkingHabit: parseEnum(
          DrinkingSmokingHabits.values,
          json['drinking_habit'] ?? json['DrinkingHabit'],
          'DrinkingSmokingHabits'),
      smokingHabit: parseEnum(
          DrinkingSmokingHabits.values,
          json['smoking_habit'] ?? json['SmokingHabit'],
          'DrinkingSmokingHabits'),
      mediaUrls: getMediaUrls(json['media_urls'] ?? json['MediaUrls']),
      verificationStatus: json['verification_status'] as String? ??
          json['VerificationStatus'] as String?,
      verificationPic:
          getString(json['verification_pic'] ?? json['VerificationPic']),
      role: json['role'] as String? ?? json['Role'] as String?,
      audioPrompt: getAudioPrompt(json, currentUserId), // Pass ID to helper
      prompts: getPrompts(json),
    );

    // Remove debug print unless needed
    // print("--- Parsed UserModel (Audio Prompt Check) ---");
    // print("ID: ${parsedUser.id}");
    // print("Name: ${parsedUser.name}");
    // print("Audio Prompt Parsed: ${parsedUser.audioPrompt != null}");
    // if (parsedUser.audioPrompt != null) {
    //   print("  -> Question: ${parsedUser.audioPrompt!.prompt.label}");
    //   print("  -> URL: ${parsedUser.audioPrompt!.audioUrl}");
    // }
    // print("------------------------------------------");

    return parsedUser;
  }

  // copyWith needs update for mediaChangedDuringEdit
  UserModel copyWith({
    int? Function()? id,
    String? Function()? name,
    String? Function()? lastName,
    String? Function()? phoneNumber,
    String? Function()? email,
    DateTime? Function()? dateOfBirth,
    double? Function()? latitude,
    double? Function()? longitude,
    Gender? Function()? gender,
    DatingIntention? Function()? datingIntention,
    String? Function()? height,
    String? Function()? hometown,
    String? Function()? jobTitle,
    String? Function()? education,
    Religion? Function()? religiousBeliefs,
    DrinkingSmokingHabits? Function()? drinkingHabit,
    DrinkingSmokingHabits? Function()? smokingHabit,
    List<String>? Function()? mediaUrls,
    List<Prompt>? prompts,
    AudioPromptModel? Function()? audioPrompt,
    String? Function()? verificationStatus,
    String? Function()? verificationPic,
    String? Function()? role,
    bool? mediaChangedDuringEdit, // <<< ADDED parameter
  }) {
    return UserModel(
      id: id != null ? id() : this.id,
      name: name != null ? name() : this.name,
      lastName: lastName != null ? lastName() : this.lastName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      email: email != null ? email() : this.email,
      dateOfBirth: dateOfBirth != null ? dateOfBirth() : this.dateOfBirth,
      latitude: latitude != null ? latitude() : this.latitude,
      longitude: longitude != null ? longitude() : this.longitude,
      gender: gender != null ? gender() : this.gender,
      datingIntention:
          datingIntention != null ? datingIntention() : this.datingIntention,
      height: height != null ? height() : this.height,
      hometown: hometown != null ? hometown() : this.hometown,
      jobTitle: jobTitle != null ? jobTitle() : this.jobTitle,
      education: education != null ? education() : this.education,
      religiousBeliefs:
          religiousBeliefs != null ? religiousBeliefs() : this.religiousBeliefs,
      drinkingHabit:
          drinkingHabit != null ? drinkingHabit() : this.drinkingHabit,
      smokingHabit: smokingHabit != null ? smokingHabit() : this.smokingHabit,
      mediaUrls: mediaUrls != null ? mediaUrls() : this.mediaUrls,
      prompts: prompts ?? List.from(this.prompts),
      audioPrompt: audioPrompt != null ? audioPrompt() : this.audioPrompt,
      verificationStatus: verificationStatus != null
          ? verificationStatus()
          : this.verificationStatus,
      verificationPic:
          verificationPic != null ? verificationPic() : this.verificationPic,
      role: role != null ? role() : this.role,
      // Pass the value or use existing
      mediaChangedDuringEdit:
          mediaChangedDuringEdit ?? this.mediaChangedDuringEdit,
    );
  }

  // isProfileValid for onboarding step 2 POST
  bool isProfileValid() {
    final dobValid = dateOfBirth != null &&
        DateTime.now().difference(dateOfBirth!).inDays >= (18 * 365.25);
    // Location/Gender validation is handled in onboarding step 1
    return name != null &&
        name!.trim().isNotEmpty &&
        name!.trim().length >= 3 &&
        dobValid &&
        datingIntention != null; // Added dating intention check for step 2
    // Removed location/gender check here as it's handled earlier
  }

  // isLocationValid remains the same (used in onboarding step 1)
  bool isLocationValid() {
    return latitude != null &&
        longitude != null &&
        latitude != 0.0 &&
        longitude != 0.0;
  }
}



================================================
File: providers/audio_player_provider.dart
================================================

// providers/audio_player_provider.dart
import 'package:audioplayers/audioplayers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

enum AudioPlayerState {
  idle,
  loading,
  playing,
  paused,
  completed,
  error,
}

final audioPlayerStateProvider = StateProvider<AudioPlayerState>((ref) => AudioPlayerState.idle);
final currentAudioUrlProvider = StateProvider<String?>((ref) => null);

final audioPlayerProvider = Provider<AudioPlayer>((ref) {
  final player = AudioPlayer();
  
  player.onPlayerComplete.listen((_) {
    ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.completed;
  });
  
  player.onPlayerStateChanged.listen((state) {
    if (state == PlayerState.playing) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.playing;
    } else if (state == PlayerState.paused) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.paused;
    } else if (state == PlayerState.stopped) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.idle;
    }
  });
  
  // Handle cleanup when the provider is disposed
  ref.onDispose(() {
    player.dispose();
  });
  
  return player;
});

class AudioPlayerNotifier extends StateNotifier<AudioPlayerState> {
  final Ref ref;
  final AudioPlayer _player;
  
  AudioPlayerNotifier(this.ref)
      : _player = ref.read(audioPlayerProvider),
        super(AudioPlayerState.idle);
  
  Future<void> play(String url) async {
    try {
      // If another audio is playing, stop it
      if (state == AudioPlayerState.playing) {
        await _player.stop();
      }
      
      state = AudioPlayerState.loading;
      ref.read(currentAudioUrlProvider.notifier).state = url;
      
      await _player.play(UrlSource(url));
      // State will be updated via listener in audioPlayerProvider
    } catch (e) {
      print("Error playing audio: $e");
      state = AudioPlayerState.error;
    }
  }
  
  Future<void> pause() async {
    if (state == AudioPlayerState.playing) {
      await _player.pause();
      // State will be updated via listener
    }
  }
  
  Future<void> resume() async {
    if (state == AudioPlayerState.paused) {
      await _player.resume();
      // State will be updated via listener
    }
  }
  
  Future<void> stop() async {
    await _player.stop();
    ref.read(currentAudioUrlProvider.notifier).state = null;
    // State will be updated via listener
  }
}

final audioPlayerControllerProvider = StateNotifierProvider<AudioPlayerNotifier, AudioPlayerState>((ref) {
  return AudioPlayerNotifier(ref);
});



================================================
File: providers/audio_upload_provider.dart
================================================
// providers/audio_upload_provider.dart
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../models/user_model.dart';
import '../repositories/media_repository.dart';
import '../utils/app_enums.dart';
import 'error_provider.dart';
import 'service_provider.dart';
import 'user_provider.dart';

final audioUploadProvider = StateNotifierProvider<AudioUploadNotifier, MediaUploadModel?>(
  (ref) {
    print('[AudioUpload] Initializing AudioUploadProvider');
    final mediaRepository = ref.watch(mediaRepositoryProvider);
    return AudioUploadNotifier(ref, mediaRepository);
  },
);

class AudioUploadNotifier extends StateNotifier<MediaUploadModel?> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  AudioPrompt? _selectedPrompt;
  String? _recordingPath;

  // Initialize with null (no audio uploaded yet)
  AudioUploadNotifier(this.ref, this._mediaRepository) : super(null) {
    print('[AudioUpload] AudioUploadNotifier created');
  }

  // Max audio size (10 MB)
  static const int _maxAudioSizeBytes = 10 * 1024 * 1024;

  // Supported audio MIME types
static final Set<String> _supportedAudioTypes = {
  'audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/webm',
  'audio/aac', 'audio/x-m4a', 'audio/x-aiff', 'audio/flac',
  'audio/mp4'  // Add this line to support M4A files
};

  // Save the recording path for later use
  void setRecordingPath(String path) {
    print('[AudioUpload] Setting recording path: $path');
    _recordingPath = path;
  }

  // Prepare audio file with validation
  bool prepareAudioFile() {
    print('[AudioUpload] Preparing audio file');
    print('[AudioUpload] Recording path: $_recordingPath');
    print('[AudioUpload] Selected prompt: ${_selectedPrompt?.value}');
    
    if (_recordingPath == null || _selectedPrompt == null) {
      print('[AudioUpload] ERROR: Missing recording path or prompt');
      return false;
    }
    
    final file = File(_recordingPath!);
    if (!file.existsSync()) {
      print('[AudioUpload] ERROR: File does not exist at path: $_recordingPath');
      return false;
    }
    
    try {
      // Validate file size
      final fileSize = file.lengthSync();
      print('[AudioUpload] File size: ${fileSize / 1024} KB');
      
      if (fileSize > _maxAudioSizeBytes) {
        print('[AudioUpload] ERROR: File too large: ${fileSize / 1024 / 1024} MB (max: ${_maxAudioSizeBytes / 1024 / 1024} MB)');
        ref.read(errorProvider.notifier).setError(
              AppError.validation("Audio is too large. Maximum size is 10 MB."),
            );
        return false;
      }

      // Detect MIME type
      final fileName = path.basename(file.path);
      final mimeType = lookupMimeType(file.path) ?? 'audio/mpeg';
      print('[AudioUpload] Filename: $fileName');
      print('[AudioUpload] MIME type: $mimeType');

      // Validate audio type
      if (!_supportedAudioTypes.contains(mimeType)) {
        print('[AudioUpload] ERROR: Unsupported audio format: $mimeType');
        ref.read(errorProvider.notifier).setError(
              AppError.validation("Unsupported audio format. Please use MP3, WAV, OGG, or other common audio formats."),
            );
        return false;
      }

      // Update state
      print('[AudioUpload] Creating MediaUploadModel');
      state = MediaUploadModel(
        file: file,
        fileName: fileName,
        fileType: mimeType,
        status: UploadStatus.idle,
      );
      
      print('[AudioUpload] Audio file prepared successfully');
      return true;
    } catch (e, stack) {
      print('[AudioUpload] ERROR preparing audio file: $e');
      print('[AudioUpload] Stack trace: $stack');
      return false;
    }
  }

  // Clear audio file
  void clearAudio() {
    print('[AudioUpload] Clearing audio state');
    state = null;
    _recordingPath = null;
    _selectedPrompt = null;
  }

  // Upload audio and save to user profile
  Future<bool> uploadAudioAndSaveToProfile() async {
    print('[AudioUpload] Starting uploadAudioAndSaveToProfile');
    
    if (state == null || _selectedPrompt == null) {
      print('[AudioUpload] State or prompt is null, attempting to prepare file');
      final prepared = prepareAudioFile();
      if (!prepared) {
        print('[AudioUpload] Failed to prepare audio file');
        return false;
      }
    }

    try {
      print('[AudioUpload] Clearing any previous errors');
      ref.read(errorProvider.notifier).clearError();

      // Update state to show upload in progress
      print('[AudioUpload] Setting state to UPLOADING');
      state = state!.copyWith(status: UploadStatus.inProgress);

      // Get presigned URL for audio
      print('[AudioUpload] Getting presigned URL for ${state!.fileName}');
      final presignedUrlResponse = await _mediaRepository.getAudioPresignedUrl(
        state!.fileName,
        state!.fileType,
        _selectedPrompt!,
      );
      
      print('[AudioUpload] Received presigned URL response: ${presignedUrlResponse.toString().substring(0, 100)}...');

      // Update state with presigned URL
      print('[AudioUpload] Updating state with presigned URL');
      state = state!.copyWith(
        presignedUrl: () => presignedUrlResponse['url'],
      );

      // Upload audio to S3
      print('[AudioUpload] Uploading file to S3');
      bool success = await _mediaRepository.uploadFileToS3(state!);
      print('[AudioUpload] Initial upload result: $success');

      // If failed, retry
      if (!success) {
        print('[AudioUpload] Initial upload failed, retrying...');
        success = await _mediaRepository.retryUpload(state!);
        print('[AudioUpload] Retry upload result: $success');
      }

      // Update state with result
      print('[AudioUpload] Setting final upload status: ${success ? "SUCCESS" : "FAILED"}');
      state = state!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload audio',
      );

      if (success) {
        // Create AudioPromptModel
        print('[AudioUpload] Creating AudioPromptModel with prompt: ${_selectedPrompt!.value}');
        final audioPromptModel = AudioPromptModel(
          prompt: _selectedPrompt!,
          audioUrl: presignedUrlResponse['url'],
        );

        // Add to user model
        print('[AudioUpload] Updating user model with audio prompt');
        ref.read(userProvider.notifier).updateAudioPrompt(audioPromptModel);
        print('[AudioUpload] User model updated successfully');
      }

      return success;
    } catch (e, stack) {
      print('[AudioUpload] ERROR during upload: $e');
      print('[AudioUpload] Stack trace: $stack');
      
      if (state != null) {
        state = state!.copyWith(
          status: UploadStatus.failed,
          errorMessage: () => 'Failed to upload audio: ${e.toString()}',
        );
      }
      return false;
    }
  }

  // Get the selected prompt
  AudioPrompt? get selectedPrompt => _selectedPrompt;

  // Set the selected prompt
  void setSelectedPrompt(AudioPrompt prompt) {
    print('[AudioUpload] Setting selected prompt: ${prompt.value}');
    _selectedPrompt = prompt;
  }
}



================================================
File: providers/auth_provider.dart
================================================
// File: providers/auth_provider.dart
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import providers to invalidate
import 'package:dtx/providers/filter_provider.dart';
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../models/error_model.dart';
import '../repositories/auth_repository.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import 'error_provider.dart';
import 'service_provider.dart';

// Provider for GoogleSignIn instance (remains the same)
final googleSignInProvider = Provider<GoogleSignIn>((ref) {
  return GoogleSignIn(
    scopes: ['email', 'profile'],
  );
});

// AuthProvider definition (remains the same)
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final authRepository = ref.watch(authRepositoryProvider);
  // *** Pass ref to the notifier ***
  return AuthNotifier(ref, authRepository);
});

class AuthNotifier extends StateNotifier<AuthState> {
  // *** Store the Ref object ***
  final Ref ref;
  final AuthRepository _authRepository;

  // *** Modify constructor to accept Ref ***
  AuthNotifier(this.ref, this._authRepository) : super(const AuthState()) {
    _loadTokenAndCheckStatus();
  }

  // _loadTokenAndCheckStatus, checkAuthStatus, signInWithGoogle remain the same

  Future<void> _loadTokenAndCheckStatus() async {
    print('[AuthNotifier] Loading token and checking initial status...');
    state = state.copyWith(isLoading: true);
    final token = await TokenStorage.getToken();
    if (token != null && token.isNotEmpty) {
      print(
          '[AuthNotifier] Token found, setting in state and checking status.');
      state = state.copyWith(jwtToken: () => token);
      await checkAuthStatus(updateState: true); // Check status if token exists
    } else {
      print('[AuthNotifier] No token found, setting state to login.');
      // If no token, status is definitely login
      state = state.copyWith(
          isLoading: false, authStatus: AuthStatus.login, jwtToken: () => null);
    }
  }

  Future<AuthStatus> checkAuthStatus({bool updateState = true}) async {
    print('[AuthNotifier checkAuthStatus] Called. updateState: $updateState');
    if (updateState) {
      state = state.copyWith(isLoading: true, error: () => null);
    }

    // Use token from state if available, otherwise try storage
    final token = state.jwtToken ?? await TokenStorage.getToken();

    // If still no token, return login status immediately
    if (token == null || token.isEmpty) {
      print(
          '[AuthNotifier checkAuthStatus] No token available, returning login status.');
      if (updateState) {
        state = state.copyWith(
            isLoading: false,
            authStatus: AuthStatus.login,
            jwtToken: () => null);
      }
      return AuthStatus.login;
    }

    try {
      final backendStatus = await _authRepository.checkAuthStatus(token);
      print(
          '[AuthNotifier checkAuthStatus] Backend status received: $backendStatus');

      if (updateState) {
        state = state.copyWith(
          isLoading: false,
          authStatus: backendStatus,
          // Keep the token in state if status is not login
          // No need to clear token here unless backendStatus is login
          jwtToken: backendStatus == AuthStatus.login ? () => null : null,
        );
        if (backendStatus == AuthStatus.login) {
          print(
              '[AuthNotifier checkAuthStatus] Status is login, removing token from storage.');
          await TokenStorage.removeToken(); // Also remove from storage
        }
      }
      print(
          '[AuthNotifier checkAuthStatus] Finished. Returning: $backendStatus');
      return backendStatus;
    } catch (e) {
      print('[AuthNotifier checkAuthStatus] Error: $e');
      if (updateState) {
        state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login, // Default to login on error
          error: () => 'Failed to check status: ${e.toString()}',
          jwtToken: () => null, // Clear token on error
        );
        print(
            '[AuthNotifier checkAuthStatus] Error occurred, removing token from storage.');
        await TokenStorage.removeToken(); // Also remove from storage
      }
      return AuthStatus.login; // Return login on error
    }
  }

  Future<AuthStatus> signInWithGoogle() async {
    print('[AuthNotifier signInWithGoogle] Attempting Google Sign-In...');
    state = state.copyWith(isLoading: true, error: () => null);
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors

    try {
      final googleSignIn = ref.read(googleSignInProvider);
      final googleUser = await googleSignIn.signIn(); // Prompts user

      if (googleUser == null) {
        print('[AuthNotifier signInWithGoogle] User cancelled Google Sign-In.');
        state = state.copyWith(isLoading: false, authStatus: AuthStatus.login);
        return AuthStatus.login; // User cancelled
      }

      print(
          '[AuthNotifier signInWithGoogle] Google Sign-In successful for: ${googleUser.email}');
      final googleAuth = await googleUser.authentication;
      final googleAccessToken = googleAuth.accessToken;

      if (googleAccessToken == null) {
        print(
            '[AuthNotifier signInWithGoogle] Failed to get Google Access Token.');
        throw ApiException('Could not retrieve access token from Google.');
      }

      print(
          '[AuthNotifier signInWithGoogle] Verifying Google Access Token with backend...');
      final appJwt = await _authRepository.verifyGoogleToken(googleAccessToken);
      print(
          '[AuthNotifier signInWithGoogle] Backend verification successful. App JWT received.');

      await TokenStorage.saveToken(appJwt);
      print('[AuthNotifier signInWithGoogle] App JWT saved to storage.');

      // IMPORTANT: After successful login and getting the JWT,
      // immediately check the status with the backend to know the next step.
      state = state.copyWith(jwtToken: () => appJwt); // Set token in state
      print(
          '[AuthNotifier signInWithGoogle] JWT set in state. Checking auth status...');
      final finalStatus = await checkAuthStatus(
          updateState: true); // Update state with final status

      print(
          '[AuthNotifier signInWithGoogle] Sign-in process complete. Final Status: $finalStatus');
      return finalStatus; // Return the status determined by checkAuthStatus
    } on ApiException catch (e) {
      print('[AuthNotifier signInWithGoogle] API Exception: ${e.message}');
      state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login,
          error: () => e.message);
      ref.read(errorProvider.notifier).setError(AppError.auth(e.message));
      await logout(); // Clear any potentially saved invalid token
      return AuthStatus.login;
    } catch (e) {
      print(
          '[AuthNotifier signInWithGoogle] Unexpected Error: ${e.toString()}');
      state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login,
          error: () => 'An unexpected error occurred during sign-in.');
      ref.read(errorProvider.notifier).setError(
          AppError.auth("An unexpected error occurred. Please try again."));
      await logout(); // Clear any potentially saved invalid token
      return AuthStatus.login;
    }
  }

  // Logout user
  Future<void> logout() async {
    print('[AuthNotifier] Logging out...');
    final currentToken = state.jwtToken ?? await TokenStorage.getToken();

    try {
      final googleSignIn = ref.read(googleSignInProvider);
      await googleSignIn.signOut(); // Sign out from Google
      await googleSignIn.disconnect().catchError((e) {
        // Catch errors during disconnect specifically, as it can sometimes fail
        print('[AuthNotifier] Non-critical error during Google disconnect: $e');
      });
    } catch (e) {
      print('[AuthNotifier] Error during Google Sign Out: $e');
      // Decide if you want to proceed with app logout even if Google logout fails
    } finally {
      await TokenStorage.removeToken(); // Remove app token *always*
      print('[AuthNotifier] Token removed from storage.');

      // Reset auth state *first*
      state = const AuthState(authStatus: AuthStatus.login);
      print('[AuthNotifier] Auth state reset to login.');

      // *** Invalidate other user-specific providers ***
      print('[AuthNotifier] Invalidating user-specific providers...');
      ref.invalidate(userProvider);
      ref.invalidate(feedProvider);
      ref.invalidate(receivedLikesProvider);
      ref.invalidate(filterProvider);
      // Add any other providers that store user-specific data here
      // e.g., ref.invalidate(chatProvider);
      // e.g., ref.invalidate(likerProfileProvider); // .family needs specific handling if needed globally
      print('[AuthNotifier] Providers invalidated.');

      // Optionally, you could call a backend logout endpoint if you have one
      // if (currentToken != null) {
      //   try {
      //     await _authRepository.logoutBackend(currentToken);
      //     print('[AuthNotifier] Backend logout successful.');
      //   } catch (e) {
      //     print('[AuthNotifier] Backend logout failed (non-critical): $e');
      //   }
      // }

      print('[AuthNotifier] Local logout complete.');
    }
  }
}



================================================
File: providers/error_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/error_model.dart';

final errorProvider = StateNotifierProvider<ErrorNotifier, AppError?>((ref) {
  return ErrorNotifier();
});

class ErrorNotifier extends StateNotifier<AppError?> {
  ErrorNotifier() : super(null);

  void setError(AppError error) => state = error;
  void clearError() => state = null;
}



================================================
File: providers/feed_provider.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/user_model.dart'; // Use full UserModel
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/user_repository.dart';
import 'package:dtx/services/api_service.dart';
// Removed FeedType import
import 'package:flutter_riverpod/flutter_riverpod.dart';

// --- Removed QuickFeedState ---

// --- Home Feed State ---
class HomeFeedState {
  final bool isLoading;
  final List<UserModel> profiles; // Use full UserModel for Home Feed
  final AppError? error;
  final bool hasFetchedOnce; // Track if initial fetch happened
  final bool hasMore; // Track if API indicates more profiles available

  const HomeFeedState({
    this.isLoading = false, // Start not loading until fetch is called
    this.profiles = const [],
    this.error,
    this.hasFetchedOnce = false,
    this.hasMore = true, // Assume more initially
  });

  HomeFeedState copyWith({
    bool? isLoading,
    List<UserModel>? profiles,
    AppError? Function()? error,
    bool? hasFetchedOnce,
    bool? hasMore,
  }) {
    return HomeFeedState(
      isLoading: isLoading ?? this.isLoading,
      profiles: profiles ?? this.profiles,
      error: error != null ? error() : this.error,
      hasFetchedOnce: hasFetchedOnce ?? this.hasFetchedOnce,
      hasMore: hasMore ?? this.hasMore,
    );
  }
}

// --- Simplified Feed Notifier (Only Home Feed) ---
class FeedNotifier extends StateNotifier<HomeFeedState> {
  final UserRepository _userRepository;
  final Ref _ref;

  FeedNotifier(this._userRepository, this._ref) : super(const HomeFeedState());

  Future<void> fetchFeed({bool forceRefresh = false}) async {
    print("[FeedNotifier] fetchFeed called. forceRefresh: $forceRefresh");

    if (state.isLoading) {
      print("[FeedNotifier] Skipping fetch (already loading).");
      return;
    }
    // If already fetched and not forcing refresh, and we have profiles or know there are no more, skip
    if (state.hasFetchedOnce &&
        !forceRefresh &&
        (state.profiles.isNotEmpty || !state.hasMore)) {
      print(
          "[FeedNotifier] Skipping fetch (already fetched & no force required). Has Profiles: ${state.profiles.isNotEmpty}, Has More: ${state.hasMore}");
      return;
    }

    state = state.copyWith(isLoading: true, error: () => null);

    try {
      // Directly fetch home feed profiles
      final result = await _userRepository
          .fetchHomeFeed(); // Assuming repo returns Map now
      final profiles = result['profiles'] as List<UserModel>;
      final hasMore =
          result['has_more'] as bool? ?? false; // Default to false if missing

      print(
          "[FeedNotifier] Fetched ${profiles.length} home profiles. Has More: $hasMore");
      if (!mounted) return;

      state = HomeFeedState(
        isLoading: false,
        profiles: profiles,
        error: null,
        hasFetchedOnce: true, // Mark as fetched
        hasMore: hasMore, // Update hasMore status
      );
    } on ApiException catch (e) {
      print("[FeedNotifier] API Exception: ${e.message}");
      if (!mounted) return;
      state = state.copyWith(
        isLoading: false,
        error: () => AppError.server(e.message),
        hasFetchedOnce:
            true, // Mark as fetched even on error to prevent reload loops
        hasMore: false, // Assume no more on error
      );
    } catch (e) {
      print("[FeedNotifier] Unexpected Error: ${e.toString()}");
      if (!mounted) return;
      state = state.copyWith(
        isLoading: false,
        error: () => AppError.generic("Failed to load feed."),
        hasFetchedOnce: true,
        hasMore: false,
      );
    }
  }

  // Method to remove a profile after interaction
  void removeProfile(int userId) {
    print("[FeedNotifier] Removing profile ID: $userId");
    if (!mounted) return;
    final updatedProfiles =
        state.profiles.where((profile) => profile.id != userId).toList();

    state = state.copyWith(profiles: updatedProfiles);

    // Optional: Fetch more if the list gets too small and we know there are more
    if (updatedProfiles.length < 3 && state.hasMore && !state.isLoading) {
      print(
          "[FeedNotifier] Profile list low (<3) and hasMore=true, fetching more...");
      fetchFeed(); // Fetch more without forcing refresh
    } else if (updatedProfiles.isEmpty && !state.hasMore) {
      print("[FeedNotifier] Profile list empty and hasMore=false.");
      // State already reflects empty list
    }
  }
}

// --- Provider Definition ---
final feedProvider = StateNotifierProvider<FeedNotifier, HomeFeedState>((ref) {
  final userRepository = ref.watch(userRepositoryProvider);
  return FeedNotifier(userRepository, ref);
});



================================================
File: providers/filter_provider.dart
================================================
// lib/providers/filter_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/filter_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// --- REMOVED: filterLoadingProvider - manage loading within the notifier ---

// --- StateNotifier Provider ---
final filterProvider =
    StateNotifierProvider<FilterNotifier, FilterSettings>((ref) {
  final filterRepository = ref.watch(filterRepositoryProvider);
  return FilterNotifier(ref, filterRepository);
});

// --- StateNotifier ---
class FilterNotifier extends StateNotifier<FilterSettings> {
  final Ref ref;
  final FilterRepository _filterRepository;
  bool _isLoading = false; // Internal loading state
  bool get isLoading => _isLoading; // Getter for UI

  FilterNotifier(this.ref, this._filterRepository)
      : super(const FilterSettings()) {
    // Optionally load filters on initialization if needed, or rely on UI trigger
    // loadFilters();
  }

  // Load filters from the repository
  Future<void> loadFilters({bool forceRemote = false}) async {
    // Prevent multiple fetches if already loading or if data exists and not forced
    if (_isLoading || (state != const FilterSettings() && !forceRemote)) {
      return;
    }
    _setLoading(true);
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors

    try {
      final filters = await _filterRepository.fetchFilters();
      if (mounted) {
        state = filters; // Update state
      }
    } catch (e) {
      if (mounted) {
        ref
            .read(errorProvider.notifier)
            .setError(AppError.generic("Could not load filter settings."));
        // Don't reset to default, keep previous state or handle error UI
      }
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  // Save filters to the repository
  Future<bool> saveFilters(FilterSettings newFilters) async {
    if (_isLoading) return false;
    _setLoading(true);
    ref.read(errorProvider.notifier).clearError();
    final previousState = state; // Keep old state in case of failure
    state = newFilters; // Optimistically update UI

    try {
      final success = await _filterRepository.updateFilters(newFilters);
      if (!success) {
        // If API returns false, revert state and show error
        if (mounted) {
          state = previousState;
          ref
              .read(errorProvider.notifier)
              .setError(AppError.server("Failed to save filters."));
        }
        return false;
      }
      return true; // Success
    } on ApiException catch (e) {
      if (mounted) {
        state = previousState; // Revert state on error
        ref.read(errorProvider.notifier).setError(AppError.server(e.message));
      }
      return false;
    } catch (e) {
      if (mounted) {
        state = previousState; // Revert state on error
        ref
            .read(errorProvider.notifier)
            .setError(AppError.generic("An unexpected error occurred."));
      }
      return false;
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  // Helper to manage internal loading state
  void _setLoading(bool loading) {
    // Could add notifyListeners() if using ChangeNotifier, but not needed for StateNotifier
    if (_isLoading != loading) {
      _isLoading = loading;
      // No need to call setState or notifyListeners for StateNotifier's internal state
    }
  }

  // Method to update a single filter value directly (e.g., from slider/switch)
  // Ensures immutability by using copyWith
  void updateSingleFilter<T>(T value, FilterField field) {
    if (_isLoading) return; // Prevent updates while saving/loading
    state = state.copyWith(
      whoYouWantToSee: field == FilterField.whoYouWantToSee
          ? () => value as FilterGenderPref? // Cast to correct type
          : null, // Return null for other fields
      radiusKm: field == FilterField.radiusKm ? () => value as int? : null,
      activeToday:
          field == FilterField.activeToday ? () => value as bool? : null,
      ageMin: field == FilterField.ageMin ? () => value as int? : null,
      ageMax: field == FilterField.ageMax ? () => value as int? : null,
    );
  }
}

// Enum to identify which filter field is being updated
enum FilterField { whoYouWantToSee, radiusKm, activeToday, ageMin, ageMax }



================================================
File: providers/liker_profile_provider.dart
================================================
// File: providers/liker_profile_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State Definition
class LikerProfileState {
  final bool isLoading;
  final UserProfileData? profile;
  final LikeInteractionDetails? likeDetails;
  final AppError? error;

  const LikerProfileState({
    this.isLoading = true, // Start loading
    this.profile,
    this.likeDetails,
    this.error,
  });

  LikerProfileState copyWith({
    bool? isLoading,
    UserProfileData? Function()? profile, // Nullable functions
    LikeInteractionDetails? Function()? likeDetails,
    AppError? Function()? error,
  }) {
    return LikerProfileState(
      isLoading: isLoading ?? this.isLoading,
      profile: profile != null ? profile() : this.profile,
      likeDetails: likeDetails != null ? likeDetails() : this.likeDetails,
      error: error != null ? error() : this.error,
    );
  }
}

// StateNotifier Definition
class LikerProfileNotifier extends StateNotifier<LikerProfileState> {
  final LikeRepository _likeRepository;
  final int _likerUserId;

  LikerProfileNotifier(this._likeRepository, this._likerUserId)
      : super(const LikerProfileState()) {
    fetchProfile(); // Fetch profile on initialization
  }

  Future<void> fetchProfile() async {
    print(
        "[LikerProfileNotifier] Fetching profile for liker ID: $_likerUserId");
    // Don't clear profile/details on refetch, only on error maybe?
    state = state.copyWith(isLoading: true, error: () => null);
    try {
      final result = await _likeRepository.fetchLikerProfile(_likerUserId);
      final profileData = result['profile'] as UserProfileData?;
      final likeDetailsData = result['likeDetails'] as LikeInteractionDetails?;

      if (profileData != null && likeDetailsData != null) {
        print("[LikerProfileNotifier] Fetch successful.");
        state = state.copyWith(
          isLoading: false,
          profile: () => profileData,
          likeDetails: () => likeDetailsData,
          error: () => null,
        );
      } else {
        // This case should ideally be caught by the repository throwing an exception
        print(
            "[LikerProfileNotifier] Fetch failed: Repository returned null data.");
        state = state.copyWith(
            isLoading: false,
            error: () => AppError.server("Failed to load profile data."));
      }
    } on ApiException catch (e) {
      print("[LikerProfileNotifier] API Exception: ${e.message}");
      // Handle 404 Not Found specifically maybe
      if (e.statusCode == 404) {
        state = state.copyWith(
            isLoading: false,
            error: () => AppError.server(
                "Profile not found or you were not liked by this user."));
      } else {
        state = state.copyWith(
            isLoading: false, error: () => AppError.server(e.message));
      }
    } catch (e) {
      print("[LikerProfileNotifier] Unexpected Error: ${e.toString()}");
      state = state.copyWith(
          isLoading: false,
          error: () => AppError.generic("Failed to load profile."));
    }
  }
}

// Provider Definition (.family)
final likerProfileProvider =
    StateNotifierProvider.family<LikerProfileNotifier, LikerProfileState, int>(
        (ref, likerUserId) {
  final likeRepository = ref.watch(likeRepositoryProvider);
  return LikerProfileNotifier(likeRepository, likerUserId);
});



================================================
File: providers/location_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:geolocator/geolocator.dart';
import '../models/error_model.dart';
import '../models/location_model.dart';
import 'error_provider.dart';
import 'user_provider.dart';

final locationProvider =
    StateNotifierProvider<LocationNotifier, LocationState>((ref) {
  return LocationNotifier(ref);
});

class LocationNotifier extends StateNotifier<LocationState> {
  final Ref ref;

  LocationNotifier(this.ref) : super(LocationState());

  void setMapReady(bool ready) {
    state = state.copyWith(isMapReady: ready);
  }

  Future<void> openLocationSettings() async {
    try {
      await Geolocator.openLocationSettings();
    } catch (e) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.network("Failed to open location settings"));
    }
  }

  Future<void> fetchCurrentLocation() async {
    // Clear any existing errors
    ref.read(errorProvider.notifier).clearError();

    // Reset state for fresh fetch
    state = state.copyWith(
      isFetching: true,
      isLoading: true,
      cachedLatitude: null,
      cachedLongitude: null,
    );

    try {
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        ref.read(errorProvider.notifier).setError(
            AppError.locationService("Location services are disabled"));
        state = state.copyWith(isLoading: false);
        return;
      }

      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          ref
              .read(errorProvider.notifier)
              .setError(AppError.validation("Location permissions are denied"));
          state = state.copyWith(isLoading: false);
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Location permissions are permanently denied"));
        state = state.copyWith(isLoading: false);
        return;
      }

      Position position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.high);

      final newLatitude = position.latitude;
      final newLongitude = position.longitude;

      // Update user provider with the location
      ref.read(userProvider.notifier).updateLocation(newLatitude, newLongitude);

      state = state.copyWith(
        latitude: newLatitude,
        longitude: newLongitude,
        cachedLatitude: newLatitude,
        cachedLongitude: newLongitude,
        isLoading: false,
      );
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
          AppError.network("Failed to fetch location: ${e.toString()}"));
      state = state.copyWith(isLoading: false);
    } finally {
      state = state.copyWith(isFetching: false);
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(latitude: latitude, longitude: longitude);
    ref.read(userProvider.notifier).updateLocation(latitude, longitude);
  }

  void useCachedLocation() {
    if (state.cachedLatitude != null && state.cachedLongitude != null) {
      updateLocation(state.cachedLatitude!, state.cachedLongitude!);
    }
  }
}



================================================
File: providers/media_upload_provider.dart
================================================
import 'dart:io';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../repositories/media_repository.dart';
import 'error_provider.dart';
import 'service_provider.dart';

final mediaUploadProvider = StateNotifierProvider<MediaUploadNotifier, List<MediaUploadModel?>>((ref) {
  final mediaRepository = ref.watch(mediaRepositoryProvider);
  return MediaUploadNotifier(ref, mediaRepository);
});

class MediaUploadNotifier extends StateNotifier<List<MediaUploadModel?>> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  
  // Initialize with 6 null slots for media
  MediaUploadNotifier(this.ref, this._mediaRepository) : super(List.filled(6, null));
  
  // File size limits in bytes
  static const int _maxImageSizeBytes = 10 * 1024 * 1024; // 10 MB
  static const int _maxVideoSizeBytes = 50 * 1024 * 1024; // 50 MB

  MediaUploadModel? _verificationImage;

  MediaUploadModel? get verificationImage => _verificationImage;

  void setVerificationImage(File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'image/jpeg';

    final isImage = mimeType.startsWith('image/');

    if (!isImage) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Only image files are allowed."),
      );
      return;
    }

    if (fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }

    // Update state
    _verificationImage = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
  }

  void clearVerificationImage() {
    _verificationImage = null;
  }

  Future<bool> uploadVerificationImage() async {
    if (_verificationImage == null) return false;

    try {
      // Clear any existing errors
      ref.read(errorProvider.notifier).clearError();

      // Get presigned URL
      final presignedUrl = await _mediaRepository.getVerificationPresignedUrl(
        _verificationImage!.fileName,
        _verificationImage!.fileType,
      );

      // Update verification image with presigned URL
      _verificationImage = _verificationImage!.copyWith(
        presignedUrl: () => presignedUrl,
        status: UploadStatus.inProgress,
      );

      // Upload the file
      final success = await _mediaRepository.uploadFileToS3(_verificationImage!);

      // Update status
      _verificationImage = _verificationImage!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload verification image',
      );

      return success;
    } on ApiException catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => e.message,
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.message),
      );
      return false;
    } catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => 'An unexpected error occurred. Please try again.',
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth("An unexpected error occurred. Please try again."),
      );
      return false;
    }
  }
  
  // Add or update media at a specific index
  void setMediaFile(int index, File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'application/octet-stream';
    
    final isImage = mimeType.startsWith('image/');
    final isVideo = mimeType.startsWith('video/');
    
    // Size validation
    if (isImage && fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }
    
    if (isVideo && fileSize > _maxVideoSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Video is too large. Maximum size is 50 MB."),
      );
      return;
    }
    
    // Update state
    final updatedState = [...state];
    updatedState[index] = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
    state = updatedState;
  }
  
  // Remove media at a specific index
  void removeMedia(int index) {
    final updatedState = [...state];
    updatedState[index] = null;
    state = updatedState;
  }
  
  // Get all non-null media items
  List<MediaUploadModel> getMediaItems() {
    return state.whereType<MediaUploadModel>().toList();
  }
  
  // Check if we have minimum required media (3)
  bool hasMinimumMedia() {
    return getMediaItems().length >= 3;
  }
  
  // Upload all media
  Future<bool> uploadAllMedia() async {
    final mediaItems = getMediaItems();
    if (mediaItems.isEmpty) return false;
    
    try {
      // Prepare file details for presigned URL request
      final fileDetails = mediaItems.map((item) => {
        'filename': item.fileName,
        'type': item.fileType,
      }).toList();
      
  print("lauda lassan 2");
      // Get presigned URLs
      final presignedUrlsResponse = await _mediaRepository.getPresignedUrls(fileDetails);
      
      // Update media items with presigned URLs
      final updatedState = [...state];
      for (int i = 0; i < mediaItems.length; i++) {
        final index = state.indexOf(mediaItems[i]);
        if (index >= 0 && index < presignedUrlsResponse.length) {
          updatedState[index] = mediaItems[i].copyWith(
            presignedUrl: () => presignedUrlsResponse[i]['url'],
            status: UploadStatus.inProgress,
          );
        }
      }
      state = updatedState;
      
      // Upload each file
      bool allSucceeded = true;
      for (int i = 0; i < mediaItems.length; i++) {
        final mediaItem = state.firstWhere(
          (item) => item?.fileName == mediaItems[i].fileName,
          orElse: () => null,
        );
        
        if (mediaItem != null) {
          final index = state.indexOf(mediaItem);
          bool success = false;
          
          try {
            success = await _mediaRepository.uploadFileToS3(mediaItem);
          } catch (e) {
            print('Initial upload failed: $e');
            success = false;
          }
          
          // Retry if failed
          if (!success) {
            success = await _mediaRepository.retryUpload(mediaItem);
          }
          
          // Update state with result
          final newUpdatedState = [...state];
          newUpdatedState[index] = mediaItem.copyWith(
            status: success ? UploadStatus.success : UploadStatus.failed,
            errorMessage: success ? () => null : () => 'Failed to upload',
          );
          state = newUpdatedState;
          
          if (!success) allSucceeded = false;
        }
      }
      
      return allSucceeded;
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.toString()),
      );
      return false;
    }
  }
}



================================================
File: providers/recieved_likes_provider.dart
================================================
// File: providers/received_likes_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State definition remains the same
class ReceivedLikesState {
  final bool isLoading;
  final List<FullProfileLiker> fullProfiles;
  final List<BasicProfileLiker> otherLikers;
  final AppError? error;

  const ReceivedLikesState({
    this.isLoading = false, // Start NOT loading initially
    this.fullProfiles = const [],
    this.otherLikers = const [],
    this.error,
  });

  ReceivedLikesState copyWith({
    bool? isLoading,
    List<FullProfileLiker>? fullProfiles,
    List<BasicProfileLiker>? otherLikers,
    AppError? Function()? error,
  }) {
    return ReceivedLikesState(
      isLoading: isLoading ?? this.isLoading,
      fullProfiles: fullProfiles ?? this.fullProfiles,
      otherLikers: otherLikers ?? this.otherLikers,
      error: error != null ? error() : this.error,
    );
  }
}

// StateNotifier definition
class ReceivedLikesNotifier extends StateNotifier<ReceivedLikesState> {
  final LikeRepository _likeRepository;

  ReceivedLikesNotifier(this._likeRepository)
      : super(const ReceivedLikesState());

  Future<void> fetchLikes() async {
    // Prevent concurrent fetches if already loading
    if (state.isLoading) {
      print("[ReceivedLikesNotifier] fetchLikes skipped, already loading.");
      return;
    }

    print("[ReceivedLikesNotifier] fetchLikes called. Setting isLoading=true.");
    state = state.copyWith(
        isLoading: true, error: () => null); // Set loading true *here*

    try {
      print(
          "[ReceivedLikesNotifier] Calling _likeRepository.fetchReceivedLikes()...");
      final result = await _likeRepository.fetchReceivedLikes();
      print(
          "[ReceivedLikesNotifier] Repository call finished. Result received.");

      // Ensure component is still mounted before modifying state
      if (!mounted) {
        print(
            "[ReceivedLikesNotifier] Component unmounted after fetch. Aborting state update.");
        return;
      }

      final fullProfiles = result['full'] as List<FullProfileLiker>? ?? [];
      final otherLikers = result['other'] as List<BasicProfileLiker>? ?? [];
      print(
          "[ReceivedLikesNotifier] fetchLikes success. Full: ${fullProfiles.length}, Other: ${otherLikers.length}. Setting isLoading=false.");

      state = state.copyWith(
        isLoading: false, // Set loading false on success
        fullProfiles: fullProfiles,
        otherLikers: otherLikers,
        error: () => null,
      );
    } on ApiException catch (e) {
      print(
          "[ReceivedLikesNotifier] fetchLikes API Exception: ${e.message}. Setting isLoading=false.");
      if (mounted) {
        state = state.copyWith(
            isLoading: false, // Set loading false on error
            error: () => AppError.server(e.message));
      } else {
        print(
            "[ReceivedLikesNotifier] Component unmounted after API exception.");
      }
    } catch (e, stacktrace) {
      // Catch generic errors and stacktrace
      print(
          "[ReceivedLikesNotifier] fetchLikes Unexpected Error: ${e.toString()}. Setting isLoading=false.");
      print(
          "[ReceivedLikesNotifier] Stacktrace: $stacktrace"); // Log stacktrace
      if (mounted) {
        state = state.copyWith(
            isLoading: false, // Set loading false on error
            error: () => AppError.generic("Failed to load likes."));
      } else {
        print(
            "[ReceivedLikesNotifier] Component unmounted after unexpected error.");
      }
    }
    // Removed finally block as isLoading=false is handled in try/catch
  }
}

// Provider definition
final receivedLikesProvider =
    StateNotifierProvider<ReceivedLikesNotifier, ReceivedLikesState>((ref) {
  final likeRepository = ref.watch(likeRepositoryProvider);
  return ReceivedLikesNotifier(likeRepository);
});



================================================
File: providers/service_provider.dart
================================================
// File: providers/service_provider.dart
import 'package:dtx/repositories/filter_repository.dart';
import 'package:dtx/repositories/user_repository.dart';
import 'package:dtx/repositories/media_repository.dart';
import 'package:dtx/repositories/like_repository.dart'; // *** ADDED Import ***
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/api_service.dart';
import '../services/http_service.dart';
import '../repositories/auth_repository.dart';
import '../utils/env_config.dart';

// API Service provider
final apiServiceProvider = Provider<ApiService>((ref) {
  return HttpService(baseUrl: EnvConfig.apiBaseUrl);
});

// Auth Repository provider
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AuthRepository(apiService);
});

// Media Repository provider
final mediaRepositoryProvider = Provider<MediaRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return MediaRepository(apiService, ref);
});

// User Repository provider
final userRepositoryProvider = Provider<UserRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return UserRepository(apiService);
});

// *** ADDED: Like Repository Provider ***
final likeRepositoryProvider = Provider<LikeRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return LikeRepository(apiService);
});

final filterRepositoryProvider = Provider<FilterRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return FilterRepository(apiService);
});
// *** END ADDED ***



================================================
File: providers/user_provider.dart
================================================
// File: providers/user_provider.dart
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:latlong2/latlong.dart'; // Keep if used
import '../models/error_model.dart';
import '../models/user_model.dart';
import '../utils/app_enums.dart';

final userLoadingProvider = StateProvider<bool>((ref) => false);

final userProvider = StateNotifierProvider<UserNotifier, UserModel>((ref) {
  return UserNotifier(ref);
});

class UserNotifier extends StateNotifier<UserModel> {
  final Ref ref;

  UserNotifier(this.ref) : super(UserModel());

  Future<bool> fetchProfile() async {
    // Only set loading true if profile is actually empty
    bool shouldShowLoading = state.id == null;
    if (shouldShowLoading) ref.read(userLoadingProvider.notifier).state = true;
    ref.read(errorProvider.notifier).clearError();

    try {
      final userRepository = ref.read(userRepositoryProvider);
      final userModel = await userRepository.fetchUserProfile();
      state = userModel; // Direct assignment from fetch is fine
      if (shouldShowLoading)
        ref.read(userLoadingProvider.notifier).state = false;
      return true;
    } on ApiException catch (e) {
      if (shouldShowLoading)
        ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
            AppError.server(e.message), // Use server error type
          );
      return false;
    } catch (e) {
      if (shouldShowLoading)
        ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
            AppError.generic(
                "Failed to load profile: ${e.toString()}"), // Use generic
          );
      return false;
    }
  }

  // --- NO CHANGE: name, dob, location, gender updates are NOT used for editing ---
  void updateName(String firstName, String? lastName) {
    // This logic is only for onboarding validation
    ref.read(errorProvider.notifier).clearError();
    if (firstName.isEmpty || firstName.trim().length < 3) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("First name must be at least 3 characters"),
          );
      // Don't update state if invalid during onboarding
      // For edit, we rely on the ProfileScreen to handle this before save
      return;
    }
    state = state.copyWith(
      name: () => firstName.trim(),
      lastName: () => lastName?.trim(),
    );
  }

  void updateDateOfBirth(DateTime date) {
    // This logic is only for onboarding validation
    ref.read(errorProvider.notifier).clearError();
    final today = DateTime.now();
    final age = today.difference(date).inDays ~/ 365.25;

    if (date.year < 1900 || date.isAfter(today)) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Invalid year"));
      return;
    }
    if (age < 18) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("You must be at least 18 years old"));
      return;
    }
    try {
      final validatedDate = DateTime(date.year, date.month, date.day);
      state = state.copyWith(dateOfBirth: () => validatedDate);
    } catch (e) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Invalid date combination"));
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(
      latitude: () => latitude,
      longitude: () => longitude,
    );
  }

  void updateGender(Gender? gender) {
    state = state.copyWith(gender: () => gender);
  }
  // --- END NO CHANGE ---

  LatLng getCurrentLocation() {
    return LatLng(state.latitude ?? 19.2183, state.longitude ?? 73.0864);
  }

  bool isLocationValid() {
    return state.latitude != null &&
        state.longitude != null &&
        state.latitude != 0.0 &&
        state.longitude != 0.0;
  }

  bool isNameValid() => (state.name?.trim().length ?? 0) >= 3;

  // --- Editable Fields ---
  void updateDatingIntention(DatingIntention? intention) {
    state = state.copyWith(datingIntention: () => intention);
  }

  bool isDatingIntentionSelected() {
    return state.datingIntention != null;
  }

  void updateHeight(String height) {
    state = state.copyWith(height: () => height);
  }

  bool isHeightSelected() {
    return state.height != null && state.height!.isNotEmpty;
  }

  void updateHometown(String? hometown) {
    // Allow setting to null for clearing
    state = state.copyWith(hometown: () => hometown?.trim());
  }

  bool isHometownSelected() {
    return state.hometown != null && state.hometown!.isNotEmpty;
  }

  void updateJobTitle(String? jobTitle) {
    // Allow setting to null for clearing
    state = state.copyWith(jobTitle: () => jobTitle?.trim());
  }

  void updateEducation(String? education) {
    // Allow setting to null for clearing
    state = state.copyWith(education: () => education?.trim());
  }

  void updateReligiousBeliefs(Religion? religion) {
    state = state.copyWith(religiousBeliefs: () => religion);
  }

  void updateDrinkingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(drinkingHabit: () => habit);
  }

  void updateSmokingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(smokingHabit: () => habit);
  }

  void addPrompt(Prompt prompt) {
    if (prompt.answer.trim().isEmpty) return;
    if (state.prompts.length >= 3) return;
    final updatedPrompts = List<Prompt>.from(state.prompts)..add(prompt);
    state = state.copyWith(prompts: updatedPrompts);
  }

  void updatePromptAtIndex(int index, Prompt newPrompt) {
    if (newPrompt.answer.trim().isEmpty) return;
    final updatedPrompts = List<Prompt>.from(state.prompts);
    if (index >= 0 && index < updatedPrompts.length) {
      updatedPrompts[index] = newPrompt;
      state = state.copyWith(prompts: updatedPrompts);
    }
  }

  void removePromptAtIndex(int index) {
    final updatedPrompts = List<Prompt>.from(state.prompts);
    if (index >= 0 && index < updatedPrompts.length) {
      updatedPrompts.removeAt(index);
      state = state.copyWith(prompts: updatedPrompts);
    }
  }

  void updateAudioPrompt(AudioPromptModel? audioPrompt) {
    state = state.copyWith(audioPrompt: () => audioPrompt);
  }

  // --- Media Updates (for edit mode) ---
  void updateMediaUrls(List<String> urls) {
    // Directly update the URLs list (typically after upload during save)
    state = state.copyWith(mediaUrls: () => urls);
    // Reset the change flag after URLs are explicitly updated post-save
    state = state.copyWith(mediaChangedDuringEdit: false);
  }

  void setMediaChangedFlag(bool changed) {
    // This flag is set by ProfileScreen when returning from MediaPickerScreen in edit mode
    state = state.copyWith(mediaChangedDuringEdit: changed);
    print("[UserNotifier] Media changed flag set to: $changed");
  }
  // --- End Media Updates ---

  // saveProfile remains for ONBOARDING STEP 2 (POST request)
  Future<bool> saveProfile() async {
    print("[UserNotifier saveProfile] Called (for onboarding step 2 - POST).");
    ref.read(userLoadingProvider.notifier).state = true;
    ref.read(errorProvider.notifier).clearError();

    if (!state.isProfileValid()) {
      // Uses onboarding validation
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Please complete all required profile fields."),
          );
      ref.read(userLoadingProvider.notifier).state = false;
      return false;
    }

    try {
      final userRepository = ref.read(userRepositoryProvider);
      // This now internally calls updateProfileDetails (POST) with the correct payload
      final success = await userRepository.updateProfile(state);

      ref.read(userLoadingProvider.notifier).state = false;
      if (!success && ref.read(errorProvider) == null) {
        // Check if error already set
        ref
            .read(errorProvider.notifier)
            .setError(AppError.server("Failed to save profile."));
      }
      return success;
    } on ApiException catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(AppError.server(e.message));
      return false;
    } catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref
          .read(errorProvider.notifier)
          .setError(AppError.generic("An unexpected error occurred."));
      return false;
    }
  }

  bool isProfileValid() {
    // For onboarding step 2 POST
    return state.isProfileValid(); // Delegate to UserModel's method
  }
}



================================================
File: repositories/auth_repository.dart
================================================
// File: repositories/auth_repository.dart
import '../models/auth_model.dart'; // Keep for AuthStatus enum
import '../services/api_service.dart';

class AuthRepository {
  final ApiService _apiService;

  AuthRepository(this._apiService);

  // --- REMOVED METHODS ---
  // Future<bool> sendOtp(String phoneNumber) async { ... }
  // Future<String> verifyOtp(String phoneNumber, String otpCode) async { ... }
  // --- END REMOVED METHODS ---

  // --- NEW METHOD ---
  /// Verifies Google Access Token with the backend and returns the App JWT.
  Future<String> verifyGoogleToken(String googleAccessToken) async {
    final String methodName = 'verifyGoogleToken';
    print('[AuthRepository $methodName] Verifying Google token...');
    try {
      final response = await _apiService.post(
        '/api/auth/google/verify', // Endpoint from API documentation
        body: {'accessToken': googleAccessToken},
      );

      if (response['success'] == true && response['token'] != null) {
        print(
            '[AuthRepository $methodName] Google token verified, got App JWT.');
        return response['token'].toString();
      } else {
        final message = response['message']?.toString() ??
            'Verification failed, no token received.';
        print('[AuthRepository $methodName] Verification failed: $message');
        throw ApiException(
            message); // Throw with message from backend if available
      }
    } on ApiException catch (e) {
      print(
          '[AuthRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      // Re-throw API exceptions to be handled by the provider
      rethrow;
    } catch (e) {
      print('[AuthRepository $methodName] Unexpected Error: ${e.toString()}');
      // Wrap other errors in ApiException
      throw ApiException(
          'An unexpected error occurred during Google verification: ${e.toString()}');
    }
  }
  // --- END NEW METHOD ---

  // Check authentication status - Updated to handle new states
  Future<AuthStatus> checkAuthStatus(String? token) async {
    final String methodName = 'checkAuthStatus';
    print('[AuthRepository $methodName] Starting auth status check.');

    if (token == null || token.isEmpty) {
      print(
          '[AuthRepository $methodName] No token provided, returning login status.');
      return AuthStatus.login;
    }

    try {
      final headers = {'Authorization': 'Bearer $token'};
      print('[AuthRepository $methodName] Making request to /api/auth-status.');
      final response =
          await _apiService.get('/api/auth-status', headers: headers);

      print('[AuthRepository $methodName] Received response: $response');

      if (response['success'] == true && response['status'] != null) {
        final statusString = response['status'].toString().toLowerCase();
        switch (statusString) {
          case 'home':
            print('[AuthRepository $methodName] Status: home');
            return AuthStatus.home;
          case 'onboarding1': // Handle new state
            print('[AuthRepository $methodName] Status: onboarding1');
            return AuthStatus.onboarding1;
          case 'onboarding2': // Handle new state
            print('[AuthRepository $methodName] Status: onboarding2');
            return AuthStatus.onboarding2;
          default:
            // If backend returns an unexpected status, treat as login
            print(
                '[AuthRepository $methodName] Status: unknown ($statusString), defaulting to login.');
            return AuthStatus.login;
        }
      } else {
        // If success is false or status is missing, treat as login needed
        print(
            '[AuthRepository $methodName] API response indicates failure or missing status, returning login.');
        return AuthStatus.login;
      }
    } on ApiException catch (e) {
      // If API returns 401/403 or other errors indicating invalid session, treat as login needed
      print(
          '[AuthRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode}), returning login.');
      return AuthStatus.login;
    } catch (e) {
      print(
          '[AuthRepository $methodName] Unexpected Error: ${e.toString()}, returning unknown.');
      return AuthStatus.unknown; // Indicate an issue occurred during the check
    }
  }
}



================================================
File: repositories/auth_status_repository.dart
================================================
// File: repositories/auth_status_repository.dart
import '../services/api_service.dart';
import '../utils/token_storage.dart';

enum AuthStatus {
  home,       // User authenticated with complete profile
  onboarding, // User authenticated but profile incomplete
  login,      // User not authenticated or invalid token
  unknown     // Error or initial state
}

class AuthStatusRepository {
  final ApiService _apiService;
  
  AuthStatusRepository(this._apiService);
  
  Future<AuthStatus> checkAuthStatus() async {
    try {
      // Get the saved token
      final token = await TokenStorage.getToken();
      
      if (token == null || token.isEmpty) {
        return AuthStatus.login;
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      // Make the API request
      final response = await _apiService.get(
        '/api/auth-status',
        headers: headers,
      );
      
      if (response['success'] == true) {
        final status = response['status']?.toString().toLowerCase();
        
        if (status == 'home') {
          return AuthStatus.home;
        } else if (status == 'onboarding') {
          return AuthStatus.onboarding;
        }
      }
      
      // Default to login if status is not recognized or success is false
      return AuthStatus.login;
    } on ApiException catch (e) {
      print('Auth status check failed: $e');
      // For authentication errors, redirect to login
      return AuthStatus.login;
    } catch (e) {
      print('Unexpected error during auth status check: $e');
      return AuthStatus.unknown;
    }
  }
}



================================================
File: repositories/filter_repository.dart
================================================
// lib/repositories/filter_repository.dart
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/token_storage.dart';

class FilterRepository {
  final ApiService _apiService;

  FilterRepository(this._apiService);

  Future<FilterSettings> fetchFilters() async {
    final String methodName = 'fetchFilters';
    print('[FilterRepository $methodName] Fetching filters...');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};

      // *** Log the raw response from the API ***
      final response =
          await _apiService.get('/api/get-filters', headers: headers);
      print('[FilterRepository $methodName] Raw API Response: $response');
      // *** End Log ***

      if (response['success'] == true) {
        if (response['filters'] != null &&
            response['filters'] is Map<String, dynamic>) {
          print('[FilterRepository $methodName] Filters found, parsing...');
          // Parsing happens within the factory now
          return FilterSettings.fromJson(
              response['filters'] as Map<String, dynamic>);
        } else {
          print(
              '[FilterRepository $methodName] Filters not set by API, returning defaults.');
          return const FilterSettings(); // Return default settings
        }
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch filters (API success false).';
        print('[FilterRepository $methodName] Fetch failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[FilterRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      print(
          '[FilterRepository $methodName] Returning default filters due to API Exception.');
      return const FilterSettings(); // Return default on API error
    } catch (e) {
      print('[FilterRepository $methodName] Unexpected Error: $e');
      print(
          '[FilterRepository $methodName] Returning default filters due to Unexpected Error.');
      return const FilterSettings(); // Return default on unexpected errors
    }
  }

  Future<bool> updateFilters(FilterSettings filters) async {
    // ... (updateFilters remains the same as previous version) ...
    final String methodName = 'updateFilters';
    print('[FilterRepository $methodName] Updating filters...');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = filters.toJsonForApi();
      print('[FilterRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/filters', body: body, headers: headers);
      print('[FilterRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print('[FilterRepository $methodName] Filters updated successfully.');
        return true;
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to update filters.';
        print('[FilterRepository $methodName] Update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[FilterRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[FilterRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while updating filters: ${e.toString()}');
    }
  }
}



================================================
File: repositories/like_repository.dart
================================================
// File: repositories/like_repository.dart
import '../models/like_models.dart';
import '../models/error_model.dart'; // Import AppError if needed by provider
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import '../utils/app_enums.dart'; // <<<--- ADDED IMPORT FOR ContentLikeType

class LikeRepository {
  final ApiService _apiService;

  LikeRepository(this._apiService);

  // likeContent(...) method remains the same
  Future<bool> likeContent({
    required int likedUserId,
    required ContentLikeType contentType,
    required String contentIdentifier,
    required LikeInteractionType interactionType,
    String? comment,
  }) async {
    final String methodName = 'likeContent';
    print(
        '[LikeRepository $methodName] Liking UserID: $likedUserId, Type: ${contentType.value}, Identifier: $contentIdentifier, Interaction: ${interactionType.value}');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'liked_user_id': likedUserId,
        'content_type': contentType.value,
        'content_identifier': contentIdentifier,
        'interaction_type': interactionType.value,
        if (comment != null && comment.trim().isNotEmpty)
          'comment': comment.trim(),
      };
      print('[LikeRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/like', body: body, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      if (e.statusCode == 403) {
        if (e.message.toLowerCase().contains('limit reached'))
          throw LikeLimitExceededException(e.message);
        else if (e.message.toLowerCase().contains('insufficient consumables') ||
            e.message.toLowerCase().contains('rose'))
          throw InsufficientRosesException(e.message);
      }
      // --- ADDED CONFLICT HANDLING for Already Liked ---
      else if (e.statusCode == 409) {
        // Re-throw specifically or handle as needed
        // For now, rethrow so the UI can potentially inform the user
        print("[LikeRepository $methodName] Conflict: Already liked/matched?");
        rethrow;
      }
      // --- END ADDED ---
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while liking content: ${e.toString()}');
    }
  }

  // dislikeUser(...) method remains the same
  Future<bool> dislikeUser({required int dislikedUserId}) async {
    final String methodName = 'dislikeUser';
    print('[LikeRepository $methodName] Disliking UserID: $dislikedUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'disliked_user_id': dislikedUserId};
      print('[LikeRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/dislike', body: body, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while disliking user: ${e.toString()}');
    }
  }

  // --- ADDED: likeBackUserProfile Method ---
  Future<bool> likeBackUserProfile({required int likedUserId}) async {
    final String methodName = 'likeBackUserProfile';
    print('[LikeRepository $methodName] Liking back UserID: $likedUserId');
    try {
      // Use the existing likeContent method with specific parameters
      return await likeContent(
        likedUserId: likedUserId,
        contentType: ContentLikeType.profile, // Use the specific type
        contentIdentifier: ContentLikeType.profile.value, // Match type value
        interactionType: LikeInteractionType.standard, // Standard like back
        comment: null, // No comment needed for profile like back
      );
    } on ApiException catch (e) {
      // Specific handling or rethrow
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      if (e.statusCode == 409) {
        print("[LikeRepository $methodName] Conflict: Already liked/matched?");
      }
      rethrow;
    } catch (e) {
      // Catch other potential errors from likeContent
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while liking back user: ${e.toString()}');
    }
  }
  // --- END ADDED Method ---

  // fetchReceivedLikes(...) method remains the same
  Future<Map<String, List<dynamic>>> fetchReceivedLikes() async {
    final String methodName = 'fetchReceivedLikes';
    print(
        '[LikeRepository $methodName] Fetching received likes...'); // Log Start
    try {
      final token = await TokenStorage.getToken();
      if (token == null) {
        print(
            '[LikeRepository $methodName] Error: Authentication token missing.');
        throw ApiException('Authentication token missing');
      }

      final headers = {'Authorization': 'Bearer $token'};
      print(
          '[LikeRepository $methodName] Making GET request to /api/likes/received...'); // Log API call
      final response =
          await _apiService.get('/api/likes/received', headers: headers);
      print(
          '[LikeRepository $methodName] API Response received: $response'); // Log Response

      if (response['success'] == true) {
        print(
            '[LikeRepository $methodName] Parsing successful response...'); // Log Parsing Start
        final List<FullProfileLiker> fullProfiles =
            (response['full_profiles'] as List? ?? [])
                .map((data) {
                  try {
                    // Add inner try-catch for parsing individual items
                    return FullProfileLiker.fromJson(
                        data as Map<String, dynamic>);
                  } catch (e) {
                    print(
                        "[LikeRepository $methodName] Error parsing FullProfileLiker: $e, Data: $data");
                    return null; // Return null for problematic items
                  }
                })
                .whereType<FullProfileLiker>() // Filter out nulls
                .toList();

        final List<BasicProfileLiker> otherLikers =
            (response['other_likers'] as List? ?? [])
                .map((data) {
                  try {
                    return BasicProfileLiker.fromJson(
                        data as Map<String, dynamic>);
                  } catch (e) {
                    print(
                        "[LikeRepository $methodName] Error parsing BasicProfileLiker: $e, Data: $data");
                    return null;
                  }
                })
                .whereType<BasicProfileLiker>() // Filter out nulls
                .toList();

        print(
            '[LikeRepository $methodName] Parsed ${fullProfiles.length} full, ${otherLikers.length} basic profiles.');
        return {'full': fullProfiles, 'other': otherLikers};
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch received likes.';
        print(
            '[LikeRepository $methodName] Fetch failed in API response: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception caught: ${e.message}, Status: ${e.statusCode}');
      rethrow; // Re-throw API exceptions to be handled by the provider
    } catch (e, stacktrace) {
      // Catch other errors and stacktrace
      print('[LikeRepository $methodName] Unexpected Error caught: $e');
      print(
          '[LikeRepository $methodName] Stacktrace: $stacktrace'); // Log stacktrace
      throw ApiException(
          'An unexpected error occurred while fetching likes: ${e.toString()}');
    }
  }

  // fetchLikerProfile(...) method remains the same
  Future<Map<String, dynamic>> fetchLikerProfile(int likerUserId) async {
    final String methodName = 'fetchLikerProfile';
    print(
        '[LikeRepository $methodName] Fetching profile for liker ID: $likerUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');

      final headers = {'Authorization': 'Bearer $token'};
      final endpoint = '/api/liker-profile/$likerUserId';
      print('[LikeRepository $methodName] Making GET request to: $endpoint');

      final response = await _apiService.get(endpoint, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');

      if (response['success'] == true &&
          response['profile'] != null &&
          response['like_details'] != null) {
        if (response['profile'] is Map<String, dynamic> &&
            response['like_details'] is Map<String, dynamic>) {
          final profileData = UserProfileData.fromJson(
              response['profile'] as Map<String, dynamic>);
          final likeDetailsData = LikeInteractionDetails.fromJson(
              response['like_details'] as Map<String, dynamic>);
          print(
              '[LikeRepository $methodName] Successfully parsed profile and like details.');
          return {'profile': profileData, 'likeDetails': likeDetailsData};
        } else {
          print(
              '[LikeRepository $methodName] Error: Invalid data format in response.');
          throw ApiException('Invalid data format received for liker profile.');
        }
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch liker profile or like details.';
        print('[LikeRepository $methodName] Fetch failed: $message');
        throw ApiException(message, statusCode: response['statusCode'] as int?);
      }
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while fetching the liker profile: ${e.toString()}');
    }
  }
}



================================================
File: repositories/media_repository.dart
================================================
// File: repositories/media_repository.dart
import 'dart:convert';
import 'dart:io';
import 'package:dio/dio.dart'; // Keep if used elsewhere, not needed for HttpClient PUT
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/utils/token_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:http_parser/http_parser.dart'; // Keep if used elsewhere
// Removed path import as not directly used here

import '../models/media_upload_model.dart';
import '../services/api_service.dart';

class MediaRepository {
  final ApiService _apiService;
  final Ref? ref; // Keep ref if needed for token access

  MediaRepository(this._apiService, [this.ref]);

  // --- NEW Method for Edit Presigned URLs ---
  Future<List<Map<String, dynamic>>> getEditPresignedUrls(
      List<Map<String, String>> fileDetails) async {
    final String methodName = 'getEditPresignedUrls';
    print(
        '[MediaRepository $methodName] Getting presigned URLs for editing...');
    if (fileDetails.isEmpty) {
      print(
          '[MediaRepository $methodName] No file details provided, returning empty list.');
      return []; // Return empty list if no files need uploading
    }
    try {
      String? token = await _getAuthToken(); // Use helper to get token
      if (token == null) {
        throw ApiException('Authentication token is missing');
      }
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'files': fileDetails};
      print('[MediaRepository $methodName] Request Body: $body');

      final response = await _apiService.post(
        '/api/edit-presigned-urls', // <-- Use the NEW endpoint
        body: body,
        headers: headers,
      );

      print('[MediaRepository $methodName] API Response: $response');
      if (response['uploads'] != null && response['uploads'] is List) {
        print('[MediaRepository $methodName] Presigned URLs received.');
        return List<Map<String, dynamic>>.from(response['uploads']);
      } else {
        final message = response['message']?.toString() ??
            'Failed to get edit presigned URLs.';
        print('[MediaRepository $methodName] Failed: $message');
        // Throw specific error if prerequisite failed
        if (message.contains("must have at least 3 existing media items")) {
          throw ApiException(message,
              statusCode: 400); // Use 400 as indicated in docs for this error
        }
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[MediaRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      rethrow;
    } catch (e) {
      print('[MediaRepository $methodName] Unexpected Error: $e');
      throw ApiException('Error getting edit presigned URLs: ${e.toString()}');
    }
  }
  // --- END NEW Method ---

  // --- Helper to get token (avoids repetition) ---
  Future<String?> _getAuthToken() async {
    String? token;
    if (ref != null) {
      // Try reading from auth provider state first
      try {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
        // print("[MediaRepository _getAuthToken] Token from Provider: $token"); // Debug
      } catch (e) {
        print(
            "[MediaRepository _getAuthToken] Error reading auth provider: $e");
        // Fallback below
      }
    }
    if (token == null || token.isEmpty) {
      // Fallback to token storage
      token = await TokenStorage.getToken();
      // print("[MediaRepository _getAuthToken] Token from Storage: $token"); // Debug
    }
    return token;
  }
  // --- END Helper ---

  // --- Existing methods (keep as they are for onboarding/audio/verification) ---
  Future<List<Map<String, dynamic>>> getPresignedUrls(
      List<Map<String, String>> fileDetails) async {
    // (Used for initial onboarding media upload)
    final String methodName = 'getPresignedUrls (Onboarding)';
    print(
        '[MediaRepository $methodName] Getting presigned URLs for onboarding...');
    try {
      String? token = await _getAuthToken();
      if (token == null) throw ApiException('Authentication token is missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'files': fileDetails};
      print('[MediaRepository $methodName] Request Body: $body');

      final response = await _apiService.post(
        '/upload', // <-- Uses the ORIGINAL endpoint for onboarding
        body: body,
        headers: headers,
      );

      print('[MediaRepository $methodName] API Response: $response');
      if (response['uploads'] != null && response['uploads'] is List) {
        print('[MediaRepository $methodName] Presigned URLs received.');
        return List<Map<String, dynamic>>.from(response['uploads']);
      } else {
        final message = response['message']?.toString() ??
            'Failed to get onboarding presigned URLs.';
        print('[MediaRepository $methodName] Failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[MediaRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      rethrow;
    } catch (e) {
      print('[MediaRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'Error getting onboarding presigned URLs: ${e.toString()}');
    }
  }

  Future<Map<String, dynamic>> getAudioPresignedUrl(
      String filename, String fileType, AudioPrompt prompt) async {
    // (Keep as is for audio)
    final String methodName = 'getAudioPresignedUrl';
    print('[MediaRepository $methodName] Getting audio presigned URL...');
    try {
      String? token = await _getAuthToken();
      if (token == null) throw ApiException('Authentication token is missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'filename': filename,
        'type': fileType,
        'prompt': prompt.value,
      };
      print('[MediaRepository $methodName] Request Body: $body');
      final response = await _apiService.post(
        '/audio',
        body: body,
        headers: headers,
      );
      print('[MediaRepository $methodName] API Response: $response');
      return response;
    } on ApiException catch (e) {
      print(
          '[MediaRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      rethrow;
    } catch (e) {
      print('[MediaRepository $methodName] Unexpected Error: $e');
      throw ApiException('Error getting audio presigned URL: ${e.toString()}');
    }
  }

  Future<String> getVerificationPresignedUrl(
      String filename, String fileType) async {
    // (Keep as is for verification)
    final String methodName = 'getVerificationPresignedUrl';
    print(
        '[MediaRepository $methodName] Getting verification presigned URL...');
    try {
      String? token = await _getAuthToken();
      if (token == null) throw ApiException('Authentication token is missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'filename': filename, 'type': fileType};
      print('[MediaRepository $methodName] Request Body: $body');
      final response = await _apiService.post(
        '/verify',
        body: body,
        headers: headers,
      );
      print('[MediaRepository $methodName] API Response: $response');
      if (response['upload_url'] != null) {
        print('[MediaRepository $methodName] Presigned URL received.');
        return response['upload_url'];
      } else {
        final message = response['message']?.toString() ??
            'Failed to get verification presigned URL.';
        print('[MediaRepository $methodName] Failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[MediaRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      rethrow;
    } catch (e) {
      print('[MediaRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'Error getting verification presigned URL: ${e.toString()}');
    }
  }

  // Upload a file to S3 using presigned URL (No changes needed)
  Future<bool> uploadFileToS3(MediaUploadModel mediaUpload) async {
    if (mediaUpload.presignedUrl == null) {
      throw ApiException('Missing presigned URL for upload');
    }

    final file = mediaUpload.file;
    final contentType = mediaUpload.fileType;
    final filePath = file.path;

    try {
      print('⏫ Starting S3 upload for: ${mediaUpload.fileName}');
      print('📁 File path: $filePath');
      print('📦 Content-Type: $contentType');
      print('📏 File size: ${(await file.length()) / 1024} KB');
      print('🔗 Presigned URL: ${mediaUpload.presignedUrl}');

      final client = HttpClient();
      final request = await client.putUrl(Uri.parse(mediaUpload.presignedUrl!));

      request.headers.set(HttpHeaders.contentTypeHeader, contentType);
      request.contentLength = await file.length();

      // print('📨 Request headers:');
      // request.headers.forEach((name, values) {
      //   print('   $name: ${values.join(', ')}');
      // });

      final fileStream = file.openRead();
      await request.addStream(fileStream);
      final response = await request.close();

      final statusCode = response.statusCode;
      final responseBody = await response.transform(utf8.decoder).join();

      print('📩 Upload response: Status=$statusCode, Body=$responseBody');

      if (statusCode != HttpStatus.ok) {
        print('❌ Upload failed with status $statusCode');
        return false;
      }

      print('✅ Upload successful for ${mediaUpload.fileName}');
      return true;
    } catch (e, stack) {
      print('‼️ Critical upload error: $e');
      print('🛑 Stack trace: $stack');
      return false; // Indicate failure
    }
  }

  // Retry failed uploads with exponential backoff (No changes needed)
  Future<bool> retryUpload(MediaUploadModel mediaUpload,
      {int maxRetries = 3}) async {
    int retryCount = 0;
    int backoffMs = 1000;

    while (retryCount < maxRetries) {
      try {
        // Add a small delay before retrying
        await Future.delayed(Duration(milliseconds: backoffMs ~/ 2));
        print(
            '🔄 Retrying upload ($retryCount/${maxRetries - 1}) for: ${mediaUpload.fileName}');
        final success = await uploadFileToS3(mediaUpload);
        if (success) return true;
      } catch (e) {
        print('Retry $retryCount failed: $e');
      }

      retryCount++;
      if (retryCount < maxRetries) {
        await Future.delayed(Duration(milliseconds: backoffMs));
        backoffMs *= 2;
      }
    }
    print(
        '❌ Upload failed after $maxRetries retries for: ${mediaUpload.fileName}');
    return false;
  }
}



================================================
File: repositories/user_repository.dart
================================================
// File: lib/repositories/user_repository.dart
import '../models/user_model.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import '../utils/app_enums.dart';

class UserRepository {
  final ApiService _apiService;

  UserRepository(this._apiService);

  // updateLocationGender remains the same
  Future<bool> updateLocationGender(
      double lat, double lon, Gender gender) async {
    final String methodName = 'updateLocationGender';
    print(
        '[UserRepository $methodName] Called with lat: $lat, lon: $lon, gender: ${gender.value}');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'latitude': lat,
        'longitude': lon,
        'gender': gender.value,
      };

      print(
          '[UserRepository $methodName] Making POST request to /api/profile/location-gender');
      final response = await _apiService.post(
        '/api/profile/location-gender',
        body: body,
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print(
            '[UserRepository $methodName] Location/Gender update successful.');
        return true;
      } else {
        final message = response['message']?.toString() ??
            'Failed to update location and gender.';
        print(
            '[UserRepository $methodName] Location/Gender update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while updating location/gender: ${e.toString()}');
    }
  }

  // updateProfileDetails remains the same (used for onboarding step 2)
  Future<bool> updateProfileDetails(Map<String, dynamic> profileData) async {
    final String methodName = 'updateProfileDetails';
    print('[UserRepository $methodName] Called.');
    // Remove any lingering null values which might cause issues with JSON encoding or backend validation
    profileData.removeWhere((key, value) => value == null);
    print('[UserRepository $methodName] Payload to send: $profileData');

    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making POST request to /api/profile');
      final response = await _apiService.post(
        '/api/profile', // The endpoint for main profile details
        body: profileData, // Send the prepared data
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print(
            '[UserRepository $methodName] Profile details update successful.');
        return true;
      } else {
        final message = response['message']?.toString() ??
            'Failed to update profile details.';
        print(
            '[UserRepository $methodName] Profile details update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while updating profile details: ${e.toString()}');
    }
  }

  // --- ADDED editProfile METHOD ---
  Future<bool> editProfile(Map<String, dynamic> profileData) async {
    final String methodName = 'editProfile';
    print('[UserRepository $methodName] Called.');
    // Remove any lingering null values (important for PATCH)
    profileData.removeWhere((key, value) => value == null);
    print(
        '[UserRepository $methodName] Payload to send via PATCH: $profileData');

    // Ensure there's actually something to update
    if (profileData.isEmpty) {
      print(
          '[UserRepository $methodName] No changes detected. Skipping API call.');
      // Consider returning a specific value or message? For now, true as nothing failed.
      return true; // Or throw ApiException("No changes to save.") if preferred
    }

    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }
      final headers = {'Authorization': 'Bearer $token'};

      print(
          '[UserRepository $methodName] Making PATCH request to /api/profile/edit');
      final response = await _apiService.patch(
        '/api/profile/edit', // The specific PATCH endpoint
        body: profileData,
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print('[UserRepository $methodName] Profile edit successful.');
        return true;
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to edit profile.';
        print('[UserRepository $methodName] Profile edit failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while editing profile: ${e.toString()}');
    }
  }
  // --- END ADDED editProfile METHOD ---

  // fetchHomeFeed remains the same
  Future<Map<String, dynamic>> fetchHomeFeed() async {
    final String methodName = 'fetchHomeFeed';
    print('[UserRepository $methodName] Called.');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making GET request to /api/homefeed');
      final response = await _apiService.get('/api/homefeed', headers: headers);

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        final profilesList =
            response['profiles'] as List? ?? []; // Handle null case
        final profiles = profilesList
            .map((profileJson) =>
                UserModel.fromJson(profileJson as Map<String, dynamic>))
            .toList();
        final hasMore = response['has_more'] as bool? ??
            false; // Default to false if missing

        print(
            '[UserRepository $methodName] Home feed fetch successful. Count: ${profiles.length}, Has More: $hasMore');
        return {'profiles': profiles, 'has_more': hasMore};
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch home feed.';
        print('[UserRepository $methodName] Home feed fetch failed: $message');
        // Handle case where 'profiles' might be null but success is true (empty feed)
        if (response['success'] == true &&
            (response['profiles'] == null ||
                (response['profiles'] is List &&
                    (response['profiles'] as List).isEmpty))) {
          print('[UserRepository $methodName] Feed is empty.');
          return {
            'profiles': <UserModel>[],
            'has_more': false
          }; // Return empty list and has_more=false
        }
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while fetching the home feed: ${e.toString()}');
    }
  }

  // fetchUserProfile remains the same
  Future<UserModel> fetchUserProfile() async {
    final String methodName = 'fetchUserProfile';
    print('[UserRepository $methodName] Called.');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making GET request to /get-profile');
      final response = await _apiService.get('/get-profile', headers: headers);

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true && response['user'] != null) {
        print('[UserRepository $methodName] Profile fetch successful.');
        if (response['user'] is Map<String, dynamic>) {
          return UserModel.fromJson(response['user'] as Map<String, dynamic>);
        } else {
          print(
              '[UserRepository $methodName] Error: Invalid user data format in response.');
          throw ApiException('Invalid user data format received from server.');
        }
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch user profile.';
        print('[UserRepository $methodName] Profile fetch failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while fetching the profile: ${e.toString()}');
    }
  }

  // updateProfile (DEPRECATED for edit - keep for onboarding step 2)
  // This uses the POST /api/profile endpoint
  Future<bool> updateProfile(UserModel userModel) async {
    print(
        "[UserRepository updateProfile] Calling updateProfileDetails (POST)...");
    Map<String, dynamic> profileData = userModel.toJsonForProfileUpdate();
    return await updateProfileDetails(profileData);
  }
}



================================================
File: services/api_service.dart
================================================
// File: services/api_service.dart
import 'dart:convert';

/// Abstract class defining the API service interface
abstract class ApiService {
  /// Base URL for all API requests
  String get baseUrl;

  /// Makes a GET request to the specified endpoint
  Future<Map<String, dynamic>> get(String endpoint,
      {Map<String, String>? headers});

  /// Makes a POST request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a PUT request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a PATCH request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> patch(
    // <<< ADDED
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a DELETE request to the specified endpoint
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  });

  /// Adds authorization token to headers
  Map<String, String> addAuthToken(Map<String, String>? headers, String token);
}

/// Exception thrown when API requests fail
class ApiException implements Exception {
  final String message;
  final int? statusCode;

  ApiException(this.message, {this.statusCode});

  @override
  String toString() =>
      'ApiException: $message ${statusCode != null ? '(Status code: $statusCode)' : ''}';
}



================================================
File: services/http_service.dart
================================================
// File: services/http_service.dart
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'api_service.dart';

/// Implementation of ApiService using the http package
class HttpService implements ApiService {
  @override
  final String baseUrl;

  HttpService({required this.baseUrl});

  @override
  Map<String, String> addAuthToken(Map<String, String>? headers, String token) {
    final updatedHeaders = {...(headers ?? {})};
    updatedHeaders['Authorization'] = 'Bearer $token';
    print(updatedHeaders);
    return updatedHeaders;
  }

  @override
  Future<Map<String, dynamic>> get(String endpoint,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      throw ApiException('Failed to perform GET request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.post(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform POST request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.put(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform PUT request: ${e.toString()}');
    }
  }

  // --- ADDED PATCH METHOD ---
  @override
  Future<Map<String, dynamic>> patch(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.patch(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );
      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform PATCH request: ${e.toString()}');
    }
  }
  // --- END ADDED PATCH METHOD ---

  @override
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  }) async {
    try {
      final request = http.Request('DELETE', Uri.parse('$baseUrl$endpoint'));

      request.headers.addAll({
        'Content-Type': 'application/json',
        ...?headers,
      });

      if (body != null) {
        request.body = json.encode(body);
      }

      final streamedResponse = await request.send();
      final response = await http.Response.fromStream(streamedResponse);

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform DELETE request: ${e.toString()}');
    }
  }

  /// Handle the HTTP response and convert to a standardized format
  Map<String, dynamic> _handleResponse(http.Response response) {
    try {
      // Allow empty body for success codes like 204 No Content
      if (response.statusCode >= 200 && response.statusCode < 300) {
        if (response.body.isEmpty) {
          return {'success': true, 'message': 'Operation successful'};
        }
        final responseData = json.decode(response.body) as Map<String, dynamic>;
        return responseData;
      } else {
        // Attempt to decode body even for errors, as it might contain error details
        Map<String, dynamic>? responseData;
        try {
          if (response.body.isNotEmpty) {
            responseData = json.decode(response.body) as Map<String, dynamic>;
          }
        } on FormatException {
          // Ignore format exception if body isn't valid JSON
          print("Warning: Non-JSON error response body: ${response.body}");
        }

        // Extract only the actual error message from the API response
        String errorMessage;

        if (responseData != null && responseData.containsKey('message')) {
          // Use the message directly from the response
          errorMessage = responseData['message'].toString();
        } else if (responseData != null && responseData.containsKey('error')) {
          // Some APIs use 'error' property
          errorMessage = responseData['error'].toString();
        } else {
          // Fallback error message including status code and reason phrase
          errorMessage =
              'Request failed: ${response.statusCode} ${response.reasonPhrase ?? ''}';
        }

        throw ApiException(errorMessage, statusCode: response.statusCode);
      }
    } on FormatException {
      // This catches JSON decoding errors for successful responses (shouldn't happen often)
      throw ApiException('Invalid response format received from server.',
          statusCode: response.statusCode);
    } catch (e) {
      // Catch other errors like network issues during response handling
      if (e is ApiException)
        rethrow; // Re-throw if it's already an ApiException
      throw ApiException('Failed to process response: ${e.toString()}',
          statusCode: response.statusCode);
    }
  }
}



================================================
File: utils/app_enums.dart
================================================
// File: lib/utils/app_enums.dart
// Import the correct location of ContentLikeType
import 'package:dtx/models/like_models.dart' show ContentLikeType;

enum Gender {
  man('man', 'Man'),
  woman('woman', 'Woman');

  final String value;
  final String label;
  const Gender(this.value, this.label);
}

enum DatingIntention {
  lifePartner('lifePartner', 'Life partner'),
  longTerm('longTerm', 'Long-term relationship'),
  longTermOpenShort(
      'longTermOpenShort', 'Long-term, open to short'), // Shortened label
  shortTermOpenLong(
      'shortTermOpenLong', 'Short-term, open to long'), // Shortened label
  shortTerm('shortTerm', 'Short-term relationship'),
  figuringOut('figuringOut', 'Figuring out my dating goals');

  final String value;
  final String label;
  const DatingIntention(this.value, this.label);
}

enum Religion {
  agnostic('agnostic', 'Agnostic'),
  atheist('atheist', 'Atheist'),
  buddhist('buddhist', 'Buddhist'),
  christian('christian', 'Christian'),
  hindu('hindu', 'Hindu'),
  jain('jain', 'Jain'),
  jewish('jewish', 'Jewish'),
  muslim('muslim', 'Muslim'),
  zoroastrian('zoroastrian', 'Zoroastrian'),
  sikh('sikh', 'Sikh'),
  spiritual('spiritual', 'Spiritual');

  final String value;
  final String label;
  const Religion(this.value, this.label);
}

enum DrinkingSmokingHabits {
  yes('yes', 'Yes'),
  sometimes('sometimes', 'Sometimes'),
  no('no', 'No');

  final String value;
  final String label;
  const DrinkingSmokingHabits(this.value, this.label);
}

enum PromptCategory {
  storyTime('storyTime', 'Story time'),
  myType('myType', 'My type'),
  gettingPersonal('gettingPersonal', 'Getting personal'),
  dateVibes('dateVibes', 'Date vibes');

  final String value;
  final String label;
  const PromptCategory(this.value, this.label);

  // --- ADDED: contentType Getter ---
  // This getter uses the ContentLikeType defined in like_models.dart
  ContentLikeType get contentType {
    switch (this) {
      case PromptCategory.storyTime:
        return ContentLikeType.promptStory;
      case PromptCategory.myType:
        return ContentLikeType.promptMytype;
      case PromptCategory.gettingPersonal:
        return ContentLikeType.promptGettingpersonal;
      case PromptCategory.dateVibes:
        return ContentLikeType.promptDatevibes;
    }
  }
  // --- END ADDED ---

  List<PromptType> getPrompts() {
    switch (this) {
      case PromptCategory.storyTime:
        return [
          PromptType.twoTruthsAndALie,
          PromptType.worstIdea,
          PromptType.biggestRisk,
          PromptType.biggestDateFail,
          PromptType.neverHaveIEver,
          PromptType.bestTravelStory,
          PromptType.weirdestGift,
          PromptType.mostSpontaneous,
          PromptType.oneThingNeverDoAgain,
        ];
      case PromptCategory.myType:
        return [
          PromptType.nonNegotiable,
          PromptType.hallmarkOfGoodRelationship,
          PromptType.lookingFor,
          PromptType.weirdlyAttractedTo,
          PromptType.allIAskIsThatYou,
          PromptType.wellGetAlongIf,
          PromptType.wantSomeoneWho,
          PromptType.greenFlags,
          PromptType.sameTypeOfWeird,
          PromptType.fallForYouIf,
          PromptType.bragAboutYou,
        ];
      case PromptCategory.gettingPersonal:
        return [
          PromptType.oneThingYouShouldKnow,
          PromptType.loveLanguage,
          PromptType.dorkiestThing,
          PromptType.dontHateMeIf,
          PromptType.geekOutOn,
          PromptType.ifLovingThisIsWrong,
          PromptType.keyToMyHeart,
          PromptType.wontShutUpAbout,
          PromptType.shouldNotGoOutWithMeIf,
          PromptType.whatIfIToldYouThat,
        ];
      case PromptCategory.dateVibes:
        return [
          PromptType.togetherWeCould,
          PromptType.firstRoundIsOnMeIf,
          PromptType.whatIOrderForTheTable,
          PromptType.bestSpotInTown,
          PromptType.bestWayToAskMeOut,
        ];
    }
  }
}

enum PromptType {
  // Story Time
  twoTruthsAndALie('twoTruthsAndALie', 'Two truths and a lie'),
  worstIdea('worstIdea', 'Worst idea I\'ve ever had'),
  biggestRisk('biggestRisk', 'Biggest risk I\'ve taken'),
  biggestDateFail('biggestDateFail', 'My biggest date fail'),
  neverHaveIEver('neverHaveIEver', 'Never have I ever'),
  bestTravelStory('bestTravelStory', 'Best travel story'),
  weirdestGift('weirdestGift', 'Weirdest gift I\'ve given or received'),
  mostSpontaneous('mostSpontaneous', 'Most spontaneous thing I\'ve done'),
  oneThingNeverDoAgain(
      'oneThingNeverDoAgain', 'One thing I\'ll never do again'),
  // My Type
  nonNegotiable('nonNegotiable', 'Something that\'s non-negotiable for me is'),
  hallmarkOfGoodRelationship(
      'hallmarkOfGoodRelationship', 'The hallmark of a good relationship is'),
  lookingFor('lookingFor', 'I\'m looking for'),
  weirdlyAttractedTo('weirdlyAttractedTo', 'I\'m weirdly attracted to'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  wellGetAlongIf('wellGetAlongIf', 'We\'ll get along if'),
  wantSomeoneWho('wantSomeoneWho', 'I want someone who'),
  greenFlags('greenFlags', 'Green flags I look out for'),
  sameTypeOfWeird('sameTypeOfWeird', 'We\'re the same type of weird if'),
  fallForYouIf('fallForYouIf', 'I\'d fall for you if'),
  bragAboutYou('bragAboutYou', 'I\'ll brag about you to my friends if'),
  // Getting Personal
  oneThingYouShouldKnow(
      'oneThingYouShouldKnow', 'The one thing you should know about me is'),
  loveLanguage('loveLanguage', 'My Love Language is'),
  dorkiestThing('dorkiestThing', 'The dorkiest thing about me is'),
  dontHateMeIf('dontHateMeIf', 'Don\'t hate me if I'),
  geekOutOn('geekOutOn', 'I geek out on'),
  ifLovingThisIsWrong('ifLovingThisIsWrong',
      'If loving this is wrong, I don\'t want to be right'),
  keyToMyHeart('keyToMyHeart', 'The key to my heart is'),
  wontShutUpAbout('wontShutUpAbout', 'I won\'t shut up about'),
  shouldNotGoOutWithMeIf(
      'shouldNotGoOutWithMeIf', 'You should *not* go out with me if'),
  whatIfIToldYouThat('whatIfIToldYouThat', 'What if I told you that'),
  // Date Vibes
  togetherWeCould('togetherWeCould', 'Together, we could'),
  firstRoundIsOnMeIf('firstRoundIsOnMeIf', 'First round is on me if'),
  whatIOrderForTheTable('whatIOrderForTheTable',
      'What I order for the table'), // Corrected enum value and label
  bestSpotInTown('bestSpotInTown', 'I know the best spot in town for'),
  bestWayToAskMeOut('bestWayToAskMeOut', 'The best way to ask me out is by');

  final String value;
  final String label;
  const PromptType(this.value, this.label);

  PromptCategory getCategory() {
    for (var category in PromptCategory.values) {
      if (category.getPrompts().contains(this)) {
        return category;
      }
    }
    print("Warning: PromptType '$value' does not belong to a known category.");
    return PromptCategory.storyTime; // Defaulting
  }
}

enum AudioPrompt {
  canWeTalkAbout('canWeTalkAbout', 'Can we talk about?'),
  captionThisPhoto('captionThisPhoto', 'Caption this photo'),
  caughtInTheAct('caughtInTheAct', 'Caught in the act'),
  changeMyMindAbout('changeMyMindAbout', 'Change my mind about'),
  chooseOurFirstDate('chooseOurFirstDate', 'Choose our first date'),
  commentIfYouveBeenHere(
      'commentIfYouveBeenHere', 'Comment if you\'ve been here'),
  cookWithMe('cookWithMe', 'Cook with me'),
  datingMeIsLike('datingMeIsLike', 'Dating me is like'),
  datingMeWillLookLike('datingMeWillLookLike', 'Dating me will look like'),
  doYouAgreeOrDisagreeThat(
      'doYouAgreeOrDisagreeThat', 'Do you agree or disagree that'),
  dontHateMeIfI('dontHateMeIfI', 'Don\'t hate me if I'),
  dontJudgeMe('dontJudgeMe', 'Don\'t judge me'),
  mondaysAmIRight('mondaysAmIRight', 'Mondays... am I right?'),
  aBoundaryOfMineIs('aBoundaryOfMineIs', 'A boundary of mine is'),
  aDailyEssential('aDailyEssential', 'A daily essential'),
  aDreamHomeMustInclude('aDreamHomeMustInclude', 'A dream home must include'),
  aFavouriteMemoryOfMine(
      'aFavouriteMemoryOfMine', 'A favourite memory of mine'),
  aFriendsReviewOfMe('aFriendsReviewOfMe', 'A friend\'s review of me'),
  aLifeGoalOfMine('aLifeGoalOfMine', 'A life goal of mine'),
  aQuickRantAbout('aQuickRantAbout', 'A quick rant about'),
  aRandomFactILoveIs('aRandomFactILoveIs', 'A random fact I love is'),
  aSpecialTalentOfMine('aSpecialTalentOfMine', 'A special talent of mine'),
  aThoughtIRecentlyHadInTheShower('aThoughtIRecentlyHadInTheShower',
      'A thought I recently had in the shower'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  guessWhereThisPhotoWasTaken(
      'guessWhereThisPhotoWasTaken', 'Guess where this photo was taken'),
  helpMeIdentifyThisPhotoBomber(
      'helpMeIdentifyThisPhotoBomber', 'Help me identify this photo bomber'),
  hiFromMeAndMyPet('hiFromMeAndMyPet', 'Hi from me and my pet'),
  howIFightTheSundayScaries(
      'howIFightTheSundayScaries', 'How I fight the Sunday scaries'),
  howHistoryWillRememberMe(
      'howHistoryWillRememberMe', 'How history will remember me'),
  howMyFriendsSeeMe('howMyFriendsSeeMe', 'How my friends see me'),
  howToPronounceMyName('howToPronounceMyName', 'How to pronounce my name'),
  iBeatMyBluesBy('iBeatMyBluesBy', 'I beat my blues by'),
  iBetYouCant('iBetYouCant', 'I bet you can\'t'),
  iCanTeachYouHowTo('iCanTeachYouHowTo', 'I can teach you how to'),
  iFeelFamousWhen('iFeelFamousWhen', 'I feel famous when'),
  iFeelMostSupportedWhen(
      'iFeelMostSupportedWhen', 'I feel most supported when');

  final String value;
  final String label;
  const AudioPrompt(this.value, this.label);
}



================================================
File: utils/env_config.dart
================================================

// File: utils/env_config.dart
import 'package:flutter_dotenv/flutter_dotenv.dart';

class EnvConfig {
  static String get apiBaseUrl => 
    dotenv.get('API_BASE_URL', fallback: 'http://10.61.67.128:8080');
}



================================================
File: utils/token_storage.dart
================================================

// File: utils/token_storage.dart
import 'package:shared_preferences/shared_preferences.dart';

class TokenStorage {
  static const String _tokenKey = 'auth_token';
  
  // Save the JWT token
  static Future<bool> saveToken(String token) async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.setString(_tokenKey, token);
  }
  
  // Get the stored JWT token
  static Future<String?> getToken() async {
    final prefs = await SharedPreferences.getInstance();
    print(prefs.getString(_tokenKey));
    return prefs.getString(_tokenKey);
  }
  
  // Remove the stored token (for logout)
  static Future<bool> removeToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.remove(_tokenKey);
  }
  
  // Check if a token exists
  static Future<bool> hasToken() async {
    final token = await getToken();
    return token != null && token.isNotEmpty;
  }
}



================================================
File: views/audioprompt.dart
================================================
import 'dart:async';
import 'dart:io'; // Keep for File checks

import 'package:audioplayers/audioplayers.dart';
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/media_upload_model.dart';
import 'package:dtx/models/auth_model.dart'; // Keep for AuthStatus check
import 'package:dtx/models/user_model.dart';
import 'package:dtx/providers/audio_upload_provider.dart';
import 'package:dtx/providers/auth_provider.dart'; // Keep for status check
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/media_upload_provider.dart'; // <<< ADDED for general media
import 'package:dtx/providers/service_provider.dart'; // Keep for repository access
import 'package:dtx/providers/user_provider.dart'; // <<< ENSURE IMPORT
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/audiopromptsselect.dart';
import 'package:dtx/views/main_navigation_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:record/record.dart';

class VoicePromptScreen extends ConsumerStatefulWidget {
  final bool isEditing;

  const VoicePromptScreen({
    Key? key,
    this.isEditing = false,
  }) : super(key: key);

  @override
  ConsumerState<VoicePromptScreen> createState() => _VoicePromptScreenState();
}

class _VoicePromptScreenState extends ConsumerState<VoicePromptScreen> {
  final AudioRecorder _audioRecorder = AudioRecorder();
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isRecording = false;
  String _recordingTime = "0:00 / 0:30";
  String? _audioPath;
  bool _isPlaying = false;
  DateTime? _startTime;
  Timer? _recordingTimer;
  bool _isSaving = false;
  AudioPrompt? _selectedPrompt;
  String? _existingAudioUrl;

  @override
  void initState() {
    super.initState();
    if (widget.isEditing) {
      final existingPromptModel = ref.read(userProvider).audioPrompt;
      if (existingPromptModel != null) {
        _selectedPrompt = existingPromptModel.prompt;
        _existingAudioUrl = existingPromptModel.audioUrl;
        ref
            .read(audioUploadProvider.notifier)
            .setSelectedPrompt(_selectedPrompt!);
      }
    } else {
      ref.read(audioUploadProvider.notifier).clearAudio();
    }
    _initializeAudioSession();
    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) setState(() => _isPlaying = false);
    });
    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted && state != PlayerState.playing) {
        if (_isPlaying && state != PlayerState.paused) {
          setState(() => _isPlaying = false);
        }
      }
    });
  }

  Future<void> _initializeAudioSession() async {
    /* ... same as before ... */ print(
        "[VoicePromptScreen] Requesting microphone permission...");
    final status = await Permission.microphone.request();
    print("[VoicePromptScreen] Microphone permission status: $status");
    if (!status.isGranted && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Microphone permission is required.')),
      );
    }
  }

  Future<void> _startRecording() async {
    /* ... same as before ... */ setState(() {
      _existingAudioUrl = null;
      _audioPath = null;
      _recordingTime = "0:00 / 0:30";
    });
    ref.read(audioUploadProvider.notifier).clearAudio();
    if (!await _audioRecorder.hasPermission()) {
      print("[VoicePromptScreen] Start Recording: Permission denied.");
      if (mounted)
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Microphone permission denied.')));
      return;
    }
    if (_isPlaying) {
      await _audioPlayer.stop();
      setState(() => _isPlaying = false);
    }
    try {
      print("[VoicePromptScreen] Starting recording...");
      final directory = await getApplicationDocumentsDirectory();
      final newPath =
          '${directory.path}/voice_prompt_${DateTime.now().millisecondsSinceEpoch}.m4a';
      print("[VoicePromptScreen] Recording path set to: $newPath");
      await _audioRecorder.start(
          const RecordConfig(encoder: AudioEncoder.aacLc),
          path: newPath);
      _audioPath = newPath;
      _startTime = DateTime.now();
      if (!mounted) return;
      setState(() => _isRecording = true);
      print("[VoicePromptScreen] Recording started.");
      _recordingTimer?.cancel();
      _recordingTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
        if (!_isRecording || !mounted || _startTime == null) {
          timer.cancel();
          return;
        }
        final duration = DateTime.now().difference(_startTime!).inSeconds;
        if (duration >= 30) {
          timer.cancel();
          _stopRecording();
          return;
        }
        if (mounted) {
          setState(() {
            _recordingTime = "0:${duration.toString().padLeft(2, '0')} / 0:30";
          });
        }
      });
    } catch (e) {
      print('[VoicePromptScreen] Recording error: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Recording failed: ${e.toString()}')));
        setState(() => _isRecording = false);
      }
    }
  }

  Future<void> _stopRecording() async {
    /* ... same as before ... */ if (!_isRecording) return;
    _recordingTimer?.cancel();
    try {
      final path = await _audioRecorder.stop();
      print('[VoicePromptScreen] Recording stopped. Path from recorder: $path');
      if (path != null) {
        final file = File(path);
        if (!await file.exists() || await file.length() == 0) {
          print(
              '[VoicePromptScreen] Error: Recording file is missing or empty after stop.');
          if (mounted)
            ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                content: Text('Failed to save recording. Please try again.')));
          setState(() {
            _isRecording = false;
            _audioPath = null;
            _recordingTime = "0:00 / 0:30";
          });
          return;
        }
        _audioPath = path;
        if (mounted) {
          setState(() {
            _isRecording = false;
          });
          ref.read(audioUploadProvider.notifier).setRecordingPath(_audioPath!);
          print(
              "[VoicePromptScreen] Recording path saved to provider: $_audioPath");
        }
      } else {
        print("[VoicePromptScreen] Stop recording returned null path.");
        if (mounted) {
          setState(() => _isRecording = false);
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Failed to save recording.')),
          );
        }
      }
    } catch (e) {
      print('[VoicePromptScreen] Stop recording error: $e');
      if (mounted) {
        setState(() => _isRecording = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error stopping recording: ${e.toString()}')),
        );
      }
    }
  }

  Future<void> _playRecording() async {
    /* ... same as before ... */ final String? pathOrUrlToPlay =
        _audioPath ?? _existingAudioUrl;
    print(
        "[VoicePromptScreen] Play recording requested. Source: $pathOrUrlToPlay");
    if (pathOrUrlToPlay == null) {
      print("[VoicePromptScreen] Playback Error: No audio source available.");
      if (mounted)
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
            content:
                Text('Please record or ensure existing audio is loaded.')));
      return;
    }
    if (_audioPath != null) {
      final file = File(_audioPath!);
      if (!await file.exists() || await file.length() == 0) {
        print(
            "[VoicePromptScreen] Playback Error: File is missing or empty at $_audioPath");
        if (mounted)
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
              content: Text('Recording file error. Please record again.')));
        setState(() => _audioPath = null);
        return;
      }
    }
    try {
      final Source audioSource = _audioPath != null
          ? DeviceFileSource(_audioPath!)
          : UrlSource(pathOrUrlToPlay);
      if (_isPlaying) {
        print("[VoicePromptScreen] Pausing playback.");
        await _audioPlayer.pause();
      } else {
        if (_audioPlayer.state == PlayerState.playing ||
            _audioPlayer.state == PlayerState.paused) {
          await _audioPlayer.stop();
        }
        print("[VoicePromptScreen] Starting playback from: $pathOrUrlToPlay");
        await _audioPlayer.play(audioSource);
      }
    } catch (e) {
      print('[VoicePromptScreen] Playback error: $e');
      if (mounted) {
        setState(() => _isPlaying = false);
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Playback failed: ${e.toString()}')));
      }
    }
  }

  void _selectPrompt() {
    /* ... same as before ... */ if (_isPlaying) {
      _audioPlayer.pause();
    }
    print("[VoicePromptScreen] Navigating to select audio prompt.");
    Navigator.push(
      context,
      MaterialPageRoute(
          builder: (context) => AudioSelectPromptScreen(
                isEditing: widget.isEditing,
              )),
    ).then((_) {
      if (mounted) {
        setState(() {
          _selectedPrompt =
              ref.read(audioUploadProvider.notifier).selectedPrompt;
        });
        print(
            "[VoicePromptScreen] Returned from prompt selection. Selected: ${_selectedPrompt?.label}");
      }
    });
  }

  // --- *** MODIFIED SAVE METHOD *** ---
  Future<void> _saveProfileAndNavigate() async {
    // <-- Added async
    print(
        '[VoicePromptScreen] Starting _saveProfileAndNavigate (isEditing: ${widget.isEditing})');
    final errorNotifier = ref.read(errorProvider.notifier);
    final userNotifier = ref.read(userProvider.notifier);
    final authNotifier =
        ref.read(authProvider.notifier); // Needed for status check
    errorNotifier.clearError();

    // Refresh local selected prompt state
    setState(() {
      _selectedPrompt = ref.read(audioUploadProvider.notifier).selectedPrompt;
    });

    if (_selectedPrompt == null) {
      print('[VoicePromptScreen] Validation Error: No audio prompt selected.');
      errorNotifier
          .setError(AppError.validation("Please select an audio prompt."));
      return;
    }

    bool isNewAudioRecording =
        _audioPath != null && File(_audioPath!).existsSync();
    bool audioPrepared = false;
    MediaUploadModel? audioUploadModel;
    String? finalAudioUrl =
        _existingAudioUrl; // Start with existing URL if editing

    // --- Audio Preparation (only if NEW recording exists) ---
    if (isNewAudioRecording) {
      print(
          '[VoicePromptScreen] New audio recording found at $_audioPath. Preparing for upload.');
      ref.read(audioUploadProvider.notifier).setRecordingPath(_audioPath!);
      audioPrepared = ref.read(audioUploadProvider.notifier).prepareAudioFile();
      if (!audioPrepared) {
        print('[VoicePromptScreen] Audio file preparation/validation failed.');
        return; // Error should be set by prepareAudioFile
      }
      audioUploadModel = ref.read(audioUploadProvider); // Get prepared model
      if (audioUploadModel == null) {
        print('[VoicePromptScreen] Error: Audio prepared but model is null.');
        errorNotifier
            .setError(AppError.generic("Error preparing audio model."));
        return;
      }
    } else if (_existingAudioUrl == null && !widget.isEditing) {
      // If onboarding and no existing URL AND no new recording, require recording
      print(
          '[VoicePromptScreen] Validation Error: No audio recorded for onboarding.');
      errorNotifier.setError(
          AppError.validation("Please record your voice prompt answer."));
      return;
    } else if (_existingAudioUrl != null) {
      print('[VoicePromptScreen] Using existing audio URL: $_existingAudioUrl');
    }
    // If editing and neither new nor existing audio, allow saving without audio (nulls it out later)

    setState(() => _isSaving = true);

    try {
      // --- *** STEP 1: Upload General Media (ONLY during ONBOARDING) *** ---
      if (!widget.isEditing) {
        print(
            "[VoicePromptScreen Onboarding] Attempting to upload general media...");
        final mediaSuccess =
            await ref.read(mediaUploadProvider.notifier).uploadAllMedia();
        if (!mediaSuccess) {
          print("[VoicePromptScreen Onboarding] General media upload failed.");
          // Error likely set by mediaUploadProvider, but set a generic one if not
          if (ref.read(errorProvider) == null) {
            errorNotifier
                .setError(AppError.server("Failed to upload photos/videos."));
          }
          throw ApiException(
              "Media upload failed during onboarding."); // Stop the process
        }
        print(
            "[VoicePromptScreen Onboarding] General media upload successful.");
      }
      // --- *** END General Media Upload Step *** ---

      // --- STEP 2: Upload Audio (if new recording exists) ---
      bool audioUploadedSuccessfully = true;
      if (isNewAudioRecording && audioPrepared && audioUploadModel != null) {
        print('[VoicePromptScreen] Attempting audio upload...');
        // Use the dedicated provider method which also updates userNotifier internally
        audioUploadedSuccessfully = await ref
            .read(audioUploadProvider.notifier)
            .uploadAudioAndSaveToProfile();

        if (!audioUploadedSuccessfully) {
          print('[VoicePromptScreen] Audio upload failed.');
          // Error should be set by audioUploadProvider
          throw ApiException("Audio upload failed."); // Stop the process
        }
        // Get the new URL from the successful upload state
        finalAudioUrl = ref
            .read(audioUploadProvider)
            ?.presignedUrl; // Read state AFTER upload
        print(
            '[VoicePromptScreen] Audio upload successful. New URL: $finalAudioUrl');
      } else if (!isNewAudioRecording && _existingAudioUrl != null) {
        // No NEW audio upload needed, just ensure user model is updated with existing URL and selected prompt
        print(
            '[VoicePromptScreen] No new audio upload needed. Updating user model with existing URL.');
        final currentAudioModel = AudioPromptModel(
            prompt: _selectedPrompt!, audioUrl: _existingAudioUrl!);
        userNotifier.updateAudioPrompt(currentAudioModel);
        finalAudioUrl = _existingAudioUrl; // Keep track of the URL
      } else if (widget.isEditing &&
          !isNewAudioRecording &&
          _existingAudioUrl == null) {
        print(
            '[VoicePromptScreen Editing] No existing or new audio. Setting audio prompt to null.');
        userNotifier.updateAudioPrompt(
            null); // Explicitly set to null when editing and no audio is provided
        finalAudioUrl = null;
      }
      // --- END Audio Upload Step ---

      // --- STEP 3: Save Profile (POST for Onboarding, PATCH for Editing) ---
      bool profileSaved = false;
      if (widget.isEditing) {
        print('[VoicePromptScreen Editing] Saving profile changes (PATCH)...');
        final latestUserState = ref.read(userProvider);
        final payload = latestUserState.toJsonForEdit();
        // Ensure audio prompt in payload is correct (null if removed, new URL if uploaded, existing if kept)
        if (finalAudioUrl != null) {
          payload['audio_prompt'] = AudioPromptModel(
                  prompt: _selectedPrompt!, audioUrl: finalAudioUrl)
              .toJson();
        } else {
          payload['audio_prompt'] = null; // Ensure it's null if no audio
        }
        // Media URLs are handled by the PATCH endpoint itself based on userProvider state
        // which was updated in MediaPickerScreen edit flow

        print("[VoicePromptScreen Editing] PATCH Payload: $payload");
        profileSaved =
            await ref.read(userRepositoryProvider).editProfile(payload);
      } else {
        // Onboarding flow
        print(
            '[VoicePromptScreen Onboarding] Saving profile details (POST)...');
        // The POST /api/profile doesn't take media/audio URLs.
        // Those uploads happened earlier and are linked via token.
        profileSaved = await userNotifier.saveProfile(); // Uses the POST method
      }
      // --- END Save Profile Step ---

      // --- STEP 4: Navigation ---
      if (profileSaved) {
        print('[VoicePromptScreen] Profile save successful.');
        if (widget.isEditing) {
          print("[VoicePromptScreen Editing] Popping back.");
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                  content: Text("Audio prompt updated!"),
                  backgroundColor: Colors.green),
            );
            Navigator.of(context).pop(); // Pop back to ProfileScreen
          }
        } else {
          // Onboarding success
          // *** --- START FIX: FETCH PROFILE BEFORE NAVIGATION --- ***
          print('[VoicePromptScreen Onboarding] Fetching updated profile...');
          await userNotifier.fetchProfile(); // <<< ADDED: Fetch fresh data
          print('[VoicePromptScreen Onboarding] Profile fetch complete.');
          // *** --- END FIX ---
          final finalStatus = await authNotifier.checkAuthStatus(
              updateState: true); // Check status again after save
          if (mounted) {
            print(
                '[VoicePromptScreen Onboarding] Navigating to MainNavigationScreen. Status: $finalStatus');
            Navigator.of(context).pushAndRemoveUntil(
              MaterialPageRoute(builder: (_) => const MainNavigationScreen()),
              (route) => false,
            );
          }
        }
      } else {
        print('[VoicePromptScreen] Profile save failed.');
        // Error should be set by saveProfile/editProfile method
        if (mounted && ref.read(errorProvider) == null) {
          errorNotifier
              .setError(AppError.server("Failed to save profile changes."));
        }
      }
      // --- END Navigation ---
    } on ApiException catch (e) {
      print(
          '[VoicePromptScreen] Save Process Failed: API Exception - ${e.message}');
      if (mounted) errorNotifier.setError(AppError.server(e.message));
    } catch (e, stack) {
      // Catch unexpected errors
      print('[VoicePromptScreen] Save Process Failed: Unexpected Error - $e');
      print(stack); // Log stack trace
      if (mounted)
        errorNotifier.setError(AppError.generic(
            "An unexpected error occurred. Please try again."));
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }
  // --- *** END MODIFIED SAVE METHOD *** ---

  @override
  Widget build(BuildContext context) {
    // Build method layout remains the same, logic for enabling button updated
    final errorState = ref.watch(errorProvider);
    final bool hasSelection = _selectedPrompt != null;
    final bool hasAudioSource = _audioPath != null || _existingAudioUrl != null;
    final bool canSave = hasSelection &&
        (hasAudioSource ||
            (widget.isEditing &&
                _existingAudioUrl == null &&
                _audioPath == null)) &&
        !_isRecording; // Allow saving null in edit mode

    // --- UI Code (Unchanged) ---
    return Scaffold(
      /* ... Scaffold setup ... */
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(
                /* ... Header for Edit/Onboarding ... */
                padding: const EdgeInsets.only(top: 10.0, bottom: 10.0),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      const SizedBox(width: 48),
                    Text(
                      widget.isEditing ? "Edit Voice Prompt" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canSave && !_isSaving
                            ? _saveProfileAndNavigate
                            : null,
                        child: _isSaving
                            ? const SizedBox(
                                width: 20,
                                height: 20,
                                child:
                                    CircularProgressIndicator(strokeWidth: 2))
                            : Text(
                                "Done",
                                style: GoogleFonts.poppins(
                                  color: canSave
                                      ? const Color(0xFF8B5CF6)
                                      : Colors.grey,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                      )
                    else
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              if (!widget.isEditing) ...[
                /* ... Onboarding Dots ... */ const SizedBox(height: 10),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: List.generate(
                      3,
                      (index) => Container(
                            margin: const EdgeInsets.symmetric(horizontal: 4),
                            height: 10,
                            width: 10,
                            decoration: BoxDecoration(
                              color: index < 2
                                  ? Colors.grey[300]
                                  : const Color(0xFF8b5cf6),
                              shape: BoxShape.circle,
                            ),
                          )),
                ),
                const SizedBox(height: 20),
              ],
              Text(
                widget.isEditing
                    ? 'Edit your Voice Prompt'
                    : 'Add a Voice Prompt\nto your profile',
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing ? 28 : 32,
                  fontWeight: FontWeight.bold,
                  height: 1.2,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 12),
              Text(
                widget.isEditing
                    ? "Select a prompt and record your answer."
                    : "Let potential matches hear your voice!",
                style:
                    GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
              ),
              const SizedBox(height: 32),
              GestureDetector(
                /* ... Prompt Selection Row ... */
                onTap: _selectPrompt,
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: Colors.grey[300]!),
                    boxShadow: [
                      BoxShadow(
                          color: Colors.grey.withOpacity(0.1),
                          blurRadius: 5,
                          offset: const Offset(0, 2))
                    ],
                  ),
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          _selectedPrompt?.label ?? 'Select a prompt *',
                          style: GoogleFonts.poppins(
                            color: _selectedPrompt != null
                                ? Colors.black87
                                : Colors.grey[600],
                            fontSize: 16,
                            fontWeight: _selectedPrompt != null
                                ? FontWeight.w500
                                : FontWeight.normal,
                          ),
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(left: 8),
                        child: Icon(Icons.arrow_drop_down_rounded,
                            color: Colors.grey[800], size: 28),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 24),
              Expanded(
                child: GestureDetector(
                  /* ... Recording Area ... */
                  onTap: _isRecording ? null : _startRecording,
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(24),
                    decoration: BoxDecoration(
                      color: Colors.grey[50],
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(color: Colors.grey[200]!),
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          _recordingTime,
                          style: GoogleFonts.poppins(
                              color: Colors.grey[500], fontSize: 18),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          _isRecording
                              ? 'Recording...'
                              : (_audioPath == null && _existingAudioUrl == null
                                  ? 'Tap microphone to start (Max 30s)'
                                  : 'Tap microphone to re-record'),
                          textAlign: TextAlign.center,
                          style: GoogleFonts.poppins(
                              color: Colors.grey[600], fontSize: 16),
                        ),
                        const Spacer(),
                        GestureDetector(
                          onTap:
                              _isRecording ? _stopRecording : _startRecording,
                          child: Container(
                            padding: const EdgeInsets.all(24),
                            decoration: BoxDecoration(
                              color: _isRecording
                                  ? Colors.redAccent
                                  : const Color(0xFF8b5cf6),
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                    color: (_isRecording
                                            ? Colors.redAccent
                                            : const Color(0xFF8b5cf6))
                                        .withOpacity(0.3),
                                    blurRadius: 10,
                                    offset: const Offset(0, 4))
                              ],
                            ),
                            child: Icon(
                                _isRecording
                                    ? Icons.stop_rounded
                                    : Icons.mic_rounded,
                                color: Colors.white,
                                size: 36),
                          ),
                        ),
                        const Spacer(),
                        if ((_audioPath != null &&
                                File(_audioPath!).existsSync()) ||
                            _existingAudioUrl != null)
                          TextButton.icon(
                            onPressed: _playRecording,
                            style: TextButton.styleFrom(
                                foregroundColor: const Color(0xFF8b5cf6)),
                            icon: Icon(_isPlaying
                                ? Icons.pause_rounded
                                : Icons.play_arrow_rounded),
                            label: Text(
                              _isPlaying
                                  ? 'Pause'
                                  : 'Play ${_audioPath != null ? "recording" : "existing"}',
                              style: GoogleFonts.poppins(
                                  fontSize: 16, fontWeight: FontWeight.w500),
                            ),
                          )
                        else
                          const SizedBox(height: 48),
                      ],
                    ),
                  ),
                ),
              ),
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.only(top: 12.0, bottom: 8.0),
                  child: Center(
                    child: Text(
                      errorState.message,
                      style: GoogleFonts.poppins(
                          color: Colors.redAccent, fontSize: 14),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
              const SizedBox(height: 16),
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.centerRight,
                  child: Padding(
                    padding: const EdgeInsets.only(bottom: 24.0),
                    child: _isSaving
                        ? const CircularProgressIndicator(
                            color: Color(0xFF8b5cf6))
                        : FloatingActionButton(
                            heroTag: 'audio_save_fab',
                            onPressed: canSave ? _saveProfileAndNavigate : null,
                            backgroundColor: canSave
                                ? const Color(0xFF8b5cf6)
                                : Colors.grey.shade400,
                            foregroundColor: Colors.white,
                            child: const Icon(Icons.check_rounded),
                          ),
                  ),
                ),
              if (widget.isEditing) const SizedBox(height: 24),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    /* ... same as before ... */ print(
        "[VoicePromptScreen] Disposing screen...");
    _recordingTimer?.cancel();
    try {
      _audioRecorder.dispose();
    } catch (e) {
      print("Error disposing recorder: $e");
    }
    try {
      if (_audioPlayer.state == PlayerState.playing ||
          _audioPlayer.state == PlayerState.paused) {
        _audioPlayer.stop();
      }
      _audioPlayer.dispose();
    } catch (e) {
      print("Error disposing player: $e");
    }
    super.dispose();
  }
}



================================================
File: views/audiopromptsselect.dart
================================================
// File: views/audiopromptsselect.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/providers/audio_upload_provider.dart';

class AudioSelectPromptScreen extends ConsumerWidget {
  final bool isEditing; // <<< ADDED

  const AudioSelectPromptScreen({
    Key? key,
    this.isEditing = false, // <<< ADDED default
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentPrompt =
        ref.watch(audioUploadProvider.notifier).selectedPrompt;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // Add back button if editing? Or rely on close? Let's use close.
                  const SizedBox(width: 24), // Placeholder for alignment
                  const Text(
                    "Select a Prompt",
                    style: TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () => Navigator.pop(context), // Always pop back
                    child: const Icon(Icons.close, size: 24),
                  ),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                itemCount: AudioPrompt.values.length,
                itemBuilder: (context, index) {
                  final prompt = AudioPrompt.values[index];
                  final isSelected = prompt == currentPrompt;

                  return GestureDetector(
                    onTap: () {
                      ref
                          .read(audioUploadProvider.notifier)
                          .setSelectedPrompt(prompt);
                      // Pop back to VoicePromptScreen, which handles further nav
                      Navigator.pop(context);
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                        color: isSelected ? const Color(0xFFEDE9FE) : null,
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              prompt.label,
                              style: TextStyle(
                                fontSize: 18,
                                color: isSelected
                                    ? const Color(0xFF8B5CF6)
                                    : Colors.black87,
                                fontWeight: isSelected
                                    ? FontWeight.w600
                                    : FontWeight.normal,
                              ),
                            ),
                          ),
                          if (isSelected)
                            const Icon(
                              Icons.check_circle,
                              color: Color(0xFF8B5CF6),
                            ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/chat_screen.dart
================================================
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class ChatPlaceholderScreen extends StatelessWidget {
  const ChatPlaceholderScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey[100],
      appBar: AppBar(
        title: Text('Messages',
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 1,
        automaticallyImplyLeading: false, // No back button in a tab screen
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.chat_bubble_outline_rounded,
                size: 80, color: Colors.grey[400]),
            const SizedBox(height: 20),
            Text(
              'Chat Coming Soon!',
              style: GoogleFonts.poppins(fontSize: 18, color: Colors.grey[600]),
            ),
            const SizedBox(height: 10),
            Text(
              'Your conversations with matches will appear here.',
              textAlign: TextAlign.center,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[500]),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dating_intentions.dart
================================================
// File: lib/views/dating_intentions.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';
import '../providers/user_provider.dart';
import 'height.dart'; // Keep for onboarding flow

class DatingIntentionsScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const DatingIntentionsScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<DatingIntentionsScreen> createState() =>
      _DatingIntentionsScreenState();
}

class _DatingIntentionsScreenState
    extends ConsumerState<DatingIntentionsScreen> {
  DatingIntention? _selectedIntention; // Local state for selection

  @override
  void initState() {
    super.initState();
    // Load current value if editing
    if (widget.isEditing) {
      _selectedIntention = ref.read(userProvider).datingIntention;
    }
  }

  void _handleNext() {
    if (_selectedIntention != null) {
      ref.read(userProvider.notifier).updateDatingIntention(_selectedIntention);
      if (widget.isEditing) {
        print("[DatingIntentionsScreen] Editing done, popping back.");
        Navigator.of(context).pop(); // Pop back to ProfileScreen
      } else {
        // Original onboarding navigation
        print("[DatingIntentionsScreen] Onboarding next: Height.");
        Navigator.push(
          context,
          MaterialPageRoute(
              builder: (context) => const HeightSelectionScreen()),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // Watch userState only to update UI if needed externally (unlikely here)
    // final userState = ref.watch(userProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            // --- Adjusted Header for Edit Mode ---
            Padding(
              padding: EdgeInsets.only(
                top: screenSize.height * 0.02,
                left: screenSize.width * 0.02,
                right: screenSize.width * 0.06,
              ),
              child: Row(
                mainAxisAlignment: widget.isEditing
                    ? MainAxisAlignment.spaceBetween
                    : MainAxisAlignment.start,
                children: [
                  if (widget.isEditing)
                    IconButton(
                      icon: const Icon(Icons.close, color: Colors.grey),
                      onPressed: () => Navigator.of(context).pop(),
                    )
                  else
                    const SizedBox(
                        width:
                            40), // Placeholder for alignment during onboarding

                  Text(
                    widget.isEditing
                        ? "Edit Intention"
                        : "", // Title only in edit mode
                    style: GoogleFonts.poppins(
                        fontSize: 18, fontWeight: FontWeight.w600),
                  ),
                  if (widget.isEditing)
                    TextButton(
                      onPressed:
                          _selectedIntention != null ? _handleNext : null,
                      child: Text(
                        "Done",
                        style: GoogleFonts.poppins(
                          color: _selectedIntention != null
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    )
                  else
                    const SizedBox(width: 40), // Placeholder during onboarding
                ],
              ),
            ),
            // --- End Adjusted Header ---
            Padding(
              padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06)
                  .copyWith(
                      top: widget.isEditing
                          ? 20
                          : screenSize.height *
                              0.01), // Less top padding if editing
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (!widget.isEditing) // Show title only during onboarding
                    Text(
                      "What's your dating intention?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width * 0.065,
                        fontWeight: FontWeight.bold,
                        color: Colors.black,
                      ),
                    ),
                  SizedBox(height: widget.isEditing ? 30 : 65),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                physics: const BouncingScrollPhysics(),
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                itemCount: DatingIntention.values.length,
                itemBuilder: (context, index) {
                  return _buildOption(DatingIntention.values[index]);
                },
              ),
            ),
            // --- Hide FAB in Edit Mode ---
            if (!widget.isEditing)
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding:
                      EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                  child: GestureDetector(
                    onTap: _selectedIntention != null
                        ? _handleNext
                        : null, // Use local state
                    child: Container(
                      width: 56,
                      height: 56,
                      decoration: BoxDecoration(
                        color: _selectedIntention != null
                            ? const Color(0xFF8B5CF6)
                            : Colors.grey.shade300,
                        shape: BoxShape.circle,
                        boxShadow: [
                          if (_selectedIntention != null)
                            BoxShadow(
                              color: Colors.black.withOpacity(0.2),
                              spreadRadius: 1,
                              blurRadius: 8,
                            ),
                        ],
                      ),
                      child: Icon(
                        Icons.arrow_forward_rounded,
                        size: 28,
                        color: _selectedIntention != null
                            ? Colors.white
                            : Colors.grey.shade500,
                      ),
                    ),
                  ),
                ),
              ),
            // --- End Hide FAB ---
            SizedBox(height: screenSize.height * 0.04),
          ],
        ),
      ),
    );
  }

  Widget _buildOption(DatingIntention intention) {
    final bool isSelected = _selectedIntention == intention; // Use local state

    return GestureDetector(
      onTap: () {
        setState(() {
          // Update local state
          _selectedIntention = intention;
        });
        // No need to update provider here, only on save/next
      },
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 16),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.transparent,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade300,
            width: 1.5,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Text(
                intention.label,
                style: GoogleFonts.poppins(
                  fontSize: intention.label.length > 20 ? 14 : 16,
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                  color: isSelected ? Colors.white : Colors.black,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            if (isSelected)
              const Icon(
                Icons.check_circle,
                color: Colors.white,
                size: 24,
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dob.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/dating_intentions.dart';
import 'package:dtx/views/location.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class DateOfBirthScreen extends ConsumerStatefulWidget {
  const DateOfBirthScreen({super.key});

  @override
  ConsumerState<DateOfBirthScreen> createState() => _DateOfBirthScreenState();
}

class _DateOfBirthScreenState extends ConsumerState<DateOfBirthScreen> {
  final TextEditingController _dayController = TextEditingController();
  final TextEditingController _monthController = TextEditingController();
  final TextEditingController _yearController = TextEditingController();

  final FocusNode _dayFocusNode = FocusNode();
  final FocusNode _monthFocusNode = FocusNode();
  final FocusNode _yearFocusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    _dayFocusNode.addListener(() {
      if (!_dayFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _monthFocusNode.addListener(() {
      if (!_monthFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _yearFocusNode.addListener(() {
      if (!_yearFocusNode.hasFocus) {
        _validateInputs();
      }
    });
  }

  @override
  void dispose() {
    _dayController.dispose();
    _monthController.dispose();
    _yearController.dispose();
    _dayFocusNode.dispose();
    _monthFocusNode.dispose();
    _yearFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.1),
                Text(
                  "What's your date of birth?",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.08,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    _buildDateInput(
                      "DD",
                      _dayController,
                      _dayFocusNode,
                      2,
                      _monthFocusNode,
                    ),
                    _buildDateInput(
                      "MM",
                      _monthController,
                      _monthFocusNode,
                      2,
                      _yearFocusNode,
                    ),
                    _buildDateInput(
                      "YYYY",
                      _yearController,
                      _yearFocusNode,
                      4,
                      null,
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.03),
                Text(
                  "We use this to calculate the age on your profile.",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.04,
                    color: Colors.white70,
                  ),
                ),
                if (error?.type == ErrorType.validation)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      error!.message,
                      style: GoogleFonts.poppins(
                        color: Colors.redAccent,
                        fontSize: screenSize.width * 0.035,
                      ),
                    ),
                  ),
                const Spacer(),
                _buildNextButton(screenSize),
                SizedBox(height: screenSize.height * 0.05),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDateInput(
    String hint,
    TextEditingController controller,
    FocusNode focusNode,
    int maxLength,
    FocusNode? nextFocusNode,
  ) {
    return Expanded(
      flex: maxLength == 4 ? 2 : 1,
      child: TextField(
        controller: controller,
        focusNode: focusNode,
        keyboardType: TextInputType.number,
        maxLength: maxLength,
        style: GoogleFonts.poppins(
          fontSize: 24,
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
        decoration: InputDecoration(
          hintText: hint,
          hintStyle: GoogleFonts.poppins(
            fontSize: 24,
            fontWeight: FontWeight.w500,
            color: Colors.white70,
          ),
          counterText: "",
          enabledBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white54, width: 2.0),
          ),
          focusedBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white, width: 2.5),
          ),
        ),
        textAlign: TextAlign.center,
        onChanged: (value) {
          if (value.length == maxLength) {
            focusNode.unfocus();
            if (nextFocusNode != null) {
              FocusScope.of(context).requestFocus(nextFocusNode);
            }
          }
          _validateInputs();
        },
      ),
    );
  }

  void _validateInputs() {
    ref.read(errorProvider.notifier).clearError();
    final day = int.tryParse(_dayController.text) ?? 0;
    final month = int.tryParse(_monthController.text) ?? 0;
    final year = int.tryParse(_yearController.text) ?? 0;

    if (_dayController.text.isEmpty ||
        _monthController.text.isEmpty ||
        _yearController.text.isEmpty) return;

    if (day < 1 || day > 31) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid day"),
          );
      return;
    }

    if (month < 1 || month > 12) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid month"),
          );
      return;
    }

    try {
      final date = DateTime(year, month, day);
      ref.read(userProvider.notifier).updateDateOfBirth(date);
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid date combination"),
          );
    }
  }

  Widget _buildNextButton(Size screenSize) {
    final isValid = _dayController.text.length == 2 &&
        _monthController.text.length == 2 &&
        _yearController.text.length == 4 &&
        ref.read(errorProvider) == null;

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: isValid ? _handleNext : null,
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: isValid ? Colors.white : Colors.grey.shade400,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: const EdgeInsets.all(16),
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24,
          color: isValid ? const Color(0xFF8B5CF6) : Colors.white54,
        ),
      ),
    );
  }

  void _handleNext() {
    final date = DateTime(
      int.parse(_yearController.text),
      int.parse(_monthController.text),
      int.parse(_dayController.text),
    );

    ref.read(userProvider.notifier).updateDateOfBirth(date);
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DatingIntentionsScreen()),
    );
  }
}



================================================
File: views/drinking.dart
================================================
// File: lib/views/drinking.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/smoking.dart'; // Keep for onboarding flow

class DrinkingScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const DrinkingScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<DrinkingScreen> createState() => _DrinkingScreenState();
}

class _DrinkingScreenState extends ConsumerState<DrinkingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedDrinkingHabit; // Local state
  // Removed _isOptionSelected, use _selectedDrinkingHabit directly
  late AnimationController _controller; // Keep for animations if desired
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );

    // Load initial value if editing
    if (widget.isEditing) {
      _selectedDrinkingHabit = ref.read(userProvider).drinkingHabit;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleNext() {
    if (_selectedDrinkingHabit != null) {
      ref
          .read(userProvider.notifier)
          .updateDrinkingHabit(_selectedDrinkingHabit);
      if (widget.isEditing) {
        print("[DrinkingScreen] Editing done, popping back.");
        Navigator.of(context).pop();
      } else {
        // Original onboarding navigation
        print("[DrinkingScreen] Onboarding next: Smoking.");
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const SmokingScreen()));
      }
    } else {
      // This should not happen if button is properly disabled, but as a fallback
      if (!widget.isEditing) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content:
                Text("Please select an option", style: GoogleFonts.poppins()),
            backgroundColor: Colors.red[400],
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically
    final bool canProceed = _selectedDrinkingHabit != null; // Check local state

    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder icon for onboarding
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: const Icon(Icons.local_bar_rounded,
                            color: Color(0xFF8B5CF6),
                            size: 30), // Slightly smaller icon
                      ),
                    Text(
                      widget.isEditing ? "Edit Drinking Habit" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canProceed ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for onboarding
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.03),
              Text(
                widget.isEditing
                    ? "Edit your drinking habits"
                    : "Do you drink?",
                textAlign: TextAlign.left,
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.07
                      : screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  height: 1.1,
                ),
              ),
              if (!widget.isEditing) // Show subtitle only during onboarding
                Text(
                  "Select your drinking habits",
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    color: Colors.grey[600],
                    height: 1.5,
                  ),
                ),
              SizedBox(height: screenSize.height * 0.04),
              Expanded(
                child: ListView.separated(
                  itemCount: DrinkingSmokingHabits.values.length,
                  separatorBuilder: (context, index) =>
                      const SizedBox(height: 12),
                  itemBuilder: (context, index) {
                    final habit = DrinkingSmokingHabits.values[index];
                    return _buildDrinkingOptionTile(
                      screenSize: screenSize,
                      title: habit.label,
                      value: habit,
                    );
                  },
                ),
              ),
              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: AnimatedScale(
                      scale: canProceed ? 1.0 : 0.95, // Use local state
                      duration: const Duration(milliseconds: 200),
                      child: GestureDetector(
                        onTap: _handleNext, // Use unified handler
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey.shade300,
                            borderRadius: BorderRadius.circular(35),
                            boxShadow: canProceed
                                ? [
                                    BoxShadow(
                                      color: const Color(0xFF8B5CF6)
                                          .withOpacity(0.3),
                                      blurRadius: 8,
                                      offset: const Offset(0, 4),
                                    ),
                                  ]
                                : null,
                          ),
                          child: Icon(
                            Icons.arrow_forward_rounded,
                            color: canProceed
                                ? Colors.white
                                : Colors.grey.shade600,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildDrinkingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedDrinkingHabit == value; // Use local state

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedDrinkingHabit = value; // Update local state
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/filter_settings_dialog.dart
================================================
// File: lib/views/filter_settings_dialog.dart
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class FilterSettingsDialog extends ConsumerStatefulWidget {
  const FilterSettingsDialog({super.key});

  @override
  ConsumerState<FilterSettingsDialog> createState() =>
      _FilterSettingsDialogState();
}

class _FilterSettingsDialogState extends ConsumerState<FilterSettingsDialog> {
  late FilterSettings _currentFilters;
  late RangeValues _currentAgeRange;
  late double _currentRadius;
  bool _isLoading = false; // Local loading state for saving

  @override
  void initState() {
    super.initState();
    // Initialize local state with current provider state when dialog opens
    final initialFilters = ref.read(filterProvider);
    _currentFilters = initialFilters;
    _currentAgeRange = RangeValues(
      initialFilters.ageMin?.toDouble() ??
          FilterSettings.defaultAgeMin.toDouble(),
      initialFilters.ageMax?.toDouble() ??
          FilterSettings.defaultAgeMax.toDouble(),
    );
    _currentRadius = initialFilters.radiusKm?.toDouble() ??
        FilterSettings.defaultRadius.toDouble();
  }

  Future<void> _applyFilters() async {
    if (_isLoading) return; // Prevent double taps

    setState(() => _isLoading = true);

    final newSettings = _currentFilters.copyWith(
      ageMin: () => _currentAgeRange.start.round(),
      ageMax: () => _currentAgeRange.end.round(),
      radiusKm: () => _currentRadius.round(),
      // whoYouWantToSee and activeToday are already updated in _currentFilters via setState
    );

    final success =
        await ref.read(filterProvider.notifier).saveFilters(newSettings);

    // Check if mounted before interacting with context or state
    if (!mounted) return;

    setState(() => _isLoading = false);

    if (success) {
      print(
          "[FilterSettingsDialog] Filters saved successfully. Refreshing feed.");
      // Trigger feed refresh AFTER saving filters
      ref.read(feedProvider.notifier).fetchFeed(forceRefresh: true);
      Navigator.of(context).pop(true); // Pop dialog and indicate success
    } else {
      // Error handling is likely done via the errorProvider in FilterNotifier
      // Optionally show a snackbar here too if desired.
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content:
                Text("Failed to save filters", style: GoogleFonts.poppins())),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // No need to watch provider's loading state directly, use local _isLoading for save button

    return AlertDialog(
      title: Text("Filters",
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
      contentPadding: const EdgeInsets.fromLTRB(20, 20, 20, 0),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // --- Who You Want To See ---
            Text("Show Me:",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: FilterGenderPref.values.map((genderPref) {
                return ChoiceChip(
                  label: Text(genderPref.value[0].toUpperCase() +
                      genderPref.value.substring(1)),
                  selected: _currentFilters.whoYouWantToSee == genderPref,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        // Use copyWith for immutability when updating local state
                        _currentFilters = _currentFilters.copyWith(
                            whoYouWantToSee: () => genderPref);
                      });
                    }
                  },
                  selectedColor: const Color(0xFFEDE9FE),
                  checkmarkColor: const Color(0xFF8B5CF6),
                  labelStyle: GoogleFonts.poppins(
                    color: _currentFilters.whoYouWantToSee == genderPref
                        ? const Color(0xFF8B5CF6)
                        : Colors.black87,
                  ),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                      side: BorderSide(
                          color: _currentFilters.whoYouWantToSee == genderPref
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey.shade300)),
                  backgroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 10),
                );
              }).toList(),
            ),
            const SizedBox(height: 20),

            // --- Age Range ---
            Text("Age Range:",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
            RangeSlider(
              values: _currentAgeRange,
              min: 18,
              max: 70,
              divisions: 52,
              labels: RangeLabels(
                _currentAgeRange.start.round().toString(),
                _currentAgeRange.end.round().toString(),
              ),
              activeColor: const Color(0xFF8B5CF6),
              inactiveColor: const Color(0xFF8B5CF6).withOpacity(0.3),
              onChanged: (RangeValues values) {
                setState(() {
                  if (values.start <= values.end) {
                    _currentAgeRange = values;
                  }
                });
              },
            ),
            Text(
              "${_currentAgeRange.start.round()} - ${_currentAgeRange.end.round()} years",
              style: GoogleFonts.poppins(color: Colors.grey[600], fontSize: 12),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),

            // --- Distance Radius ---
            Text("Distance (km):",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
            Slider(
              value: _currentRadius,
              min: 1,
              max: 500,
              divisions: 499,
              label: _currentRadius.round().toString(),
              activeColor: const Color(0xFF8B5CF6),
              inactiveColor: const Color(0xFF8B5CF6).withOpacity(0.3),
              onChanged: (double value) {
                setState(() {
                  _currentRadius = value;
                });
              },
            ),
            Text(
              "${_currentRadius.round()} km",
              style: GoogleFonts.poppins(color: Colors.grey[600], fontSize: 12),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),

            // --- Active Today ---
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text("Active Today Only:",
                    style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
                Switch(
                  value: _currentFilters.activeToday ??
                      FilterSettings.defaultActiveToday,
                  activeColor: const Color(0xFF8B5CF6),
                  onChanged: (bool value) {
                    setState(() {
                      _currentFilters =
                          _currentFilters.copyWith(activeToday: () => value);
                    });
                  },
                ),
              ],
            ),
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: Text('Cancel', style: GoogleFonts.poppins(color: Colors.grey)),
          onPressed: () =>
              Navigator.of(context).pop(false), // Indicate no change
        ),
        ElevatedButton(
          style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF8B5CF6),
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20))),
          onPressed: _isLoading ? null : _applyFilters, // Disable while saving
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                      strokeWidth: 2, color: Colors.white))
              : Text('Apply', style: GoogleFonts.poppins()),
        ),
      ],
      actionsPadding: const EdgeInsets.symmetric(horizontal: 15, vertical: 10),
    );
  }
}



================================================
File: views/gender.dart
================================================
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart'; // Import FilterProvider
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:dtx/views/main_navigation_screen.dart'; // Import MainNavigationScreen
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../models/error_model.dart';
import '../providers/user_provider.dart';
import '../providers/error_provider.dart';
import '../providers/service_provider.dart';
// Removed Home import

class GenderSelectionScreen extends ConsumerStatefulWidget {
  const GenderSelectionScreen({super.key});

  @override
  ConsumerState<GenderSelectionScreen> createState() =>
      _GenderSelectionScreenState();
}

class _GenderSelectionScreenState extends ConsumerState<GenderSelectionScreen> {
  bool _isSubmitting = false;

  void _initiateEarlyFetches() {
    print(
        "[GenderSelectionScreen] Initiating early data fetches (Filters, HomeFeed).");
    // Don't await, let them run in background
    ref.read(filterProvider.notifier).loadFilters();
    ref.read(feedProvider.notifier).fetchFeed();
  }

  Future<void> _submitLocationAndGender() async {
    final userState = ref.read(userProvider);
    final errorNotifier = ref.read(errorProvider.notifier);
    final authNotifier = ref.read(authProvider.notifier);

    errorNotifier.clearError();

    if (userState.latitude == null || userState.longitude == null) {
      errorNotifier.setError(
          AppError.validation("Location data is missing. Please go back."));
      return;
    }
    if (userState.gender == null) {
      errorNotifier.setError(AppError.validation("Please select a gender."));
      return;
    }

    setState(() => _isSubmitting = true);

    try {
      final userRepository = ref.read(userRepositoryProvider);
      final success = await userRepository.updateLocationGender(
        userState.latitude!,
        userState.longitude!,
        userState.gender!,
      );

      if (success) {
        print(
            "[GenderSelectionScreen] Location/Gender submitted successfully.");
        final finalStatus =
            await authNotifier.checkAuthStatus(updateState: true);
        print("[GenderSelectionScreen] Auth status updated to: $finalStatus");

        if (mounted) {
          Widget nextScreen;
          // Navigate to MainNavigationScreen if onboarding is complete (status onboarding2 or home)
          if (finalStatus == AuthStatus.onboarding2 ||
              finalStatus == AuthStatus.home) {
            print(
                "[GenderSelectionScreen] Navigating to MainNavigationScreen.");
            _initiateEarlyFetches(); // Start loading data
            nextScreen = const MainNavigationScreen();
          } else {
            // Fallback to GoogleSignInScreen if status is unexpectedly login/unknown
            print(
                "[GenderSelectionScreen] Unexpected status ($finalStatus), navigating to GoogleSignInScreen.");
            nextScreen = const GoogleSignInScreen();
          }

          Navigator.pushAndRemoveUntil(
            context,
            MaterialPageRoute(builder: (context) => nextScreen),
            (Route<dynamic> route) => false,
          );
        }
      } else {
        print(
            "[GenderSelectionScreen] Location/Gender submission failed (API returned false).");
        if (ref.read(errorProvider) == null) {
          errorNotifier
              .setError(AppError.server("Failed to update location/gender."));
        }
      }
    } on ApiException catch (e) {
      print(
          "[GenderSelectionScreen] API Exception during submit: ${e.message}");
      errorNotifier.setError(AppError.server(e.message));
    } catch (e) {
      print(
          "[GenderSelectionScreen] Unexpected error during submit: ${e.toString()}");
      errorNotifier.setError(
          AppError.generic("An unexpected error occurred. Please try again."));
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Build method remains largely the same, only navigation logic changed
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);
    final errorState = ref.watch(errorProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.03),
              Align(
                alignment: Alignment.topLeft,
                child: IconButton(
                  icon: Icon(Icons.arrow_back_ios_new, color: Colors.grey[600]),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              Text(
                "Which gender best\ndescribes you?",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.075,
                  fontWeight: FontWeight.bold,
                  color: Colors.black,
                  height: 1.2,
                ),
              ),
              SizedBox(height: screenSize.height * 0.05),
              Column(
                children: [Gender.man, Gender.woman]
                    .map((gender) => _buildOption(gender))
                    .toList(),
              ),
              const Spacer(),
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.only(bottom: 10.0),
                  child: Text(
                    errorState.message,
                    style: GoogleFonts.poppins(
                        color: Colors.redAccent, fontSize: 14),
                    textAlign: TextAlign.center,
                  ),
                ),
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding: const EdgeInsets.only(bottom: 20.0),
                  child: _isSubmitting
                      ? const CircularProgressIndicator(
                          color: Color(0xFF8B5CF6))
                      : FloatingActionButton(
                          heroTag: 'gender_next_fab',
                          onPressed: userState.gender != null
                              ? _submitLocationAndGender
                              : null,
                          backgroundColor: userState.gender != null
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey.shade300,
                          foregroundColor: Colors.white,
                          child: const Icon(Icons.arrow_forward_rounded),
                        ),
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOption(Gender gender) {
    // _buildOption implementation remains the same
    final bool isSelected = ref.watch(userProvider).gender == gender;
    final errorNotifier = ref.read(errorProvider.notifier);

    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: Material(
        borderRadius: BorderRadius.circular(12),
        color: isSelected ? const Color(0xFFEDE9FE) : Colors.grey.shade50,
        elevation: isSelected ? 1 : 0,
        shadowColor: const Color(0xFF8B5CF6).withOpacity(0.3),
        child: InkWell(
          onTap: () {
            errorNotifier.clearError();
            ref.read(userProvider.notifier).updateGender(gender);
          },
          borderRadius: BorderRadius.circular(12),
          child: Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color:
                    isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade300,
                width: isSelected ? 1.5 : 1,
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  gender.label,
                  style: GoogleFonts.poppins(
                    fontSize: 18,
                    fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
                    color: isSelected
                        ? const Color(0xFF8B5CF6)
                        : Colors.grey.shade800,
                  ),
                ),
                if (isSelected)
                  const Icon(
                    Icons.check_circle_outline_rounded,
                    color: Color(0xFF8B5CF6),
                    size: 24,
                  )
                else
                  Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      border:
                          Border.all(color: Colors.grey.shade400, width: 1.5),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/google_sign_in_screen.dart
================================================
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart'; // Import FilterProvider
import 'package:dtx/views/location.dart';
import 'package:dtx/views/main_navigation_screen.dart'; // Import MainNavigationScreen
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/models/auth_model.dart';
// Removed FeedType import
// Removed Home import
// Removed NameInputScreen import

class GoogleSignInScreen extends ConsumerWidget {
  const GoogleSignInScreen({super.key});

  void _initiateEarlyFetches(WidgetRef ref) {
    print(
        "[GoogleSignInScreen] Initiating early data fetches (Filters, HomeFeed).");
    // Don't await, let them run in background
    ref.read(filterProvider.notifier).loadFilters();
    ref.read(feedProvider.notifier).fetchFeed();
  }

  Future<void> _handleSignIn(BuildContext context, WidgetRef ref) async {
    final status = await ref.read(authProvider.notifier).signInWithGoogle();
    if (!context.mounted) return;

    Widget destination;
    switch (status) {
      case AuthStatus.home:
      case AuthStatus.onboarding2: // Both go to main screen now
        print('[GoogleSignInScreen] Navigating to MainNavigationScreen');
        _initiateEarlyFetches(ref); // Start loading data
        destination = const MainNavigationScreen();
        break;
      case AuthStatus.onboarding1:
        print('[GoogleSignInScreen] Navigating to LocationInputScreen');
        destination = const LocationInputScreen();
        break;
      case AuthStatus.login:
      case AuthStatus.unknown:
      default:
        // Stay on this screen if sign-in failed or status is unexpected
        print(
            '[GoogleSignInScreen] Sign in failed or status unknown/login. Staying on screen.');
        return;
    }
    // Use pushReplacement to prevent going back to the sign-in screen
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(builder: (context) => destination),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Build method remains largely the same, only navigation logic changed
    final authState = ref.watch(authProvider);
    final errorState = ref.watch(errorProvider);
    final screenSize = MediaQuery.of(context).size;

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  const Spacer(flex: 2),
                  Text(
                    'Peeple',
                    style: GoogleFonts.pacifico(
                      fontSize: screenSize.width * 0.15,
                      color: Colors.white,
                      shadows: [
                        Shadow(
                          color: Colors.black.withOpacity(0.5),
                          blurRadius: 10,
                          offset: const Offset(2, 2),
                        ),
                      ],
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.03),
                  Text(
                    'Connect Authentically',
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.045,
                      color: Colors.white.withOpacity(0.8),
                      fontWeight: FontWeight.w300,
                    ),
                  ),
                  const Spacer(flex: 3),
                  if (authState.isLoading)
                    const CircularProgressIndicator(color: Colors.white)
                  else
                    ElevatedButton.icon(
                      icon: Image.asset('assets/google_logo.png',
                          height: 24.0,
                          errorBuilder: (context, error, stackTrace) =>
                              const Icon(Icons.login, size: 24)),
                      label: Text(
                        'Sign In with Google',
                        style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                            color: Colors.black87),
                      ),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.white,
                        foregroundColor: Colors.black87,
                        minimumSize: const Size(double.infinity, 50),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                      onPressed: () => _handleSignIn(context, ref),
                    ),
                  SizedBox(height: screenSize.height * 0.02),
                  if (errorState != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 15.0),
                      child: Text(
                        errorState.message,
                        textAlign: TextAlign.center,
                        style: GoogleFonts.poppins(
                          color: Colors.redAccent[100],
                          fontSize: 14,
                        ),
                      ),
                    ),
                  const Spacer(flex: 1),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 20.0),
                    child: Text(
                      'By signing in, you agree to our Terms of Service and Privacy Policy.',
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                        fontSize: 12,
                        color: Colors.white.withOpacity(0.6),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/height.dart
================================================
// File: lib/views/height.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
// Removed unused app_enums import
import '../providers/user_provider.dart';
import 'hometown.dart'; // Keep for onboarding flow

class HeightSelectionScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const HeightSelectionScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<HeightSelectionScreen> createState() =>
      _HeightSelectionScreenState();
}

class _HeightSelectionScreenState extends ConsumerState<HeightSelectionScreen> {
  String _unit = "FT"; // Default unit is Feet
  int _selectedFeetIndex = 0; // Start at the first index (4' 0")
  int _selectedCmIndex = 30; // Start at 150 cm (index 30 for 120cm base)

  // Define the starting and ending points explicitly
  int _startFeet = 4;
  int _startInches = 0;
  int _endFeet = 7; // Extended range up to 7'0"
  int _endInches = 0;

  int _startCm = 120;
  int _endCm = 213; // Approx 7'0"

  late List<String> _feetValues;
  late List<String> _cmValues;

  String _initialHeightValue = ''; // Store initial value for comparison/reset

  // Function to convert CM to Feet and Inches string
  String _cmToFeet(int cm) {
    double totalInches = cm * 0.393701;
    int feet = (totalInches / 12).floor();
    int inches = (totalInches % 12).round();
    if (inches == 12) {
      feet++;
      inches = 0;
    }
    return "$feet' $inches\""; // API format
  }

  // Function to convert Feet and Inches string to CM
  int _feetToCm(String feetInchStr) {
    try {
      final parts = feetInchStr.replaceAll('"', '').split("'");
      if (parts.length == 2) {
        final feet = int.tryParse(parts[0]) ?? 0;
        final inches = int.tryParse(parts[1]) ?? 0;
        double totalInches = (feet * 12) + inches.toDouble();
        return (totalInches / 0.393701).round();
      }
    } catch (e) {
      print("Error parsing height $feetInchStr: $e");
    }
    return _startCm; // Default fallback
  }

  @override
  void initState() {
    super.initState();

    // Generate Feet Values (4'0" to 7'0")
    _feetValues = List.generate(
      ((_endFeet * 12) + _endInches) - ((_startFeet * 12) + _startInches) + 1,
      (index) {
        int totalInches = ((_startFeet * 12) + _startInches) + index;
        int feet = totalInches ~/ 12;
        int inches = totalInches % 12;
        return "$feet' $inches\""; // API format
      },
    );

    // Generate CM Values (120cm to 213cm)
    _cmValues = List.generate(
        _endCm - _startCm + 1, (index) => "${_startCm + index} cm");

    // Load initial value if editing
    if (widget.isEditing) {
      final currentHeight = ref.read(userProvider).height;
      _initialHeightValue = currentHeight ?? '';
      if (currentHeight != null && currentHeight.isNotEmpty) {
        // Determine initial unit and index
        if (currentHeight.contains("'")) {
          // Assume FT format
          _unit = "FT";
          _selectedFeetIndex = _feetValues.indexOf(currentHeight);
          if (_selectedFeetIndex == -1) _selectedFeetIndex = 0; // Fallback
        } else if (currentHeight.toLowerCase().contains('cm')) {
          // Assume CM format (unlikely based on save logic, but check)
          _unit = "CM";
          _selectedCmIndex = _cmValues.indexOf(currentHeight);
          if (_selectedCmIndex == -1) _selectedCmIndex = 30; // Fallback ~150cm
        } else {
          // If format is unknown, try parsing as FT
          _unit = "FT";
          _selectedFeetIndex = _feetValues.indexOf(currentHeight);
          if (_selectedFeetIndex == -1) _selectedFeetIndex = 0; // Fallback
        }
      } else {
        // Default if no existing height
        _unit = "FT";
        _selectedFeetIndex = 11; // Default to 5'11" approx
      }
    } else {
      // Default for onboarding
      _unit = "FT";
      _selectedFeetIndex = 11; // Default to 5'11" approx
    }
  }

  void _handleNext() {
    _updateHeight(ref, forceUpdate: true); // Ensure provider is updated
    if (widget.isEditing) {
      print("[HeightSelectionScreen] Editing done, popping back.");
      Navigator.of(context).pop(); // Pop back to ProfileScreen
    } else {
      // Original onboarding navigation
      print("[HeightSelectionScreen] Onboarding next: Hometown.");
      Navigator.push(
        context,
        MaterialPageRoute(builder: (context) => const HometownScreen()),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState =
        ref.watch(userProvider); // Watch for external updates if needed

    // Use appropriate values for the current unit
    final List<String> currentValues = _unit == "FT" ? _feetValues : _cmValues;
    int currentIndex = _unit == "FT" ? _selectedFeetIndex : _selectedCmIndex;

    // Check if the current value in the provider matches the displayed value
    final bool hasValueChanged = (_unit == "FT" &&
            userState.height != _feetValues[currentIndex]) ||
        (_unit == "CM" &&
            userState.height !=
                _cmToFeet(
                    int.parse(_cmValues[currentIndex].replaceAll(" cm", ""))));

    // Determine if the "Done" button should be enabled
    final bool canProceed =
        userState.height != null && userState.height!.isNotEmpty;

    // --- Create FixedExtentScrollController ---
    final scrollController =
        FixedExtentScrollController(initialItem: currentIndex);

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4), // Light background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: widget.isEditing
                      ? MainAxisAlignment.spaceBetween
                      : MainAxisAlignment.start,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      const SizedBox(width: 40), // Placeholder

                    Text(
                      widget.isEditing ? "Edit Height" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canProceed ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      const SizedBox(width: 40), // Placeholder
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(
                  height: widget.isEditing ? 40 : screenSize.height * 0.02),

              // Title (Shown in both modes, slightly smaller in edit)
              Center(
                child: Text(
                  "How tall are you?",
                  style: GoogleFonts.poppins(
                    fontSize: widget.isEditing
                        ? screenSize.width * 0.08
                        : screenSize.width * 0.1,
                    fontWeight: FontWeight.w700, // More bold title
                    color: const Color(0xFF333333), // Darker title color
                  ),
                ),
              ),

              SizedBox(
                  height: screenSize.height *
                      0.05), // Increased spacing below title

              // Height Selector
              Expanded(
                child: ListWheelScrollView.useDelegate(
                  controller: scrollController, // Use the controller
                  itemExtent: 70, // Increased item extent for better spacing
                  diameterRatio: 1.3, // Adjusted for better visual
                  physics: const FixedExtentScrollPhysics(),
                  onSelectedItemChanged: (index) {
                    setState(() {
                      if (_unit == "FT") {
                        _selectedFeetIndex = index;
                      } else {
                        _selectedCmIndex = index;
                      }
                      // Update provider immediately on scroll change
                      _updateHeight(ref);
                    });
                  },
                  childDelegate: ListWheelChildBuilderDelegate(
                    childCount: currentValues.length,
                    builder: (context, index) {
                      final isSelected = index == currentIndex;
                      return Center(
                        child: Text(
                          currentValues[index],
                          style: GoogleFonts.poppins(
                            fontSize: isSelected
                                ? 30
                                : 22, // Larger font sizes for list items
                            fontWeight: isSelected
                                ? FontWeight.w600
                                : FontWeight.w400, // Adjusted weight
                            color: isSelected
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey
                                    .shade700, // Highlighted selected color, darker unselected
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ),

              SizedBox(
                  height: screenSize.height *
                      0.03), // Reduced spacing above buttons

              // Unit Toggle Buttons - Improved UI
              Padding(
                padding: EdgeInsets.symmetric(
                    horizontal: screenSize.width *
                        0.1), // Add horizontal padding for buttons
                child: Row(
                  mainAxisAlignment:
                      MainAxisAlignment.spaceAround, // Space buttons evenly
                  children: [
                    _buildUnitButton("FT", screenSize, scrollController),
                    _buildUnitButton("CM", screenSize, scrollController),
                  ],
                ),
              ),

              SizedBox(
                  height: screenSize.height *
                      0.04), // Spacing before forward button

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Center(
                  child: GestureDetector(
                    onTap: canProceed ? _handleNext : null,
                    child: Container(
                      width: 70, // Even larger button
                      height: 70,
                      decoration: BoxDecoration(
                        color: canProceed
                            ? const Color(0xFF8B5CF6)
                            : Colors.grey.shade400,
                        borderRadius: BorderRadius.circular(35), // More rounded
                      ),
                      child: const Icon(
                        Icons.arrow_forward_rounded,
                        color: Colors.white,
                        size: 32, // Larger icon
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              SizedBox(
                  height: screenSize.height * 0.06), // Increased bottom spacing
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildUnitButton(String unit, Size screenSize,
      FixedExtentScrollController scrollController) {
    final isSelected = _unit == unit;
    return GestureDetector(
      onTap: () {
        if (_unit != unit) {
          // Only update if switching units
          setState(() {
            _unit = unit;
            // Update the scroll position when unit changes
            if (_unit == "FT") {
              // Convert CM index to approximate FT index
              final currentCm = _startCm + _selectedCmIndex;
              final feetStr = _cmToFeet(currentCm);
              _selectedFeetIndex = _feetValues.indexOf(feetStr);
              if (_selectedFeetIndex == -1) _selectedFeetIndex = 11; // Fallback
              // Animate scroll AFTER setState completes
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (scrollController.hasClients) {
                  scrollController.animateToItem(_selectedFeetIndex,
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut);
                }
              });
            } else {
              // Switching to CM
              // Convert FT index to approximate CM index
              final currentFt = _feetValues[_selectedFeetIndex];
              final cmValue = _feetToCm(currentFt);
              _selectedCmIndex = cmValue - _startCm;
              if (_selectedCmIndex < 0 ||
                  _selectedCmIndex >= _cmValues.length) {
                _selectedCmIndex = 30; // Fallback
              }
              // Animate scroll AFTER setState completes
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (scrollController.hasClients) {
                  scrollController.animateToItem(_selectedCmIndex,
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut);
                }
              });
            }
            // Update provider after unit switch and index calculation
            _updateHeight(ref);
          });
        }
      },
      child: Container(
        padding: EdgeInsets.symmetric(
            vertical: 12,
            horizontal: screenSize.width * 0.08), // Dynamic horizontal padding
        decoration: BoxDecoration(
          color: isSelected
              ? const Color(0xFF8B5CF6)
              : Colors.white, // White background for unselected
          border: Border.all(color: Colors.grey.shade300), // Subtle border
          borderRadius: BorderRadius.circular(30), // Even more rounded corners
          boxShadow: [
            // Subtle shadow for depth
            BoxShadow(
              color: Colors.grey.withOpacity(0.15),
              spreadRadius: 0,
              blurRadius: 3,
              offset: const Offset(0, 2), // changes position of shadow
            ),
          ],
        ),
        child: Text(
          unit,
          style: GoogleFonts.poppins(
            fontSize: 18, // Larger font size for buttons
            fontWeight: isSelected
                ? FontWeight.w600
                : FontWeight.w500, // Slightly bolder for selected
            color: isSelected
                ? Colors.white
                : const Color(0xFF555555), // Darker text for unselected
          ),
        ),
      ),
    );
  }

  // Modified to accept forceUpdate flag
  void _updateHeight(WidgetRef ref, {bool forceUpdate = false}) {
    String selectedValue = _unit == "FT"
        ? _feetValues[_selectedFeetIndex]
        : _cmValues[_selectedCmIndex];

    // Convert CM selection to FT' IN" format for saving
    String heightToSave = (_unit == "CM")
        ? _cmToFeet(int.parse(selectedValue.replaceAll(" cm", "")))
        : selectedValue;

    // Only update the provider if the value changed or if forced (e.g., on Done)
    if (forceUpdate || ref.read(userProvider).height != heightToSave) {
      print(
          "[HeightSelectionScreen] Updating height in provider to: $heightToSave");
      ref.read(userProvider.notifier).updateHeight(heightToSave);
    }
  }
}



================================================
File: views/home.dart
================================================
// File: lib/views/home.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/feed_provider.dart';
import 'package:dtx/providers/filter_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/views/filter_settings_dialog.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/widgets/home_profile_card.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/utils/app_enums.dart';

class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen> {
  List<UserModel> _feedProfiles = [];
  bool _isInteracting = false; // To show overlay during API call

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final feedState = ref.read(feedProvider);
      if (!feedState.hasFetchedOnce && !feedState.isLoading) {
        print("[HomeScreen initState] Feed not fetched yet, triggering fetch.");
        _fetchFeed();
      } else {
        if (mounted) {
          // Initialize local state from provider if already fetched
          setState(() {
            _feedProfiles = feedState.profiles;
          });
        }
      }
      final filterState = ref.read(filterProvider);
      final filterNotifier = ref.read(filterProvider.notifier);
      if (filterState == const FilterSettings() && !filterNotifier.isLoading) {
        print(
            "[HomeScreen initState] Filters appear default, triggering load.");
        filterNotifier.loadFilters();
      }
    });
  }

  @override
  void dispose() {
    super.dispose();
  }

  Future<void> _fetchFeed({bool force = false}) async {
    print("[HomeScreen _fetchFeed] Fetching home feed. Force: $force");
    ref.read(errorProvider.notifier).clearError();
    await ref.read(feedProvider.notifier).fetchFeed(forceRefresh: force);
    // State update is handled by the ref.listen below
  }

  // Dialog shown if user tries to interact before completing onboarding step 2
  void _showCompleteProfileDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text("Complete Your Profile",
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          content: Text(
              "To interact with profiles, please complete your profile setup.",
              style: GoogleFonts.poppins()),
          actions: <Widget>[
            TextButton(
              child:
                  Text("Later", style: GoogleFonts.poppins(color: Colors.grey)),
              onPressed: () => Navigator.of(dialogContext).pop(),
            ),
            TextButton(
              child: Text("Complete Profile",
                  style: GoogleFonts.poppins(color: Color(0xFF8B5CF6))),
              onPressed: () {
                Navigator.of(dialogContext).pop();
                // Navigate to the first screen of the remaining onboarding flow
                Navigator.push(context,
                    MaterialPageRoute(builder: (_) => const NameInputScreen()));
              },
            ),
          ],
        );
      },
    );
  }

  // Called by HomeProfileCard after a successful interaction (like OR dislike)
  void _removeTopCard() {
    print("[HomeScreen _removeTopCard] Removing top card from local state.");
    if (!mounted) return;
    if (_feedProfiles.isNotEmpty) {
      final removedUserId = _feedProfiles[0].id!;
      // Update local state FIRST for immediate UI reflection
      setState(() {
        _feedProfiles.removeAt(0);
      });
      // Then notify the provider
      print(
          "[HomeScreen _removeTopCard] Notifying FeedProvider to remove profile ID: $removedUserId");
      ref.read(feedProvider.notifier).removeProfile(removedUserId);
    }
  }

  // API call handler for LIKES (passed to card)
  Future<bool> _callLikeRepository({
    required int targetUserId,
    required ContentLikeType contentType,
    required String contentIdentifier,
    required LikeInteractionType interactionType,
    String? comment,
  }) async {
    // Check if profile is complete before allowing interaction
    final authStatus = ref.read(authProvider).authStatus;
    if (authStatus == AuthStatus.onboarding2) {
      print(
          "[HomeScreen _callLikeRepository] Interaction blocked: Profile incomplete (onboarding2).");
      _showCompleteProfileDialog();
      return false; // Indicate failure
    }

    if (_isInteracting) return false; // Prevent double taps during API call
    if (mounted) setState(() => _isInteracting = true); // Show overlay

    final errorNotifier = ref.read(errorProvider.notifier)..clearError();
    bool success = false;
    try {
      final likeRepo = ref.read(likeRepositoryProvider);
      print(
          "[HomeScreen _callLikeRepository] Calling API: Target $targetUserId, Type: $contentType, ID: $contentIdentifier, Interaction: $interactionType, Comment: ${comment != null}");
      success = await likeRepo.likeContent(
          likedUserId: targetUserId,
          contentType: contentType,
          contentIdentifier: contentIdentifier,
          interactionType: interactionType,
          comment: comment);

      if (!success) {
        // If API returns false, check if an error was already set by repo/service
        if (mounted && ref.read(errorProvider) == null) {
          print(
              "[HomeScreen _callLikeRepository] API returned false, setting generic error.");
          errorNotifier.setError(
              AppError.server("Could not send ${interactionType.value}."));
          _showErrorSnackbar(
              "Could not send ${interactionType.value}."); // Show feedback
        }
      } else {
        print("[HomeScreen _callLikeRepository] API call successful.");
      }
    } on LikeLimitExceededException catch (e) {
      print("[HomeScreen _callLikeRepository] Like Limit Error: ${e.message}");
      if (mounted) errorNotifier.setError(AppError.validation(e.message));
      _showErrorSnackbar(e.message); // Show specific feedback
    } on InsufficientRosesException catch (e) {
      print(
          "[HomeScreen _callLikeRepository] Insufficient Roses: ${e.message}");
      if (mounted) errorNotifier.setError(AppError.validation(e.message));
      _showErrorSnackbar(e.message); // Show specific feedback
    } on ApiException catch (e) {
      print("[HomeScreen _callLikeRepository] API Exception: ${e.message}");
      if (mounted) errorNotifier.setError(AppError.server(e.message));
      _showErrorSnackbar(e.message); // Show API error message
    } catch (e) {
      print(
          "[HomeScreen _callLikeRepository] Unexpected Error: ${e.toString()}");
      if (mounted)
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false); // Hide overlay
    }
    print("[HomeScreen _callLikeRepository] Returning success: $success");
    return success; // Return the outcome
  }

  // --- ADDED: API call handler for DISLIKES (passed to card) ---
  Future<bool> _callDislikeRepository(int targetUserId) async {
    // Check if profile is complete before allowing interaction
    final authStatus = ref.read(authProvider).authStatus;
    if (authStatus == AuthStatus.onboarding2) {
      print(
          "[HomeScreen _callDislikeRepository] Interaction blocked: Profile incomplete (onboarding2).");
      _showCompleteProfileDialog();
      return false;
    }

    if (_isInteracting) return false;
    if (mounted) setState(() => _isInteracting = true);

    final errorNotifier = ref.read(errorProvider.notifier)..clearError();
    bool success = false;
    try {
      final likeRepo = ref.read(likeRepositoryProvider);
      print(
          "[HomeScreen _callDislikeRepository] Calling dislike API for Target $targetUserId");
      success = await likeRepo.dislikeUser(dislikedUserId: targetUserId);

      if (!success) {
        if (mounted && ref.read(errorProvider) == null) {
          print(
              "[HomeScreen _callDislikeRepository] API returned false, setting generic error.");
          errorNotifier.setError(AppError.server("Could not dislike user."));
          _showErrorSnackbar("Could not dislike user.");
        }
      } else {
        print("[HomeScreen _callDislikeRepository] API call successful.");
      }
    } on ApiException catch (e) {
      print("[HomeScreen _callDislikeRepository] API Exception: ${e.message}");
      if (mounted) errorNotifier.setError(AppError.server(e.message));
      _showErrorSnackbar(e.message);
    } catch (e) {
      print(
          "[HomeScreen _callDislikeRepository] Unexpected Error: ${e.toString()}");
      if (mounted)
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
    print("[HomeScreen _callDislikeRepository] Returning success: $success");
    return success;
  }
  // --- END ADDED ---

  void _showErrorSnackbar(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
          content: Text(message, style: GoogleFonts.poppins()),
          backgroundColor: Colors.redAccent), // Use red for errors
    );
  }

  Future<void> _openFilterDialog() async {
    print("[HomeScreen] Opening Filter Dialog.");
    await showDialog<bool>(
      context: context,
      builder: (context) => const FilterSettingsDialog(),
    );
  }

  @override
  Widget build(BuildContext context) {
    final feedState = ref.watch(feedProvider);
    final filters = ref.watch(filterProvider);

    // Update local profile list when provider changes
    ref.listen<HomeFeedState>(feedProvider, (_, next) {
      if (mounted && _feedProfiles != next.profiles) {
        // Only update if different
        setState(() {
          _feedProfiles = next.profiles;
          print(
              "[HomeScreen Listener] Updated local _feedProfiles. Count: ${_feedProfiles.length}");
        });
      }
    });

    final error = feedState.error ?? ref.watch(errorProvider);
    final isLoadingFeed = feedState.isLoading && !feedState.hasFetchedOnce;
    final bool hasProfilesToShow =
        _feedProfiles.isNotEmpty; // Use local state list

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text("Discover",
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 0,
        automaticallyImplyLeading: false,
        actions: [
          IconButton(
            icon: const Icon(Icons.tune_rounded, color: Color(0xFF8B5CF6)),
            tooltip: "Filters",
            onPressed: _openFilterDialog,
          ),
        ],
      ),
      body: Column(
        children: [
          // Filter Chips Row (remains the same)
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 12.0, vertical: 10.0),
            child: GestureDetector(
                onTap: _openFilterDialog,
                child: Container(
                  color: Colors.transparent,
                  height: 34,
                  child: SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    physics: const BouncingScrollPhysics(),
                    child: Row(
                      children: _buildFilterChips(filters),
                    ),
                  ),
                )),
          ),

          // Feed Area (Expanded)
          Expanded(
            child: Stack(
              alignment: Alignment.center, // Center children like indicators
              children: [
                if (isLoadingFeed)
                  const CircularProgressIndicator(color: Color(0xFF8B5CF6))
                // Show loading only if initial fetch AND no profiles loaded yet
                else if (error != null && !hasProfilesToShow)
                  _buildErrorState(error) // Show error only if no profiles
                else if (!hasProfilesToShow)
                  _buildEmptyState() // Show empty state if no profiles and no error
                else // Only build the card if there are profiles
                  // --- Pass Dislike Callback ---
                  _buildProfileCardAtIndex(
                      0), // Build using local _feedProfiles

                // General interaction loading overlay (covers everything)
                if (_isInteracting)
                  Positioned.fill(
                    child: Container(
                      color: Colors.white.withOpacity(0.5),
                      child: const Center(
                          child: CircularProgressIndicator(
                              color: Color(0xFF8B5CF6))),
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  // _buildFilterChips, _buildFilterChip, _buildEmptyState, _buildErrorState remain the same
  List<Widget> _buildFilterChips(FilterSettings filters) {
    List<Widget> chips = [];
    chips.add(_buildFilterChip(
        Icons.wc_rounded,
        filters.whoYouWantToSee?.value.replaceFirst(
                filters.whoYouWantToSee!.value[0],
                filters.whoYouWantToSee!.value[0].toUpperCase()) ??
            FilterSettings.defaultGenderPref.value.replaceFirst(
                FilterSettings.defaultGenderPref.value[0],
                FilterSettings.defaultGenderPref.value[0].toUpperCase())));
    chips.add(_buildFilterChip(Icons.cake_outlined,
        '${filters.ageMin ?? FilterSettings.defaultAgeMin}-${filters.ageMax ?? FilterSettings.defaultAgeMax}'));
    chips.add(_buildFilterChip(Icons.social_distance_outlined,
        '${filters.radiusKm ?? FilterSettings.defaultRadius} km'));
    bool activeTodayValue =
        filters.activeToday ?? FilterSettings.defaultActiveToday;
    chips.add(_buildFilterChip(
      activeTodayValue
          ? Icons.access_time_filled_rounded
          : Icons.access_time_rounded,
      activeTodayValue ? 'Active Today' : 'Active: Any',
    ));
    return chips;
  }

  Widget _buildFilterChip(IconData icon, String label) {
    const Color themeColor = Color(0xFF8B5CF6);
    const Color themeBgColor = Color(0xFFEDE9FE);
    const Color themeTextColor = themeColor;

    return Padding(
      padding: const EdgeInsets.only(right: 8.0),
      child: Chip(
        avatar: Icon(icon, size: 16, color: themeColor),
        label: Text(label),
        labelStyle: GoogleFonts.poppins(
            fontSize: 12, color: themeTextColor, fontWeight: FontWeight.w500),
        backgroundColor: themeBgColor,
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: const VisualDensity(horizontal: 0.0, vertical: -2),
        side: BorderSide.none,
        elevation: 0.5,
        shadowColor: themeColor.withOpacity(0.2),
      ),
    );
  }

  // --- MODIFIED: Build card using local state ---
  Widget _buildProfileCardAtIndex(int index) {
    if (index >= 0 && index < _feedProfiles.length) {
      final currentProfile = _feedProfiles[index];
      return HomeProfileCard(
        // Use unique key based on profile ID to help Flutter optimize
        key: ValueKey(currentProfile.id),
        profile: currentProfile,
        // Pass the callback function to handle the LIKE API call
        performLikeApiCall: (
            {required contentType,
            required contentIdentifier,
            required interactionType,
            comment}) async {
          if (currentProfile.id == null) return false;
          return await _callLikeRepository(
              targetUserId: currentProfile.id!,
              contentType: contentType,
              contentIdentifier: contentIdentifier,
              interactionType: interactionType,
              comment: comment);
        },
        // --- Pass DISLIKE callback ---
        performDislikeApiCall: () async {
          if (currentProfile.id == null) return false;
          return await _callDislikeRepository(currentProfile.id!);
        },
        // Callback to remove the card after success (like OR dislike)
        onInteractionComplete: _removeTopCard,
      );
    }
    // Should ideally not happen if hasProfilesToShow is checked correctly
    return Container(
        alignment: Alignment.center,
        child: Text("No more profiles.", style: GoogleFonts.poppins()));
  }
  // --- END MODIFICATION ---

  Widget _buildEmptyState() {
    // Wrap in LayoutBuilder to ensure scroll physics work for refresh
    return LayoutBuilder(builder: (context, constraints) {
      return SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.people_outline_rounded,
                    size: 80, color: Colors.grey[400]),
                const SizedBox(height: 20),
                Text(
                  "That's everyone for now!",
                  style: GoogleFonts.poppins(
                      fontSize: 18, color: Colors.grey[600]),
                ),
                const SizedBox(height: 10),
                Text(
                  "Adjust your filters or check back later.",
                  textAlign: TextAlign.center,
                  style: GoogleFonts.poppins(
                      fontSize: 14, color: Colors.grey[500]),
                ),
                const SizedBox(height: 20),
                ElevatedButton.icon(
                  icon: const Icon(Icons.refresh_rounded, size: 18),
                  label: const Text("Refresh Feed"),
                  style: ElevatedButton.styleFrom(
                    foregroundColor: Colors.white,
                    backgroundColor: const Color(0xFF8B5CF6),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(20)),
                    padding: const EdgeInsets.symmetric(
                        horizontal: 20, vertical: 10),
                  ),
                  onPressed: () => _fetchFeed(force: true),
                ),
              ],
            ),
          ),
        ),
      );
    });
  }

  Widget _buildErrorState(AppError error) {
    // Wrap in LayoutBuilder to ensure scroll physics work for refresh
    return LayoutBuilder(builder: (context, constraints) {
      return SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline_rounded,
                      size: 60, color: Colors.redAccent[100]),
                  const SizedBox(height: 20),
                  Text(
                    "Oops! Something went wrong",
                    style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.grey[700]),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 10),
                  Text(
                    error.message,
                    style: GoogleFonts.poppins(
                        fontSize: 14, color: Colors.grey[600]),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 20),
                  ElevatedButton.icon(
                    icon: const Icon(Icons.refresh_rounded, size: 18),
                    label: const Text("Retry"),
                    style: ElevatedButton.styleFrom(
                      foregroundColor: Colors.white,
                      backgroundColor: const Color(0xFF8B5CF6),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(20)),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 30, vertical: 12),
                    ),
                    onPressed: () => _fetchFeed(force: true),
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    });
  }
}



================================================
File: views/hometown.dart
================================================
// File: lib/views/hometown.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/job.dart'; // Keep for onboarding flow

class HometownScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const HometownScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<HometownScreen> createState() => _HometownScreenState();
}

class _HometownScreenState extends ConsumerState<HometownScreen> {
  final TextEditingController _hometownController = TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _hometownController.text = ref.read(userProvider).hometown ?? '';
    }
    // Add listener to enable/disable Done button
    _hometownController.addListener(() {
      if (widget.isEditing) setState(() {});
    });
  }

  @override
  void dispose() {
    _hometownController.dispose();
    super.dispose();
  }

  void _handleNext() {
    String? hometown;
    if (_hometownController.text.trim().isNotEmpty) {
      hometown = _hometownController.text.trim();
    } else {
      hometown = null; // Explicitly set to null if empty
    }
    ref.read(userProvider.notifier).updateHometown(hometown);

    if (widget.isEditing) {
      print("[HometownScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[HometownScreen] Onboarding next: Job.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const JobTitleScreen()));
    }
  }

  void _handleSkipOrClear() {
    FocusScope.of(context).unfocus();
    _hometownController.clear(); // Clear text field
    ref
        .read(userProvider.notifier)
        .updateHometown(null); // Update provider to null
    if (widget.isEditing) {
      print("[HometownScreen] Clearing field and popping back.");
      Navigator.of(context).pop(); // Pop back immediately after clearing
    } else {
      // Original onboarding skip navigation
      print("[HometownScreen] Skipping to Job.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const JobTitleScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    // Determine if Done button should be enabled in Edit mode
    final bool canProceedEditing =
        widget.isEditing && _hometownController.text.trim().isNotEmpty;

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      IconButton(
                        // Keep original icon for onboarding
                        icon: const Icon(Icons.home_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {}, // No action needed here
                      ),

                    Text(
                      widget.isEditing ? "Edit Hometown" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    // Show "Done" in edit mode, "Skip" in onboarding
                    if (widget.isEditing)
                      TextButton(
                        onPressed:
                            _handleNext, // Always enabled, saves empty as null
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color:
                                const Color(0xFF8B5CF6), // Always enabled color
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      TextButton(
                        onPressed: _handleSkipOrClear, // Use unified handler
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                              fontSize: 16, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),

              // Question Text
              Text(
                widget.isEditing
                    ? "Edit your hometown"
                    : "Where's your home\ntown?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),

              SizedBox(height: screenSize.height * 0.05),

              // Text Field
              Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                child: TextField(
                  controller: _hometownController,
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    color: Colors.black87,
                  ),
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    hintText: "e.g., New Delhi",
                    hintStyle: GoogleFonts.poppins(
                      fontSize: 22,
                      color: Colors.grey.shade500,
                    ),
                    border: const UnderlineInputBorder(
                      borderSide: BorderSide(color: Colors.grey, width: 1.0),
                    ),
                    focusedBorder: const UnderlineInputBorder(
                      borderSide:
                          BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                    ),
                    // Add clear button in edit mode if text exists
                    suffixIcon: widget.isEditing &&
                            _hometownController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, color: Colors.grey),
                            onPressed: () {
                              _hometownController.clear();
                              // Optionally update provider immediately on clear
                              // ref.read(userProvider.notifier).updateHometown(null);
                            },
                          )
                        : null,
                  ),
                ),
              ),

              const Spacer(),

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: GestureDetector(
                      onTap: _handleNext, // Always enabled for onboarding
                      child: Container(
                        width: 70,
                        height: 70,
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(35),
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/job.dart
================================================
// File: lib/views/job.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/study.dart'; // Keep for onboarding flow

class JobTitleScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const JobTitleScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<JobTitleScreen> createState() => _JobTitleScreenState();
}

class _JobTitleScreenState extends ConsumerState<JobTitleScreen> {
  final TextEditingController _jobTitleController = TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _jobTitleController.text = ref.read(userProvider).jobTitle ?? '';
    }
    // Add listener to enable/disable Done button in edit mode if needed
    _jobTitleController.addListener(() {
      if (widget.isEditing) setState(() {});
    });
  }

  @override
  void dispose() {
    _jobTitleController.dispose();
    super.dispose();
  }

  void _handleNext() {
    String? jobTitle;
    if (_jobTitleController.text.trim().isNotEmpty) {
      jobTitle = _jobTitleController.text.trim();
    } else {
      jobTitle = null; // Explicitly set to null if empty
    }
    ref.read(userProvider.notifier).updateJobTitle(jobTitle);

    if (widget.isEditing) {
      print("[JobTitleScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[JobTitleScreen] Onboarding next: Study.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const StudyLocationScreen()));
    }
  }

  void _handleSkipOrClear() {
    FocusScope.of(context).unfocus();
    _jobTitleController.clear(); // Clear text field
    ref
        .read(userProvider.notifier)
        .updateJobTitle(null); // Update provider to null
    if (widget.isEditing) {
      print("[JobTitleScreen] Clearing field and popping back.");
      Navigator.of(context).pop(); // Pop back immediately after clearing
    } else {
      // Original onboarding skip navigation
      print("[JobTitleScreen] Skipping to Study.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const StudyLocationScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    // Determine if Done button should be enabled in Edit mode (optional, could always allow saving null)
    // final bool canProceedEditing = widget.isEditing && _jobTitleController.text.trim().isNotEmpty;

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      IconButton(
                        // Keep original icon for onboarding
                        icon: const Icon(Icons.work_outline_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {}, // No action needed here
                      ),

                    Text(
                      widget.isEditing ? "Edit Job Title" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    // Show "Done" in edit mode, "Skip" in onboarding
                    if (widget.isEditing)
                      TextButton(
                        onPressed: _handleNext, // Always enabled
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color:
                                const Color(0xFF8B5CF6), // Always enabled color
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      TextButton(
                        onPressed: _handleSkipOrClear, // Use unified handler
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                              fontSize: 16, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),

              // Question Text
              Text(
                widget.isEditing
                    ? "Edit your job title"
                    : "What's your job\ntitle?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),

              SizedBox(height: screenSize.height * 0.05),

              // Text Field
              Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                child: TextField(
                  controller: _jobTitleController,
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    color: Colors.black87,
                  ),
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    hintText: "e.g., Software Engineer",
                    hintStyle: GoogleFonts.poppins(
                      fontSize: 22,
                      color: Colors.grey.shade500,
                    ),
                    border: const UnderlineInputBorder(
                      borderSide: BorderSide(color: Colors.grey, width: 1.0),
                    ),
                    focusedBorder: const UnderlineInputBorder(
                      borderSide:
                          BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                    ),
                    // Add clear button in edit mode if text exists
                    suffixIcon: widget.isEditing &&
                            _jobTitleController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, color: Colors.grey),
                            onPressed: () {
                              _jobTitleController.clear();
                            },
                          )
                        : null,
                  ),
                ),
              ),

              const Spacer(),

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: GestureDetector(
                      onTap: _handleNext, // Always enabled for onboarding
                      child: Container(
                        width: 70,
                        height: 70,
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(35),
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/liker_profile_screen.dart
================================================
// File: lib/views/liker_profile_screen.dart
import 'dart:math'; // Import math for max function
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/liker_profile_provider.dart';
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/providers/audio_player_provider.dart'; // Import for audio player state
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/utils/app_enums.dart';

class LikerProfileScreen extends ConsumerStatefulWidget {
  final int likerUserId;

  const LikerProfileScreen({super.key, required this.likerUserId});

  @override
  ConsumerState<LikerProfileScreen> createState() => _LikerProfileScreenState();
}

class _LikerProfileScreenState extends ConsumerState<LikerProfileScreen> {
  bool _isInteracting = false; // Local state for loading indicator

  // --- Dislike Handler (Keep as is) ---
  Future<void> _handleDislike() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text("Dislike Profile?", style: GoogleFonts.poppins()),
        content: Text(
            "Are you sure you want to dislike this profile? They won't appear again.",
            style: GoogleFonts.poppins()),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text("Cancel",
                  style: GoogleFonts.poppins(color: Colors.grey))),
          TextButton(
              onPressed: () => Navigator.pop(context, true),
              child: Text("Dislike",
                  style: GoogleFonts.poppins(color: Colors.red))),
        ],
      ),
    );

    if (confirm != true) return;

    if (!mounted) return;
    setState(() => _isInteracting = true);
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();

    try {
      final success = await ref
          .read(likeRepositoryProvider)
          .dislikeUser(dislikedUserId: widget.likerUserId);

      if (success && mounted) {
        ref.invalidate(receivedLikesProvider);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("Profile disliked.", style: GoogleFonts.poppins()),
              backgroundColor: Colors.grey[700]),
        );
        Navigator.of(context).pop();
      } else if (!success && mounted) {
        if (ref.read(errorProvider) == null) {
          errorNotifier.setError(AppError.server("Failed to dislike profile."));
          _showErrorSnackbar("Failed to dislike profile.");
        }
      }
    } on ApiException catch (e) {
      if (mounted) errorNotifier.setError(AppError.server(e.message));
      _showErrorSnackbar(e.message);
    } catch (e) {
      if (mounted)
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
  }

  // --- Like Back Handler (Keep as is) ---
  Future<void> _handleLikeBack() async {
    if (_isInteracting) return;
    if (!mounted) return;
    setState(() => _isInteracting = true);
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();

    try {
      final success = await ref
          .read(likeRepositoryProvider)
          .likeBackUserProfile(likedUserId: widget.likerUserId);

      if (success && mounted) {
        ref.invalidate(receivedLikesProvider);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("It's a Match! 🎉", style: GoogleFonts.poppins()),
              backgroundColor: Colors.green),
        );
        Navigator.of(context).pop();
        // TODO: Optionally navigate to chat screen here?
      } else if (!success && mounted) {
        if (ref.read(errorProvider) == null) {
          errorNotifier.setError(AppError.server("Failed to like back."));
          _showErrorSnackbar("Failed to like back.");
        }
      }
    } on ApiException catch (e) {
      if (mounted) errorNotifier.setError(AppError.server(e.message));
      if (e.statusCode == 409) {
        _showErrorSnackbar("You have already matched or liked this user.");
      } else {
        _showErrorSnackbar(e.message);
      }
    } catch (e) {
      if (mounted)
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false);
    }
  }

  // --- Error Snackbar Helper (Keep as is) ---
  void _showErrorSnackbar(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).removeCurrentSnackBar();
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message, style: GoogleFonts.poppins()),
        backgroundColor: Colors.redAccent,
        duration: const Duration(seconds: 3),
      ),
    );
  }

  // --- Helper for FAB-style buttons (Keep as is) ---
  Widget _buildLikerActionButton({
    required IconData icon,
    required Color color,
    required Color backgroundColor,
    required VoidCallback? onPressed,
    required String tooltip,
    double size = 60.0,
    double iconSize = 30.0,
  }) {
    return Tooltip(
      message: tooltip,
      child: FloatingActionButton(
        heroTag: tooltip,
        onPressed: onPressed,
        backgroundColor:
            onPressed != null ? backgroundColor : Colors.grey.shade400,
        elevation: onPressed != null ? 4.0 : 0.0,
        child: Icon(
          icon,
          color: onPressed != null ? color : Colors.white70,
          size: iconSize,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(likerProfileProvider(widget.likerUserId));
    final profile = state.profile;
    final likeDetails = state.likeDetails;

    return Scaffold(
      backgroundColor: Colors.white,
      // --- Floating Action Buttons Row (Keep as is) ---
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
      floatingActionButton: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            // Dislike Button (Left)
            _buildLikerActionButton(
              icon: Icons.close_rounded,
              color: Colors.red,
              backgroundColor: Colors.white,
              onPressed: _isInteracting ? null : _handleDislike,
              tooltip: "Dislike",
            ),
            // Like Back Button (Right)
            _buildLikerActionButton(
              icon: Icons.favorite_rounded,
              color: Colors.white,
              backgroundColor: const Color(0xFF8B5CF6),
              onPressed: _isInteracting ? null : _handleLikeBack,
              tooltip: "Like Back",
            ),
          ],
        ),
      ),
      body: _buildBody(context, state, profile, likeDetails, ref),
    );
  }

  Widget _buildBody(
      BuildContext context,
      LikerProfileState state,
      UserProfileData? profile,
      LikeInteractionDetails? likeDetails,
      WidgetRef ref) {
    if (state.isLoading) {
      return const Center(
          child: CircularProgressIndicator(color: Color(0xFF8B5CF6)));
    }

    if (state.error != null) {
      return _buildErrorState(context, state.error!, ref);
    }

    if (profile == null || likeDetails == null) {
      return _buildErrorState(
          context, AppError.generic("Profile data could not be loaded."), ref);
    }

    // --- START: Content Block Generation (Adapted from HomeProfileCard) ---
    final List<dynamic> contentBlocks = [];
    final mediaUrls = profile.mediaUrls ?? [];
    final prompts = profile.prompts;

    contentBlocks.add("header_section");
    contentBlocks.add("like_details_banner");
    if (mediaUrls.isNotEmpty) contentBlocks.add(mediaUrls[0]);
    if (prompts.isNotEmpty) contentBlocks.add(prompts[0]);
    contentBlocks.add("vitals_section");

    int mediaIndex = 1;
    int promptIndex = 1;
    int maxRemaining = max(mediaUrls.length, prompts.length);

    for (int i = 1; i < maxRemaining; i++) {
      if (mediaIndex < mediaUrls.length) {
        contentBlocks.add(mediaUrls[mediaIndex]);
        mediaIndex++;
      }
      if (promptIndex < prompts.length) {
        contentBlocks.add(prompts[promptIndex]);
        promptIndex++;
      }
    }
    if (profile.audioPrompt != null) {
      contentBlocks.add(profile.audioPrompt!);
    }
    // --- END: Content Block Generation ---

    return CustomScrollView(
      slivers: [
        SliverAppBar(
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          elevation: 1,
          pinned: true,
          leading: IconButton(
            icon: Icon(Icons.arrow_back_ios_new,
                color: Colors.grey[700], size: 20),
            onPressed: () => Navigator.of(context).pop(),
          ),
          // --- REMOVED title property ---
          // title: Text(
          //   profile.name ?? 'Profile',
          //   style:
          //       GoogleFonts.poppins(fontWeight: FontWeight.w600, fontSize: 18),
          // ),
          // --- END REMOVED ---
        ),

        SliverPadding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          sliver: SliverList(
            delegate: SliverChildBuilderDelegate(
              (context, index) {
                final item = contentBlocks[index];
                final double topPadding = (index == 0) ? 8.0 : 0;
                final double bottomPadding = 20.0;
                final double horizontalPadding = 12.0;
                Widget contentWidget;

                if (item is String && item == "header_section") {
                  contentWidget = _buildHeaderBlock(profile);
                } else if (item is String && item == "like_details_banner") {
                  if (likeDetails != null) {
                    contentWidget =
                        _buildLikeDetailsBanner(likeDetails, profile);
                  } else {
                    contentWidget = const SizedBox.shrink();
                  }
                } else if (item is String && item.startsWith('http')) {
                  int originalMediaIndex =
                      (profile.mediaUrls ?? []).indexOf(item);
                  if (originalMediaIndex == -1) originalMediaIndex = 0;
                  contentWidget =
                      _buildMediaItem(context, ref, item, originalMediaIndex);
                } else if (item is Prompt) {
                  contentWidget = _buildPromptItem(context, ref, item);
                } else if (item is AudioPromptModel) {
                  contentWidget = _buildAudioItem(context, ref, item);
                } else if (item is String && item == "vitals_section") {
                  contentWidget = _buildVitalsBlock(profile);
                } else {
                  contentWidget = const SizedBox.shrink();
                }

                return Padding(
                  padding: EdgeInsets.fromLTRB(horizontalPadding, topPadding,
                      horizontalPadding, bottomPadding),
                  child: contentWidget,
                );
              },
              childCount: contentBlocks.length,
            ),
          ),
        ),
        SliverToBoxAdapter(
            child: SizedBox(height: 100)), // Ensure space for FABs
      ],
    );
  }

  // --- Error State Widget (unchanged) ---
  Widget _buildErrorState(BuildContext context, AppError error, WidgetRef ref) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(30.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                size: 60, color: Colors.redAccent[100]),
            const SizedBox(height: 20),
            Text(
              "Oops!",
              style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[700]),
            ),
            const SizedBox(height: 10),
            Text(
              error.message,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded, size: 18),
              label: const Text("Retry"),
              style: ElevatedButton.styleFrom(
                foregroundColor: Colors.white,
                backgroundColor: const Color(0xFF8B5CF6),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20)),
                padding:
                    const EdgeInsets.symmetric(horizontal: 30, vertical: 12),
              ),
              onPressed: () => ref
                  .read(likerProfileProvider(widget.likerUserId).notifier)
                  .fetchProfile(),
            ),
            const SizedBox(height: 10),
            TextButton(
              child: const Text("Go Back"),
              style: TextButton.styleFrom(foregroundColor: Colors.grey[600]),
              onPressed: () => Navigator.of(context).pop(),
            )
          ],
        ),
      ),
    );
  }

  // --- START: Copied & Adapted Helper Widgets from HomeProfileCard ---

  Widget _buildHeaderBlock(UserModel profile) {
    final age = profile.age;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '${profile.name ?? 'Name'}${profile.lastName != null && profile.lastName!.isNotEmpty ? ' ${profile.lastName}' : ''}${age != null ? ' • $age' : ''}',
          style: GoogleFonts.poppins(
              fontSize: 26, fontWeight: FontWeight.bold, color: Colors.black87),
        ),
        if (profile.hometown != null && profile.hometown!.isNotEmpty) ...[
          const SizedBox(height: 4),
          Row(
            children: [
              Icon(Icons.location_on_outlined,
                  size: 16, color: Colors.grey[600]),
              const SizedBox(width: 4),
              Text(
                profile.hometown!,
                style:
                    GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
              ),
            ],
          ),
        ]
      ],
    );
  }

  Widget _buildVitalsBlock(UserModel profile) {
    final List<Widget> vitals = [];
    if (profile.height != null && profile.height!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.height, profile.height!));
    }
    if (profile.religiousBeliefs != null) {
      vitals.add(_buildVitalRow(
          Icons.church_outlined, profile.religiousBeliefs!.label));
    }
    if (profile.jobTitle != null && profile.jobTitle!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.work_outline, profile.jobTitle!));
    }
    if (profile.education != null && profile.education!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.school_outlined, profile.education!));
    }
    if (profile.drinkingHabit != null) {
      vitals.add(_buildVitalRow(
          Icons.local_bar_outlined, "Drinks: ${profile.drinkingHabit!.label}"));
    }
    if (profile.smokingHabit != null) {
      vitals.add(_buildVitalRow(Icons.smoking_rooms_outlined,
          "Smokes: ${profile.smokingHabit!.label}"));
    }

    if (vitals.isEmpty) return const SizedBox.shrink();

    return Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        width: double.infinity,
        decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(10),
            border: Border.all(color: Colors.grey[200]!),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 3),
              )
            ]),
        child: Column(
          children: List.generate(vitals.length * 2 - 1, (index) {
            if (index.isEven) {
              return vitals[index ~/ 2];
            } else {
              return Divider(height: 16, thickness: 1, color: Colors.grey[200]);
            }
          }),
        ));
  }

  Widget _buildVitalRow(IconData icon, String label) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6.0),
      child: Row(
        children: [
          Icon(icon, size: 20, color: Colors.grey[600]),
          const SizedBox(width: 12),
          Expanded(
              child: Text(label,
                  style: GoogleFonts.poppins(
                      fontSize: 15, color: Colors.grey[800]))),
        ],
      ),
    );
  }

  Widget _buildMediaItem(
      BuildContext context, WidgetRef ref, String url, int index) {
    bool isVideo = url.toLowerCase().contains('.mp4') ||
        url.toLowerCase().contains('.mov');

    return ClipRRect(
      borderRadius: BorderRadius.circular(10),
      child: AspectRatio(
        aspectRatio: 4 / 5.5,
        child: Container(
          decoration: BoxDecoration(color: Colors.grey[200]),
          child: Stack(
            fit: StackFit.expand,
            children: [
              Image.network(url,
                  fit: BoxFit.cover,
                  loadingBuilder: (ctx, child, prog) => prog == null
                      ? child
                      : Center(
                          child: CircularProgressIndicator(
                              value: prog.expectedTotalBytes != null
                                  ? prog.cumulativeBytesLoaded /
                                      prog.expectedTotalBytes!
                                  : null,
                              color: Colors.grey[400])),
                  errorBuilder: (ctx, err, st) => Center(
                      child: Icon(Icons.image_not_supported_outlined,
                          color: Colors.grey[400], size: 40))),
              if (isVideo)
                Center(
                  child: Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.5),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.play_arrow_rounded,
                        color: Colors.white, size: 30),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPromptItem(BuildContext context, WidgetRef ref, Prompt prompt) {
    if (prompt.answer.trim().isEmpty) return const SizedBox.shrink();

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(10),
          border: Border.all(color: Colors.grey[200]!),
          boxShadow: [
            BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ]),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(prompt.question.label,
              style: GoogleFonts.poppins(
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[600])),
          const SizedBox(height: 10),
          Text(prompt.answer,
              style: GoogleFonts.poppins(
                  fontSize: 20,
                  color: Colors.black87,
                  height: 1.4,
                  fontWeight: FontWeight.w500)),
        ],
      ),
    );
  }

  Widget _buildAudioItem(
      BuildContext context, WidgetRef ref, AudioPromptModel audio) {
    final audioPlayerState = ref.watch(audioPlayerStateProvider);
    final currentPlayingUrl = ref.watch(currentAudioUrlProvider);
    final playerNotifier = ref.read(audioPlayerControllerProvider.notifier);

    final bool isThisPlaying = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.playing;
    final bool isThisLoading = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.loading;
    final bool isThisPaused = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.paused;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey[200]!),
          boxShadow: [
            BoxShadow(
                color: Colors.grey.withOpacity(0.06),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ]),
      child: Row(
        children: [
          InkWell(
            onTap: () {
              if (isThisLoading) return;
              if (isThisPlaying) {
                playerNotifier.pause();
              } else if (isThisPaused) {
                playerNotifier.resume();
              } else {
                playerNotifier.play(audio.audioUrl);
              }
            },
            borderRadius: BorderRadius.circular(24),
            child: Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: const Color(0xFF8B5CF6),
                borderRadius: BorderRadius.circular(24),
                boxShadow: [
                  BoxShadow(
                      color: const Color(0xFF8B5CF6).withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2))
                ],
              ),
              child: isThisLoading
                  ? const Padding(
                      padding: EdgeInsets.all(12.0),
                      child: CircularProgressIndicator(
                          strokeWidth: 2, color: Colors.white))
                  : Icon(
                      isThisPlaying
                          ? Icons.pause_rounded
                          : Icons.play_arrow_rounded,
                      color: Colors.white,
                      size: 28,
                    ),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(audio.prompt.label,
                    style: GoogleFonts.poppins(
                        fontSize: 15,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF1A1A1A))),
                const SizedBox(height: 4),
                Text(
                    isThisLoading
                        ? "Loading..."
                        : isThisPlaying
                            ? "Playing..."
                            : isThisPaused
                                ? "Paused"
                                : "Tap to listen",
                    style: GoogleFonts.poppins(
                        fontSize: 13, color: Colors.grey[600])),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDetailChip(IconData icon, String label, {bool subtle = false}) {
    if (label.isEmpty) return const SizedBox.shrink();
    return Container(
      padding: EdgeInsets.symmetric(
          horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
      decoration: BoxDecoration(
        color: subtle ? Colors.transparent : Colors.grey[100],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
            color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: subtle ? 16 : 18,
            color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6),
          ),
          const SizedBox(width: 6),
          Flexible(
            child: Text(
              label,
              style: GoogleFonts.poppins(
                fontSize: subtle ? 13 : 14,
                fontWeight: FontWeight.w500,
                color: subtle ? Colors.grey.shade700 : Colors.grey[800],
              ),
              overflow: TextOverflow.ellipsis,
              maxLines: 2,
            ),
          ),
        ],
      ),
    );
  }

  // --- END: Copied & Adapted Helper Widgets ---

  // --- Like Details Banner (Corrected Signature and Call) ---
  Widget _buildLikeDetailsBanner(
      LikeInteractionDetails likeDetails, UserProfileData? profile) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
          color:
              likeDetails.isRose ? Colors.purple.shade50 : Colors.blue.shade50,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
              color: likeDetails.isRose
                  ? Colors.purple.shade100
                  : Colors.blue.shade100)),
      child: Row(
        children: [
          Icon(
            likeDetails.isRose ? Icons.star_rounded : Icons.favorite_rounded,
            color: likeDetails.isRose
                ? Colors.purple.shade400
                : Colors.pink.shade300,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              likeDetails.likeComment != null &&
                      likeDetails.likeComment!.isNotEmpty
                  ? '"${likeDetails.likeComment}"'
                  : (likeDetails.isRose
                      ? '${profile?.name ?? "They"} sent you a Rose!'
                      : '${profile?.name ?? "They"} liked your profile!'),
              style: GoogleFonts.poppins(
                fontSize: 14,
                fontWeight: FontWeight.w500,
                fontStyle: (likeDetails.likeComment != null &&
                        likeDetails.likeComment!.isNotEmpty)
                    ? FontStyle.italic
                    : FontStyle.normal,
                color: likeDetails.isRose
                    ? Colors.purple.shade700
                    : Colors.blue.shade700,
              ),
            ),
          ),
        ],
      ),
    );
  }
  // --- END Like Details Banner ---
} // End of State class



================================================
File: views/location.dart
================================================
// File: views/location.dart
import 'package:dtx/models/error_model.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:app_settings/app_settings.dart'; // Keep for opening settings
import '../providers/location_provider.dart';
import '../providers/error_provider.dart';
import '../providers/user_provider.dart'; // Ensure user provider is imported
import 'gender.dart'; // Ensure GenderSelectionScreen is imported

class LocationInputScreen extends ConsumerStatefulWidget {
  const LocationInputScreen({super.key});

  @override
  ConsumerState<LocationInputScreen> createState() =>
      _LocationInputScreenState();
}

class _LocationInputScreenState extends ConsumerState<LocationInputScreen> {
  late final MapController _mapController;

  @override
  void initState() {
    super.initState();
    _mapController = MapController();
    // Fetch location after the first frame is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Only fetch if location isn't already valid in the user state
      // This prevents unnecessary fetches if the user navigates back and forth
      if (!ref.read(userProvider.notifier).isLocationValid()) {
        print("[LocationInputScreen] Initial location fetch triggered.");
        ref.read(locationProvider.notifier).fetchCurrentLocation();
      } else {
        print(
            "[LocationInputScreen] Skipping initial fetch, location already set.");
        // Ensure the map moves to the existing location if needed
        _moveToCurrentLocation();
      }
    });
  }

  void _onMapReady() {
    print("[LocationInputScreen] Map Ready.");
    // It might be safer to set map ready state in the provider
    // ref.read(locationProvider.notifier).setMapReady(true);
    _moveToCurrentLocation();
  }

  void _moveToCurrentLocation() {
    final locationState = ref.read(locationProvider);
    final userLocation =
        ref.read(userProvider); // Get location from user provider

    // Use user provider's location if valid, otherwise use location provider's state
    final LatLng targetLocation = LatLng(
      userLocation.latitude ?? locationState.latitude,
      userLocation.longitude ?? locationState.longitude,
    );

    print("[LocationInputScreen] Moving map to: $targetLocation");
    // Check if mapController is initialized and ready
    // Note: FlutterMap doesn't have a direct 'isReady' flag accessible here easily.
    // We rely on onMapReady having been called implicitly before this might be needed.
    // A small delay could be a workaround if needed, but usually direct call is fine.
    try {
      _mapController.move(targetLocation, _mapController.camera.zoom);
    } catch (e) {
      print(
          "[LocationInputScreen] Error moving map (potentially before ready): $e");
      // Optionally, schedule the move again slightly later
      // Future.delayed(Duration(milliseconds: 100), () => _moveToCurrentLocation());
    }
  }

  // Dialog for location services disabled
  Future<void> _showLocationServiceDialog() async {
    // Prevent showing multiple dialogs
    if (ModalRoute.of(context)?.isCurrent ?? false) {
      print("[LocationInputScreen] Showing Location Service Dialog.");
      return showDialog<void>(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext dialogContext) {
          // Use different context name
          return AlertDialog(
            title: Text('Location Services Required',
                style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
            content: SingleChildScrollView(
              child: ListBody(
                children: <Widget>[
                  Text(
                      'To show you relevant places around you, we need access to your location.',
                      style: GoogleFonts.poppins()),
                  const SizedBox(height: 15),
                  Text(
                      'Please enable location services in your device settings.',
                      style: GoogleFonts.poppins()),
                ],
              ),
            ),
            actions: <Widget>[
              TextButton(
                child: Text('Open Settings',
                    style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6))),
                onPressed: () {
                  Navigator.pop(dialogContext); // Use dialogContext
                  ref.read(locationProvider.notifier).openLocationSettings();
                },
              ),
              TextButton(
                child: Text('Retry',
                    style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6))),
                onPressed: () {
                  Navigator.pop(dialogContext); // Use dialogContext
                  ref.read(errorProvider.notifier).clearError();
                  ref.read(locationProvider.notifier).fetchCurrentLocation();
                },
              ),
            ],
          );
        },
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // Listen to location provider for map center and loading state
    final locationState = ref.watch(locationProvider);
    // Listen to user provider for the marker position (the confirmed location)
    final userState = ref.watch(userProvider);
    final error = ref.watch(errorProvider);

    // Use user's location for the marker if available, otherwise default
    final markerLatLng = LatLng(userState.latitude ?? locationState.latitude,
        userState.longitude ?? locationState.longitude);

    // Show location service dialog if needed after the build phase
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (error?.type == ErrorType.locationService) {
        _showLocationServiceDialog();
      }
    });

    return Scaffold(
      backgroundColor: Colors.white, // Use a clean white background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.04),
              // Progress Indicator (Optional) - Can use a step indicator if preferred
              // Center(child: Text("Step 1 of X", style: GoogleFonts.poppins(color: Colors.grey))),

              SizedBox(height: screenSize.height * 0.03),
              Row(
                children: [
                  Icon(
                    Icons.location_on_outlined,
                    color: const Color(0xFF8B5CF6), // Themed icon color
                    size: 32,
                  ),
                  const SizedBox(width: 10),
                  Text(
                    "Where do you live?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.07,
                      fontWeight: FontWeight.bold,
                      color: const Color(0xFF1A1A1A), // Darker text color
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 10),
              Text(
                "Drag the map to set your approximate location. Only your general area will be shown.",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey.shade600,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              Expanded(
                child: locationState.isLoading && !userState.isLocationValid()
                    ? const Center(
                        child: CircularProgressIndicator(
                        color: Color(0xFF8B5CF6),
                      ))
                    : ClipRRect(
                        // Use ClipRRect for rounded corners
                        borderRadius: BorderRadius.circular(15.0),
                        child: FlutterMap(
                          mapController: _mapController,
                          options: MapOptions(
                            initialCenter:
                                markerLatLng, // Start centered on user/default
                            initialZoom: 14.0,
                            onMapReady: _onMapReady,
                            // Update location provider AND user provider on tap/drag end
                            onTap: (tapPosition, latlng) {
                              print(
                                  "[LocationInputScreen] Map Tapped: $latlng");
                              ref
                                  .read(locationProvider.notifier)
                                  .updateLocation(
                                      latlng.latitude, latlng.longitude);
                            },
                            // Optional: Update on position changed (can be laggy)
                            // onPositionChanged: (position, hasGesture) {
                            //   if (hasGesture) {
                            //     final center = position.center;
                            //     if (center != null) {
                            //       ref.read(locationProvider.notifier)
                            //          .updateLocation(center.latitude, center.longitude);
                            //     }
                            //   }
                            // },
                          ),
                          children: [
                            TileLayer(
                              urlTemplate:
                                  'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                              // Use standard OSM tiles
                              userAgentPackageName:
                                  'com.peeple.dating', // Replace with your app's package name
                            ),
                            MarkerLayer(
                              markers: [
                                Marker(
                                  point:
                                      markerLatLng, // Marker follows user's selected location
                                  width: 50, // Slightly larger marker
                                  height: 50,
                                  child: const Icon(
                                    Icons.location_pin, // Use a pin icon
                                    color: Color(0xFF8B5CF6),
                                    size: 50,
                                  ),
                                ),
                              ],
                            ),
                            // Add a button to re-center on fetched location
                            if (locationState.cachedLatitude != null &&
                                locationState.cachedLongitude != null)
                              Positioned(
                                bottom:
                                    80, // Position above the main next button
                                right: 16,
                                child: FloatingActionButton.small(
                                  // Smaller FAB
                                  heroTag: 'recenter_fab', // Unique heroTag
                                  onPressed: () {
                                    print(
                                        "[LocationInputScreen] Recenter button pressed.");
                                    ref
                                        .read(locationProvider.notifier)
                                        .useCachedLocation();
                                    // Move map after state updates
                                    WidgetsBinding.instance
                                        .addPostFrameCallback(
                                            (_) => _moveToCurrentLocation());
                                  },
                                  backgroundColor: const Color(0xFF8B5CF6),
                                  child: Icon(
                                      locationState.isFetching
                                          ? Icons
                                              .location_searching // Indicate fetching
                                          : Icons.my_location,
                                      color: Colors.white),
                                ),
                              ),
                          ],
                        ),
                      ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              // Show error messages from ErrorProvider
              if (error != null &&
                  error.type !=
                      ErrorType
                          .locationService) // Don't show non-service errors here if dialog handles it
                Padding(
                  padding: const EdgeInsets.only(bottom: 8.0),
                  child: Text(
                    error.message,
                    style: GoogleFonts.poppins(color: Colors.redAccent),
                    textAlign: TextAlign.center,
                  ),
                ),
              // Next Button
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding: const EdgeInsets.only(
                      bottom: 16.0), // Add some bottom padding
                  child: FloatingActionButton(
                    heroTag: 'next_fab', // Unique heroTag
                    onPressed: userState
                            .isLocationValid() // Enable only if location is set
                        ? () {
                            print(
                                "[LocationInputScreen] Next button pressed. Navigating to Gender.");
                            Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const GenderSelectionScreen()));
                          }
                        : null, // Disable button if location is not valid
                    backgroundColor: userState.isLocationValid()
                        ? const Color(0xFF8B5CF6)
                        : Colors.grey.shade400,
                    foregroundColor: Colors.white,
                    child: const Icon(Icons.arrow_forward_rounded),
                  ),
                ),
              ),
              SizedBox(
                  height: screenSize.height * 0.02), // Adjust bottom spacing
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    // Avoid potential errors if _mapController wasn't initialized
    // _mapController?.dispose(); // No need to dispose MapController typically
    super.dispose();
  }
}



================================================
File: views/main_navigation_screen.dart
================================================
// File: lib/views/main_navigation_screen.dart
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/chat_screen.dart';
import 'package:dtx/views/home.dart';
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/who_liked_you_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class MainNavigationScreen extends ConsumerStatefulWidget {
  const MainNavigationScreen({super.key});

  @override
  ConsumerState<MainNavigationScreen> createState() =>
      _MainNavigationScreenState();
}

class _MainNavigationScreenState extends ConsumerState<MainNavigationScreen> {
  int _selectedIndex = 0;

  static const List<Widget> _widgetOptions = <Widget>[
    HomeScreen(),
    WhoLikedYouScreen(),
    ChatPlaceholderScreen(),
    ProfileScreen(),
  ];

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      print(
          "[MainNavigationScreen] Post-frame callback: Initiating Likes and Profile fetches if needed.");

      // --- Simplified Fetch Logic ---
      // Fetch Likes only if data is empty (initial load)
      final likesState = ref.read(receivedLikesProvider);
      if (likesState.fullProfiles.isEmpty && likesState.otherLikers.isEmpty) {
        print(
            "[MainNavigationScreen] Likes data is empty, calling fetchLikes.");
        // We don't check isLoading here, let the notifier handle it if needed.
        // Adding a direct read+call might be slightly risky if the user switches tabs
        // VERY fast, but generally okay for initial load. A safer pattern might
        // involve listening or using FutureProvider if concurrent calls are a major concern.
        ref.read(receivedLikesProvider.notifier).fetchLikes();
      } else {
        print(
            "[MainNavigationScreen] Likes data already present, skipping fetchLikes call.");
      }

      // Fetch Profile only if data is missing (initial load)
      final userState = ref.read(userProvider);
      if (userState.name == null) {
        print(
            "[MainNavigationScreen] User profile data is empty, calling fetchProfile.");
        // Same note as above regarding potential concurrency.
        ref.read(userProvider.notifier).fetchProfile();
      } else {
        print(
            "[MainNavigationScreen] User profile data already present, skipping fetchProfile call.");
      }
      // --- End Simplified Fetch Logic ---
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: IndexedStack(
          index: _selectedIndex,
          children: _widgetOptions,
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(
            icon: Icon(Icons.home_outlined),
            activeIcon: Icon(Icons.home_filled),
            label: 'Discover',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.favorite_border_rounded),
            activeIcon: Icon(Icons.favorite_rounded),
            label: 'Likes',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.chat_bubble_outline_rounded),
            activeIcon: Icon(Icons.chat_bubble_rounded),
            label: 'Chat',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person_outline_rounded),
            activeIcon: Icon(Icons.person_rounded),
            label: 'Profile',
          ),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: const Color(0xFF8B5CF6),
        unselectedItemColor: Colors.grey[600],
        onTap: _onItemTapped,
        type: BottomNavigationBarType.fixed,
        showUnselectedLabels: true,
        backgroundColor: Colors.white,
        elevation: 5.0,
        selectedLabelStyle:
            GoogleFonts.poppins(fontSize: 12, fontWeight: FontWeight.w500),
        unselectedLabelStyle: GoogleFonts.poppins(fontSize: 12),
      ),
    );
  }
}



================================================
File: views/media.dart
================================================
// File: lib/views/media.dart
import 'dart:io';
import 'dart:typed_data'; // Keep if thumbnail generation is used (not shown, but possible)
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/prompt.dart'; // Keep for onboarding flow
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:reorderable_grid_view/reorderable_grid_view.dart';
import 'package:dotted_border/dotted_border.dart';
import 'package:path/path.dart' as p; // Use prefix for path
import 'package:mime/mime.dart'; // Use mime package

import '../models/error_model.dart';
import '../models/media_upload_model.dart'; // Import MediaUploadModel

class MediaPickerScreen extends ConsumerStatefulWidget {
  final bool isEditing;

  const MediaPickerScreen({
    super.key,
    this.isEditing = false,
  });

  @override
  ConsumerState<MediaPickerScreen> createState() => _MediaPickerState();
}

class _MediaPickerState extends ConsumerState<MediaPickerScreen> {
  // Holds String URLs for existing media, MediaUploadModel for new/local files, or null for empty slots.
  List<dynamic> _displayItems = List.filled(6, null);
  bool _isInitialized = false; // Track initialization

  // Keep allowed types
  final Set<String> _allowedImageMime = {
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/jpg'
  };
  final Set<String> _allowedVideoMime = {
    'video/mp4',
    'video/quicktime',
    'video/x-msvideo',
    'video/mpeg',
    'video/3gpp',
    'video/mp2t'
  };
  final Set<String> _allowedImageExtensions = {
    'jpg',
    'jpeg',
    'png',
    'gif',
    'webp',
    'bmp',
    'tiff'
  };
  final Set<String> _allowedVideoExtensions = {
    'mp4',
    'mov',
    'avi',
    'mpeg',
    'mpg',
    '3gp',
    'ts',
    'mkv'
  };

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) => _initializeMedia());
  }

  // *** --- START FIX: Modified Initialization Logic --- ***
  void _initializeMedia() {
    if (_isInitialized && !widget.isEditing)
      return; // Prevent re-init on onboarding if already done
    // Allow re-initialization if entering edit mode again
    print(
        "[MediaPickerScreen] Initializing Media (isEditing: ${widget.isEditing})...");

    final mediaUploadNotifier = ref.read(mediaUploadProvider.notifier);
    final currentUser = ref.read(userProvider);

    // Clear the mediaUploadProvider state ONLY when entering the screen.
    // It tracks *unsaved* local file selections made during THIS session.
    mediaUploadNotifier.state = List.filled(6, null);
    print("[MediaPickerScreen] Cleared mediaUploadProvider state.");

    List<dynamic> tempDisplayItems =
        List.filled(6, null); // Use local temp list

    // Populate based on current user state (URLs or local paths from previous edits)
    final currentIdentifiers = currentUser.mediaUrls ?? [];
    print(
        "[MediaPickerScreen] Populating from userProvider identifiers: $currentIdentifiers");

    for (int i = 0; i < currentIdentifiers.length && i < 6; i++) {
      final identifier = currentIdentifiers[i];
      if (identifier.isNotEmpty) {
        // 1. Check if it's an HTTP URL
        if (identifier.startsWith('http')) {
          tempDisplayItems[i] = identifier; // Store the URL string
          print("  - Slot $i: Existing URL: $identifier");
        }
        // 2. Check if it's a potentially valid local file path
        else if (identifier.contains('/') || identifier.contains('\\')) {
          try {
            final file = File(identifier);
            // IMPORTANT: We cannot call file.exists() synchronously here.
            // Assume if it's a path stored previously, it *was* valid.
            // We'll create a MediaUploadModel optimistically. If the file is
            // deleted later, the UI build (_buildMediaPlaceholder) will handle the error.

            final fileName = p.basename(file.path);
            final mimeType = lookupMimeType(file.path) ??
                'application/octet-stream'; // Default MIME

            tempDisplayItems[i] = MediaUploadModel(
                file: file,
                fileName: fileName,
                fileType: mimeType,
                status: UploadStatus.idle // Local files are initially idle
                );
            print(
                "  - Slot $i: Local File Path (from previous edit): $identifier");
          } catch (e) {
            print(
                "  - Slot $i: Error processing potential path '$identifier': $e. Treating as empty.");
            tempDisplayItems[i] = null;
          }
        }
        // 3. Otherwise, treat as invalid/empty
        else {
          print(
              "  - Slot $i: Invalid identifier '$identifier'. Treating as empty.");
          tempDisplayItems[i] = null;
        }
      }
    }

    // Update local state for UI building
    setState(() {
      _displayItems = tempDisplayItems; // Use the populated temp list
      _isInitialized = true;
      _updateForwardButtonState(); // Update button based on initial state
    });
    print(
        "[MediaPickerScreen] Initialization complete. Display Items: ${_displayItems.map((item) {
      if (item is MediaUploadModel) return "File: ${item.fileName}";
      if (item is String)
        return "URL: ${item.substring(item.length - 10)}"; // Show end of URL
      return 'null';
    }).toList()}");
  }
  // *** --- END FIX --- ***

  @override
  void dispose() {
    super.dispose();
  }

  // *** --- START FIX: Modified _pickMedia --- ***
  Future<void> _pickMedia(int index) async {
    ref.read(errorProvider.notifier).clearError();
    final ImagePicker picker = ImagePicker();
    final XFile? media = await picker.pickMedia();

    if (media != null) {
      final mimeType = media.mimeType?.toLowerCase();
      final fileName = p.basename(media.path);
      final extension =
          p.extension(media.path).toLowerCase().replaceAll('.', '');
      final filePath = media.path.replaceFirst('file://', '');
      final file = File(filePath);

      // Validation...
      final isValidImage = _allowedImageMime.contains(mimeType) ||
          _allowedImageExtensions.contains(extension);
      final isValidVideo = _allowedVideoMime.contains(mimeType) ||
          _allowedVideoExtensions.contains(extension);
      final fileSize = await file.length();
      final isImage = isValidImage;
      final isVideo = isValidVideo;

      if (isImage && fileSize > 10 * 1024 * 1024) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Image is too large. Maximum size is 10 MB."));
        // Don't clear slot here, let validation prevent update below
        return;
      }
      if (isVideo && fileSize > 50 * 1024 * 1024) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Video is too large. Maximum size is 50 MB."));
        return;
      }
      // --- End Basic Validation ---

      // --- First Item Image Validation (using temp state) ---
      final tempDisplayItems = List.from(_displayItems);
      final potentialNewModel = MediaUploadModel(
          file: file,
          fileName: fileName,
          fileType: mimeType ?? (isVideo ? 'video/mp4' : 'image/jpeg'));
      tempDisplayItems[index] =
          potentialNewModel; // Simulate adding the new file

      final firstItem = tempDisplayItems[0];
      bool firstIsImage = false;
      if (firstItem is MediaUploadModel) {
        firstIsImage = firstItem.fileType.startsWith('image/');
      } else if (firstItem is String) {
        final lowerUrl = firstItem.toLowerCase();
        firstIsImage = [
          '.jpg',
          '.jpeg',
          '.png',
          '.gif',
          '.webp',
          '.bmp',
          '.tiff'
        ].any((ext) => lowerUrl.endsWith(ext));
      }

      if (index == 0 && !firstIsImage) {
        await _showErrorDialog(context, isMainImage: true);
        return; // Prevent update if first item isn't image
      }
      // --- End First Item Validation ---

      if (!isValidImage && !isValidVideo) {
        await _showErrorDialog(context);
        return;
      }
      // --- End Format Validation ---

      // If all validations pass, create the final model
      final newModel = MediaUploadModel(
          file: file,
          fileName: fileName,
          fileType: mimeType ??
              (isVideo ? 'video/mp4' : 'image/jpeg'), // Provide fallback MIME
          status: UploadStatus.idle // Initial status
          );

      // Update provider state (only holds NEW files selected in *this* session)
      // Need to copy current provider state and update the specific index
      final currentProviderState =
          List<MediaUploadModel?>.from(ref.read(mediaUploadProvider));
      currentProviderState[index] = newModel;
      ref.read(mediaUploadProvider.notifier).state = currentProviderState;
      print(
          "[MediaPickerScreen] Updated mediaUploadProvider at index $index with ${newModel.fileName}");

      // Update local display state for UI
      setState(() {
        _displayItems[index] = newModel; // Update the display list directly
        _updateForwardButtonState();
      });
      // Signal change if editing
      if (widget.isEditing) {
        ref.read(userProvider.notifier).setMediaChangedFlag(true);
      }
    }
  }
  // *** --- END FIX --- ***

  // *** --- START FIX: Modified _clearSlot --- ***
  void _clearSlot(int index) {
    // Count selected based on the local display list
    final currentCount = _displayItems.where((item) => item != null).length;

    // --- Minimum Items Validation ---
    // Check if clearing this slot would result in less than 3 items
    bool wouldBeLessThanMin =
        (_displayItems[index] != null && currentCount <= 3);
    if (wouldBeLessThanMin) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Minimum of 3 media items required."));
      return;
    }
    // --- End Minimum Items Validation ---

    // --- First Item Image Validation ---
    // Simulate state after clearing to check if first item is still valid
    final tempDisplayItems = List.from(_displayItems);
    tempDisplayItems[index] = null; // Simulate removal

    final firstItemAfterClear = tempDisplayItems[0];
    bool firstIsImageAfterClear = false;
    if (firstItemAfterClear is MediaUploadModel) {
      firstIsImageAfterClear =
          firstItemAfterClear.fileType.startsWith('image/');
    } else if (firstItemAfterClear is String) {
      final lowerUrl = firstItemAfterClear.toLowerCase();
      firstIsImageAfterClear = [
        '.jpg',
        '.jpeg',
        '.png',
        '.gif',
        '.webp',
        '.bmp',
        '.tiff'
      ].any((ext) => lowerUrl.endsWith(ext));
    }

    // If clearing the first item AND there are other items left,
    // but the new first item isn't an image, prevent clearing.
    if (index == 0 && currentCount > 1 && !firstIsImageAfterClear) {
      ref.read(errorProvider.notifier).setError(AppError.validation(
          "Cannot remove the main photo if the next item is not a photo. Reorder first."));
      return;
    }
    // --- End First Item Validation ---

    // --- If validations pass, proceed with clearing ---
    ref.read(errorProvider.notifier).clearError(); // Clear any previous error

    // Check if the item being cleared was a NEWLY added local file in this session
    final itemToClear = _displayItems[index];
    if (itemToClear is MediaUploadModel) {
      // If it was a local file selected in THIS session, remove it from the mediaUploadProvider
      final currentProviderState =
          List<MediaUploadModel?>.from(ref.read(mediaUploadProvider));
      if (index < currentProviderState.length) {
        // Safety check
        currentProviderState[index] = null; // Clear slot in provider state
        ref.read(mediaUploadProvider.notifier).state = currentProviderState;
        print(
            "[MediaPickerScreen] Cleared slot $index in mediaUploadProvider.");
      }
    } else {
      print(
          "[MediaPickerScreen] Cleared slot $index which contained an existing URL or was empty.");
    }

    // Update local state for UI
    setState(() {
      _displayItems[index] = null; // Clear the local display slot
      _updateForwardButtonState();
    });
    // Signal change if editing
    if (widget.isEditing) {
      ref.read(userProvider.notifier).setMediaChangedFlag(true);
    }
  }
  // *** --- END FIX --- ***

  Future<void> _showErrorDialog(BuildContext context,
      {bool isMainImage = false}) async {
    // (Keep as is)
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(isMainImage ? 'Invalid Main Image' : 'Invalid File Type'),
        content: Text(isMainImage
            ? 'Main image must be an image file.\nAllowed formats: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF'
            : 'Allowed formats:\n• Images: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF\n• Videos: MP4, MOV, AVI, MPEG, 3GP, TS, MKV'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  // *** --- START FIX: Modified _reorderMedia --- ***
  void _reorderMedia(int oldGridIndex, int newGridIndex) {
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors

    // Create a mutable copy of the local display list
    List<dynamic> reorderedDisplayItems = List.from(_displayItems);
    final item = reorderedDisplayItems.removeAt(oldGridIndex);
    reorderedDisplayItems.insert(newGridIndex, item);

    // --- VALIDATION: Ensure first slot is an image AFTER reorder ---
    final firstItem = reorderedDisplayItems[0];
    bool firstIsImage = false;
    if (firstItem is MediaUploadModel) {
      firstIsImage = firstItem.fileType.startsWith('image/');
    } else if (firstItem is String) {
      final lowerUrl = firstItem.toLowerCase();
      firstIsImage = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff']
          .any((ext) => lowerUrl.endsWith(ext));
    }

    if (firstItem == null || !firstIsImage) {
      // Also check if first item is null
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("The first item must be a photo."));
      // Do NOT update state if invalid
      return;
    }
    // --- End Validation ---

    // Update local state for UI
    setState(() {
      _displayItems = reorderedDisplayItems;
      _updateForwardButtonState();
    });

    // --- Update mediaUploadProvider state ---
    // Reconstruct the provider state to match the new order,
    // containing only the MediaUploadModels (representing NEW files).
    List<MediaUploadModel?> newProviderState = List.filled(6, null);
    for (int i = 0; i < reorderedDisplayItems.length; i++) {
      if (reorderedDisplayItems[i] is MediaUploadModel) {
        newProviderState[i] = reorderedDisplayItems[i] as MediaUploadModel;
      }
    }
    ref.read(mediaUploadProvider.notifier).state = newProviderState;
    print("[MediaPickerScreen] Reordered. Updated mediaUploadProvider state.");
    // --- End Provider State Update ---

    // Signal change if editing
    if (widget.isEditing) {
      ref.read(userProvider.notifier).setMediaChangedFlag(true);
    }
  }
  // *** --- END FIX --- ***

  // Count selected based on local display list
  int _countSelectedMedia() {
    return _displayItems.where((item) => item != null).length;
  }

  // Update button state based on local display list
  void _updateForwardButtonState() {
    // No need to call setState here as this is called within setState blocks elsewhere
    // Logic to determine button state is moved to the build method.
  }

  // *** --- START FIX: Modified _handleDone --- ***
  void _handleDone() {
    final currentCount = _countSelectedMedia(); // Use local count
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();

    // Validate minimum items
    if (currentCount < 3) {
      errorNotifier
          .setError(AppError.validation("Minimum 3 media items required."));
      return;
    }

    // Validate first item is image (check local display list)
    final firstItem = _displayItems[0];
    bool firstIsImage = false;
    if (firstItem is MediaUploadModel) {
      firstIsImage = firstItem.fileType.startsWith('image/');
    } else if (firstItem is String) {
      final lowerUrl = firstItem.toLowerCase();
      firstIsImage = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff']
          .any((ext) => lowerUrl.endsWith(ext));
    }

    if (firstItem == null || !firstIsImage) {
      // Check for null as well
      errorNotifier
          .setError(AppError.validation("The first item must be a photo."));
      return;
    }

    // If editing, update user provider state with local file paths/URLs
    if (widget.isEditing) {
      List<String> identifiers = [];
      for (final item in _displayItems) {
        // Iterate through local display list
        if (item is MediaUploadModel) {
          identifiers.add(item.file.path); // Add local path
        } else if (item is String) {
          identifiers.add(item); // Add existing URL
        }
        // Null items are skipped, resulting in potentially fewer than 6 items in the final list
      }

      // Update user provider with the final list of identifiers
      ref.read(userProvider.notifier).updateMediaUrls(identifiers);
      // If any local file was picked/reordered/cleared, this flag should be true
      ref
          .read(userProvider.notifier)
          .setMediaChangedFlag(true); // Ensure flag is set if changes were made
      print(
          "[MediaPickerScreen Edit] Updated userProvider state with identifiers: $identifiers. Popping back.");
      Navigator.of(context).pop();
    } else {
      // --- ONBOARDING Flow ---
      // Provider state (mediaUploadProvider) already holds the MediaUploadModels.
      // No further action needed here before navigation.
      print(
          "[MediaPickerScreen Onboarding] Files ready in provider. Navigating to Prompts.");
      Navigator.pushReplacement(
          context,
          MaterialPageRoute(
              builder: (context) => const ProfileAnswersScreen()));
      // --- End ONBOARDING Flow ---
    }
  }
  // *** --- END FIX --- ***

  @override
  Widget build(BuildContext context) {
    // Watch provider only for errors, maybe? Grid uses local state.
    // final providerState = ref.watch(mediaUploadProvider); // Less relevant now
    final errorState = ref.watch(errorProvider);
    final screenSize = MediaQuery.of(context).size;

    // Calculate enabled state within build using local list
    final int selectedCount = _countSelectedMedia();
    bool firstIsImage = true;
    final firstItem = _displayItems[0]; // Check local list
    if (firstItem is MediaUploadModel) {
      firstIsImage = firstItem.fileType.startsWith('image/');
    } else if (firstItem is String) {
      final lowerUrl = firstItem.toLowerCase();
      firstIsImage = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff']
          .any((ext) => lowerUrl.endsWith(ext));
    } else {
      firstIsImage = false; // Cannot proceed if first slot is null
    }

    final bool isForwardButtonEnabled = selectedCount >= 3 && firstIsImage;

    // Show loading if not initialized yet
    if (!_isInitialized) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }

    return Scaffold(
      backgroundColor: const Color(0xFFFAFAFA), // Lighter background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Header (keep as is) ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: Icon(Icons.photo_library_rounded,
                            color: const Color(0xFF8B5CF6), size: 30),
                      ),
                    Text(
                      widget.isEditing ? "Edit Media" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: isForwardButtonEnabled ? _handleDone : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: isForwardButtonEnabled
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---
              SizedBox(height: screenSize.height * 0.02),
              Text(
                widget.isEditing
                    ? "Manage Your Gallery"
                    : "Create Your Gallery",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.07
                      : screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  letterSpacing: -0.5,
                ),
              ),
              Text(
                widget.isEditing
                    ? "Add, remove, or reorder photos/videos (min 3)"
                    : "Select at least 3 photos or videos",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey[600],
                  fontWeight: FontWeight.w500,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(20),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  padding: const EdgeInsets.all(16),
                  child: ReorderableGridView.count(
                    crossAxisCount: 2,
                    mainAxisSpacing: 16,
                    crossAxisSpacing: 16,
                    childAspectRatio: 0.95, // Adjust aspect ratio if needed
                    shrinkWrap: true,
                    physics: const BouncingScrollPhysics(),
                    // *** FIX: Use _displayItems.length ***
                    children: List.generate(_displayItems.length,
                        (index) => _buildMediaPlaceholder(index)),
                    onReorder: _reorderMedia,
                  ),
                ),
              ),
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 8.0),
                  child: Center(
                    child: Text(
                      errorState.message,
                      style:
                          GoogleFonts.poppins(color: Colors.red, fontSize: 14),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
              // --- Bottom Bar (keep as is) ---
              if (!widget.isEditing)
                Container(
                  padding: EdgeInsets.symmetric(
                    vertical: screenSize.height * 0.02,
                    horizontal: screenSize.width * 0.04,
                  ),
                  margin:
                      const EdgeInsets.only(top: 10), // Add margin if needed
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(16),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, -4),
                      ),
                    ],
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "${selectedCount}/6 Selected",
                            style: GoogleFonts.poppins(
                              fontSize: screenSize.width * 0.04,
                              fontWeight: FontWeight.w600,
                              color: const Color(0xFF8B5CF6),
                            ),
                          ),
                          Text(
                            "Minimum 3 required",
                            style: GoogleFonts.poppins(
                              fontSize: screenSize.width * 0.035,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                      GestureDetector(
                        onTap: isForwardButtonEnabled
                            ? _handleDone
                            : null, // Use calculated state
                        child: AnimatedContainer(
                          duration: const Duration(milliseconds: 200),
                          width: 60,
                          height: 60,
                          decoration: BoxDecoration(
                            color: isForwardButtonEnabled
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey[300],
                            borderRadius: BorderRadius.circular(30),
                            boxShadow: isForwardButtonEnabled
                                ? [
                                    BoxShadow(
                                      color: const Color(0xFF8B5CF6)
                                          .withOpacity(0.3),
                                      blurRadius: 8,
                                      offset: const Offset(0, 4),
                                    ),
                                  ]
                                : null,
                          ),
                          child: Icon(
                            Icons.arrow_forward_rounded,
                            color: isForwardButtonEnabled
                                ? Colors.white
                                : Colors.grey[500],
                            size: 28,
                          ),
                        ),
                      )
                    ],
                  ),
                ),
              // --- End Hide Bottom Bar ---
              SizedBox(
                  height: widget.isEditing
                      ? 16
                      : screenSize.height * 0.02), // Adjusted bottom padding
            ],
          ),
        ),
      ),
    );
  }

  // *** --- START FIX: Modified _buildMediaPlaceholder --- ***
  Widget _buildMediaPlaceholder(int index) {
    final item = _displayItems[index]; // Read from local display list
    final key = ValueKey(item is String
        ? item
        : (item as MediaUploadModel?)?.file.path ?? 'empty_$index');

    bool isVideo = false;
    bool isImage = false;
    Widget imageWidget = Container(); // Default empty

    if (item is MediaUploadModel) {
      final file = item.file;
      final mimeType = item.fileType;
      isImage = mimeType.startsWith('image/');
      isVideo = mimeType.startsWith('video/');
      if (isImage) {
        imageWidget = Image.file(file, fit: BoxFit.cover,
            errorBuilder: (_, error, stack) {
          print("Error loading local file ${file.path}: $error");
          return const Icon(Icons.broken_image);
        });
      } else if (isVideo) {
        imageWidget = Container(
            color: Colors.grey[300],
            child: const Center(
                child: Icon(Icons.videocam_outlined,
                    color: Colors.grey, size: 40)));
      }
    } else if (item is String && item.startsWith('http')) {
      final lowerUrl = item.toLowerCase();
      isImage = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff']
          .any((ext) => lowerUrl.endsWith(ext));
      isVideo = ['.mp4', '.mov', '.avi', '.mpeg', '.mpg', '.3gp', '.ts', '.mkv']
          .any((ext) => lowerUrl.endsWith(ext));
      if (isImage) {
        imageWidget = Image.network(item,
            fit: BoxFit.cover,
            loadingBuilder: (ctx, child, prog) => prog == null
                ? child
                : Center(
                    child: CircularProgressIndicator(
                        value: prog.expectedTotalBytes != null
                            ? prog.cumulativeBytesLoaded /
                                prog.expectedTotalBytes!
                            : null,
                        color: Colors.grey[400])),
            errorBuilder: (ctx, err, st) {
              print("Error loading network image $item: $err");
              return Center(
                  child: Icon(Icons.image_not_supported_outlined,
                      color: Colors.grey[400], size: 40));
            });
      } else if (isVideo) {
        imageWidget = Container(
            color: Colors.grey[300],
            child: const Center(
                child: Icon(Icons.videocam_outlined,
                    color: Colors.grey, size: 40)));
      }
    }

    return GestureDetector(
      key: key, // Use the generated key
      onTap: () => _pickMedia(index),
      child: DottedBorder(
        dashPattern: const [6, 3],
        color: index == 0
            ? const Color(0xFF8B5CF6)
            : const Color(0xFF8B5CF6).withOpacity(0.6),
        strokeWidth: 2,
        borderType: BorderType.RRect,
        radius: const Radius.circular(16),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (item != null) // Show image/video placeholder if item exists
                ClipRRect(
                    borderRadius: BorderRadius.circular(16),
                    child: imageWidget),

              if (item == null) // Show Add icon if slot is empty
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        index == 0
                            ? Icons.add_photo_alternate_rounded
                            : Icons.add_rounded,
                        color: const Color(0xFF8B5CF6).withOpacity(0.6),
                        size: 36,
                      ),
                      if (index == 0)
                        Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: Text("Main Photo",
                              style: GoogleFonts.poppins(fontSize: 14)),
                        ),
                    ],
                  ),
                ),
              if (isVideo) // Show video overlay if it's a video
                const Center(
                  child: Icon(Icons.play_circle_fill_rounded,
                      color: Colors.white70, size: 48),
                ),
              // Show remove button if item exists (local or remote)
              if (item != null)
                Positioned(
                  top: 4,
                  right: 4,
                  child: GestureDetector(
                    onTap: () => _clearSlot(index),
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.6),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(Icons.close_rounded,
                          color: Colors.white, size: 16),
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
  // *** --- END FIX --- ***
}

enum MediaType { image, video }



================================================
File: views/name.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/dob.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class NameInputScreen extends ConsumerStatefulWidget {
  const NameInputScreen({super.key});

  @override
  ConsumerState<NameInputScreen> createState() => _NameInputScreenState();
}

class _NameInputScreenState extends ConsumerState<NameInputScreen> {
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;

  @override
  void initState() {
    super.initState();
    final user = ref.read(userProvider);
    _firstNameController = TextEditingController(text: user.name);
    _lastNameController = TextEditingController(text: user.lastName ?? '');
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      child: const Icon(
                        Icons.badge_outlined,
                        size: 28,
                        color: Colors.white,
                      ),
                    ),
                    const SizedBox(width: 10),
                    Text(
                      "What's your name?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width * 0.06,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.04),
                _buildFirstNameInput(error, screenSize),
                SizedBox(height: screenSize.height * 0.03),
                _buildLastNameInput(screenSize),
                const Spacer(),
                _buildNextButton(screenSize, error),
                SizedBox(height: screenSize.height * 0.04),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFirstNameInput(AppError? error, Size screenSize) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          decoration: BoxDecoration(
            border: Border(
              bottom: BorderSide(
                color: error?.type == ErrorType.validation
                    ? Colors.red
                    : Colors.white54,
                width: 1.5,
              ),
            ),
          ),
          child: TextField(
            controller: _firstNameController,
            style: GoogleFonts.poppins(
              fontSize: screenSize.width * 0.05,
              fontWeight: FontWeight.w500,
              color: Colors.white,
            ),
            cursorColor: Colors.white,
            decoration: InputDecoration(
              labelText: "First name (required)",
              labelStyle: GoogleFonts.poppins(
                fontSize: screenSize.width * 0.042,
                color: Colors.white54,
              ),
              border: InputBorder.none,
            ),
            onChanged: (value) => _updateName(value, _lastNameController.text),
          ),
        ),
        if (error?.type == ErrorType.validation)
          Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Text(
              error!.message,
              style: GoogleFonts.poppins(
                color: Colors.redAccent,
                fontSize: screenSize.width * 0.035,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildLastNameInput(Size screenSize) {
    return TextField(
      controller: _lastNameController,
      style: GoogleFonts.poppins(
        fontSize: screenSize.width * 0.05,
        fontWeight: FontWeight.w500,
        color: Colors.white,
      ),
      cursorColor: Colors.white,
      decoration: InputDecoration(
        labelText: "Last name (optional)",
        labelStyle: GoogleFonts.poppins(
          fontSize: screenSize.width * 0.042,
          color: Colors.white54,
        ),
        enabledBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white54, width: 1.5),
        ),
        focusedBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white, width: 2.0),
        ),
      ),
      onChanged: (value) => _updateName(_firstNameController.text, value),
    );
  }

  Widget _buildNextButton(Size screenSize, AppError? error) {
    final isValid = ref.read(userProvider.notifier).isNameValid();

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: error == null && isValid
            ? () => _handleNextButton()
            : null, // Disable button if there are errors
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: error != null || !isValid
              ? Colors.grey.shade400 // Disable button if there are errors
              : Colors.white,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: EdgeInsets.all(16), // Adjusted padding
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24, // Adjusted icon size
          color: error != null || !isValid
              ? Colors.white54 // Change icon color when disabled
              : const Color(0xFF8B5CF6),
        ),
      ),
    );
  }

  void _updateName(String firstName, String lastName) {
    ref.read(userProvider.notifier).updateName(firstName, lastName);
  }

  void _handleNextButton() {
    ref.read(errorProvider.notifier).clearError();
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DateOfBirthScreen()),
    );
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    super.dispose();
  }
}



================================================
File: views/profile_screens.dart
================================================
import 'dart:math';
import 'dart:io';

// Keep necessary imports...
import 'package:dtx/models/media_upload_model.dart';
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/dating_intentions.dart';
import 'package:dtx/views/drinking.dart';
import 'package:dtx/views/height.dart';
import 'package:dtx/views/hometown.dart';
import 'package:dtx/views/job.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/prompt.dart';
import 'package:dtx/views/religion.dart';
import 'package:dtx/views/smoking.dart';
import 'package:dtx/views/study.dart';
import 'package:dtx/views/textpromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:audioplayers/audioplayers.dart'; // Keep for local player
import 'package:path/path.dart' as path; // Import path package
import 'package:mime/mime.dart'; // Import mime package

import 'package:dtx/models/user_model.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/settings_screen.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/service_provider.dart'; // Keep
import 'package:dtx/providers/media_upload_provider.dart'; // Keep
import 'package:dtx/services/api_service.dart'; // Keep
// Import audio player provider for audio playback UI state (Global player, not local)
// Keep import if global player UI is needed elsewhere, but playback uses local _audioPlayer
import 'package:dtx/providers/audio_player_provider.dart';
// Import MediaRepository provider
import 'package:dtx/repositories/media_repository.dart'; // Import MediaRepository

class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  // Retain state for Audio Player, Edit Mode, Saving, Original Data
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isPlaying = false;
  String? _currentAudioUrl;
  bool _isEditing = false;
  bool _isSaving = false;
  UserModel? _originalProfileData; // To store data before editing starts

  @override
  void initState() {
    super.initState();
    // Fetch profile if needed (e.g., if user lands directly here after login)
    // Moved fetching logic primarily to MainNavigationScreen
    _setupLocalAudioPlayerListeners();
  }

  void _setupLocalAudioPlayerListeners() {
    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted) {
        setState(() {
          _isPlaying = state == PlayerState.playing;
          if (state == PlayerState.stopped || state == PlayerState.completed) {
            _currentAudioUrl = null;
          }
        });
      }
    });
    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) {
        setState(() {
          _isPlaying = false;
          _currentAudioUrl = null;
        });
      }
    });
  }

  @override
  void dispose() {
    try {
      if (_audioPlayer.state == PlayerState.playing ||
          _audioPlayer.state == PlayerState.paused) {
        _audioPlayer.stop();
      }
      _audioPlayer.release();
      _audioPlayer.dispose();
    } catch (e) {
      print("Error releasing/disposing local audio player: $e");
    }
    super.dispose();
  }

  // --- Local Audio Control --- (Keep as is)
  Future<void> _playOrPauseAudio(String audioUrl) async {
    if (!mounted) return;
    try {
      final currentState = _audioPlayer.state;
      if (currentState == PlayerState.playing && _currentAudioUrl == audioUrl) {
        await _audioPlayer.pause();
      } else if (currentState == PlayerState.paused &&
          _currentAudioUrl == audioUrl) {
        await _audioPlayer.resume();
      } else {
        if (currentState == PlayerState.playing ||
            currentState == PlayerState.paused) {
          await _audioPlayer.stop();
        }
        await _audioPlayer.setSource(UrlSource(audioUrl));
        await _audioPlayer.resume();
        if (mounted) setState(() => _currentAudioUrl = audioUrl);
      }
    } catch (e) {
      print("Error playing/pausing audio: $e");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error playing audio: ${e.toString()}')));
        setState(() {
          _isPlaying = false;
          _currentAudioUrl = null;
        });
      }
    }
  }

  // --- Edit Mode Handlers (_enterEditMode, _cancelEditMode) ---
  void _enterEditMode() {
    _originalProfileData = ref.read(userProvider); // Store original state
    ref.read(userProvider.notifier).setMediaChangedFlag(false); // Reset flag
    setState(() => _isEditing = true);
  }

  void _cancelEditMode() {
    if (_originalProfileData != null) {
      // Restore state ONLY if media hasn't changed during the edit process
      // If media DID change, it's complex to revert provider state easily,
      // so we might just refetch or accept the userProvider's current state.
      // For simplicity, let's just refetch if media changed.
      if (!ref.read(userProvider).mediaChangedDuringEdit) {
        print("[ProfileScreen] Cancelling edit, restoring original data.");
        ref.read(userProvider.notifier).state = _originalProfileData!;
      } else {
        print("[ProfileScreen] Cancelling edit, media changed, refetching.");
        // Optionally clear the flag before refetching
        ref.read(userProvider.notifier).setMediaChangedFlag(false);
        ref.read(userProvider.notifier).fetchProfile();
      }
    } else {
      print("[ProfileScreen] Cancelling edit, no original data, refetching.");
      ref
          .read(userProvider.notifier)
          .fetchProfile(); // Refetch if original is missing
    }
    ref.read(errorProvider.notifier).clearError(); // Clear any edit errors
    setState(() => _isEditing = false);
  }

  // --- *** UPDATED Save Handler *** ---
  Future<void> _handleSave() async {
    print("[ProfileScreen _handleSave] Starting Save Process...");
    final errorNotifier = ref.read(errorProvider.notifier)..clearError();
    if (!mounted) return;
    setState(() => _isSaving = true); // Show loading indicator

    final userState = ref.read(userProvider);
    final userNotifier = ref.read(userProvider.notifier);
    final mediaRepo = ref.read(mediaRepositoryProvider);
    final userRepo = ref.read(userRepositoryProvider);

    // Use original data for comparison if available, else current state
    final initialMediaUrls =
        _originalProfileData?.mediaUrls ?? userState.mediaUrls ?? [];
    final currentMediaIdentifiers =
        List<String>.from(userState.mediaUrls ?? []); // List from userProvider

    List<String> finalMediaUrls = []; // To store the final list of S3 URLs
    List<Map<String, String>> filesToUploadDetails = [];
    List<MediaUploadModel> fileModelsToUpload = []; // Keep models for S3 upload

    try {
      // --- Identify Files vs Existing URLs ---
      print("[ProfileScreen _handleSave] Identifying files vs URLs...");
      for (int i = 0; i < currentMediaIdentifiers.length; i++) {
        final identifier = currentMediaIdentifiers[i];
        if (identifier.isEmpty) continue; // Skip empty slots

        bool isLocalFile = false;
        File? potentialFile;
        try {
          // Check if it's an absolute path (common on mobile) or relative
          Uri? uri = Uri.tryParse(identifier);
          if (uri != null &&
              !uri.isAbsolute &&
              !identifier.startsWith('http')) {
            // If it's not an absolute URI and not HTTP(S), treat as potential file path
            isLocalFile = true;
          } else if (identifier.startsWith('/')) {
            // Catch explicit absolute paths like /data/user/...
            isLocalFile = true;
          }

          if (isLocalFile) {
            potentialFile = File(identifier);
            // Check existence *only* if it looks like a file path
            isLocalFile = await potentialFile.exists();
          }
        } catch (e) {
          print("Error checking file path '$identifier': $e");
          isLocalFile = false;
        }

        if (isLocalFile && potentialFile != null) {
          print("  - Found Local File at index $i: ${potentialFile.path}");
          final fileName = path.basename(potentialFile.path);
          final mimeType =
              lookupMimeType(potentialFile.path) ?? 'application/octet-stream';
          filesToUploadDetails.add({'filename': fileName, 'type': mimeType});
          // Store the model WITH the file object for later upload
          fileModelsToUpload.add(MediaUploadModel(
            file: potentialFile,
            fileName: fileName,
            fileType: mimeType,
            // presignedUrl will be added later
          ));
        } else if (identifier.startsWith('http')) {
          print("  - Found Existing URL at index $i: $identifier");
          // Add existing URL directly to the final list for now
          // We'll reconstruct the order later
        } else {
          print(
              "  - Warning: Skipping invalid identifier at index $i: $identifier");
        }
      }
      print(
          "[ProfileScreen _handleSave] Files to upload: ${fileModelsToUpload.length}");

      // --- Upload Files if Needed ---
      Map<String, String> uploadedUrlMap =
          {}; // Map original path -> new S3 URL
      if (fileModelsToUpload.isNotEmpty) {
        print(
            "[ProfileScreen _handleSave] Getting presigned URLs for ${fileModelsToUpload.length} files...");
        final presignedUrlsResponse =
            await mediaRepo.getEditPresignedUrls(filesToUploadDetails);

        if (presignedUrlsResponse.length != fileModelsToUpload.length) {
          throw ApiException("Mismatch in number of presigned URLs received.");
        }

        // Prepare models with URLs for upload
        List<Future<bool>> uploadFutures = [];
        for (int i = 0; i < fileModelsToUpload.length; i++) {
          final fileModel = fileModelsToUpload[i];
          final urlData = presignedUrlsResponse.firstWhere(
              (u) =>
                  u['filename'] == fileModel.fileName &&
                  u['type'] == fileModel.fileType,
              orElse: () => throw ApiException(
                  "Could not find presigned URL for ${fileModel.fileName}"));
          final presignedUrl = urlData['url'] as String;

          final modelWithUrl =
              fileModel.copyWith(presignedUrl: () => presignedUrl);
          fileModelsToUpload[i] = modelWithUrl; // Update the model in the list

          print(
              "[ProfileScreen _handleSave] Uploading ${fileModel.fileName}...");
          // Use retryUpload for robustness
          uploadFutures.add(mediaRepo.retryUpload(modelWithUrl).then((success) {
            if (success) {
              // Store mapping from original file path to S3 URL
              uploadedUrlMap[fileModel.file.path] = presignedUrl
                  .split('?')
                  .first; // Store URL without query params
            }
            return success;
          }));
        }

        final uploadResults = await Future.wait(uploadFutures);
        if (uploadResults.any((success) => !success)) {
          // Find which one failed for better logging (optional)
          for (int i = 0; i < uploadResults.length; ++i) {
            if (!uploadResults[i]) {
              print("❌ Upload failed for: ${fileModelsToUpload[i].fileName}");
            }
          }
          throw ApiException("One or more media uploads failed.");
        }
        print("[ProfileScreen _handleSave] All media uploads successful.");
      } else {
        print("[ProfileScreen _handleSave] No new files to upload.");
      }

      // --- Reconstruct Final URL List ---
      print("[ProfileScreen _handleSave] Reconstructing final URL list...");
      for (final identifier in currentMediaIdentifiers) {
        if (identifier.isEmpty) continue;

        if (uploadedUrlMap.containsKey(identifier)) {
          // It was a local file that was successfully uploaded
          final s3Url = uploadedUrlMap[identifier];
          if (s3Url != null) {
            finalMediaUrls.add(s3Url);
            print("  - Adding New URL: $s3Url (from $identifier)");
          } else {
            print(
                "  - Warning: Uploaded file path $identifier not found in URL map.");
          }
        } else if (identifier.startsWith('http')) {
          // It was an existing URL
          finalMediaUrls.add(identifier);
          print("  - Adding Existing URL: $identifier");
        }
        // Skip invalid identifiers already warned about
      }
      print("[ProfileScreen _handleSave] Final URLs: $finalMediaUrls");

      // --- Validate Final Media Count ---
      if (finalMediaUrls.length < 3) {
        throw ApiException(
            "Profile must have at least 3 media items after saving.");
      }

      // --- Prepare PATCH Payload ---
      final latestUserState = ref.read(userProvider); // Read latest state again
      Map<String, dynamic> payload = latestUserState.toJsonForEdit();
      payload['media_urls'] =
          finalMediaUrls; // Use the final reconstructed list

      // Remove non-editable fields just in case
      payload.removeWhere((key, value) => [
            'name',
            'last_name',
            'date_of_birth',
            'latitude',
            'longitude',
            'gender',
            'id',
            'email',
            'phone_number',
            'created_at',
            'verification_status',
            'role',
            'verification_pic'
          ].contains(key));

      print("[ProfileScreen _handleSave] Preparing PATCH payload: $payload");

      // --- Call API ---
      print("[ProfileScreen _handleSave] Calling userRepo.editProfile...");
      final bool success = await userRepo.editProfile(payload);

      if (success) {
        print("[ProfileScreen _handleSave] Profile edit successful.");
        // Update user provider with final URLs and reset flags
        userNotifier.updateMediaUrls(
            finalMediaUrls); // updateMediaUrls now resets the flag internally
        _originalProfileData = ref
            .read(userProvider); // Update original data after successful save

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
                content: Text("Profile updated successfully!"),
                backgroundColor: Colors.green),
          );
          setState(() => _isEditing = false); // Exit edit mode
        }
      } else {
        print(
            "[ProfileScreen _handleSave] Profile edit failed (API returned false).");
        if (mounted && ref.read(errorProvider) == null) {
          errorNotifier
              .setError(AppError.server("Failed to save profile changes."));
        }
      }
    } on ApiException catch (e) {
      print(
          "[ProfileScreen _handleSave] Save failed: API Exception - ${e.message}");
      if (mounted) errorNotifier.setError(AppError.server(e.message));
    } catch (e, stack) {
      print("[ProfileScreen _handleSave] Save failed: Unexpected error - $e");
      print(stack);
      if (mounted) {
        errorNotifier
            .setError(AppError.generic("An unexpected error occurred."));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false); // Hide loading indicator
    }
  }
  // --- *** END UPDATED Save Handler *** ---

  // --- Helper Methods --- (Keep capitalizeFirstLetter, _buildTopIconButton, _buildEmptySection, _buildDetailChip, _buildSmallEditButton as is)
  String capitalizeFirstLetter(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }

  Widget _buildTopIconButton({
    required IconData icon,
    required String tooltip,
    required VoidCallback onPressed,
    bool isDisabled = false,
    Color? color,
  }) {
    final iconColor =
        isDisabled ? Colors.grey[400] : (color ?? const Color(0xFF8B5CF6));
    return IconButton(
      icon: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: isDisabled ? Colors.grey[200] : Colors.grey[100],
          borderRadius: BorderRadius.circular(12),
        ),
        child: Icon(icon, color: iconColor, size: 20),
      ),
      tooltip: isDisabled ? null : tooltip,
      onPressed: isDisabled ? null : onPressed,
    );
  }

  Widget _buildEmptySection(
      String title, String message, IconData icon, VoidCallback? onEditTap) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: 30, horizontal: 20),
      margin: const EdgeInsets.symmetric(
          vertical: 16), // Keep margin for consistency
      decoration: BoxDecoration(
          color: Colors.grey[50],
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey[200]!)),
      child: Stack(children: [
        Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(title,
                style: GoogleFonts.poppins(
                    fontSize: 18,
                    fontWeight: FontWeight.w600,
                    color: Colors.grey[800])),
            const SizedBox(height: 16), // Add space below title
            Icon(icon, size: 40, color: Colors.grey[400]),
            const SizedBox(height: 12),
            Text(message,
                textAlign: TextAlign.center,
                style:
                    GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600])),
          ],
        ),
        if (_isEditing && onEditTap != null)
          Positioned(
            top: 8,
            right: 8,
            child: _buildSmallEditButton(
                onPressed: onEditTap, tooltip: 'Add $title'),
          ),
      ]),
    );
  }

  Widget _buildDetailChip(IconData icon, String label, {bool subtle = false}) {
    if (label.isEmpty) return const SizedBox.shrink();
    return Container(
      padding: EdgeInsets.symmetric(
          horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
      decoration: BoxDecoration(
        color: subtle ? Colors.transparent : Colors.grey[100],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
            color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: subtle ? 16 : 18,
            color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6),
          ),
          const SizedBox(width: 6),
          Flexible(
            // Allow text to wrap if needed
            child: Text(
              label,
              style: GoogleFonts.poppins(
                fontSize: subtle ? 13 : 14,
                fontWeight: FontWeight.w500,
                color: subtle ? Colors.grey.shade700 : Colors.grey[800],
              ),
              overflow: TextOverflow.ellipsis, // Prevent long text overflow
              maxLines: 2,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSmallEditButton(
      {required VoidCallback onPressed,
      IconData icon = Icons.edit_outlined,
      String? tooltip = 'Edit'}) {
    return Material(
      color: Colors.white.withOpacity(0.8),
      shape: const CircleBorder(),
      child: InkWell(
        customBorder: const CircleBorder(),
        onTap: onPressed,
        child: Container(
          padding: const EdgeInsets.all(6),
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 3)
            ],
          ),
          child: Icon(icon, color: const Color(0xFF8B5CF6), size: 18),
        ),
      ),
    );
  }
  // --- END Helper Methods ---

  @override
  Widget build(BuildContext context) {
    final user = ref.watch(userProvider);
    final isLoadingProfile = ref.watch(userLoadingProvider);
    // Watch for API errors specifically during save
    final apiError = ref.watch(errorProvider);

    // --- Loading State --- (Keep as is)
    if (isLoadingProfile && user.name == null && !_isEditing) {
      return Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
            title: Text("Profile",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
            backgroundColor: Colors.white,
            foregroundColor: Colors.black,
            elevation: 0,
            automaticallyImplyLeading: false,
            actions: [
              _buildTopIconButton(
                  icon: Icons.edit_outlined,
                  tooltip: 'Edit Profile',
                  onPressed: () {},
                  isDisabled: true),
              const SizedBox(width: 8),
              _buildTopIconButton(
                  icon: Icons.settings_outlined,
                  tooltip: 'Settings',
                  onPressed: () {},
                  isDisabled: true),
              const SizedBox(width: 8),
            ]),
        body: const Center(
            child: CircularProgressIndicator(color: Color(0xFF8B5CF6))),
      );
    }

    // --- Error State (Display non-saving errors) ---
    // Only show general API errors if NOT currently in the saving process
    if (apiError != null && !_isSaving) {
      return Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          title: Text("Profile Error",
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          elevation: 0,
          automaticallyImplyLeading: false,
          actions: [
            _buildTopIconButton(
                icon: Icons.edit_outlined,
                tooltip: 'Edit Profile',
                onPressed: () {},
                isDisabled: true),
            const SizedBox(width: 8),
            _buildTopIconButton(
                icon: Icons.settings_outlined,
                tooltip: 'Settings',
                onPressed: () {},
                isDisabled: true),
            const SizedBox(width: 8),
          ],
        ),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(20.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 50),
                const SizedBox(height: 15),
                Text("Could not load profile",
                    style: GoogleFonts.poppins(
                        fontSize: 18, fontWeight: FontWeight.w600),
                    textAlign: TextAlign.center),
                const SizedBox(height: 8),
                Text(apiError.message,
                    textAlign: TextAlign.center,
                    style: GoogleFonts.poppins(color: Colors.grey[600])),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () {
                    ref.read(errorProvider.notifier).clearError();
                    ref.read(userProvider.notifier).fetchProfile();
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF8B5CF6),
                      foregroundColor: Colors.white),
                  child: const Text("Retry"),
                )
              ],
            ),
          ),
        ),
      );
    }

    // --- Prepare Content Blocks (Logic remains the same) ---
    final List<dynamic> contentBlocks = [];
    final currentMedia = user.mediaUrls ?? [];
    final prompts = user.prompts;

    contentBlocks.add("header_section");

    if (currentMedia.isNotEmpty) {
      // Add the first media item or an empty placeholder if editing
      contentBlocks
          .add({"type": "media", "value": currentMedia[0], "index": 0});
    } else if (_isEditing) {
      contentBlocks.add("empty_media_section");
    }

    if (prompts.isNotEmpty) {
      contentBlocks.add(prompts[0]);
    } else if (_isEditing) {
      contentBlocks.add("empty_prompt_section");
    }

    contentBlocks.add("vitals_section"); // Always add vitals section wrapper

    int mediaIndex = 1;
    int promptIndex = 1;
    // Use max of lengths OR 6/3 if editing to show empty slots potentially
    int maxMediaSlots = _isEditing ? 6 : currentMedia.length;
    int maxPromptSlots = _isEditing ? 3 : prompts.length;
    int maxRemaining = max(maxMediaSlots, maxPromptSlots);

    for (int i = 1; i < maxRemaining; i++) {
      // Add Media (existing or empty slot if editing)
      if (mediaIndex < maxMediaSlots) {
        if (mediaIndex < currentMedia.length) {
          contentBlocks.add({
            "type": "media",
            "value": currentMedia[mediaIndex],
            "index": mediaIndex
          });
        } else if (_isEditing) {
          // Add placeholder for potential add in media picker
          contentBlocks.add({"type": "empty_media_slot", "index": mediaIndex});
        }
        mediaIndex++;
      }
      // Add Prompt (existing or empty slot if editing)
      if (promptIndex < maxPromptSlots) {
        if (promptIndex < prompts.length) {
          contentBlocks.add(prompts[promptIndex]);
        } else if (_isEditing) {
          // Add placeholder for potential add in prompt editor
          contentBlocks
              .add({"type": "empty_prompt_slot", "index": promptIndex});
        }
        promptIndex++;
      }
    }

    // Add Audio Prompt (existing or empty slot if editing)
    if (user.audioPrompt != null) {
      contentBlocks.add(user.audioPrompt!);
    } else if (_isEditing) {
      contentBlocks.add("empty_audio_section");
    }
    // --- End Content Block Preparation ---

    // --- Build UI ---
    return Scaffold(
      backgroundColor: Colors.white,
      body: Stack(// Use Stack for loading overlay
          children: [
        RefreshIndicator(
          color: const Color(0xFF8B5CF6),
          onRefresh: () async {
            if (!_isEditing) {
              ref
                  .read(errorProvider.notifier)
                  .clearError(); // Clear error on refresh
              await ref.read(userProvider.notifier).fetchProfile();
            }
          },
          child: CustomScrollView(
            physics: const BouncingScrollPhysics(
                parent: AlwaysScrollableScrollPhysics()),
            slivers: [
              SliverAppBar(
                pinned: true,
                floating: false,
                elevation: 1,
                backgroundColor: Colors.white,
                foregroundColor: Colors.black,
                automaticallyImplyLeading: false,
                title: Text(_isEditing ? "Edit Profile" : "Profile",
                    style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
                actions: _isEditing
                    ? [
                        /* Save/Cancel Actions */
                        TextButton(
                            onPressed: _isSaving
                                ? null
                                : _cancelEditMode, // Disable during save
                            child: Text("Cancel",
                                style: GoogleFonts.poppins(
                                    color: _isSaving
                                        ? Colors.grey[400]
                                        : Colors.grey))),
                        TextButton(
                            onPressed: _isSaving
                                ? null
                                : _handleSave, // Disable during save
                            child: Text("Save",
                                style: GoogleFonts.poppins(
                                    color: _isSaving
                                        ? Colors.grey[400]
                                        : const Color(0xFF8B5CF6),
                                    fontWeight: FontWeight.bold))),
                        const SizedBox(width: 8),
                      ]
                    : [
                        /* View Mode Actions */
                        _buildTopIconButton(
                            icon: Icons.edit_outlined,
                            tooltip: 'Edit Profile',
                            onPressed: _enterEditMode),
                        const SizedBox(width: 8),
                        _buildTopIconButton(
                            icon: Icons.settings_outlined,
                            tooltip: 'Settings',
                            onPressed: () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const SettingsScreen()))),
                        const SizedBox(width: 8),
                      ],
              ),

              // --- Main Content List ---
              SliverPadding(
                padding: const EdgeInsets.only(top: 8.0),
                sliver: SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      final item = contentBlocks[index];
                      final double bottomPadding = 24.0;
                      final double horizontalPadding = 16.0;
                      Widget contentWidget;

                      // Build content based on type
                      if (item is String && item == "header_section") {
                        contentWidget = _buildHeaderBlock(user);
                      }
                      // Handle Empty Sections (Placeholders shown during edit)
                      else if (item is String &&
                          item == "empty_media_section") {
                        contentWidget = _buildEmptySection(
                            "Photos & Videos",
                            "Add photos and videos!",
                            Icons.add_photo_alternate_outlined,
                            () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const MediaPickerScreen(
                                            isEditing: true))));
                      } else if (item is String &&
                          item == "empty_prompt_section") {
                        contentWidget = _buildEmptySection(
                            "About Me",
                            "Add prompt answers!",
                            Icons.chat_bubble_outline,
                            () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) => ProfileAnswersScreen(
                                        isEditing: true))));
                      } else if (item is String &&
                          item == "empty_audio_section") {
                        contentWidget = _buildEmptySection(
                            "Voice Prompt",
                            "Record a voice prompt!",
                            Icons.mic_none_rounded,
                            () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const VoicePromptScreen(
                                            isEditing: true))));
                      } else if (item is Map &&
                          item["type"] == "empty_media_slot") {
                        contentWidget = _buildEmptyMediaSlot(() =>
                            Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const MediaPickerScreen(
                                            isEditing: true))));
                      } else if (item is Map &&
                          item["type"] == "empty_prompt_slot") {
                        contentWidget = _buildEmptyPromptSlot(
                            item["index"],
                            () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) => TextSelectPromptScreen(
                                        isEditing:
                                            true)))); // Pass index if needed later
                      }

                      // Handle Content Items
                      else if (item is Map && item["type"] == "media") {
                        String displayValue = item["value"];
                        bool isLocalFile = false;
                        // More robust check if it's a local file path vs URL
                        if (!displayValue.startsWith('http') &&
                            (displayValue.contains('/') ||
                                displayValue.contains('\\'))) {
                          // Basic check: Doesn't start with http and contains path separators
                          // A more reliable check might involve trying File(displayValue).exists() but that's async
                          isLocalFile = true;
                        }
                        contentWidget = _buildMediaItem(
                            context, ref, displayValue, item["index"],
                            isLocalFile: isLocalFile);
                      } else if (item is Prompt) {
                        int promptEditIndex = user.prompts
                            .indexWhere((p) => p.question == item.question);
                        contentWidget = _buildPromptItem(item,
                            onEditTap: () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        TextSelectPromptScreen(
                                            isEditing: true,
                                            editIndex: promptEditIndex >= 0
                                                ? promptEditIndex
                                                : null))));
                      } else if (item is AudioPromptModel) {
                        contentWidget = _buildAudioItem(item,
                            onEditTap: () => Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const VoicePromptScreen(
                                            isEditing: true))));
                      } else if (item is String && item == "vitals_section") {
                        contentWidget = _buildVitalsBlock(user,
                            onEditTap: _navigateToVitalsEditFlow);
                      } else {
                        contentWidget = const SizedBox.shrink();
                      }

                      return Padding(
                        padding: EdgeInsets.fromLTRB(horizontalPadding, 0,
                            horizontalPadding, bottomPadding),
                        child: contentWidget,
                      );
                    },
                    childCount: contentBlocks.length,
                  ),
                ),
              ),
              const SliverToBoxAdapter(child: SizedBox(height: 20)),
            ],
          ),
        ),
        // --- Loading Overlay ---
        if (_isSaving)
          Positioned.fill(
            child: Container(
              color: Colors.black.withOpacity(0.5),
              child: const Center(
                child: CircularProgressIndicator(color: Color(0xFF8B5CF6)),
              ),
            ),
          ),
      ]),
    );
  }

  // --- Block Builder Widgets (Adapted for ProfileScreen) ---

  Widget _buildHeaderBlock(UserModel user) {
    // (Keep as is)
    final age = user.age;
    final capitalizedName =
        user.name != null ? capitalizeFirstLetter(user.name!) : "Your Name";
    final capitalizedLastName =
        user.lastName != null && user.lastName!.isNotEmpty
            ? capitalizeFirstLetter(user.lastName!)
            : "";

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '$capitalizedName $capitalizedLastName ${age != null ? "• $age" : ""}',
          style: GoogleFonts.poppins(
              fontSize: 28,
              fontWeight: FontWeight.w700,
              color: const Color(0xFF1A1A1A),
              height: 1.2),
        ),
        const SizedBox(height: 12),
        Wrap(
          spacing: 10,
          runSpacing: 8,
          children: [
            // Non-editable
            if (user.gender != null)
              _buildDetailChip(Icons.person_outline_rounded, user.gender!.label,
                  subtle: true),
            // Editable - Hometown (Now editable via Vitals flow)
            if (user.hometown != null && user.hometown!.isNotEmpty)
              _buildEditableChip(
                icon: Icons.location_on_outlined,
                label: user.hometown!,
                onEditTap: () => Navigator.push(
                    context,
                    MaterialPageRoute(
                        builder: (context) =>
                            const HometownScreen(isEditing: true))),
                subtle: true, // Keep subtle look
              )
            else if (_isEditing)
              _buildAddChip(
                  label: "Add Hometown",
                  onAddTap: () => Navigator.push(
                      context,
                      MaterialPageRoute(
                          builder: (context) =>
                              const HometownScreen(isEditing: true))),
                  subtle: true),

            // Editable - Dating Intention
            if (user.datingIntention != null)
              _buildEditableChip(
                  icon: Icons.favorite_border_rounded,
                  label: user.datingIntention!.label,
                  onEditTap: () => Navigator.push(
                      context,
                      MaterialPageRoute(
                          builder: (context) =>
                              const DatingIntentionsScreen(isEditing: true))),
                  subtle: true)
            else if (_isEditing)
              _buildAddChip(
                  label: "Add Intention",
                  onAddTap: () => Navigator.push(
                      context,
                      MaterialPageRoute(
                          builder: (context) =>
                              const DatingIntentionsScreen(isEditing: true))),
                  subtle: true),
          ],
        ),
      ],
    );
  }

  // --- Modified Media Item Builder ---
  Widget _buildMediaItem(
      BuildContext context, WidgetRef ref, String urlOrPath, int index,
      {required bool isLocalFile}) {
    bool isVideo = false;
    if (!isLocalFile) {
      // Basic URL check for video extensions
      final lowerUrl = urlOrPath.toLowerCase();
      isVideo = ['.mp4', '.mov', '.avi', '.mpeg', '.mpg', '.3gp', '.ts', '.mkv']
          .any((ext) => lowerUrl.endsWith(ext));
    } else {
      // Use MIME type for local files if possible, fallback to extension
      final mimeType = lookupMimeType(urlOrPath);
      if (mimeType != null) {
        isVideo = mimeType.startsWith('video/');
      } else {
        // Fallback extension check for local files
        String ext = path.basename(urlOrPath).split('.').last.toLowerCase();
        isVideo = ['mp4', 'mov', 'avi', 'mpeg', 'mpg', '3gp', 'ts', 'mkv']
            .contains(ext);
      }
    }

    return ClipRRect(
      borderRadius: BorderRadius.circular(10),
      child: AspectRatio(
        aspectRatio: 4 / 5.5,
        child: Container(
          decoration: BoxDecoration(color: Colors.grey[200]),
          child: Stack(
            fit: StackFit.expand,
            children: [
              // Display Image/Video Thumbnail
              if (isLocalFile)
                Image.file(File(urlOrPath),
                    fit: BoxFit.cover,
                    errorBuilder: (_, __, ___) =>
                        const Icon(Icons.broken_image))
              else
                Image.network(urlOrPath,
                    fit: BoxFit.cover,
                    loadingBuilder: (ctx, child, prog) => prog == null
                        ? child
                        : Center(
                            child: CircularProgressIndicator(
                                value: prog.expectedTotalBytes != null
                                    ? prog.cumulativeBytesLoaded /
                                        prog.expectedTotalBytes!
                                    : null,
                                color: Colors.grey[400])),
                    errorBuilder: (ctx, err, st) => Center(
                        child: Icon(Icons.image_not_supported_outlined,
                            color: Colors.grey[400], size: 40))),
              // Video indicator
              if (isVideo)
                Center(
                  child: Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.5),
                        shape: BoxShape.circle),
                    child: const Icon(Icons.play_arrow_rounded,
                        color: Colors.white, size: 30),
                  ),
                ),

              // *** --- START FIX: Edit Button Condition --- ***
              // Show edit button if _isEditing, regardless of index
              if (_isEditing)
                // *** --- END FIX --- ***
                Positioned(
                  top: 8,
                  right: 8,
                  child: _buildSmallEditButton(
                      icon: Icons.edit, // Use edit icon
                      tooltip: "Edit Media Gallery",
                      onPressed: () async {
                        // Make async
                        // --- ADDED: Clear media provider before navigating ---
                        print(
                            "[ProfileScreen] Clearing mediaUploadProvider before navigating to MediaPickerScreen (Edit).");
                        ref.read(mediaUploadProvider.notifier).state =
                            List.filled(6, null);
                        // --- END ADDED ---
                        await Navigator.push(
                            // Await navigation
                            context,
                            MaterialPageRoute(
                                builder: (context) =>
                                    const MediaPickerScreen(isEditing: true)));
                        // Optional: Force rebuild or state sync after returning?
                        // Not strictly necessary if MediaPickerScreen correctly updates userProvider.
                      }),
                ),
            ],
          ),
        ),
      ),
    );
  }

  // --- NEW: Empty Media Slot ---
  Widget _buildEmptyMediaSlot(VoidCallback onEditTap) {
    return ClipRRect(
      borderRadius: BorderRadius.circular(10),
      child: AspectRatio(
        aspectRatio: 4 / 5.5,
        child: Material(
          color: Colors.grey[100],
          child: InkWell(
            onTap: onEditTap, // Navigate to media picker
            child: Center(
              child: Icon(Icons.add_photo_alternate_outlined,
                  size: 40, color: Colors.grey[400]),
            ),
          ),
        ),
      ),
    );
  }

  // --- NEW: Empty Prompt Slot ---
  Widget _buildEmptyPromptSlot(int index, VoidCallback onEditTap) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
          color: Colors.grey[50],
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey[200]!)),
      child: Material(
        // Wrap with Material for InkWell effect
        color: Colors.transparent,
        child: InkWell(
          onTap: onEditTap, // Navigate to prompt selection/writing
          borderRadius: BorderRadius.circular(16), // Match container radius
          child: Padding(
            // Add padding inside InkWell for content
            padding: const EdgeInsets.symmetric(
                vertical: 20), // Adjust vertical padding
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center, // Center content
              children: [
                Icon(Icons.add_circle_outline,
                    color: Colors.grey[400], size: 24),
                const SizedBox(width: 8),
                Text(
                  "Add prompt #${index + 1}",
                  style: GoogleFonts.poppins(
                      fontSize: 16, color: Colors.grey[600]),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildPromptItem(Prompt prompt, {required VoidCallback onEditTap}) {
    // (Keep as is)
    if (prompt.answer.trim().isEmpty && !_isEditing)
      return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.grey[200]!),
        boxShadow: [
          BoxShadow(
              color: Colors.grey.withOpacity(0.06),
              blurRadius: 10,
              offset: const Offset(0, 3))
        ],
      ),
      child: Stack(
        clipBehavior: Clip.none, // Allow button overflow slightly
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(prompt.question.label,
                  style: GoogleFonts.poppins(
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                      color: const Color(0xFF8B5CF6))),
              const SizedBox(height: 10),
              if (prompt.answer.trim().isNotEmpty)
                Text(prompt.answer,
                    style: GoogleFonts.poppins(
                        fontSize: 16,
                        color: Colors.grey[850],
                        height: 1.5,
                        fontWeight: FontWeight.w500))
              else if (_isEditing)
                Text("Tap edit to add your answer...",
                    style: GoogleFonts.poppins(
                        fontSize: 16,
                        color: Colors.grey[400],
                        fontStyle: FontStyle.italic)),
            ],
          ),
          if (_isEditing) // Show edit button only in edit mode
            Positioned(
              top: -12,
              right: -12,
              child: _buildSmallEditButton(
                  onPressed: onEditTap, tooltip: "Edit Prompt"),
            ),
        ],
      ),
    );
  }

  Widget _buildAudioItem(AudioPromptModel audio,
      {required VoidCallback onEditTap}) {
    // (Keep as is)
    final bool isThisPlaying = _currentAudioUrl == audio.audioUrl && _isPlaying;
    final bool isThisPaused = _currentAudioUrl == audio.audioUrl &&
        !_isPlaying &&
        _audioPlayer.state == PlayerState.paused;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.grey[200]!),
        boxShadow: [
          BoxShadow(
              color: Colors.grey.withOpacity(0.06),
              blurRadius: 10,
              offset: const Offset(0, 3))
        ],
      ),
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          Row(
            children: [
              InkWell(
                onTap: () => _playOrPauseAudio(audio.audioUrl),
                borderRadius: BorderRadius.circular(24),
                child: Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6),
                      borderRadius: BorderRadius.circular(24),
                      boxShadow: [
                        BoxShadow(
                            color: const Color(0xFF8B5CF6).withOpacity(0.3),
                            blurRadius: 8,
                            offset: const Offset(0, 2))
                      ]),
                  child: Icon(
                      isThisPlaying
                          ? Icons.pause_rounded
                          : Icons.play_arrow_rounded,
                      color: Colors.white,
                      size: 28),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(audio.prompt.label,
                        style: GoogleFonts.poppins(
                            fontSize: 15,
                            fontWeight: FontWeight.w500,
                            color: const Color(0xFF1A1A1A))),
                    const SizedBox(height: 4),
                    Text(
                        isThisPlaying
                            ? "Playing..."
                            : (isThisPaused ? "Paused" : "Tap to listen"),
                        style: GoogleFonts.poppins(
                            fontSize: 13, color: Colors.grey[600])),
                  ],
                ),
              ),
            ],
          ),
          if (_isEditing)
            Positioned(
              top: -12,
              right: -12,
              child: _buildSmallEditButton(
                  onPressed: onEditTap, tooltip: "Edit Voice Prompt"),
            ),
        ],
      ),
    );
  }

  Widget _buildVitalsBlock(UserModel user, {required VoidCallback onEditTap}) {
    // (Keep as is)
    final List<Widget> vitals = [];
    if (user.height != null && user.height!.isNotEmpty)
      vitals.add(_buildEditableChip(
          icon: Icons.height_rounded,
          label: user.height!,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const HeightSelectionScreen(isEditing: true)))));
    if (user.religiousBeliefs != null)
      vitals.add(_buildEditableChip(
          icon: Icons.church_outlined,
          label: user.religiousBeliefs!.label,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const ReligionScreen(isEditing: true)))));
    // Editable Job/Edu via this block's edit button
    if (user.jobTitle != null && user.jobTitle!.isNotEmpty)
      vitals.add(_buildEditableChip(
          icon: Icons.work_outline_rounded,
          label: user.jobTitle!,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const JobTitleScreen(isEditing: true)))));
    if (user.education != null && user.education!.isNotEmpty)
      vitals.add(_buildEditableChip(
          icon: Icons.school_outlined,
          label: user.education!,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const StudyLocationScreen(isEditing: true)))));
    // Editable Habits
    if (user.drinkingHabit != null)
      vitals.add(_buildEditableChip(
          icon: Icons.local_bar_outlined,
          label: "Drinks: ${user.drinkingHabit!.label}",
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const DrinkingScreen(isEditing: true)))));
    if (user.smokingHabit != null)
      vitals.add(_buildEditableChip(
          icon: Icons.smoking_rooms_outlined,
          label: "Smokes: ${user.smokingHabit!.label}",
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const SmokingScreen(isEditing: true)))));

    // Add "Add" buttons if editing and field is empty
    if (_isEditing) {
      if (user.height == null || user.height!.isEmpty)
        vitals.add(_buildAddChip(
            label: "Add Height",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const HeightSelectionScreen(isEditing: true)))));
      if (user.religiousBeliefs == null)
        vitals.add(_buildAddChip(
            label: "Add Religion",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const ReligionScreen(isEditing: true)))));
      if (user.jobTitle == null || user.jobTitle!.isEmpty)
        vitals.add(_buildAddChip(
            label: "Add Job",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const JobTitleScreen(isEditing: true)))));
      if (user.education == null || user.education!.isEmpty)
        vitals.add(_buildAddChip(
            label: "Add Education",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const StudyLocationScreen(isEditing: true)))));
      if (user.drinkingHabit == null)
        vitals.add(_buildAddChip(
            label: "Add Drinking Habit",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const DrinkingScreen(isEditing: true)))));
      if (user.smokingHabit == null)
        vitals.add(_buildAddChip(
            label: "Add Smoking Habit",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const SmokingScreen(isEditing: true)))));
    }

    if (vitals.isEmpty && !_isEditing) return const SizedBox.shrink();
    if (vitals.isEmpty && _isEditing)
      return _buildEmptySection("Vitals & Habits", "Add more details!",
          Icons.list_alt_rounded, onEditTap);

    return Container(
        width: double.infinity,
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey[200]!),
          boxShadow: [
            BoxShadow(
                color: Colors.grey.withOpacity(0.06),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ],
        ),
        child: Stack(clipBehavior: Clip.none, children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(
                padding: const EdgeInsets.only(bottom: 12.0),
                child: Text("Vitals & Habits",
                    style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: const Color(0xFF1A1A1A))),
              ),
              Wrap(spacing: 8, runSpacing: 8, children: vitals),
            ],
          ),
          if (_isEditing)
            Positioned(
              top: -12,
              right: -12,
              child: _buildSmallEditButton(
                  onPressed: onEditTap, tooltip: "Edit Vitals"),
            ),
        ]));
  }

  // --- Editable Chip Widget --- (Keep as is)
  Widget _buildEditableChip({
    required IconData icon,
    required String label,
    required VoidCallback onEditTap,
    bool subtle = false,
  }) {
    if (label.isEmpty) return const SizedBox.shrink();
    return InkWell(
      onTap: _isEditing ? onEditTap : null,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
        decoration: BoxDecoration(
          color: subtle ? Colors.transparent : Colors.grey[100],
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
              color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon,
                size: subtle ? 16 : 18,
                color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6)),
            const SizedBox(width: 6),
            Flexible(
                child: Text(label,
                    style: GoogleFonts.poppins(
                        fontSize: subtle ? 13 : 14,
                        fontWeight: FontWeight.w500,
                        color:
                            subtle ? Colors.grey.shade700 : Colors.grey[800]),
                    overflow: TextOverflow.ellipsis)),
            if (_isEditing) ...[
              const SizedBox(width: 6),
              Icon(Icons.edit, size: 14, color: Colors.grey[500]),
            ]
          ],
        ),
      ),
    );
  }

  // --- Add Chip Widget --- (Keep as is)
  Widget _buildAddChip({
    required String label,
    required VoidCallback onAddTap,
    bool subtle = false,
  }) {
    return InkWell(
      onTap: onAddTap,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
        decoration: BoxDecoration(
          color: Colors.transparent,
          borderRadius: BorderRadius.circular(20),
          border:
              Border.all(color: Colors.grey.shade400, style: BorderStyle.solid),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.add_circle_outline,
                size: subtle ? 16 : 18, color: Colors.grey.shade600),
            const SizedBox(width: 6),
            Flexible(
                child: Text(label,
                    style: GoogleFonts.poppins(
                        fontSize: subtle ? 13 : 14,
                        fontWeight: FontWeight.w500,
                        color: Colors.grey.shade700),
                    overflow: TextOverflow.ellipsis)),
          ],
        ),
      ),
    );
  }

  // Helper to navigate to the start of the vitals editing flow (Keep as is)
  void _navigateToVitalsEditFlow() {
    Navigator.push(
        context,
        MaterialPageRoute(
            builder: (context) =>
                const HeightSelectionScreen(isEditing: true)));
  }
} // End of _ProfileScreenState



================================================
File: views/prompt.dart
================================================
// File: lib/views/prompt.dart
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/audioprompt.dart'; // Keep for onboarding flow
// Removed unused audiopromptsselect import
// Removed unused media import
import 'package:dtx/views/textpromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';

class ProfileAnswersScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const ProfileAnswersScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<ProfileAnswersScreen> createState() =>
      _ProfileAnswersScreenState();
}

class _ProfileAnswersScreenState extends ConsumerState<ProfileAnswersScreen> {
  // Removed _isForwardButtonEnabled - logic handled by checking prompt count now

  // --- No need for initState/updateForwardButtonState ---

  void _handlePromptTap(Prompt? prompt, int index) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => TextSelectPromptScreen(
          editIndex: prompt != null ? index : null,
          isEditing: widget.isEditing, // <<< Pass editing flag
        ),
      ),
    ); // No need for .then() as UI updates reactively
  }

  void _handleRemovePrompt(int index) {
    // Add confirmation dialog?
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text("Remove Prompt?"),
        content:
            const Text("Are you sure you want to remove this prompt answer?"),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: const Text("Cancel"),
          ),
          TextButton(
            onPressed: () {
              ref.read(userProvider.notifier).removePromptAtIndex(index);
              Navigator.pop(dialogContext);
            },
            child: const Text("Remove", style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  void _handleNext() {
    final prompts = ref.read(userProvider).prompts;
    // Onboarding requires at least one prompt
    if (!widget.isEditing &&
        prompts.where((p) => p.answer.trim().isNotEmpty).isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text("Please answer at least one prompt.",
              style: GoogleFonts.poppins()),
          backgroundColor: Colors.red[400],
        ),
      );
      return;
    }

    if (widget.isEditing) {
      print("[ProfileAnswersScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[ProfileAnswersScreen] Onboarding next: Audio Prompt.");
      Navigator.pushReplacement(
        // Use replacement for onboarding
        context,
        MaterialPageRoute(builder: (context) => const VoicePromptScreen()),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);
    final prompts = userState.prompts;
    final bool canProceed =
        prompts.where((p) => p.answer.trim().isNotEmpty).isNotEmpty;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: 0, // No back button needed here typically
                  right: 0,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder for onboarding alignment
                      const SizedBox(width: 48),
                    Text(
                      widget.isEditing ? "Edit Prompts" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed:
                            _handleNext, // Always enabled for edit? Or check canProceed? Let's allow saving empty.
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: const Color(0xFF8B5CF6), // Always enabled
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for onboarding
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              const SizedBox(height: 20), // Reduced top space
              Text(
                widget.isEditing ? "Edit Your Prompts" : "Profile Prompts",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? 28
                      : 36, // Slightly smaller title in edit
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 12),
              Text(
                widget.isEditing
                    ? "Tap a prompt to edit or remove it."
                    : "Share three interesting facts about yourself",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 40),
              Expanded(
                child: ListView.separated(
                  itemCount: 3,
                  separatorBuilder: (_, __) => const SizedBox(height: 24),
                  itemBuilder: (context, index) {
                    final prompt =
                        index < prompts.length ? prompts[index] : null;
                    return _buildPromptCard(prompt, index);
                  },
                ),
              ),
              const SizedBox(height: 16),
              // --- Hide Bottom Bar in Edit Mode ---
              if (!widget.isEditing)
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Text(
                      "At least 1 prompt required",
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        color: Colors.grey[600],
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                    _buildForwardButton(canProceed), // Pass enabled state
                  ],
                ),
              // --- End Hide Bottom Bar ---
              SizedBox(
                  height: widget.isEditing ? 16 : 32), // Adjust bottom padding
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPromptCard(Prompt? prompt, int index) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: prompt != null ? const Color(0xFF8B5CF6) : Colors.grey[300]!,
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(16),
          onTap: () => _handlePromptTap(prompt, index),
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        prompt?.question.label ?? "Add a prompt",
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w500,
                          color: prompt != null
                              ? Colors.black87
                              : Colors.grey[700],
                        ),
                      ),
                    ),
                    // Show Edit or Add Icon
                    Icon(
                      prompt != null
                          ? Icons.edit_outlined
                          : Icons.add_circle_outline,
                      color: const Color(0xFF8B5CF6),
                      size: 24,
                    ),
                    // Add Remove Icon if editing and prompt exists
                    if (widget.isEditing && prompt != null) ...[
                      const SizedBox(width: 10),
                      IconButton(
                        icon: Icon(Icons.delete_outline,
                            color: Colors.redAccent.withOpacity(0.7), size: 24),
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                        tooltip: "Remove Prompt",
                        onPressed: () => _handleRemovePrompt(index),
                      ),
                    ]
                  ],
                ),
                if (prompt?.answer.isNotEmpty ?? false) ...[
                  const SizedBox(height: 12),
                  Text(
                    prompt!.answer,
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey[700], // Slightly muted answer color
                      height: 1.4,
                    ),
                    maxLines: 3, // Limit display lines
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  // Onboarding Forward Button
  Widget _buildForwardButton(bool isEnabled) {
    return GestureDetector(
      onTap: isEnabled ? _handleNext : null,
      child: Container(
        width: 70,
        height: 70,
        decoration: BoxDecoration(
          color: isEnabled ? const Color(0xFF8B5CF6) : Colors.grey.shade400,
          borderRadius: BorderRadius.circular(35),
          boxShadow: [
            if (isEnabled)
              BoxShadow(
                color: const Color(0xFF8B5CF6).withOpacity(0.3),
                blurRadius: 12,
                offset: const Offset(0, 4),
              ),
          ],
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          color: isEnabled ? Colors.white : Colors.grey.shade600,
          size: 32,
        ),
      ),
    );
  }
}



================================================
File: views/religion.dart
================================================
// File: lib/views/religion.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/drinking.dart'; // Keep for onboarding flow

class ReligionScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const ReligionScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<ReligionScreen> createState() => _ReligionScreenState();
}

class _ReligionScreenState extends ConsumerState<ReligionScreen> {
  Religion? _selectedReligion; // Local state

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _selectedReligion = ref.read(userProvider).religiousBeliefs;
    }
  }

  void _handleNext() {
    if (_selectedReligion != null) {
      ref.read(userProvider.notifier).updateReligiousBeliefs(_selectedReligion);
      if (widget.isEditing) {
        print("[ReligionScreen] Editing done, popping back.");
        Navigator.of(context).pop();
      } else {
        // Original onboarding navigation
        print("[ReligionScreen] Onboarding next: Drinking.");
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const DrinkingScreen()));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder for alignment in onboarding
                      const SizedBox(
                          width: 48), // Matches IconButton width approx

                    Text(
                      widget.isEditing ? "Edit Religion" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    if (widget.isEditing)
                      TextButton(
                        onPressed:
                            _selectedReligion != null ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: _selectedReligion != null
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for alignment in onboarding
                      const SizedBox(
                          width: 48), // Matches TextButton width approx
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),
              Text(
                widget.isEditing
                    ? "Edit your religious beliefs"
                    : "What are your religious beliefs?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),
              SizedBox(height: screenSize.height * 0.05),
              Wrap(
                spacing: screenSize.width * 0.03,
                runSpacing: screenSize.height * 0.015,
                children: Religion.values
                    .map((religion) =>
                        _buildReligionButton(religion, screenSize))
                    .toList(),
              ),
              const Spacer(),
              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Padding(
                  padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      GestureDetector(
                        onTap: _selectedReligion != null ? _handleNext : null,
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: _selectedReligion != null
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey.shade300,
                            borderRadius: BorderRadius.circular(35),
                          ),
                          child: const Icon(
                            Icons.arrow_forward_rounded,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildReligionButton(Religion religion, Size screenSize) {
    bool isSelected = _selectedReligion == religion; // Use local state
    return GestureDetector(
      onTap: () =>
          setState(() => _selectedReligion = religion), // Update local state
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.015),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
          borderRadius: BorderRadius.circular(25),
          border: Border.all(color: Colors.grey.shade300, width: 1.0),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              religion.label,
              style: GoogleFonts.poppins(
                fontSize: 18,
                fontWeight: FontWeight.w500,
                color: isSelected ? Colors.white : Colors.black87,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/selfie_capture_screen.dart
================================================
// File: views/selfie_capture_screen.dart
import 'dart:async';
import 'dart:io';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/views/verification_pending_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:camera/camera.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class SelfieCaptureScreen extends ConsumerStatefulWidget {
  const SelfieCaptureScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<SelfieCaptureScreen> createState() => _SelfieCaptureScreenState();
}

class _SelfieCaptureScreenState extends ConsumerState<SelfieCaptureScreen>
    with WidgetsBindingObserver {
  CameraController? _cameraController;
  List<CameraDescription> _cameras = [];
  bool _isCameraInitialized = false;
  bool _hasError = false;
  double _aspectRatio = 1.0;
  bool _isUploading = false; // Track uploading state

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initializeCamera();
  }

  Future<void> _initializeCamera() async {
    try {
      _cameras = await availableCameras();
      if (_cameras.isEmpty) throw Exception('No cameras available');

      final frontCamera = _cameras.firstWhere(
        (camera) => camera.lensDirection == CameraLensDirection.front,
        orElse: () => _cameras.first,
      );

      _cameraController = CameraController(
        frontCamera,
        ResolutionPreset.medium,
        enableAudio: false,
      );

      await _cameraController!.initialize();
      
      final previewSize = _cameraController!.value.previewSize!;
      _aspectRatio = previewSize.width / previewSize.height;

      if (mounted) setState(() => _isCameraInitialized = true);
      
    } catch (e) {
      if (mounted) setState(() => _hasError = true);
      print('Camera Error: $e');
    }
  }

  Widget _buildCameraPreview() {
    if (_hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, color: Colors.white, size: 50),
            const SizedBox(height: 20),
            Text(
              'Camera Error',
              style: GoogleFonts.poppins(color: Colors.white, fontSize: 20),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: _initializeCamera,
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF8B5CF6),
              ),
              child: Text(
                'Retry',
                style: GoogleFonts.poppins(color: Colors.white),
              ),
            ),
          ],
        ),
      );
    }

    if (!_isCameraInitialized || _cameraController == null) {
      return const Center(
        child: CircularProgressIndicator(color: Color(0xFF8B5CF6)),
      );
    }

    return AspectRatio(
      aspectRatio: _aspectRatio,
      child: CameraPreview(_cameraController!),
    );
  }

  Future<void> _captureImage() async {
    if (!_isCameraInitialized || _cameraController == null) return;

    try {
      setState(() => _isUploading = true);

      final image = await _cameraController!.takePicture();
      final imageFile = File(image.path);

      // Set verification image in provider
      ref.read(mediaUploadProvider.notifier).setVerificationImage(imageFile);

      // Upload verification image
      final success = await ref.read(mediaUploadProvider.notifier).uploadVerificationImage();

      setState(() => _isUploading = false);

      if (success) {
        // Navigate to verification pending screen
        if (mounted) {
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (context) => const VerificationPendingScreen()),
          );
        }
      } else {
        // Handle upload failure
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to upload verification image. Please try again.')),
        );
      }
    } catch (e) {
      setState(() => _isUploading = false);
      print('Capture Error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Capture Error: ${e.toString()}')),
      );
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _cameraController?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Stack(
          children: [
            Column(
              children: [
                // Header
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.arrow_back, color: Colors.white),
                        onPressed: () => Navigator.pop(context),
                      ),
                      Text(
                        "Take Selfie",
                        style: GoogleFonts.poppins(
                          color: Colors.white,
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
                Expanded(
                  child: _buildCameraPreview(),
                ),
              ],
            ),

            // Loading indicator overlay
            if (_isUploading)
              Container(
                color: Colors.black.withOpacity(0.5),
                child: const Center(
                  child: CircularProgressIndicator(
                    color: Color(0xFF8B5CF6),
                  ),
                ),
              ),
          ],
        ),
      ),
      floatingActionButton: !_isUploading ? FloatingActionButton(
        backgroundColor: const Color(0xFF8B5CF6),
        onPressed: _captureImage,
        child: const Icon(Icons.camera_alt, color: Colors.white),
      ) : null,
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
    );
  }
}



================================================
File: views/settings_screen.dart
================================================
// File: lib/views/settings_screen.dart
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class SettingsScreen extends ConsumerWidget {
  const SettingsScreen({super.key});

  Future<void> _showLogoutConfirmationDialog(
      BuildContext context, WidgetRef ref) async {
    return showDialog<void>(
      context: context,
      barrierDismissible: false, // User must tap button!
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text('Confirm Logout',
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          content: Text('Are you sure you want to log out?',
              style: GoogleFonts.poppins()),
          actions: <Widget>[
            TextButton(
              child: Text('Cancel',
                  style: GoogleFonts.poppins(color: Colors.grey)),
              onPressed: () {
                Navigator.of(dialogContext).pop(); // Close the dialog
              },
            ),
            TextButton(
              child: Text('Logout',
                  style: GoogleFonts.poppins(color: Colors.redAccent)),
              onPressed: () async {
                Navigator.of(dialogContext).pop(); // Close the dialog first
                await _performLogout(context, ref); // Perform logout
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _performLogout(BuildContext context, WidgetRef ref) async {
    print("[SettingsScreen] Performing logout...");
    // Call the logout method from the auth provider
    await ref.read(authProvider.notifier).logout();
    print("[SettingsScreen] Logout complete. Navigating to SignInScreen.");

    // Navigate to the sign-in screen and remove all previous routes
    // Check if context is still valid before navigating
    if (context.mounted) {
      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (context) => const GoogleSignInScreen()),
        (Route<dynamic> route) => false, // Remove all routes
      );
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      backgroundColor: Colors.grey[100], // Light background for settings
      appBar: AppBar(
        title: Text(
          'Settings',
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
        ),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 1,
      ),
      body: ListView(
        padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 16),
        children: [
          // Example Setting (can add more later)
          // ListTile(
          //   leading: Icon(Icons.notifications_outlined, color: Colors.grey[700]),
          //   title: Text('Notifications', style: GoogleFonts.poppins()),
          //   trailing: Icon(Icons.arrow_forward_ios_rounded, size: 16, color: Colors.grey[500]),
          //   onTap: () {
          //     // TODO: Navigate to Notification Settings
          //   },
          // ),
          // Divider(), // Separator

          // Logout Option
          ListTile(
            leading: Icon(Icons.logout_rounded, color: Colors.redAccent[200]),
            title: Text('Logout',
                style: GoogleFonts.poppins(color: Colors.redAccent[200])),
            onTap: () => _showLogoutConfirmationDialog(context, ref),
          ),
          Divider(),
        ],
      ),
    );
  }
}



================================================
File: views/smoking.dart
================================================
// File: lib/views/smoking.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/media.dart'; // Keep for onboarding flow

class SmokingScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const SmokingScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<SmokingScreen> createState() => _SmokingScreenState();
}

class _SmokingScreenState extends ConsumerState<SmokingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedSmokingHabit; // Local state
  // Removed _isOptionSelected
  late AnimationController _controller; // Keep for animations if desired
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );

    // Load initial value if editing
    if (widget.isEditing) {
      _selectedSmokingHabit = ref.read(userProvider).smokingHabit;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleNext() {
    if (_selectedSmokingHabit != null) {
      ref.read(userProvider.notifier).updateSmokingHabit(_selectedSmokingHabit);
      if (widget.isEditing) {
        print("[SmokingScreen] Editing done, popping back.");
        Navigator.of(context).pop();
      } else {
        // Original onboarding navigation
        print("[SmokingScreen] Onboarding next: Media.");
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const MediaPickerScreen()));
      }
    } else {
      if (!widget.isEditing) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content:
                Text("Please select an option", style: GoogleFonts.poppins()),
            backgroundColor: Colors.red[400],
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically
    final bool canProceed = _selectedSmokingHabit != null; // Check local state

    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder icon for onboarding
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: const Icon(Icons.smoking_rooms_rounded,
                            color: Color(0xFF8B5CF6),
                            size: 30), // Slightly smaller
                      ),
                    Text(
                      widget.isEditing ? "Edit Smoking Habit" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canProceed ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for onboarding
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.03),
              Text(
                widget.isEditing ? "Edit your smoking habits" : "Do you smoke?",
                textAlign: TextAlign.left,
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.07
                      : screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  height: 1.1,
                ),
              ),
              if (!widget.isEditing) // Show subtitle only during onboarding
                Text(
                  "Select your smoking habits",
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    color: Colors.grey[600],
                    height: 1.5,
                  ),
                ),
              SizedBox(height: screenSize.height * 0.04),
              Expanded(
                child: ListView.separated(
                  itemCount: DrinkingSmokingHabits.values.length,
                  separatorBuilder: (context, index) =>
                      const SizedBox(height: 12),
                  itemBuilder: (context, index) {
                    final habit = DrinkingSmokingHabits.values[index];
                    return _buildSmokingOptionTile(
                      screenSize: screenSize,
                      title: habit.label,
                      value: habit,
                    );
                  },
                ),
              ),
              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: AnimatedScale(
                      scale: canProceed ? 1.0 : 0.95, // Use local state
                      duration: const Duration(milliseconds: 200),
                      child: GestureDetector(
                        onTap: _handleNext, // Use unified handler
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey.shade300,
                            borderRadius: BorderRadius.circular(35),
                            boxShadow: canProceed
                                ? [
                                    BoxShadow(
                                      color: const Color(0xFF8B5CF6)
                                          .withOpacity(0.3),
                                      blurRadius: 8,
                                      offset: const Offset(0, 4),
                                    ),
                                  ]
                                : null,
                          ),
                          child: Icon(
                            Icons.arrow_forward_rounded,
                            color: canProceed
                                ? Colors.white
                                : Colors.grey.shade600,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSmokingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedSmokingHabit == value; // Use local state

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedSmokingHabit = value; // Update local state
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/splash_screen.dart
================================================
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart'; // Import FilterProvider
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:dtx/views/location.dart';
import 'package:dtx/views/main_navigation_screen.dart'; // Import MainNavigationScreen
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
// Removed FeedType import
// Removed NameInputScreen import
// Removed Home import

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnim;
  late Animation<double> _scaleAnim;
  bool _animationComplete = false;
  bool _statusCheckComplete = false;
  AuthStatus _authStatus = AuthStatus.unknown;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
    _checkAuthStatus();
  }

  void _setupAnimation() {
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );

    _fadeAnim = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.0, 0.8, curve: Curves.easeIn),
      ),
    );

    _scaleAnim = Tween<double>(begin: 0.7, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.elasticOut,
      ),
    );

    _controller.forward();

    Future.delayed(const Duration(milliseconds: 2000), () {
      if (mounted) {
        setState(() {
          _animationComplete = true;
        });
        _navigateIfReady();
      }
    });
  }

  Future<void> _checkAuthStatus() async {
    print('[SplashScreen] Checking Auth Status...');
    try {
      final status = await ref
          .read(authProvider.notifier)
          .checkAuthStatus(updateState: false);
      print('[SplashScreen] Auth Status Check Result: $status');

      if (!mounted) return;

      setState(() {
        _authStatus = status;
        _statusCheckComplete = true;
      });
      _navigateIfReady();
    } catch (e) {
      print('[SplashScreen] Error during Auth Status Check: $e');
      if (!mounted) return;
      setState(() {
        _authStatus = AuthStatus.login; // Default to login on error
        _statusCheckComplete = true;
      });
      _navigateIfReady();
    }
  }

  void _initiateEarlyFetches() {
    print("[SplashScreen] Initiating early data fetches (Filters, HomeFeed).");
    // Don't await, let them run in background
    ref.read(filterProvider.notifier).loadFilters();
    ref.read(feedProvider.notifier).fetchFeed();
  }

  void _navigateIfReady() {
    print(
        '[SplashScreen] Navigate If Ready: Animation Complete=$_animationComplete, Status Check Complete=$_statusCheckComplete, Status=$_authStatus');

    if (_animationComplete && _statusCheckComplete) {
      print('[SplashScreen] Conditions met. Navigating...');
      Widget destination;

      switch (_authStatus) {
        case AuthStatus.home:
        case AuthStatus
              .onboarding2: // Both home and onboarding2 go to main screen
          print('[SplashScreen] Navigating to MainNavigationScreen');
          _initiateEarlyFetches(); // Start loading data needed for MainNavigationScreen
          destination = const MainNavigationScreen();
          break;
        case AuthStatus.onboarding1:
          print('[SplashScreen] Navigating to LocationInputScreen');
          destination = const LocationInputScreen();
          break;
        case AuthStatus.login:
        case AuthStatus.unknown:
        default:
          print('[SplashScreen] Navigating to GoogleSignInScreen');
          destination = const GoogleSignInScreen();
          break;
      }

      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (_) => destination),
      );
    } else {
      print('[SplashScreen] Conditions not met. Waiting...');
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Build method remains largely the same, only navigation logic changed
    final Size screenSize = MediaQuery.of(context).size;
    final double responsiveFontSize = screenSize.width * 0.18;
    final double subtitleFontSize = screenSize.width * 0.04;
    final double bottomPadding = screenSize.height * 0.05;

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF4C1D95), Color(0xFF7C3AED), Color(0xFF8B5CF6)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Stack(
          children: [
            Center(
              child: AnimatedBuilder(
                animation: _controller,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Transform.scale(
                      scale: _scaleAnim.value,
                      child: FittedBox(
                        fit: BoxFit.scaleDown,
                        child: Text(
                          'Peeple',
                          style: GoogleFonts.pacifico(
                            fontSize: responsiveFontSize,
                            color: Colors.white,
                            shadows: [
                              Shadow(
                                color: Colors.black.withOpacity(0.6),
                                blurRadius: 15,
                                offset: const Offset(0, 4),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
            Positioned(
              bottom: bottomPadding,
              left: 0,
              right: 0,
              child: AnimatedBuilder(
                animation: _fadeAnim,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Text(
                      'Connect. Share. Thrive.',
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                        color: Colors.white.withOpacity(0.9),
                        fontSize: subtitleFontSize,
                        fontWeight: FontWeight.w300,
                        letterSpacing: 0.5,
                      ),
                    ),
                  );
                },
              ),
            ),
            if (_animationComplete && !_statusCheckComplete)
              Positioned(
                bottom: bottomPadding + 50,
                left: 0,
                right: 0,
                child: const Center(
                  child: SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(
                      strokeWidth: 2.5,
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/study.dart
================================================
// File: lib/views/study.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/religion.dart'; // Keep for onboarding flow

class StudyLocationScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const StudyLocationScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<StudyLocationScreen> createState() =>
      _StudyLocationScreenState();
}

class _StudyLocationScreenState extends ConsumerState<StudyLocationScreen> {
  final TextEditingController _studyLocationController =
      TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _studyLocationController.text = ref.read(userProvider).education ?? '';
    }
    // Add listener to enable/disable Done button in edit mode if needed
    _studyLocationController.addListener(() {
      if (widget.isEditing) setState(() {});
    });
  }

  @override
  void dispose() {
    _studyLocationController.dispose();
    super.dispose();
  }

  void _handleNext() {
    String? education;
    if (_studyLocationController.text.trim().isNotEmpty) {
      education = _studyLocationController.text.trim();
    } else {
      education = null; // Explicitly set to null if empty
    }
    ref.read(userProvider.notifier).updateEducation(education);

    if (widget.isEditing) {
      print("[StudyLocationScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[StudyLocationScreen] Onboarding next: Religion.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const ReligionScreen()));
    }
  }

  void _handleSkipOrClear() {
    FocusScope.of(context).unfocus();
    _studyLocationController.clear(); // Clear text field
    ref
        .read(userProvider.notifier)
        .updateEducation(null); // Update provider to null
    if (widget.isEditing) {
      print("[StudyLocationScreen] Clearing field and popping back.");
      Navigator.of(context).pop(); // Pop back immediately after clearing
    } else {
      // Original onboarding skip navigation
      print("[StudyLocationScreen] Skipping to Religion.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const ReligionScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      IconButton(
                        // Keep original icon for onboarding
                        icon: const Icon(Icons.school_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {}, // No action needed here
                      ),

                    Text(
                      widget.isEditing ? "Edit Education" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    // Show "Done" in edit mode, "Skip" in onboarding
                    if (widget.isEditing)
                      TextButton(
                        onPressed: _handleNext, // Always enabled
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color:
                                const Color(0xFF8B5CF6), // Always enabled color
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      TextButton(
                        onPressed: _handleSkipOrClear, // Use unified handler
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                              fontSize: 16, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),

              // Question Text
              Text(
                widget.isEditing
                    ? "Edit where you studied"
                    : "Where did you study?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),

              SizedBox(height: screenSize.height * 0.05),

              // Text Field
              Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                child: TextField(
                  controller: _studyLocationController,
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    color: Colors.black87,
                  ),
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    hintText: "e.g., IIT Delhi",
                    hintStyle: GoogleFonts.poppins(
                      fontSize: 22,
                      color: Colors.grey.shade500,
                    ),
                    border: const UnderlineInputBorder(
                      borderSide: BorderSide(color: Colors.grey, width: 1.0),
                    ),
                    focusedBorder: const UnderlineInputBorder(
                      borderSide:
                          BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                    ),
                    // Add clear button in edit mode if text exists
                    suffixIcon: widget.isEditing &&
                            _studyLocationController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, color: Colors.grey),
                            onPressed: () {
                              _studyLocationController.clear();
                            },
                          )
                        : null,
                  ),
                ),
              ),

              const Spacer(),

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: GestureDetector(
                      onTap: _handleNext, // Always enabled for onboarding
                      child: Container(
                        width: 70,
                        height: 70,
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(35),
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/textpromptsselect.dart
================================================
// File: lib/views/textpromptsselect.dart
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Import Riverpod
import 'package:dtx/providers/user_provider.dart'; // Import UserProvider
import 'package:dtx/utils/app_enums.dart';
import 'package:google_fonts/google_fonts.dart'; // Import GoogleFonts

// Change StatefulWidget to ConsumerStatefulWidget
class TextSelectPromptScreen extends ConsumerStatefulWidget {
  final int? editIndex;
  final bool isEditing;

  const TextSelectPromptScreen({
    super.key,
    this.editIndex,
    this.isEditing = false,
  });

  @override
  ConsumerState<TextSelectPromptScreen> createState() =>
      _TextSelectPromptScreenState();
}

// Change State to ConsumerState
class _TextSelectPromptScreenState
    extends ConsumerState<TextSelectPromptScreen> {
  PromptCategory selectedCategory = PromptCategory.storyTime;
  bool showAllPrompts = false;

  List<PromptType> get currentPrompts {
    if (showAllPrompts) {
      return PromptCategory.values
          .expand((category) => category.getPrompts())
          .toList();
    }
    return selectedCategory.getPrompts();
  }

  // Function to check for duplicates
  bool _isDuplicate(PromptType selectedPromptType) {
    final existingPrompts = ref.read(userProvider).prompts;
    for (int i = 0; i < existingPrompts.length; i++) {
      // Skip check if editing the current index
      if (widget.isEditing && widget.editIndex == i) {
        continue;
      }
      if (existingPrompts[i].question == selectedPromptType) {
        return true; // Found a duplicate
      }
    }
    return false; // No duplicate found
  }

  @override
  Widget build(BuildContext context) {
    // Read existing prompts to disable selected ones
    final existingPromptQuestions = ref.watch(userProvider
        .select((user) => user.prompts.map((p) => p.question).toSet()));

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  GestureDetector(
                    onTap: () {
                      setState(() {
                        showAllPrompts = !showAllPrompts;
                      });
                    },
                    child: Text(
                      showAllPrompts ? 'View by Category' : 'View all',
                      style: TextStyle(
                        color: const Color(0xFF8b5cf6),
                        fontSize: 16,
                        fontWeight:
                            showAllPrompts ? FontWeight.bold : FontWeight.w500,
                      ),
                    ),
                  ),
                  Text(
                    'Prompts', // Keep title centered
                    style: GoogleFonts.poppins(
                      // Use GoogleFonts if desired
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () => Navigator.pop(context),
                    child: const Icon(Icons.close),
                  ),
                ],
              ),
            ),
            if (!showAllPrompts)
              SingleChildScrollView(
                // ... Category chips (unchanged) ...
                scrollDirection: Axis.horizontal,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: Row(
                  children: PromptCategory.values.map((category) {
                    final isSelected = category == selectedCategory;
                    return Padding(
                      padding: const EdgeInsets.only(right: 8),
                      child: GestureDetector(
                        onTap: () =>
                            setState(() => selectedCategory = category),
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 20,
                            vertical: 10,
                          ),
                          decoration: BoxDecoration(
                            color: isSelected
                                ? const Color(0xFF8b5cf6)
                                : Colors.white,
                            borderRadius: BorderRadius.circular(20),
                            border: Border.all(
                              color: const Color(0xFF8b5cf6),
                              width: 1,
                            ),
                          ),
                          child: Text(
                            category.label,
                            style: TextStyle(
                              color: isSelected
                                  ? Colors.white
                                  : const Color(0xFF8b5cf6),
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ),
            const SizedBox(height: 16),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: currentPrompts.length,
                itemBuilder: (context, index) {
                  final promptType = currentPrompts[index];
                  final bool isAlreadySelected =
                      existingPromptQuestions.contains(promptType);
                  final bool isEditingThisPrompt = widget.isEditing &&
                      widget.editIndex != null &&
                      ref.read(userProvider).prompts.length >
                          widget.editIndex! &&
                      ref
                              .read(userProvider)
                              .prompts[widget.editIndex!]
                              .question ==
                          promptType;

                  final bool isDisabled = isAlreadySelected &&
                      !isEditingThisPrompt; // Disable if selected elsewhere

                  return GestureDetector(
                    onTap: isDisabled
                        ? null
                        : () async {
                            // Make onTap async
                            final category = promptType.getCategory();
                            // Navigate and wait for result
                            final result = await Navigator.push(
                              // <-- Use await
                              context,
                              MaterialPageRoute(
                                builder: (context) => WriteAnswerScreen(
                                  category: category,
                                  question: promptType,
                                  editIndex: widget.editIndex,
                                  isEditing: widget.isEditing,
                                ),
                              ),
                            );

                            // If NOT editing and WriteAnswerScreen popped with success (true)
                            if (!widget.isEditing &&
                                result == true &&
                                context.mounted) {
                              // Pop this screen (TextSelectPromptScreen) to go back to ProfileAnswersScreen
                              Navigator.pop(context);
                            }
                          },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                      ),
                      child: Text(
                        promptType.label,
                        style: TextStyle(
                          fontSize: 16,
                          // Dim text if disabled
                          color: isDisabled ? Colors.grey[400] : Colors.black87,
                          // Add strike-through if disabled? (Optional)
                          // decoration: isDisabled ? TextDecoration.lineThrough : null,
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/verification_message_screen.dart
================================================

import 'package:dtx/views/home.dart';
import 'package:dtx/views/selfie_capture_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationMessageScreen extends StatelessWidget {
  const VerificationMessageScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40), // Top spacing
              // Illustration or Icon
              Container(
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  shape: BoxShape.circle,
                ),
                child: Center(
                  child: Icon(
                    Icons.verified_user_outlined,
                    size: 100,
                    color: const Color(0xFF8B5CF6),
                  ),
                ),
              ),
              const SizedBox(height: 32),
              // Title
              Text(
                "Profile Verification",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 16),
              // Subtitle/Description
              Text(
                "We are verifying your profile to ensure that no one else can use your photo. This helps us keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),
              const Spacer(), // Pushes the button to the bottom
              // Continue Button
              GestureDetector(
onTap: () {
  // Navigate to HomeScreen
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(builder: (context) => const SelfieCaptureScreen(),
  ));
},
                child: Container(
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 32), // Bottom spacing
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/verification_pending_screen.dart
================================================
// File: views/verification_pending_screen.dart
import 'dart:io';
// Removed FeedType import
// Import MainNavigationScreen
import 'package:dtx/views/main_navigation_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationPendingScreen extends StatelessWidget {
  final File? selfieImage;

  const VerificationPendingScreen({
    Key? key,
    this.selfieImage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              // ... (rest of the build method remains the same until the button) ...
              const SizedBox(height: 40),

              // Selfie preview (keep existing)
              Container(
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: const Color(0xFF8B5CF6),
                    width: 4,
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: const Color(0xFF8B5CF6).withOpacity(0.2),
                      blurRadius: 15,
                      spreadRadius: 5,
                    ),
                  ],
                ),
                child: ClipOval(
                  child: selfieImage != null
                      ? Image.file(
                          selfieImage!,
                          fit: BoxFit.cover,
                        )
                      : Container(
                          color: Colors.grey[200],
                          child: Icon(
                            Icons.person,
                            size: 80,
                            color: Colors.grey[400],
                          ),
                        ),
                ),
              ),
              const SizedBox(height: 32),
              Text(
                "Verification in Progress",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 16),
              Text(
                "We're verifying your profile to ensure no one else can use your photos. This helps keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),
              const SizedBox(height: 24),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 20,
                  vertical: 12,
                ),
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          Color(0xFF8B5CF6),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Text(
                      "Verification in progress",
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF8B5CF6),
                      ),
                    ),
                  ],
                ),
              ),
              const Spacer(),

              // Continue Button - FIXED NAVIGATION
              GestureDetector(
                onTap: () {
                  Navigator.pushAndRemoveUntil(
                    context,
                    MaterialPageRoute(
                      // Navigate to MainNavigationScreen instead of HomeScreen
                      builder: (context) => const MainNavigationScreen(),
                    ),
                    (route) => false, // Remove all previous routes
                  );
                },
                child: Container(
                  /* ... Button container ... */
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue Swiping",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/who_liked_you_screen.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/views/liker_profile_screen.dart';
import 'package:dtx/widgets/basic_liker_profile_card.dart';
import 'package:dtx/widgets/full_liker_profile_card.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class WhoLikedYouScreen extends ConsumerStatefulWidget {
  const WhoLikedYouScreen({super.key});

  @override
  ConsumerState<WhoLikedYouScreen> createState() => _WhoLikedYouScreenState();
}

class _WhoLikedYouScreenState extends ConsumerState<WhoLikedYouScreen> {
  @override
  void initState() {
    super.initState();
    // Fetching is initiated in MainNavigationScreen initState now
  }

  // _navigateToLikerProfile remains the same...
  void _navigateToLikerProfile(int likerUserId) {
    print(
        "[WhoLikedYouScreen] Navigating to profile for liker ID: $likerUserId");
    ref.read(errorProvider.notifier).clearError();
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => LikerProfileScreen(likerUserId: likerUserId),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(receivedLikesProvider);
    // Error watching remains the same
    final generalError = ref.watch(errorProvider);
    final displayError = state.error ?? generalError;

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text("Likes You've Received",
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        elevation: 1,
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        automaticallyImplyLeading: false,
      ),
      body: RefreshIndicator(
        color: const Color(0xFF8B5CF6),
        onRefresh: () async {
          // Clear previous error before refresh if needed
          ref.read(errorProvider.notifier).clearError();
          await ref.read(receivedLikesProvider.notifier).fetchLikes();
        },
        // *** Check isLoading state from the provider ***
        child: state.isLoading // Check the provider's loading state directly
            ? const Center(
                child: CircularProgressIndicator(color: Color(0xFF8B5CF6)))
            : _buildBody(state, displayError), // Pass state and combined error
      ),
    );
  }

  // _buildBody should now assume isLoading is false when called
  Widget _buildBody(ReceivedLikesState state, AppError? error) {
    if (error != null) {
      return _buildErrorState(error.message);
    }

    if (state.fullProfiles.isEmpty && state.otherLikers.isEmpty) {
      return _buildEmptyState();
    }

    // CustomScrollView structure remains the same
    return CustomScrollView(
      slivers: [
        if (state.fullProfiles.isNotEmpty)
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 20, 16, 12),
              child: Text(
                "Recent Likes & Roses",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[800],
                ),
              ),
            ),
          ),
        if (state.fullProfiles.isNotEmpty)
          SliverPadding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            sliver: SliverGrid(
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2,
                crossAxisSpacing: 12,
                mainAxisSpacing: 12,
                childAspectRatio: 0.75,
              ),
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  final liker = state.fullProfiles[index];
                  return FullLikerProfileCard(
                    liker: liker,
                    onTap: () => _navigateToLikerProfile(liker.likerUserId),
                  );
                },
                childCount: state.fullProfiles.length,
              ),
            ),
          ),
        if (state.otherLikers.isNotEmpty)
          SliverToBoxAdapter(
            child: Padding(
              padding: EdgeInsets.fromLTRB(
                  16, state.fullProfiles.isNotEmpty ? 24 : 20, 16, 12),
              child: Text(
                state.fullProfiles.isNotEmpty ? "Older Likes" : "Likes",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[800],
                ),
              ),
            ),
          ),
        if (state.otherLikers.isNotEmpty)
          SliverPadding(
            padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
            sliver: SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  final liker = state.otherLikers[index];
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 10.0),
                    child: BasicLikerProfileCard(
                      liker: liker,
                      onTap: () => _navigateToLikerProfile(liker.likerUserId),
                    ),
                  );
                },
                childCount: state.otherLikers.length,
              ),
            ),
          ),
        const SliverToBoxAdapter(child: SizedBox(height: 20)),
      ],
    );
  }

  // _buildEmptyState and _buildErrorState remain the same
  Widget _buildEmptyState() {
    return LayoutBuilder(
      // Use LayoutBuilder to ensure Center takes full space for scrollable refresh
      builder: (context, constraints) => SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(30.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.favorite_border_rounded,
                      size: 70, color: Colors.grey[300]),
                  const SizedBox(height: 20),
                  Text("No Likes Yet",
                      style: GoogleFonts.poppins(
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey[700])),
                  const SizedBox(height: 10),
                  Text("People who like you will appear here.",
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                          fontSize: 15, color: Colors.grey[500])),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildErrorState(String message) {
    return LayoutBuilder(
      // Use LayoutBuilder for scrollable refresh
      builder: (context, constraints) => SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(30.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline_rounded,
                      size: 60, color: Colors.redAccent[100]),
                  const SizedBox(height: 20),
                  Text("Oops!",
                      style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey[700])),
                  const SizedBox(height: 10),
                  Text(message,
                      style: GoogleFonts.poppins(
                          fontSize: 14, color: Colors.grey[600]),
                      textAlign: TextAlign.center),
                  const SizedBox(height: 20),
                  ElevatedButton.icon(
                    icon: const Icon(Icons.refresh_rounded, size: 18),
                    label: const Text("Retry"),
                    style: ElevatedButton.styleFrom(
                      foregroundColor: Colors.white,
                      backgroundColor: const Color(0xFF8B5CF6),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(20)),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 30, vertical: 12),
                    ),
                    onPressed: () =>
                        ref.read(receivedLikesProvider.notifier).fetchLikes(),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/writeprompt.dart
================================================
// File: lib/views/writeprompt.dart
import 'package:dtx/utils/app_enums.dart';
// Removed unused prompt.dart import
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// Removed unused google_fonts import
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/models/user_model.dart';

class WriteAnswerScreen extends ConsumerStatefulWidget {
  final PromptCategory category;
  final PromptType question;
  final int? editIndex;
  final bool isEditing; // <<< ADDED

  const WriteAnswerScreen({
    super.key,
    required this.category,
    required this.question,
    this.editIndex,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<WriteAnswerScreen> createState() => _WriteAnswerScreenState();
}

class _WriteAnswerScreenState extends ConsumerState<WriteAnswerScreen> {
  late final TextEditingController _answerController;

  @override
  void initState() {
    super.initState();
    _answerController = TextEditingController();
    _loadExistingAnswer();

    // Add listener to update UI when text changes
    _answerController.addListener(() {
      if (mounted) {
        setState(() {}); // Trigger rebuild to enable/disable Done button
      }
    });
  }

  void _loadExistingAnswer() {
    // Load only if editing an *existing* prompt (editIndex is not null)
    if (widget.editIndex != null && widget.isEditing) {
      final prompts = ref.read(userProvider).prompts;
      if (widget.editIndex! < prompts.length) {
        // Check if the question being edited matches the passed question
        // This prevents loading the wrong answer if the user selected a different question for the same slot
        if (prompts[widget.editIndex!].question == widget.question) {
          _answerController.text = prompts[widget.editIndex!].answer;
        } else {
          print(
              "Warning: Editing index ${widget.editIndex} but question changed. Starting fresh.");
        }
      }
    }
  }

  void _saveAnswer() {
    final answerText = _answerController.text.trim();
    bool actionTaken = false; // Flag to check if any action was performed

    if (answerText.isNotEmpty) {
      final newPrompt = Prompt(
        category: widget.category,
        question: widget.question,
        answer: answerText,
      );

      int targetIndex =
          widget.editIndex ?? ref.read(userProvider).prompts.length;

      if (widget.editIndex != null &&
          widget.editIndex! < ref.read(userProvider).prompts.length) {
        ref
            .read(userProvider.notifier)
            .updatePromptAtIndex(widget.editIndex!, newPrompt);
        print("Updated prompt at index: ${widget.editIndex}");
        actionTaken = true;
      } else if (ref.read(userProvider).prompts.length < 3) {
        ref.read(userProvider.notifier).addPrompt(newPrompt);
        print("Added new prompt.");
        actionTaken = true;
      } else {
        print("Error: Cannot add prompt, maximum reached.");
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("You can only have 3 prompts.")));
        return;
      }

      // Navigate back
      if (widget.isEditing) {
        // Pop twice for editing
        int popCount = 0;
        Navigator.of(context).popUntil((route) => popCount++ == 2);
      } else {
        // Onboarding: Pop once and signal success
        Navigator.of(context).pop(true); // <-- Signal success
      }
    } else if (widget.isEditing && widget.editIndex != null) {
      // Handle clearing existing prompt during edit
      print(
          "Removing prompt at index: ${widget.editIndex} due to empty answer.");
      ref.read(userProvider.notifier).removePromptAtIndex(widget.editIndex!);
      actionTaken = true;
      // Pop twice for editing
      int popCount = 0;
      Navigator.of(context).popUntil((route) => popCount++ == 2);
    } else if (!widget.isEditing) {
      // Don't allow saving empty prompt during onboarding if "Done" is pressed
      ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Please enter an answer.")));
      return; // Stay on the screen
    }

    // If no action was taken but user pressed Done (e.g., editing non-existent index with empty text)
    if (!actionTaken) {
      // Just pop back once (likely from TextSelectPromptScreen)
      Navigator.of(context).pop(false); // Signal no change made
    }
  }

  @override
  void dispose() {
    _answerController.dispose(); // Clean up the controller
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final bool canSave = _answerController.text.trim().isNotEmpty;
    // Or, if clearing is allowed via Done button:
    // final bool canSave = true; // Always allow Done, handle empty in _saveAnswer

    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 1,
        centerTitle: true,
        title: Text(
          widget.editIndex != null && widget.isEditing
              ? 'Edit Answer'
              : 'Write Answer', // Dynamic title
          style: const TextStyle(
            color: Colors.black,
            fontSize: 18,
            fontWeight: FontWeight.w700,
          ),
        ),
        leadingWidth: 80,
        leading: GestureDetector(
          onTap: () => Navigator.pop(context), // Always pop back to selection
          child: const Center(
            child: Text(
              'Cancel',
              style: TextStyle(
                color: Color(0xFF8B5CF6),
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ),
        actions: [
          TextButton(
            // Enable based on whether text is present OR if editing an existing prompt (to allow clearing)
            onPressed: canSave || (widget.isEditing && widget.editIndex != null)
                ? _saveAnswer
                : null,
            child: Text(
              'Done',
              style: TextStyle(
                // Adjust color based on combined condition
                color: canSave || (widget.isEditing && widget.editIndex != null)
                    ? const Color(0xFF8B5CF6)
                    : const Color(0xFF8B5CF6).withOpacity(0.5),
                fontSize: 16,
                fontWeight: FontWeight.w700,
              ),
            ),
          ),
        ],
      ),
      body: SingleChildScrollView(
        // Wrap in SingleChildScrollView
        child: Column(
          children: [
            const SizedBox(height: 64),
            Container(
              margin: const EdgeInsets.symmetric(horizontal: 16),
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: const Color(0xFF8B5CF6).withOpacity(0.3),
                  width: 2,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.grey.withOpacity(0.1),
                    spreadRadius: 2,
                    blurRadius: 8,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      widget.question.label,
                      style: const TextStyle(
                        fontSize: 17,
                        fontWeight: FontWeight.w600,
                        color: Colors.black87,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Icon(
                    // Dynamic icon based on action
                    widget.editIndex != null && widget.isEditing
                        ? Icons.edit_note_rounded
                        : Icons.question_answer_outlined,
                    color: const Color(0xFF8B5CF6).withOpacity(0.8),
                    size: 24,
                  ),
                ],
              ),
            ),
            const SizedBox(height: 54),
            Container(
              height: 200,
              margin: const EdgeInsets.symmetric(horizontal: 16),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: const Color(0xFFE5E7EB),
                  width: 1.5,
                ),
              ),
              child: Stack(
                children: [
                  Padding(
                    padding: const EdgeInsets.all(16),
                    child: TextField(
                      controller: _answerController,
                      maxLength: 255,
                      maxLines: null, // Allows multiline input
                      minLines: 5, // Set a minimum line count
                      keyboardType: TextInputType
                          .multiline, // Explicitly set keyboard type
                      textCapitalization:
                          TextCapitalization.sentences, // Capitalize sentences
                      style: const TextStyle(
                        fontSize: 16,
                        color: Colors.black87,
                        height: 1.4,
                      ),
                      decoration: const InputDecoration(
                        border: InputBorder.none,
                        hintText: 'Type your answer here...',
                        hintStyle: TextStyle(
                          color: Color(0xFF94A3B8),
                          fontSize: 16,
                          fontWeight: FontWeight.w400,
                        ),
                        counterText: '', // Hide the default counter
                      ),
                    ),
                  ),
                  Positioned(
                    right: 16,
                    bottom: 16,
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: Colors.grey[100],
                        borderRadius: BorderRadius.circular(6),
                      ),
                      child: Text(
                        // Use characters method for accurate length including newlines
                        '${_answerController.text.characters.length}/255',
                        style: const TextStyle(
                          color: Color(0xFF64748B),
                          fontSize: 13,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 24),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/youtube.dart
================================================
import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:flutter/services.dart'; // Required for Clipboard

// --- Configuration (kept outside the widget for clarity) ---

// Define the necessary YouTube scope
const List<String> _scopes = <String>[
  'https://www.googleapis.com/auth/youtube.readonly',
];

// Instantiate GoogleSignIn with the defined scopes
// You might want to manage this instance more globally in your app
// (e.g., using a service locator or provider) if other parts need it,
// but keeping it here works for a self-contained screen.
final GoogleSignIn _googleSignIn = GoogleSignIn(
  scopes: _scopes,
);

// --- Screen Widget ---

class YoutubeSignInScreen extends StatefulWidget {
  // You can add parameters here if needed, e.g., callbacks for when login succeeds/fails
  // final VoidCallback? onLoginSuccess;
  // final Function(String)? onTokenReceived;

  const YoutubeSignInScreen({
    super.key,
    // this.onLoginSuccess,
    // this.onTokenReceived,
  });

  @override
  State<YoutubeSignInScreen> createState() => _YoutubeSignInScreenState();
}

class _YoutubeSignInScreenState extends State<YoutubeSignInScreen> {
  GoogleSignInAccount? _currentUser;
  String _message = 'Not logged in';
  String? _accessToken; // To store the access token
  bool _isSigningIn = false; // To prevent multiple sign-in attempts
  bool _isFetchingToken = false; // To show progress while getting token

  @override
  void initState() {
    super.initState();

    // Listen for user changes (e.g., sign out from elsewhere or successful sign-in)
    _googleSignIn.onCurrentUserChanged.listen((GoogleSignInAccount? account) {
      // Important: Check if the widget is still mounted before calling setState
      if (mounted) {
        _updateUser(account);
      }
    }).onError((error) {
      // Handle stream errors if necessary
      print("Error listening to user changes: $error");
      if (mounted) {
        setState(() {
          _message = "Error listening for user changes.";
          _currentUser = null;
          _accessToken = null;
        });
      }
    });

    // Try silent sign-in on screen initialization
    // Make sure this doesn't interfere with other login logic in your app
    _googleSignIn.signInSilently().then((account) {
      // No need to call _updateUser here, the listener above will handle it
    }).catchError((err) {
      print('Error during silent sign-in attempt: $err');
      // Don't necessarily show an error here, silent sign-in failing is common
      if (mounted) {
        setState(() {
          _message = 'Not logged in (silent sign-in failed or not available)';
        });
      }
    });
  }

  @override
  void dispose() {
    // It's generally good practice to cancel stream subscriptions,
    // though onCurrentUserChanged might be managed internally by the plugin.
    // If you had custom StreamSubscriptions, you'd cancel them here.
    super.dispose();
  }

  void _updateUser(GoogleSignInAccount? account) async {
    // Check mounted again just to be safe, especially with async operations
    if (!mounted) return;

    setState(() {
      _currentUser = account;
      _accessToken = null; // Reset token when user changes
      _isFetchingToken = account != null; // Start fetching if user is not null
      if (_currentUser != null) {
        _message =
            "Logged in as ${_currentUser!.displayName ?? _currentUser!.email}";
      } else {
        _message = "Not logged in";
      }
    });

    // If user is logged in, print details and get the access token
    if (_currentUser != null) {
      // --- ADDED: Print User Details to Console ---
      print("--- Google User Details ---");
      print(
          "Display Name: ${_currentUser!.displayName ?? 'Not Provided'}"); // Handle potential null display name
      print("Email: ${_currentUser!.email}");
      print("User ID: ${_currentUser!.id}"); // Added User ID as well
      print("---------------------------");
      // --- END ADDED ---

      await _getAccessToken();
    }
  }

  // Function to get the access token
  Future<void> _getAccessToken() async {
    if (_currentUser == null) return;

    // Ensure mounted check before async operation and setState
    if (!mounted) return;

    setState(() {
      _isFetchingToken = true; // Show loading indicator
    });

    try {
      final GoogleSignInAuthentication auth =
          await _currentUser!.authentication;
      if (mounted) {
        // Check again after await
        setState(() {
          _accessToken = auth.accessToken;
          _isFetchingToken = false; // Hide loading indicator
          print("Access Token: $_accessToken"); // Print for debugging
          print("ID Token: ${auth.idToken}"); // Also available
          // Optional: Call a callback if provided via widget constructor
          // widget.onTokenReceived?.call(_accessToken!);
        });
      }
    } catch (err) {
      print('Error getting authentication token: $err');
      if (mounted) {
        // Check again after await
        setState(() {
          _message = 'Error getting token: $err';
          _accessToken = null;
          _isFetchingToken = false; // Hide loading indicator
        });
      }
    }
  }

  // Sign-in function
  Future<void> _handleSignIn() async {
    if (_isSigningIn) return; // Prevent double taps

    if (!mounted) return;
    setState(() {
      _isSigningIn = true;
      _message = "Signing in..."; // Provide feedback
    });

    try {
      // Start the sign-in process
      await _googleSignIn.signIn();
      // The onCurrentUserChanged listener will handle the update upon success.
      // If signIn() returns null (user cancelled), the listener will also get null.
    } catch (error) {
      print('Error signing in: $error');
      if (mounted) {
        // Check after await
        setState(() {
          _message = 'Error signing in: $error';
          _accessToken = null; // Clear token on error
        });
      }
    } finally {
      if (mounted) {
        // Check in finally block
        setState(() {
          _isSigningIn = false; // Allow sign-in attempts again
          // If _currentUser is still null here, sign-in likely failed or was cancelled
          if (_currentUser == null && !_message.startsWith("Error")) {
            _message = "Sign in cancelled or failed.";
          }
        });
      }
    }
  }

  // Sign-out function
  Future<void> _handleSignOut() async {
    if (!mounted) return;

    setState(() {
      _message = "Signing out...";
    });

    try {
      // Disconnect removes permissions, signOut just logs out locally
      await _googleSignIn.disconnect();
      // The onCurrentUserChanged listener handles the UI update.
    } catch (error) {
      print('Error signing out: $error');
      if (mounted) {
        // Check after await
        setState(() {
          // Restore user info if disconnect fails? Or keep logged-out state?
          // Keeping logged-out state might be less confusing.
          _message = 'Error signing out: $error';
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Determine button states
    final bool canSignIn = !_isSigningIn && _currentUser == null;
    final bool canSignOut = _currentUser != null;
    final bool showTokenInfo = _currentUser != null;
    final bool showCopyButton = _accessToken != null;

    return Scaffold(
      // You might want to remove this AppBar if the screen is embedded
      // within another Scaffold that already has one.
      appBar: AppBar(
        title: const Text('YouTube Account Login'),
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment:
                CrossAxisAlignment.center, // Center items horizontally
            children: <Widget>[
              // Display User Info or Status Message
              if (showTokenInfo) ...[
                ListTile(
                  leading: GoogleUserCircleAvatar(identity: _currentUser!),
                  title: Text(_currentUser!.displayName ?? 'No Name'),
                  subtitle: Text(_currentUser!.email),
                  contentPadding: EdgeInsets.zero, // Adjust padding if needed
                ),
                const SizedBox(height: 20),
                const Text("Access Token:",
                    style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 5),
                if (_isFetchingToken)
                  const Padding(
                    padding: EdgeInsets.symmetric(vertical: 10.0),
                    child: CircularProgressIndicator(),
                  )
                else if (_accessToken != null)
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey.shade300),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: SelectableText(
                      _accessToken!,
                      style: const TextStyle(fontSize: 12),
                      textAlign: TextAlign.center,
                      maxLines: 5, // Limit display lines if needed
                      scrollPhysics:
                          const ClampingScrollPhysics(), // Prevent scrolling within text box
                    ),
                  )
                else
                  const Text("Could not retrieve token.",
                      style:
                          TextStyle(color: Colors.red)), // Show if fetch failed
                const SizedBox(height: 10),
                ElevatedButton.icon(
                  icon: const Icon(Icons.copy, size: 16),
                  label: const Text('Copy Token'),
                  onPressed: showCopyButton
                      ? () {
                          Clipboard.setData(ClipboardData(text: _accessToken!));
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text('Access Token Copied!'),
                                duration: Duration(seconds: 2)),
                          );
                        }
                      : null, // Disable button if no token
                ),
              ] else ...[
                // Show Status Message when logged out or during sign-in process
                Text(_message, textAlign: TextAlign.center),
                const SizedBox(height: 20),
              ],

              const Spacer(), // Pushes buttons towards the bottom if desired

              // Sign In / Sign Out Buttons
              if (canSignIn)
                ElevatedButton.icon(
                  icon: const Icon(Icons.login),
                  label: const Text('Sign In with Google'),
                  onPressed: _handleSignIn,
                  style: ElevatedButton.styleFrom(
                      minimumSize:
                          const Size(200, 40)), // Ensure decent button size
                )
              else if (_isSigningIn)
                const CircularProgressIndicator() // Show progress during sign-in action
              else if (canSignOut)
                ElevatedButton.icon(
                  icon: const Icon(Icons.logout),
                  label: const Text('Sign Out & Disconnect'),
                  onPressed: _handleSignOut,
                  style: ElevatedButton.styleFrom(
                      backgroundColor:
                          Colors.redAccent, // Indicate destructive action
                      minimumSize: const Size(200, 40)),
                ),
              const SizedBox(height: 20), // Add some padding at the bottom
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/core/error_handler.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/models/error_model.dart';

class GlobalErrorHandler extends ConsumerWidget {
  final Widget child;
  const GlobalErrorHandler({super.key, required this.child});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final error = ref.watch(errorProvider);

    return Stack(
      children: [
        child,
        if (error != null) _buildErrorOverlay(context, error, ref),
      ],
    );
  }

  Widget _buildErrorOverlay(
      BuildContext context, AppError error, WidgetRef ref) {
    return Positioned.fill(
      child: Material(
        color: Colors.black54,
        child: Center(
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 20),
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  error.message,
                  style: const TextStyle(fontSize: 16),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () =>
                      ref.read(errorProvider.notifier).clearError(),
                  child: const Text('OK'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: widgets/basic_liker_profile_card.dart
================================================
// File: widgets/basic_liker_profile_card.dart
import 'package:dtx/models/like_models.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart'; // For date formatting

class BasicLikerProfileCard extends StatelessWidget {
  final BasicProfileLiker liker;
  final VoidCallback onTap;

  const BasicLikerProfileCard({
    super.key,
    required this.liker,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final timeAgo = liker.likedAt != null
        ? DateFormat.yMd().add_jm().format(liker.likedAt!) // Example format
        : 'Some time ago';

    return InkWell(
      // Make the card tappable
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.grey.shade200),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.03),
              blurRadius: 5,
              offset: const Offset(0, 1),
            )
          ],
        ),
        child: Row(
          children: [
            // Profile Picture Placeholder/Image
            CircleAvatar(
              radius: 25,
              backgroundColor: Colors.grey[200],
              backgroundImage: (liker.firstProfilePicUrl != null)
                  ? NetworkImage(liker.firstProfilePicUrl!)
                  : null,
              child: (liker.firstProfilePicUrl == null)
                  ? Icon(Icons.person, color: Colors.grey[400])
                  : null,
            ),
            const SizedBox(width: 12),
            // Name and Like Info
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    liker.name.isNotEmpty ? liker.name : 'Unknown User',
                    style: GoogleFonts.poppins(
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'Liked you $timeAgo',
                    style: GoogleFonts.poppins(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 8),
            // Rose/Comment Indicators
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                if (liker.isRose)
                  Icon(Icons.star_rounded,
                      color: Colors.purple.shade300, size: 20),
                if (liker.likeComment != null &&
                    liker.likeComment!.isNotEmpty) ...[
                  if (liker.isRose) const SizedBox(width: 4), // Spacing if both
                  Icon(Icons.chat_bubble_outline_rounded,
                      color: Colors.blue.shade300, size: 18),
                ]
              ],
            )
          ],
        ),
      ),
    );
  }
}



================================================
File: widgets/full_liker_profile_card.dart
================================================
// File: widgets/full_liker_profile_card.dart
import 'package:dtx/models/like_models.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart'; // For date formatting

class FullLikerProfileCard extends StatelessWidget {
  // --- FIX: Correct class name ---
  final FullProfileLiker liker;
  // --- END FIX ---
  final VoidCallback onTap;

  const FullLikerProfileCard({
    super.key,
    required this.liker,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final profile = liker.profile;
    final age = profile.age;
    final firstImage = profile.firstMediaUrl;
    final timeAgo = liker.likedAt != null
        ? DateFormat.yMd().add_jm().format(liker.likedAt!) // Example format
        : 'Some time ago';

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(15.0),
      child: Container(
        // Removed fixed height to allow content to define height
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(15.0),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
          image: firstImage != null
              ? DecorationImage(
                  image: NetworkImage(firstImage),
                  fit: BoxFit.cover,
                  onError: (err, st) => print(
                      "Error loading image $firstImage: $err"), // Add error logging
                  colorFilter: ColorFilter.mode(
                    Colors.black.withOpacity(0.3),
                    BlendMode.darken,
                  ),
                )
              : null, // No image if null
          color: firstImage == null
              ? Colors.grey[300]
              : Colors.white, // Placeholder color or white background
        ),
        child: Stack(
          children: [
            // Placeholder Icon if no image
            if (firstImage == null)
              Center(
                  child: Icon(Icons.person, size: 60, color: Colors.grey[500])),

            // Gradient Overlay for text (only if image exists)
            if (firstImage != null)
              Positioned.fill(
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(15.0),
                    gradient: LinearGradient(
                        colors: [
                          Colors.transparent,
                          Colors.black.withOpacity(0.7)
                        ],
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        stops: const [0.4, 1.0]),
                  ),
                ),
              ),

            // Info Text
            Positioned(
              bottom: 12,
              left: 12,
              right: 12,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Name & Age
                  Text(
                    '${profile.name ?? 'Unknown User'}${age != null ? ', $age' : ''}',
                    style: GoogleFonts.poppins(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      // Adjust text color based on background
                      color: firstImage != null ? Colors.white : Colors.black87,
                      shadows: firstImage != null
                          ? [
                              Shadow(
                                  blurRadius: 2,
                                  color: Colors.black.withOpacity(0.7))
                            ]
                          : [],
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),

                  // Like Timestamp
                  Text(
                    'Liked you $timeAgo',
                    style: GoogleFonts.poppins(
                      fontSize: 11,
                      color: firstImage != null
                          ? Colors.white.withOpacity(0.8)
                          : Colors.grey[600],
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),

                  // Comment Preview (if exists)
                  if (liker.likeComment != null &&
                      liker.likeComment!.isNotEmpty) ...[
                    const SizedBox(height: 6),
                    Row(
                      children: [
                        Icon(Icons.chat_bubble_outline_rounded,
                            color: firstImage != null
                                ? Colors.white.withOpacity(0.8)
                                : Colors.blue.shade300,
                            size: 14),
                        const SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            '"${liker.likeComment!}"',
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              fontStyle: FontStyle.italic,
                              color: firstImage != null
                                  ? Colors.white.withOpacity(0.9)
                                  : Colors.black87,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ],
                    ),
                  ],
                ],
              ),
            ),

            // Rose Indicator (Top Right)
            if (liker.isRose)
              Positioned(
                top: 8,
                right: 8,
                child: Container(
                  padding: const EdgeInsets.all(5),
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.5),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(Icons.star_rounded,
                      color: Colors.yellow.shade600, size: 18),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: widgets/home_profile_card.dart
================================================
// File: widgets/home_profile_card.dart
import 'dart:async'; // Import async
import 'dart:math';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/audio_player_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/providers/user_provider.dart'; // Import user provider
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

// Function Type Definitions
typedef PerformLikeApiCall = Future<bool> Function({
  required ContentLikeType contentType,
  required String contentIdentifier,
  required LikeInteractionType interactionType,
  String? comment,
});

// --- ADDED: Dislike Callback Type ---
typedef PerformDislikeApiCall = Future<bool> Function();

typedef InteractionCompleteCallback = void Function();

class HomeProfileCard extends ConsumerWidget {
  final UserModel profile;
  final PerformLikeApiCall performLikeApiCall;
  final PerformDislikeApiCall performDislikeApiCall; // <<< ADDED
  final InteractionCompleteCallback onInteractionComplete;

  const HomeProfileCard({
    super.key,
    required this.profile,
    required this.performLikeApiCall,
    required this.performDislikeApiCall, // <<< ADDED
    required this.onInteractionComplete,
  });

  // _showInteractionDialog(...) remains the same as previous version
  Future<void> _showInteractionDialog(
    BuildContext context,
    WidgetRef ref,
    ContentLikeType contentType,
    String contentIdentifier,
    String? previewImageUrl,
  ) async {
    final currentUserGender = ref.read(userProvider).gender;
    final isMale = currentUserGender == Gender.man;
    final FocusNode commentFocusNode = FocusNode();
    final TextEditingController commentController = TextEditingController();
    final ValueNotifier<bool> sendLikeEnabledNotifier =
        ValueNotifier<bool>(!isMale);
    final ValueNotifier<bool> _isDialogInteractionActive =
        ValueNotifier<bool>(false);
    VoidCallback? listenerCallback;

    if (isMale) {
      listenerCallback = () {
        if (context.mounted && commentController.value.text != null) {
          try {
            sendLikeEnabledNotifier.value =
                commentController.text.trim().isNotEmpty;
          } catch (e) {
            print(
                "Error accessing sendLikeEnabledNotifier in listener (might be disposed): $e");
          }
        }
      };
      commentController.addListener(listenerCallback);
    }

    Future<void> _handleInteraction(LikeInteractionType interactionType) async {
      if (_isDialogInteractionActive.value) return;

      String comment = "";
      try {
        comment = commentController.text.trim();
      } catch (e) {
        print("Error reading commentController text: $e");
        return;
      }

      commentFocusNode.unfocus();
      await Future.delayed(const Duration(milliseconds: 100));

      try {
        _isDialogInteractionActive.value = true;
      } catch (e) {
        print("Error setting _isDialogInteractionActive to true: $e");
        return;
      }

      bool success = false;
      try {
        success = await performLikeApiCall(
          contentType: contentType,
          contentIdentifier: contentIdentifier,
          interactionType: interactionType,
          comment: comment.isNotEmpty ? comment : null,
        );

        if (success && context.mounted) {
          Navigator.of(context, rootNavigator: true).pop();
          onInteractionComplete();
        }
      } finally {
        try {
          if (context.mounted && _isDialogInteractionActive.value) {
            _isDialogInteractionActive.value = false;
          }
        } catch (e) {
          print(
              "Error setting _isDialogInteractionActive to false (notifier disposed?): $e");
        }
      }
    }

    try {
      await showDialog<void>(
        context: context,
        barrierDismissible: true,
        builder: (BuildContext dialogContext) {
          return AlertDialog(
            contentPadding: const EdgeInsets.all(16),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(20.0),
            ),
            content: SizedBox(
              width: MediaQuery.of(dialogContext).size.width * 0.8,
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (previewImageUrl != null)
                      ClipRRect(
                        borderRadius: BorderRadius.circular(12.0),
                        child: Image.network(
                          previewImageUrl,
                          height: 100,
                          width: double.infinity,
                          fit: BoxFit.cover,
                          errorBuilder: (_, __, ___) => Container(
                              height: 100,
                              color: Colors.grey[200],
                              child: Icon(Icons.broken_image,
                                  color: Colors.grey[400])),
                        ),
                      ),
                    if (previewImageUrl == null &&
                        contentType == ContentLikeType.audioPrompt)
                      Container(
                        height: 100,
                        width: double.infinity,
                        decoration: BoxDecoration(
                          color: Colors.grey[100],
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        child: Center(
                            child: Icon(Icons.multitrack_audio_rounded,
                                size: 40, color: Colors.grey[500])),
                      ),
                    if (previewImageUrl == null &&
                        contentType != ContentLikeType.audioPrompt)
                      Container(
                        height: 100,
                        width: double.infinity,
                        decoration: BoxDecoration(
                          color: Colors.grey[100],
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        child: Center(
                            child: Icon(Icons.article_outlined,
                                size: 40, color: Colors.grey[500])),
                      ),
                    const SizedBox(height: 16),
                    TextField(
                      controller: commentController,
                      focusNode: commentFocusNode,
                      decoration: InputDecoration(
                        hintText: "Add a comment...",
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide: BorderSide(color: Colors.grey.shade300),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide:
                              const BorderSide(color: Color(0xFF8B5CF6)),
                        ),
                        contentPadding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 10),
                      ),
                      maxLength: 150,
                      maxLines: 3,
                      minLines: 1,
                      textCapitalization: TextCapitalization.sentences,
                    ),
                    const SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        ValueListenableBuilder<bool>(
                          valueListenable: sendLikeEnabledNotifier,
                          builder: (context, isCommentValid, child) {
                            final bool roseButtonEnabled =
                                !isMale || isCommentValid;
                            return ValueListenableBuilder<bool>(
                              valueListenable: _isDialogInteractionActive,
                              builder: (context, isInteractionActive, child) {
                                final bool effectiveEnabled =
                                    roseButtonEnabled && !isInteractionActive;
                                return OutlinedButton.icon(
                                  icon: Icon(
                                    Icons.star_rounded,
                                    color: effectiveEnabled
                                        ? Colors.purple.shade300
                                        : Colors.grey.shade400,
                                    size: 18,
                                  ),
                                  label: Text(
                                    "Send Rose",
                                    style: GoogleFonts.poppins(
                                      fontWeight: FontWeight.w500,
                                      color: effectiveEnabled
                                          ? Colors.purple.shade400
                                          : Colors.grey.shade500,
                                      fontSize: 13,
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                  style: OutlinedButton.styleFrom(
                                    foregroundColor: effectiveEnabled
                                        ? Colors.purple.shade400
                                        : Colors.grey.shade500,
                                    side: BorderSide(
                                      color: effectiveEnabled
                                          ? Colors.purple.shade100
                                          : Colors.grey.shade300,
                                    ),
                                    shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(25),
                                    ),
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 10, horizontal: 12),
                                  ),
                                  onPressed: effectiveEnabled
                                      ? () => _handleInteraction(
                                          LikeInteractionType.rose)
                                      : null,
                                );
                              },
                            );
                          },
                        ),
                        ValueListenableBuilder<bool>(
                          valueListenable: sendLikeEnabledNotifier,
                          builder: (context, isCommentValid, child) {
                            final bool likeButtonEnabled =
                                !isMale || isCommentValid;
                            return ValueListenableBuilder<bool>(
                              valueListenable: _isDialogInteractionActive,
                              builder: (context, isInteractionActive, child) {
                                final bool effectiveEnabled =
                                    likeButtonEnabled && !isInteractionActive;
                                return ElevatedButton.icon(
                                  icon: Icon(
                                    Icons.favorite_rounded,
                                    color: effectiveEnabled
                                        ? Colors.white
                                        : Colors.grey.shade400,
                                    size: 18,
                                  ),
                                  label: Text(
                                    "Send Like",
                                    style: GoogleFonts.poppins(
                                        fontWeight: FontWeight.w600,
                                        color: effectiveEnabled
                                            ? Colors.white
                                            : Colors.grey.shade500,
                                        fontSize: 13),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: effectiveEnabled
                                        ? Colors.pink.shade300
                                        : Colors.grey.shade200,
                                    disabledBackgroundColor:
                                        Colors.grey.shade200,
                                    shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(25),
                                    ),
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 10, horizontal: 12),
                                    elevation: effectiveEnabled ? 2 : 0,
                                  ),
                                  onPressed: effectiveEnabled
                                      ? () => _handleInteraction(
                                          LikeInteractionType.standard)
                                      : null,
                                );
                              },
                            );
                          },
                        ),
                      ],
                    ),
                    ValueListenableBuilder<bool>(
                        valueListenable: _isDialogInteractionActive,
                        builder: (context, isInteractionActive, child) {
                          return TextButton(
                            child: Text("Cancel",
                                style: GoogleFonts.poppins(
                                    color: isInteractionActive
                                        ? Colors.grey.shade400
                                        : Colors.grey)),
                            onPressed: isInteractionActive
                                ? null
                                : () => Navigator.of(dialogContext).pop(),
                          );
                        }),
                  ],
                ),
              ),
            ),
          );
        },
      );
    } finally {
      if (listenerCallback != null) {
        try {
          commentController.removeListener(listenerCallback);
          listenerCallback = null;
        } catch (e) {
          print(
              "Error removing commentController listener (already removed?): $e");
        }
      }
      try {
        sendLikeEnabledNotifier.dispose();
      } catch (e) {
        print("Error disposing sendLikeEnabledNotifier: $e");
      }
      try {
        commentController.dispose();
      } catch (e) {
        print("Error disposing commentController: $e");
      }
      try {
        commentFocusNode.dispose();
      } catch (e) {
        print("Error disposing commentFocusNode: $e");
      }
      try {
        _isDialogInteractionActive.dispose();
      } catch (e) {
        print("Error disposing _isDialogInteractionActive: $e");
      }
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final List<dynamic> contentBlocks = [];
    final mediaUrls = profile.mediaUrls ?? [];
    final prompts = profile.prompts;

    contentBlocks.add("header_section");
    if (mediaUrls.isNotEmpty) contentBlocks.add(mediaUrls[0]);
    if (prompts.isNotEmpty) contentBlocks.add(prompts[0]);
    contentBlocks.add("vitals_section");

    int mediaIndex = 1;
    int promptIndex = 1;
    int maxRemaining = max(mediaUrls.length, prompts.length);

    for (int i = 1; i < maxRemaining; i++) {
      if (mediaIndex < mediaUrls.length) {
        contentBlocks.add(mediaUrls[mediaIndex]);
        mediaIndex++;
      }
      if (promptIndex < prompts.length) {
        contentBlocks.add(prompts[promptIndex]);
        promptIndex++;
      }
    }
    if (profile.audioPrompt != null) {
      contentBlocks.add(profile.audioPrompt!);
    }

    return Container(
      color: Colors.white,
      child: Stack(
        // <-- Use Stack here
        children: [
          // --- Main Scrollable Content ---
          ListView.builder(
            physics: const ClampingScrollPhysics(),
            padding: const EdgeInsets.only(
                bottom: 80.0), // <-- Add padding for buttons
            itemCount: contentBlocks.length,
            itemBuilder: (context, index) {
              final item = contentBlocks[index];
              final double topPadding = (index == 0) ? 16.0 : 0;
              final double bottomPadding = 20.0;
              final double horizontalPadding = 12.0;
              Widget contentWidget;

              // --- BUILD BLOCKS (Keep existing logic) ---
              if (item is String && item == "header_section") {
                contentWidget = _buildHeaderBlock(profile);
              } else if (item is String && item.startsWith('http')) {
                int originalMediaIndex =
                    (profile.mediaUrls ?? []).indexOf(item);
                if (originalMediaIndex == -1) originalMediaIndex = 0;
                contentWidget =
                    _buildMediaItem(context, ref, item, originalMediaIndex);
              } else if (item is Prompt) {
                contentWidget = _buildPromptItem(context, ref, item);
              } else if (item is AudioPromptModel) {
                contentWidget = _buildAudioItem(context, ref, item);
              } else if (item is String && item == "vitals_section") {
                contentWidget = _buildVitalsBlock(profile);
              } else {
                contentWidget = const SizedBox.shrink();
              }
              // --- END BUILD BLOCKS ---

              return Padding(
                padding: EdgeInsets.fromLTRB(horizontalPadding, topPadding,
                    horizontalPadding, bottomPadding),
                child: contentWidget,
              );
            },
          ),
          // --- END Main Scrollable Content ---

          // --- MODIFIED: Only Dislike Button in Overlay ---
          Positioned(
            bottom: 15, // Adjust vertical position as needed
            left: 30, // Position it on the left
            child: _buildActionButton(
                icon: Icons.close_rounded,
                color: Colors.redAccent.shade100,
                onPressed: () async {
                  // Make async
                  bool success = await performDislikeApiCall();
                  if (success) {
                    onInteractionComplete(); // Remove card if dislike succeeds
                  }
                },
                tooltip: "Dislike",
                size: 55 // Slightly smaller buttons if desired
                ),
          ),
          // --- END MODIFICATION ---
        ],
      ),
      // --- END Stack ---
    );
  }

  // --- Helper methods (_buildHeaderBlock, _buildVitalsBlock, _buildVitalRow, etc.) remain unchanged ---
  Widget _buildHeaderBlock(UserModel profile) {
    final age = profile.age;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Flexible(
              child: Text(
                '${profile.name ?? 'Name'}${age != null ? ', $age' : ''}',
                style: GoogleFonts.poppins(
                    fontSize: 26,
                    fontWeight: FontWeight.bold,
                    color: Colors.black87),
              ),
            ),
          ],
        ),
        if (profile.hometown != null && profile.hometown!.isNotEmpty) ...[
          const SizedBox(height: 4),
          Row(
            children: [
              Icon(Icons.location_on_outlined,
                  size: 16, color: Colors.grey[600]),
              const SizedBox(width: 4),
              Text(
                profile.hometown!,
                style:
                    GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
              ),
            ],
          ),
        ]
      ],
    );
  }

  Widget _buildVitalsBlock(UserModel profile) {
    final List<Widget> vitals = [];
    if (profile.height != null && profile.height!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.height, profile.height!));
    }
    if (profile.religiousBeliefs != null) {
      vitals.add(_buildVitalRow(
          Icons.church_outlined, profile.religiousBeliefs!.label));
    }
    if (profile.jobTitle != null && profile.jobTitle!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.work_outline, profile.jobTitle!));
    }
    if (profile.education != null && profile.education!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.school_outlined, profile.education!));
    }
    if (profile.drinkingHabit != null) {
      vitals.add(_buildVitalRow(
          Icons.local_bar_outlined, "Drinks: ${profile.drinkingHabit!.label}"));
    }
    if (profile.smokingHabit != null) {
      vitals.add(_buildVitalRow(Icons.smoking_rooms_outlined,
          "Smokes: ${profile.smokingHabit!.label}"));
    }

    if (vitals.isEmpty) return const SizedBox.shrink();

    return Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        width: double.infinity,
        decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(10),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 3),
              )
            ]),
        child: Column(
          children: List.generate(vitals.length * 2 - 1, (index) {
            if (index.isEven) {
              return vitals[index ~/ 2];
            } else {
              return Divider(height: 16, thickness: 1, color: Colors.grey[200]);
            }
          }),
        ));
  }

  Widget _buildVitalRow(IconData icon, String label) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6.0),
      child: Row(
        children: [
          Icon(icon, size: 20, color: Colors.grey[600]),
          const SizedBox(width: 12),
          Expanded(
              child: Text(label,
                  style: GoogleFonts.poppins(
                      fontSize: 15, color: Colors.grey[800]))),
        ],
      ),
    );
  }

  Widget _buildMediaItem(
      BuildContext context, WidgetRef ref, String url, int index) {
    bool isVideo = url.toLowerCase().contains('.mp4') ||
        url.toLowerCase().contains('.mov');

    return ClipRRect(
      borderRadius: BorderRadius.circular(10), // Consistent rounding
      child: AspectRatio(
        aspectRatio: 4 / 5.5, // Or your desired ratio
        child: Container(
          decoration: BoxDecoration(color: Colors.grey[200]), // Placeholder bg
          child: Stack(
            fit: StackFit.expand,
            children: [
              Image.network(url,
                  fit: BoxFit.cover,
                  loadingBuilder: (ctx, child, prog) => prog == null
                      ? child
                      : Center(
                          child: CircularProgressIndicator(
                              value: prog.expectedTotalBytes != null
                                  ? prog.cumulativeBytesLoaded /
                                      prog.expectedTotalBytes!
                                  : null,
                              color: Colors.grey[400])),
                  errorBuilder: (ctx, err, st) => Center(
                      child: Icon(Icons.image_not_supported_outlined,
                          color: Colors.grey[400], size: 40))),
              if (isVideo) // Show video indicator
                Center(
                  child: Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.5),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.play_arrow_rounded,
                        color: Colors.white, size: 30),
                  ),
                ),
              Positioned(
                  bottom: 10,
                  right: 10,
                  child: _buildSmallLikeButton(() => _showInteractionDialog(
                        context,
                        ref,
                        ContentLikeType.media,
                        index.toString(), // Use index as identifier for media
                        url,
                      )))
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPromptItem(BuildContext context, WidgetRef ref, Prompt prompt) {
    if (prompt.answer.trim().isEmpty) return const SizedBox.shrink();

    return Container(
      width: double.infinity, // Take full width
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
          color: Colors.white, // White background
          borderRadius: BorderRadius.circular(10), // Rounded corners
          boxShadow: [
            // Subtle shadow
            BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ]),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start, // Align top
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Prompt Question
                Text(prompt.question.label,
                    style: GoogleFonts.poppins(
                        fontSize: 14, // Slightly smaller question
                        fontWeight: FontWeight.w600,
                        color: Colors.grey[600])), // Subdued color
                const SizedBox(height: 10),
                // Prompt Answer
                Text(prompt.answer,
                    style: GoogleFonts.poppins(
                        fontSize: 20, // Larger answer text
                        color: Colors.black87,
                        height: 1.4, // Line height
                        fontWeight: FontWeight.w500)),
              ],
            ),
          ),
          const SizedBox(width: 12), // Spacing before button
          // Like Button
          _buildSmallLikeButton(() => _showInteractionDialog(
                context,
                ref,
                prompt.category.contentType, // Get type from category
                prompt.question.value, // Use question enum value as identifier
                null, // No image preview for prompts
              )),
        ],
      ),
    );
  }

  Widget _buildAudioItem(
      BuildContext context, WidgetRef ref, AudioPromptModel audio) {
    final audioPlayerState = ref.watch(audioPlayerStateProvider);
    final currentPlayingUrl = ref.watch(currentAudioUrlProvider);
    final playerNotifier = ref.read(audioPlayerControllerProvider.notifier);

    final bool isThisPlaying = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.playing;
    final bool isThisLoading = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.loading;
    final bool isThisPaused = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.paused;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16), // More rounded
          border: Border.all(color: Colors.grey[200]!),
          boxShadow: [
            BoxShadow(
                color: Colors.grey.withOpacity(0.06),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ]),
      child: Row(
        children: [
          InkWell(
            onTap: () {
              if (isThisLoading) return;

              if (isThisPlaying) {
                playerNotifier.pause();
              } else if (isThisPaused) {
                playerNotifier.resume();
              } else {
                playerNotifier.play(audio.audioUrl);
              }
            },
            borderRadius: BorderRadius.circular(24),
            child: Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: const Color(0xFF8B5CF6),
                borderRadius: BorderRadius.circular(24),
                boxShadow: [
                  BoxShadow(
                      color: const Color(0xFF8B5CF6).withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2))
                ],
              ),
              child: isThisLoading
                  ? const Padding(
                      padding: EdgeInsets.all(12.0),
                      child: CircularProgressIndicator(
                          strokeWidth: 2, color: Colors.white))
                  : Icon(
                      isThisPlaying
                          ? Icons.pause_rounded
                          : Icons.play_arrow_rounded,
                      color: Colors.white,
                      size: 28,
                    ),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(audio.prompt.label,
                    style: GoogleFonts.poppins(
                        fontSize: 15,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF1A1A1A))),
                const SizedBox(height: 4),
                Text(
                    isThisLoading
                        ? "Loading..."
                        : isThisPlaying
                            ? "Playing..."
                            : isThisPaused
                                ? "Paused"
                                : "Tap to listen",
                    style: GoogleFonts.poppins(
                        fontSize: 13, color: Colors.grey[600])),
              ],
            ),
          ),
          const SizedBox(width: 16),
          _buildSmallLikeButton(() => _showInteractionDialog(
                context,
                ref,
                ContentLikeType.audioPrompt,
                "0", // API requires "0" for audio prompts
                null,
              )),
        ],
      ),
    );
  }

  Widget _buildSmallLikeButton(VoidCallback onPressed) {
    return Container(
      width: 40,
      height: 40,
      decoration: BoxDecoration(
          color: Colors.white, // White background
          shape: BoxShape.circle,
          boxShadow: [
            // Subtle shadow
            BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 5)
          ]),
      child: IconButton(
        padding: EdgeInsets.zero, // Remove default padding
        icon: Icon(Icons.favorite_border_rounded,
            color: Colors.pink[200], // Soft pink color
            size: 22), // Icon size
        tooltip: 'Like this item',
        onPressed: onPressed,
      ),
    );
  }

  Widget _buildActionButton({
    required IconData icon,
    required Color color,
    required VoidCallback onPressed,
    required String tooltip,
    double size = 60.0, // Default size
    double iconSize = 30.0,
  }) {
    return Tooltip(
      message: tooltip,
      child: Material(
        color: Colors.white,
        shape: const CircleBorder(),
        elevation: 3.0,
        shadowColor: Colors.black.withOpacity(0.2),
        child: InkWell(
          customBorder: const CircleBorder(),
          onTap: onPressed,
          child: Container(
            width: size,
            height: size,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(color: Colors.grey.shade200, width: 1.0),
            ),
            child: Icon(
              icon,
              color: color,
              size: iconSize,
            ),
          ),
        ),
      ),
    );
  }
} // End of HomeProfileCard


