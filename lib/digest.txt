Directory structure:
└── lib/
    ├── main.dart
    ├── models/
    │   ├── auth_model.dart
    │   ├── error_model.dart
    │   ├── location_model.dart
    │   ├── media_upload_model.dart
    │   └── user_model.dart
    ├── providers/
    │   ├── audio_player_provider.dart
    │   ├── audio_upload_provider.dart
    │   ├── auth_provider.dart
    │   ├── error_provider.dart
    │   ├── location_provider.dart
    │   ├── media_upload_provider.dart
    │   ├── service_provider.dart
    │   └── user_provider.dart
    ├── repositories/
    │   ├── auth_repository.dart
    │   ├── auth_status_repository.dart
    │   ├── media_repository.dart
    │   └── user_repository.dart
    ├── services/
    │   ├── api_service.dart
    │   └── http_service.dart
    ├── utils/
    │   ├── app_enums.dart
    │   ├── env_config.dart
    │   └── token_storage.dart
    └── views/
        ├── audioprompt.dart
        ├── audiopromptsselect.dart
        ├── dating_intentions.dart
        ├── dob.dart
        ├── drinking.dart
        ├── gender.dart
        ├── height.dart
        ├── home.dart
        ├── hometown.dart
        ├── job.dart
        ├── location.dart
        ├── media.dart
        ├── name.dart
        ├── otp.dart
        ├── phone.dart
        ├── profile_screens.dart
        ├── prompt.dart
        ├── religion.dart
        ├── selfie_capture_screen.dart
        ├── smoking.dart
        ├── splash_screen.dart
        ├── study.dart
        ├── textpromptsselect.dart
        ├── verification_message_screen.dart
        ├── verification_pending_screen.dart
        ├── writeprompt.dart
        ├── youtube.dart
        └── core/
            └── error_handler.dart

================================================
File: main.dart
================================================
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/gender.dart';
import 'package:dtx/views/height.dart';
import 'package:dtx/views/home.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/views/phone.dart';
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/prompt.dart';
import 'package:flutter/material.dart';
import 'package:dtx/views/splash_screen.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

void main() async {
  // Ensure Flutter is initialized
  WidgetsFlutterBinding.ensureInitialized();
  
  // Load environment variables
  await dotenv.load(fileName: ".env");
  
  runApp(
    // Adding ProviderScope at the root of the app
    const ProviderScope(
      child: MyApp(),
    ),
  );
}

// Change StatelessWidget to ConsumerWidget to use Riverpod
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp(
      title: 'DTX',
      debugShowCheckedModeBanner: false, // Optional: removes debug banner
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // You can add more theme configurations here
      ),
      // You can change the home screen here based on your flow
      // For example, start with PhoneInputScreen for authentication flow
      home: const SplashScreen() ,
    );
  }
}



================================================
File: models/auth_model.dart
================================================
// File: models/auth_model.dart
enum AuthStatus {
  home,       // User authenticated with complete profile
  onboarding, // User authenticated but profile incomplete
  login,      // User not authenticated or invalid token
  unknown     // Error or initial state
}

class AuthState {
  final String? unverifiedPhone;
  final String? verificationId;
  final bool isLoading;
  final String? error;
  final int? resendTimer;
  final String? jwtToken;
  final AuthStatus authStatus;

  const AuthState({
    this.unverifiedPhone,
    this.verificationId,
    this.isLoading = false,
    this.error,
    this.resendTimer,
    this.jwtToken,
    this.authStatus = AuthStatus.unknown,
  });

  AuthState copyWith({
    String? Function()? unverifiedPhone,
    String? Function()? verificationId,
    bool? isLoading,
    String? Function()? error,
    int? Function()? resendTimer,
    String? Function()? jwtToken,
    AuthStatus? authStatus,
  }) {
    return AuthState(
      unverifiedPhone:
          unverifiedPhone != null ? unverifiedPhone() : this.unverifiedPhone,
      verificationId:
          verificationId != null ? verificationId() : this.verificationId,
      isLoading: isLoading ?? this.isLoading,
      error: error != null ? error() : this.error,
      resendTimer: resendTimer != null ? resendTimer() : this.resendTimer,
      jwtToken: jwtToken != null ? jwtToken() : this.jwtToken,
      authStatus: authStatus ?? this.authStatus,
    );
  }
  
  // Check if user is authenticated
  bool get isAuthenticated => jwtToken != null && jwtToken!.isNotEmpty;
}



================================================
File: models/error_model.dart
================================================
enum ErrorType { network, validation, auth, generic, locationService,server }

class AppError {
  final String message;
  final ErrorType type;
  final DateTime timestamp;

  AppError({
    required this.message,
    required this.type,
  }) : timestamp = DateTime.now();

  factory AppError.network(String message) => AppError(
        message: message,
        type: ErrorType.network,
      );

  factory AppError.validation(String message) => AppError(
        message: message,
        type: ErrorType.validation,
      );

  factory AppError.auth(String message) => AppError(
        message: message,
        type: ErrorType.auth,
      );

  factory AppError.locationService(String message) => AppError(
        message: message,
        type: ErrorType.locationService,
      );

  factory AppError.server(String message) => AppError(
        message: message,
        type: ErrorType.server,
      );
}



================================================
File: models/location_model.dart
================================================
class LocationState {
  final bool isLoading;
  final bool isFetching;
  final double latitude;
  final double longitude;
  final double? cachedLatitude;
  final double? cachedLongitude;
  final bool isMapReady;

  LocationState({
    this.isLoading = true,
    this.isFetching = false,
    this.latitude = 19.2183, // Default location
    this.longitude = 73.0864,
    this.cachedLatitude,
    this.cachedLongitude,
    this.isMapReady = false,
  });

  LocationState copyWith({
    bool? isLoading,
    bool? isFetching,
    double? latitude,
    double? longitude,
    double? cachedLatitude,
    double? cachedLongitude,
    bool? isMapReady,
  }) {
    return LocationState(
      isLoading: isLoading ?? this.isLoading,
      isFetching: isFetching ?? this.isFetching,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      cachedLatitude: cachedLatitude ?? this.cachedLatitude,
      cachedLongitude: cachedLongitude ?? this.cachedLongitude,
      isMapReady: isMapReady ?? this.isMapReady,
    );
  }
}



================================================
File: models/media_upload_model.dart
================================================

// models/media_upload_model.dart
import 'dart:io';

enum UploadStatus {
  idle,
  inProgress,
  success,
  failed,
}

class MediaUploadModel {
  final File file;
  final String fileName;
  final String fileType;
  final String? presignedUrl;
  final UploadStatus status;
  final String? errorMessage;
  
  MediaUploadModel({
    required this.file,
    required this.fileName,
    required this.fileType,
    this.presignedUrl,
    this.status = UploadStatus.idle,
    this.errorMessage,
  });
  
  MediaUploadModel copyWith({
    File? file,
    String? fileName,
    String? fileType,
    String? Function()? presignedUrl,
    UploadStatus? status,
    String? Function()? errorMessage,
  }) {
    return MediaUploadModel(
      file: file ?? this.file,
      fileName: fileName ?? this.fileName,
      fileType: fileType ?? this.fileType,
      presignedUrl: presignedUrl != null ? presignedUrl() : this.presignedUrl,
      status: status ?? this.status,
      errorMessage: errorMessage != null ? errorMessage() : this.errorMessage,
    );
  }
}



================================================
File: models/user_model.dart
================================================
import 'package:dtx/utils/app_enums.dart';

class Prompt {
  final PromptCategory category;
  final PromptType question;
  final String answer;

  Prompt({
    required this.category,
    required this.question,
    required this.answer,
  });

  Map<String, dynamic> toJson() => {
        'category': category.value,
        'question': question.value,
        'answer': answer,
      };

  factory Prompt.fromJson(Map<String, dynamic> json) => Prompt(
        category: PromptCategory.values.firstWhere(
            (e) => e.value == json['category'],
            orElse: () => PromptCategory.storyTime),
        question: PromptType.values.firstWhere(
            (e) => e.value == json['question'],
            orElse: () => PromptType.twoTruthsAndALie),
        answer: json['answer'],
      );

  Prompt copyWith({String? answer}) {
    return Prompt(
      category: category,
      question: question,
      answer: answer ?? this.answer,
    );
  }

  @override
  String toString() {
    return 'Prompt(question: ${question.label}, answer: $answer)';
  }
}

class AudioPromptModel {
  final AudioPrompt prompt;
  final String audioUrl;

  AudioPromptModel({
    required this.prompt,
    required this.audioUrl,
  });

  Map<String, dynamic> toJson() => {
        'prompt': prompt.value,
        'audio_url': audioUrl,
      };

  factory AudioPromptModel.fromJson(Map<String, dynamic> json) =>
      AudioPromptModel(
        prompt: AudioPrompt.values.firstWhere(
            (e) => e.value == json['prompt'],
            orElse: () => AudioPrompt.aBoundaryOfMineIs),
        audioUrl: json['audio_url'],
      );
}

class UserModel {
  final String? name;
  final String? lastName;
  final String? phoneNumber;
  final DateTime? dateOfBirth;
  final double? latitude;
  final double? longitude;
  final Gender? gender;
  final DatingIntention? datingIntention;
  final String? height;
  final String? hometown;
  final String? jobTitle;
  final String? education;
  final Religion? religiousBeliefs;
  final DrinkingSmokingHabits? drinkingHabit;
  final DrinkingSmokingHabits? smokingHabit;
  final List<String>? mediaUrls;
  final List<Prompt> prompts;
  final AudioPromptModel? audioPrompt;

  UserModel({
    this.name,
    this.lastName,
    this.phoneNumber,
    this.dateOfBirth,
    this.latitude,
    this.longitude,
    this.gender,
    this.datingIntention,
    this.height,
    this.hometown,
    this.jobTitle,
    this.education,
    this.religiousBeliefs,
    this.drinkingHabit,
    this.smokingHabit,
    this.mediaUrls,
    this.prompts = const [],
    this.audioPrompt,
  });

  Map<String, dynamic> toJson() => {
        'name': name,
        'last_name': lastName,
        'phone_number': phoneNumber,
        'date_of_birth': dateOfBirth?.toIso8601String(),
        'latitude': latitude,
        'longitude': longitude,
        'gender': gender?.value,
        'dating_intention': datingIntention?.value,
        'height': height,
        'hometown': hometown,
        'job_title': jobTitle,
        'education': education,
        'religious_beliefs': religiousBeliefs?.value,
        'drinking_habit': drinkingHabit?.value,
        'smoking_habit': smokingHabit?.value,
        'media_urls': mediaUrls,
        'prompts': prompts.map((prompt) => prompt.toJson()).toList(),
        'audio_prompt': audioPrompt?.toJson(),
      };

  factory UserModel.fromJson(Map<String, dynamic> json) => UserModel(
        name: json['name'],
        lastName: json['last_name'],
        phoneNumber: json['phone_number'],
        dateOfBirth: json['date_of_birth'] != null
            ? DateTime.parse(json['date_of_birth'])
            : null,
        latitude: json['latitude'],
        longitude: json['longitude'],
        gender: json['gender'] != null
            ? Gender.values.firstWhere(
                (e) => e.value == json['gender'],
                orElse: () => Gender.man,
              )
            : null,
        datingIntention: json['dating_intention'] != null
            ? DatingIntention.values.firstWhere(
                (e) => e.value == json['dating_intention'],
                orElse: () => DatingIntention.figuringOut,
              )
            : null,
        height: json['height'],
        hometown: json['hometown'],
        jobTitle: json['job_title'],
        education: json['education'],
        religiousBeliefs: json['religious_beliefs'] != null
            ? Religion.values.firstWhere(
                (e) => e.value == json['religious_beliefs'],
                orElse: () => Religion.agnostic,
              )
            : null,
        drinkingHabit: json['drinking_habit'] != null
            ? DrinkingSmokingHabits.values.firstWhere(
                (e) => e.value == json['drinking_habit'],
                orElse: () => DrinkingSmokingHabits.no,
              )
            : null,
        smokingHabit: json['smoking_habit'] != null
            ? DrinkingSmokingHabits.values.firstWhere(
                (e) => e.value == json['smoking_habit'],
                orElse: () => DrinkingSmokingHabits.no,
              )
            : null,
        mediaUrls: json['media_urls'] != null
            ? List<String>.from(json['media_urls'])
            : null,
        prompts: json['prompts'] != null
            ? (json['prompts'] as List)
                .map((prompt) => Prompt.fromJson(prompt))
                .toList()
            : [],
        audioPrompt: json['audio_prompt'] != null
            ? AudioPromptModel.fromJson(json['audio_prompt'])
            : null,
      );

  UserModel copyWith({
    String? name,
    String? lastName,
    String? phoneNumber,
    DateTime? dateOfBirth,
    double? latitude,
    double? longitude,
    Gender? gender,
    DatingIntention? datingIntention,
    String? height,
    String? hometown,
    String? jobTitle,
    String? education,
    Religion? religiousBeliefs,
    DrinkingSmokingHabits? drinkingHabit,
    DrinkingSmokingHabits? smokingHabit,
    List<String>? mediaUrls,
    List<Prompt>? prompts,
    AudioPromptModel? audioPrompt,
  }) {
    return UserModel(
      name: name ?? this.name,
      lastName: lastName ?? this.lastName,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      dateOfBirth: dateOfBirth ?? this.dateOfBirth,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      gender: gender ?? this.gender,
      datingIntention: datingIntention ?? this.datingIntention,
      height: height ?? this.height,
      hometown: hometown ?? this.hometown,
      jobTitle: jobTitle ?? this.jobTitle,
      education: education ?? this.education,
      religiousBeliefs: religiousBeliefs ?? this.religiousBeliefs,
      drinkingHabit: drinkingHabit ?? this.drinkingHabit,
      smokingHabit: smokingHabit ?? this.smokingHabit,
      mediaUrls: mediaUrls ?? this.mediaUrls,
      prompts: prompts ?? List.from(this.prompts),
      audioPrompt: audioPrompt ?? this.audioPrompt,
    );
  }
}



================================================
File: providers/audio_player_provider.dart
================================================

// providers/audio_player_provider.dart
import 'package:audioplayers/audioplayers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

enum AudioPlayerState {
  idle,
  loading,
  playing,
  paused,
  completed,
  error,
}

final audioPlayerStateProvider = StateProvider<AudioPlayerState>((ref) => AudioPlayerState.idle);
final currentAudioUrlProvider = StateProvider<String?>((ref) => null);

final audioPlayerProvider = Provider<AudioPlayer>((ref) {
  final player = AudioPlayer();
  
  player.onPlayerComplete.listen((_) {
    ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.completed;
  });
  
  player.onPlayerStateChanged.listen((state) {
    if (state == PlayerState.playing) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.playing;
    } else if (state == PlayerState.paused) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.paused;
    } else if (state == PlayerState.stopped) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.idle;
    }
  });
  
  // Handle cleanup when the provider is disposed
  ref.onDispose(() {
    player.dispose();
  });
  
  return player;
});

class AudioPlayerNotifier extends StateNotifier<AudioPlayerState> {
  final Ref ref;
  final AudioPlayer _player;
  
  AudioPlayerNotifier(this.ref)
      : _player = ref.read(audioPlayerProvider),
        super(AudioPlayerState.idle);
  
  Future<void> play(String url) async {
    try {
      // If another audio is playing, stop it
      if (state == AudioPlayerState.playing) {
        await _player.stop();
      }
      
      state = AudioPlayerState.loading;
      ref.read(currentAudioUrlProvider.notifier).state = url;
      
      await _player.play(UrlSource(url));
      // State will be updated via listener in audioPlayerProvider
    } catch (e) {
      print("Error playing audio: $e");
      state = AudioPlayerState.error;
    }
  }
  
  Future<void> pause() async {
    if (state == AudioPlayerState.playing) {
      await _player.pause();
      // State will be updated via listener
    }
  }
  
  Future<void> resume() async {
    if (state == AudioPlayerState.paused) {
      await _player.resume();
      // State will be updated via listener
    }
  }
  
  Future<void> stop() async {
    await _player.stop();
    ref.read(currentAudioUrlProvider.notifier).state = null;
    // State will be updated via listener
  }
}

final audioPlayerControllerProvider = StateNotifierProvider<AudioPlayerNotifier, AudioPlayerState>((ref) {
  return AudioPlayerNotifier(ref);
});



================================================
File: providers/audio_upload_provider.dart
================================================
// providers/audio_upload_provider.dart
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../models/user_model.dart';
import '../repositories/media_repository.dart';
import '../utils/app_enums.dart';
import 'error_provider.dart';
import 'service_provider.dart';
import 'user_provider.dart';

final audioUploadProvider = StateNotifierProvider<AudioUploadNotifier, MediaUploadModel?>(
  (ref) {
    print('[AudioUpload] Initializing AudioUploadProvider');
    final mediaRepository = ref.watch(mediaRepositoryProvider);
    return AudioUploadNotifier(ref, mediaRepository);
  },
);

class AudioUploadNotifier extends StateNotifier<MediaUploadModel?> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  AudioPrompt? _selectedPrompt;
  String? _recordingPath;

  // Initialize with null (no audio uploaded yet)
  AudioUploadNotifier(this.ref, this._mediaRepository) : super(null) {
    print('[AudioUpload] AudioUploadNotifier created');
  }

  // Max audio size (10 MB)
  static const int _maxAudioSizeBytes = 10 * 1024 * 1024;

  // Supported audio MIME types
static final Set<String> _supportedAudioTypes = {
  'audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/webm',
  'audio/aac', 'audio/x-m4a', 'audio/x-aiff', 'audio/flac',
  'audio/mp4'  // Add this line to support M4A files
};

  // Save the recording path for later use
  void setRecordingPath(String path) {
    print('[AudioUpload] Setting recording path: $path');
    _recordingPath = path;
  }

  // Prepare audio file with validation
  bool prepareAudioFile() {
    print('[AudioUpload] Preparing audio file');
    print('[AudioUpload] Recording path: $_recordingPath');
    print('[AudioUpload] Selected prompt: ${_selectedPrompt?.value}');
    
    if (_recordingPath == null || _selectedPrompt == null) {
      print('[AudioUpload] ERROR: Missing recording path or prompt');
      return false;
    }
    
    final file = File(_recordingPath!);
    if (!file.existsSync()) {
      print('[AudioUpload] ERROR: File does not exist at path: $_recordingPath');
      return false;
    }
    
    try {
      // Validate file size
      final fileSize = file.lengthSync();
      print('[AudioUpload] File size: ${fileSize / 1024} KB');
      
      if (fileSize > _maxAudioSizeBytes) {
        print('[AudioUpload] ERROR: File too large: ${fileSize / 1024 / 1024} MB (max: ${_maxAudioSizeBytes / 1024 / 1024} MB)');
        ref.read(errorProvider.notifier).setError(
              AppError.validation("Audio is too large. Maximum size is 10 MB."),
            );
        return false;
      }

      // Detect MIME type
      final fileName = path.basename(file.path);
      final mimeType = lookupMimeType(file.path) ?? 'audio/mpeg';
      print('[AudioUpload] Filename: $fileName');
      print('[AudioUpload] MIME type: $mimeType');

      // Validate audio type
      if (!_supportedAudioTypes.contains(mimeType)) {
        print('[AudioUpload] ERROR: Unsupported audio format: $mimeType');
        ref.read(errorProvider.notifier).setError(
              AppError.validation("Unsupported audio format. Please use MP3, WAV, OGG, or other common audio formats."),
            );
        return false;
      }

      // Update state
      print('[AudioUpload] Creating MediaUploadModel');
      state = MediaUploadModel(
        file: file,
        fileName: fileName,
        fileType: mimeType,
        status: UploadStatus.idle,
      );
      
      print('[AudioUpload] Audio file prepared successfully');
      return true;
    } catch (e, stack) {
      print('[AudioUpload] ERROR preparing audio file: $e');
      print('[AudioUpload] Stack trace: $stack');
      return false;
    }
  }

  // Clear audio file
  void clearAudio() {
    print('[AudioUpload] Clearing audio state');
    state = null;
    _recordingPath = null;
    _selectedPrompt = null;
  }

  // Upload audio and save to user profile
  Future<bool> uploadAudioAndSaveToProfile() async {
    print('[AudioUpload] Starting uploadAudioAndSaveToProfile');
    
    if (state == null || _selectedPrompt == null) {
      print('[AudioUpload] State or prompt is null, attempting to prepare file');
      final prepared = prepareAudioFile();
      if (!prepared) {
        print('[AudioUpload] Failed to prepare audio file');
        return false;
      }
    }

    try {
      print('[AudioUpload] Clearing any previous errors');
      ref.read(errorProvider.notifier).clearError();

      // Update state to show upload in progress
      print('[AudioUpload] Setting state to UPLOADING');
      state = state!.copyWith(status: UploadStatus.inProgress);

      // Get presigned URL for audio
      print('[AudioUpload] Getting presigned URL for ${state!.fileName}');
      final presignedUrlResponse = await _mediaRepository.getAudioPresignedUrl(
        state!.fileName,
        state!.fileType,
        _selectedPrompt!,
      );
      
      print('[AudioUpload] Received presigned URL response: ${presignedUrlResponse.toString().substring(0, 100)}...');

      // Update state with presigned URL
      print('[AudioUpload] Updating state with presigned URL');
      state = state!.copyWith(
        presignedUrl: () => presignedUrlResponse['url'],
      );

      // Upload audio to S3
      print('[AudioUpload] Uploading file to S3');
      bool success = await _mediaRepository.uploadFileToS3(state!);
      print('[AudioUpload] Initial upload result: $success');

      // If failed, retry
      if (!success) {
        print('[AudioUpload] Initial upload failed, retrying...');
        success = await _mediaRepository.retryUpload(state!);
        print('[AudioUpload] Retry upload result: $success');
      }

      // Update state with result
      print('[AudioUpload] Setting final upload status: ${success ? "SUCCESS" : "FAILED"}');
      state = state!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload audio',
      );

      if (success) {
        // Create AudioPromptModel
        print('[AudioUpload] Creating AudioPromptModel with prompt: ${_selectedPrompt!.value}');
        final audioPromptModel = AudioPromptModel(
          prompt: _selectedPrompt!,
          audioUrl: presignedUrlResponse['url'],
        );

        // Add to user model
        print('[AudioUpload] Updating user model with audio prompt');
        ref.read(userProvider.notifier).updateAudioPrompt(audioPromptModel);
        print('[AudioUpload] User model updated successfully');
      }

      return success;
    } catch (e, stack) {
      print('[AudioUpload] ERROR during upload: $e');
      print('[AudioUpload] Stack trace: $stack');
      
      if (state != null) {
        state = state!.copyWith(
          status: UploadStatus.failed,
          errorMessage: () => 'Failed to upload audio: ${e.toString()}',
        );
      }
      return false;
    }
  }

  // Get the selected prompt
  AudioPrompt? get selectedPrompt => _selectedPrompt;

  // Set the selected prompt
  void setSelectedPrompt(AudioPrompt prompt) {
    print('[AudioUpload] Setting selected prompt: ${prompt.value}');
    _selectedPrompt = prompt;
  }
}



================================================
File: providers/auth_provider.dart
================================================
// File: providers/auth_provider.dart
import 'package:dtx/models/auth_model.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/error_model.dart';
import '../repositories/auth_repository.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import 'error_provider.dart';
import 'service_provider.dart';

final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final authRepository = ref.watch(authRepositoryProvider);
  return AuthNotifier(ref, authRepository);
});

class AuthNotifier extends StateNotifier<AuthState> {
  final Ref ref;
  final AuthRepository _authRepository;
  int _lastRequestId = 0;
  static final _phoneRegex = RegExp(r'^[6-9][0-9]{9}$');

  AuthNotifier(this.ref, this._authRepository) : super(const AuthState()) {
    // Try to load token on initialization
    _loadToken();
  }
  
  // Load token from storage if it exists
  Future<void> _loadToken() async {
    final token = await TokenStorage.getToken();
    if (token != null && token.isNotEmpty) {
      state = state.copyWith(jwtToken: () => token);
    }
  }
  
  // Check authentication status
Future<AuthStatus> checkAuthStatus({bool updateState = true}) async {
  try {
    if (updateState) {
      state = state.copyWith(isLoading: true);
    }

    // Get token (either from state or storage)
    String? token = state.jwtToken;
    if (token == null || token.isEmpty) {
      token = await TokenStorage.getToken();
    }

    // Check auth status via repository
    final authStatus = await _authRepository.checkAuthStatus(token);

    if (updateState) {
      state = state.copyWith(
        isLoading: false,
        authStatus: authStatus,
      );
    }
    
    return authStatus;
  } catch (e) {
    if (updateState) {
      state = state.copyWith(
        isLoading: false,
        authStatus: AuthStatus.login,
      );
    }
    return AuthStatus.login;
  }
}

  Future<bool> verifyPhone(String phone) async {
    final requestId = ++_lastRequestId;

    state = state.copyWith(
      isLoading: true,
      unverifiedPhone: () => null,
    );

    // Clear any existing errors first
    ref.read(errorProvider.notifier).clearError();

    if (phone.isEmpty) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Phone number can't be empty"),
          );
      state = state.copyWith(isLoading: false);
      return false;
    }

    if (!_phoneRegex.hasMatch(phone)) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Please enter a valid Indian phone number"),
          );
      state = state.copyWith(isLoading: false);
      return false;
    }

    // Clear error on successful verification
    ref.read(errorProvider.notifier).clearError();

    state = state.copyWith(
      unverifiedPhone: () => phone,
      isLoading: false,
    );
    return true;
  }
  
  // Send OTP to the user's phone
  Future<bool> sendOtp(String phoneNumber) async {
    try {
      state = state.copyWith(isLoading: true);
      
      final success = await _authRepository.sendOtp(phoneNumber);
      
      state = state.copyWith(
        isLoading: false, 
        unverifiedPhone: () => success ? phoneNumber : null,
      );
      
      if (!success) {
        ref.read(errorProvider.notifier).setError(
          AppError.auth("Failed to send OTP. Please try again."),
        );
      }
      
      return success;
    } on ApiException catch (e) {
      state = state.copyWith(isLoading: false);
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.message),
      );
      return false;
    } catch (e) {
      state = state.copyWith(isLoading: false);
      ref.read(errorProvider.notifier).setError(
        AppError.auth("An unexpected error occurred. Please try again."),
      );
      return false;
    }
  }
  
  // Verify OTP entered by user
  Future<bool> verifyOtp(String phoneNumber, String otpCode) async {
    try {
      state = state.copyWith(isLoading: true);
      
      final token = await _authRepository.verifyOtp(phoneNumber, otpCode);
      
      // Save token to secure storage
      await TokenStorage.saveToken(token);
      
      state = state.copyWith(
        isLoading: false,
        jwtToken: () => token,
      );
      
      return true;
    } on ApiException catch (e) {
      state = state.copyWith(isLoading: false);
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.message),
      );
      return false;
    } catch (e) {
      state = state.copyWith(isLoading: false);
      ref.read(errorProvider.notifier).setError(
        AppError.auth("An unexpected error occurred. Please try again."),
      );
      return false;
    }
  }
  
  // Logout user
  Future<void> logout() async {
    await TokenStorage.removeToken();
    state = const AuthState();
  }
}



================================================
File: providers/error_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/error_model.dart';

final errorProvider = StateNotifierProvider<ErrorNotifier, AppError?>((ref) {
  return ErrorNotifier();
});

class ErrorNotifier extends StateNotifier<AppError?> {
  ErrorNotifier() : super(null);

  void setError(AppError error) => state = error;
  void clearError() => state = null;
}



================================================
File: providers/location_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:geolocator/geolocator.dart';
import '../models/error_model.dart';
import '../models/location_model.dart';
import 'error_provider.dart';
import 'user_provider.dart';

final locationProvider =
    StateNotifierProvider<LocationNotifier, LocationState>((ref) {
  return LocationNotifier(ref);
});

class LocationNotifier extends StateNotifier<LocationState> {
  final Ref ref;

  LocationNotifier(this.ref) : super(LocationState());

  void setMapReady(bool ready) {
    state = state.copyWith(isMapReady: ready);
  }

  Future<void> openLocationSettings() async {
    try {
      await Geolocator.openLocationSettings();
    } catch (e) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.network("Failed to open location settings"));
    }
  }

  Future<void> fetchCurrentLocation() async {
    // Clear any existing errors
    ref.read(errorProvider.notifier).clearError();

    // Reset state for fresh fetch
    state = state.copyWith(
      isFetching: true,
      isLoading: true,
      cachedLatitude: null,
      cachedLongitude: null,
    );

    try {
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        ref.read(errorProvider.notifier).setError(
            AppError.locationService("Location services are disabled"));
        state = state.copyWith(isLoading: false);
        return;
      }

      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          ref
              .read(errorProvider.notifier)
              .setError(AppError.validation("Location permissions are denied"));
          state = state.copyWith(isLoading: false);
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Location permissions are permanently denied"));
        state = state.copyWith(isLoading: false);
        return;
      }

      Position position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.high);

      final newLatitude = position.latitude;
      final newLongitude = position.longitude;

      // Update user provider with the location
      ref.read(userProvider.notifier).updateLocation(newLatitude, newLongitude);

      state = state.copyWith(
        latitude: newLatitude,
        longitude: newLongitude,
        cachedLatitude: newLatitude,
        cachedLongitude: newLongitude,
        isLoading: false,
      );
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
          AppError.network("Failed to fetch location: ${e.toString()}"));
      state = state.copyWith(isLoading: false);
    } finally {
      state = state.copyWith(isFetching: false);
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(latitude: latitude, longitude: longitude);
    ref.read(userProvider.notifier).updateLocation(latitude, longitude);
  }

  void useCachedLocation() {
    if (state.cachedLatitude != null && state.cachedLongitude != null) {
      updateLocation(state.cachedLatitude!, state.cachedLongitude!);
    }
  }
}



================================================
File: providers/media_upload_provider.dart
================================================
import 'dart:io';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../repositories/media_repository.dart';
import 'error_provider.dart';
import 'service_provider.dart';

final mediaUploadProvider = StateNotifierProvider<MediaUploadNotifier, List<MediaUploadModel?>>((ref) {
  final mediaRepository = ref.watch(mediaRepositoryProvider);
  return MediaUploadNotifier(ref, mediaRepository);
});

class MediaUploadNotifier extends StateNotifier<List<MediaUploadModel?>> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  
  // Initialize with 6 null slots for media
  MediaUploadNotifier(this.ref, this._mediaRepository) : super(List.filled(6, null));
  
  // File size limits in bytes
  static const int _maxImageSizeBytes = 10 * 1024 * 1024; // 10 MB
  static const int _maxVideoSizeBytes = 50 * 1024 * 1024; // 50 MB

  MediaUploadModel? _verificationImage;

  MediaUploadModel? get verificationImage => _verificationImage;

  void setVerificationImage(File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'image/jpeg';

    final isImage = mimeType.startsWith('image/');

    if (!isImage) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Only image files are allowed."),
      );
      return;
    }

    if (fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }

    // Update state
    _verificationImage = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
  }

  void clearVerificationImage() {
    _verificationImage = null;
  }

  Future<bool> uploadVerificationImage() async {
    if (_verificationImage == null) return false;

    try {
      // Clear any existing errors
      ref.read(errorProvider.notifier).clearError();

      // Get presigned URL
      final presignedUrl = await _mediaRepository.getVerificationPresignedUrl(
        _verificationImage!.fileName,
        _verificationImage!.fileType,
      );

      // Update verification image with presigned URL
      _verificationImage = _verificationImage!.copyWith(
        presignedUrl: () => presignedUrl,
        status: UploadStatus.inProgress,
      );

      // Upload the file
      final success = await _mediaRepository.uploadFileToS3(_verificationImage!);

      // Update status
      _verificationImage = _verificationImage!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload verification image',
      );

      return success;
    } on ApiException catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => e.message,
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.message),
      );
      return false;
    } catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => 'An unexpected error occurred. Please try again.',
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth("An unexpected error occurred. Please try again."),
      );
      return false;
    }
  }
  
  // Add or update media at a specific index
  void setMediaFile(int index, File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'application/octet-stream';
    
    final isImage = mimeType.startsWith('image/');
    final isVideo = mimeType.startsWith('video/');
    
    // Size validation
    if (isImage && fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }
    
    if (isVideo && fileSize > _maxVideoSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Video is too large. Maximum size is 50 MB."),
      );
      return;
    }
    
    // Update state
    final updatedState = [...state];
    updatedState[index] = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
    state = updatedState;
  }
  
  // Remove media at a specific index
  void removeMedia(int index) {
    final updatedState = [...state];
    updatedState[index] = null;
    state = updatedState;
  }
  
  // Get all non-null media items
  List<MediaUploadModel> getMediaItems() {
    return state.whereType<MediaUploadModel>().toList();
  }
  
  // Check if we have minimum required media (3)
  bool hasMinimumMedia() {
    return getMediaItems().length >= 3;
  }
  
  // Upload all media
  Future<bool> uploadAllMedia() async {
    final mediaItems = getMediaItems();
    if (mediaItems.isEmpty) return false;
    
    try {
      // Prepare file details for presigned URL request
      final fileDetails = mediaItems.map((item) => {
        'filename': item.fileName,
        'type': item.fileType,
      }).toList();
      
  print("lauda lassan 2");
      // Get presigned URLs
      final presignedUrlsResponse = await _mediaRepository.getPresignedUrls(fileDetails);
      
      // Update media items with presigned URLs
      final updatedState = [...state];
      for (int i = 0; i < mediaItems.length; i++) {
        final index = state.indexOf(mediaItems[i]);
        if (index >= 0 && index < presignedUrlsResponse.length) {
          updatedState[index] = mediaItems[i].copyWith(
            presignedUrl: () => presignedUrlsResponse[i]['url'],
            status: UploadStatus.inProgress,
          );
        }
      }
      state = updatedState;
      
      // Upload each file
      bool allSucceeded = true;
      for (int i = 0; i < mediaItems.length; i++) {
        final mediaItem = state.firstWhere(
          (item) => item?.fileName == mediaItems[i].fileName,
          orElse: () => null,
        );
        
        if (mediaItem != null) {
          final index = state.indexOf(mediaItem);
          bool success = false;
          
          try {
            success = await _mediaRepository.uploadFileToS3(mediaItem);
          } catch (e) {
            print('Initial upload failed: $e');
            success = false;
          }
          
          // Retry if failed
          if (!success) {
            success = await _mediaRepository.retryUpload(mediaItem);
          }
          
          // Update state with result
          final newUpdatedState = [...state];
          newUpdatedState[index] = mediaItem.copyWith(
            status: success ? UploadStatus.success : UploadStatus.failed,
            errorMessage: success ? () => null : () => 'Failed to upload',
          );
          state = newUpdatedState;
          
          if (!success) allSucceeded = false;
        }
      }
      
      return allSucceeded;
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.toString()),
      );
      return false;
    }
  }
}



================================================
File: providers/service_provider.dart
================================================

// File: providers/service_provider.dart
import 'package:dtx/models/media_upload_model.dart';
import 'package:dtx/repositories/media_repository.dart';
import 'package:dtx/repositories/user_repository.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/api_service.dart';
import '../services/http_service.dart';
import '../repositories/auth_repository.dart';
import '../utils/env_config.dart';

// API Service provider
final apiServiceProvider = Provider<ApiService>((ref) {
  return HttpService(baseUrl: EnvConfig.apiBaseUrl);
});

// Auth Repository provider
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AuthRepository(apiService);
});

final mediaRepositoryProvider = Provider<MediaRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return MediaRepository(apiService, ref);  // Pass the ref here
});

final userRepositoryProvider = Provider<UserRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return UserRepository(apiService);
});



================================================
File: providers/user_provider.dart
================================================
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:latlong2/latlong.dart';
import '../models/error_model.dart';
import '../models/user_model.dart';
import '../utils/app_enums.dart';

// Add this provider to track the loading state
final userLoadingProvider = StateProvider<bool>((ref) => false);

final userProvider = StateNotifierProvider<UserNotifier, UserModel>((ref) {
  return UserNotifier(ref);
});

class UserNotifier extends StateNotifier<UserModel> {
  final Ref ref;

  UserNotifier(this.ref) : super(UserModel());

  // New method to fetch user profile
  Future<bool> fetchProfile() async {
    try {
      ref.read(userLoadingProvider.notifier).state = true;
      ref.read(errorProvider.notifier).clearError();
      
      final userRepository = ref.read(userRepositoryProvider);
      final userModel = await userRepository.fetchUserProfile();
      
      state = userModel;
      
      ref.read(userLoadingProvider.notifier).state = false;
      return true;
    } on ApiException catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.message),
      );
      return false;
    } catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
        AppError.auth("Failed to load profile: ${e.toString()}"),
      );
      return false;
    }
  }

  void updateName(String firstName, String? lastName) {
    ref.read(errorProvider.notifier).clearError();

    if (firstName.isEmpty) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("First name is required"),
          );
      return;
    }

    if (firstName.trim().length < 3) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("First name must be at least 3 characters"),
          );
      return;
    }

    state = state.copyWith(
      name: firstName.trim(),
      lastName: lastName?.trim(),
    );
  }

  void updateDateOfBirth(DateTime date) {
    ref.read(errorProvider.notifier).clearError();

    final today = DateTime.now();
    final age = today.difference(date).inDays ~/ 365;

    if (date.year < 1900 || date.year > today.year) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid year"),
          );
      return;
    }

    if (age < 18) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("You must be at least 18 years old"),
          );
      return;
    }

    try {
      final validatedDate = DateTime(date.year, date.month, date.day);
      state = state.copyWith(dateOfBirth: validatedDate);
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid date combination"),
          );
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(
      latitude: latitude,
      longitude: longitude,
    );
  }

  LatLng getCurrentLocation() {
    return LatLng(
      state.latitude ?? 0.0,
      state.longitude ?? 0.0,
    );
  }

  bool isLocationValid() {
    return state.latitude != null &&
        state.longitude != null &&
        state.latitude != 0.0 &&
        state.longitude != 0.0;
  }

  bool isNameValid() => (state.name?.trim().length ?? 0) >= 3;

  void updateDatingIntention(DatingIntention? intention) {
    state = state.copyWith(
      datingIntention: intention,
    );
  }

  bool isDatingIntentionSelected() {
    return state.datingIntention != null;
  }

  void updateGender(Gender? gender) {
    state = state.copyWith(
      gender: gender,
    );
  }

  bool isGenderSelected() {
    return state.gender != null;
  }

  void updateHeight(String height) {
    state = state.copyWith(
      height: height,
    );
  }

  bool isHeightSelected() {
    return state.height != null;
  }

  void updateHometown(String? hometown) {
    state = state.copyWith(
      hometown: hometown,
    );
  }

  bool isHometownSelected() {
    return state.hometown != null;
  }

  void updateJobTitle(String? jobTitle) {
    state = state.copyWith(
      jobTitle: jobTitle?.trim(),
    );
  }

  void updateEducation(String? education) {
    state = state.copyWith(
      education: education?.trim(),
    );
  }

  void updateReligiousBeliefs(Religion? religion) {
    state = state.copyWith(
      religiousBeliefs: religion,
    );
  }

  void updateDrinkingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(
      drinkingHabit: habit,
    );
  }

  void updateSmokingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(
      smokingHabit: habit,
    );
  }

  void addPrompt(Prompt prompt) {
    final updatedPrompts = List<Prompt>.from(state.prompts)..add(prompt);
    state = state.copyWith(prompts: updatedPrompts);
  }

  void updatePromptAtIndex(int index, Prompt newPrompt) {
    final updatedPrompts = List<Prompt>.from(state.prompts);
    if (index < updatedPrompts.length) {
      updatedPrompts[index] = newPrompt;
      state = state.copyWith(prompts: updatedPrompts);
    }
  }

  Future<bool> saveProfile() async {
    try {
      // Clear any existing errors
      ref.read(errorProvider.notifier).clearError();
      
      // Basic validation
      if (!isProfileValid()) {
        ref.read(errorProvider.notifier).setError(
          AppError.validation("Please complete all required fields"),
        );
        return false;
      }
      
      // Get the repository from provider
      final userRepository = ref.read(userRepositoryProvider);
      
      // Send the profile data to the API
      final success = await userRepository.updateProfile(state);
      
      if (!success) {
        ref.read(errorProvider.notifier).setError(
          AppError.auth("Failed to save profile. Please try again."),
        );
      }
      
      return success;
    } on ApiException catch (e) {
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.message),
      );
      return false;
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
        AppError.auth("An unexpected error occurred. Please try again."),
      );
      return false;
    }
  }
  
  // Helper method to validate profile completeness
  bool isProfileValid() {
    return state.name != null && 
           state.name!.isNotEmpty &&
           state.dateOfBirth != null &&
           state.gender != null &&
           state.datingIntention != null &&
           isLocationValid();
  }

  void updateAudioPrompt(AudioPromptModel audioPrompt) {
    state = state.copyWith(
      audioPrompt: audioPrompt,
    );
  }
}



================================================
File: repositories/auth_repository.dart
================================================
// File: repositories/auth_repository.dart
import '../models/auth_model.dart';
import '../services/api_service.dart';

class AuthRepository {
  final ApiService _apiService;
  
  AuthRepository(this._apiService);
  
  // Send OTP to the provided phone number
  Future<bool> sendOtp(String phoneNumber) async {
    try {
      final response = await _apiService.post(
        '/api/send-otp',
        body: {'phoneNumber': phoneNumber},
      );
      
      return response['success'] == true;
    } on ApiException catch (e) {
      // Re-throw as repository exception or handle differently
      throw e;
    }
  }
  
  // Verify OTP and get JWT token
  Future<String> verifyOtp(String phoneNumber, String otpCode) async {
    try {
      final response = await _apiService.post(
        '/api/verify-otp',
        body: {
          'phoneNumber': phoneNumber,
          'otpCode': otpCode,
        },
      );
      
      if (response['success'] == true && response['token'] != null) {
        return response['token'].toString();
      } else {
        throw ApiException('Failed to verify OTP: No token received');
      }
    } on ApiException catch (e) {
      // Re-throw as repository exception or handle differently
      throw e;
    }
  }
  
  // Check authentication status
Future<AuthStatus> checkAuthStatus(String? token) async {
  final String methodName = 'checkAuthStatus';
  print('[${DateTime.now()}] $methodName - Starting auth status check');
  
  if (token == null || token.isEmpty) {
    print('[${DateTime.now()}] $methodName - No token found, redirecting to login');
    return AuthStatus.login;
  }

  try {
    // Sanitize token for logging (show first 4 and last 4 chars)
    final sanitizedToken = '${token.substring(0, 4)}...${token.substring(token.length - 4)}';
    print('[${DateTime.now()}] $methodName - Using token: $sanitizedToken');
    
    final headers = {
      'Authorization': 'Bearer $token',
    };
    
    print('[${DateTime.now()}] $methodName - Making request to /api/auth-status');
    print('[${DateTime.now()}] $methodName - Headers: ${headers.keys.join(', ')}');
    
    final response = await _apiService.get(
      '/api/auth-status',
      headers: headers,
    );
    
    print('[${DateTime.now()}] $methodName - Received response:');
    print('  Status Code: ${response['statusCode'] ?? 'Unknown'}');
    print('  Success: ${response['success']}');
    print('  Status: ${response['status']}');
    print('  Message: ${response['message']}');

    if (response['success'] == true) {
      final status = response['status']?.toString().toLowerCase();
      
      switch (status) {
        case 'home':
          print('[${DateTime.now()}] $methodName - Valid home status received');
          return AuthStatus.home;
        case 'onboarding':
          print('[${DateTime.now()}] $methodName - Profile incomplete, redirecting to onboarding');
          return AuthStatus.onboarding;
        default:
          print('[${DateTime.now()}] $methodName - Unrecognized status: $status');
          print('[${DateTime.now()}] $methodName - Defaulting to login');
          return AuthStatus.login;
      }
    }
    
    print('[${DateTime.now()}] $methodName - API response indicates failure');
    print('[${DateTime.now()}] $methodName - Full response: $response');
    return AuthStatus.login;

  } on ApiException catch (e, stack) {
    print('[${DateTime.now()}] $methodName - API Exception occurred:');
    print('  Error Type: ${e.runtimeType}');
    print('  Message: ${e.message}');
    print('  Status Code: ${e.statusCode}');
    print('  Stack Trace: $stack');
    return AuthStatus.login;
    
  } catch (e, stack) {
    print('[${DateTime.now()}] $methodName - Unexpected error occurred:');
    print('  Error Type: ${e.runtimeType}');
    print('  Message: $e');
    print('  Stack Trace: $stack');
    return AuthStatus.unknown;
  }
}


}



================================================
File: repositories/auth_status_repository.dart
================================================
// File: repositories/auth_status_repository.dart
import '../services/api_service.dart';
import '../utils/token_storage.dart';

enum AuthStatus {
  home,       // User authenticated with complete profile
  onboarding, // User authenticated but profile incomplete
  login,      // User not authenticated or invalid token
  unknown     // Error or initial state
}

class AuthStatusRepository {
  final ApiService _apiService;
  
  AuthStatusRepository(this._apiService);
  
  Future<AuthStatus> checkAuthStatus() async {
    try {
      // Get the saved token
      final token = await TokenStorage.getToken();
      
      if (token == null || token.isEmpty) {
        return AuthStatus.login;
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      // Make the API request
      final response = await _apiService.get(
        '/api/auth-status',
        headers: headers,
      );
      
      if (response['success'] == true) {
        final status = response['status']?.toString().toLowerCase();
        
        if (status == 'home') {
          return AuthStatus.home;
        } else if (status == 'onboarding') {
          return AuthStatus.onboarding;
        }
      }
      
      // Default to login if status is not recognized or success is false
      return AuthStatus.login;
    } on ApiException catch (e) {
      print('Auth status check failed: $e');
      // For authentication errors, redirect to login
      return AuthStatus.login;
    } catch (e) {
      print('Unexpected error during auth status check: $e');
      return AuthStatus.unknown;
    }
  }
}



================================================
File: repositories/media_repository.dart
================================================
// File: repositories/media_repository.dart
import 'dart:convert';
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/utils/token_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:http_parser/http_parser.dart';
import 'package:path/path.dart' as path;
import '../models/media_upload_model.dart';
import '../services/api_service.dart';

class MediaRepository {
  final ApiService _apiService;
  final Ref? ref;
  
  MediaRepository(this._apiService, [this.ref]);
  
  // Get presigned URLs for uploading files
  Future<List<Map<String, dynamic>>> getPresignedUrls(List<Map<String, String>> fileDetails) async {
    try {
      // Get the token either from the provider or storage
      String? token;
      if (ref != null) {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      }
      
      if (token == null) {
        // Fallback to token storage if not available from provider
        token = await TokenStorage.getToken();
      }
      
      if (token == null) {
        throw ApiException('Authentication token is missing');
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      final response = await _apiService.post(
        '/upload',
        body: {
          'files': fileDetails,
        },
        headers: headers,
      );
      
      if (response['uploads'] != null) {
        return List<Map<String, dynamic>>.from(response['uploads']);
      } else {
        throw ApiException('Failed to get presigned URLs');
      }
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error getting presigned URLs: ${e.toString()}');
    }
  }

  // Get presigned URL for audio upload
  Future<Map<String, dynamic>> getAudioPresignedUrl(String filename, String fileType, AudioPrompt prompt) async {
    try {
      // Get the token either from the provider or storage
      String? token;
      if (ref != null) {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      }
      
      if (token == null) {
        // Fallback to token storage if not available from provider
        token = await TokenStorage.getToken();
      }
      
      if (token == null) {
        throw ApiException('Authentication token is missing');
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      final response = await _apiService.post(
        '/audio',
        body: {
          'filename': filename,
          'type': fileType,
          'prompt': prompt.value,
        },
        headers: headers,
      );
      
      return response;
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error getting audio presigned URL: ${e.toString()}');
    }
  }

    // Get presigned URL for verification photo upload
  Future<String> getVerificationPresignedUrl(String filename, String fileType) async {
    try {
      // Get the token either from the provider or storage
      String? token;
      if (ref != null) {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      }

      if (token == null) {
        // Fallback to token storage if not available from provider
        token = await TokenStorage.getToken();
      }

      if (token == null) {
        throw ApiException('Authentication token is missing');
      }

      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };

      final response = await _apiService.post(
        '/verify',
        body: {
          'filename': filename,
          'type': fileType,
        },
        headers: headers,
      );

      if (response['upload_url'] != null) {
        return response['upload_url'];
      } else {
        throw ApiException('Failed to get verification presigned URL');
      }
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error getting verification presigned URL: ${e.toString()}');
    }
  }
  
  // Upload a file to S3 using presigned URL
// Upload a file to S3 using presigned URL
Future<bool> uploadFileToS3(MediaUploadModel mediaUpload) async {
  if (mediaUpload.presignedUrl == null) {
    throw ApiException('Missing presigned URL for upload');
  }

  final file = mediaUpload.file;
  final contentType = mediaUpload.fileType;
  final filePath = file.path;

  try {
    print('⏫ Starting S3 upload for: ${mediaUpload.fileName}');
    print('📁 File path: $filePath');
    print('📦 Content-Type: $contentType');
    print('📏 File size: ${(await file.length()) / 1024} KB');
    print('🔗 Presigned URL: ${mediaUpload.presignedUrl}');

    final client = HttpClient();
    final request = await client.putUrl(Uri.parse(mediaUpload.presignedUrl!));
    
    // Set headers from curl example
    request.headers.set(HttpHeaders.contentTypeHeader, contentType);
    request.contentLength = await file.length();

    // Add debug headers
    print('📨 Request headers:');
    request.headers.forEach((name, values) {
      print('   $name: ${values.join(', ')}');
    });

    // Pipe file content directly
    final fileStream = file.openRead();
    await request.addStream(fileStream);
    final response = await request.close();

    // Get response details
    final statusCode = response.statusCode;
    final responseHeaders = response.headers;
    final responseBody = await response.transform(utf8.decoder).join();

    print('📩 Upload response:');
    print('   Status: $statusCode');
    print('   Headers:');
    responseHeaders.forEach((name, values) {
      print('     $name: ${values.join(', ')}');
    });
    print('   Body: $responseBody');

    if (statusCode != HttpStatus.ok) {
      print('❌ Upload failed with status $statusCode');
      return false;
    }

    print('✅ Upload successful for ${mediaUpload.fileName}');
    return true;
  } catch (e, stack) {
    print('‼️ Critical upload error: $e');
    print('🛑 Stack trace: $stack');
    return false;
  }
}

  // Retry failed uploads with exponential backoff
  Future<bool> retryUpload(MediaUploadModel mediaUpload, {int maxRetries = 3}) async {
    int retryCount = 0;
    int backoffMs = 1000; // Start with 1 second
    
    while (retryCount < maxRetries) {
      try {
        final success = await uploadFileToS3(mediaUpload);
        if (success) return true;
      } catch (e) {
        print('Retry $retryCount failed: $e');
      }
      
      retryCount++;
      if (retryCount < maxRetries) {
        // Exponential backoff
        await Future.delayed(Duration(milliseconds: backoffMs));
        backoffMs *= 2; // Double the wait time for next retry
      }
    }
    
    return false;
  }
}



================================================
File: repositories/user_repository.dart
================================================

// File: repositories/user_repository.dart
import '../models/user_model.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';

class UserRepository {
  final ApiService _apiService;
  
  UserRepository(this._apiService);
  
// File: repositories/user_repository.dart (update)
// File: repositories/user_repository.dart (update)
Future<bool> updateProfile(UserModel userModel) async {
  try {
    // Get the saved token
    final token = await TokenStorage.getToken();
    
    if (token == null || token.isEmpty) {
      throw ApiException('Authentication token is missing');
    }
    
    // Create auth headers
    final headers = {
      'Authorization': 'Bearer $token',
    };
    
    // Format date of birth correctly (YYYY-MM-DD format without time)
    String? formattedDateOfBirth;
    if (userModel.dateOfBirth != null) {
      final dob = userModel.dateOfBirth!;
      formattedDateOfBirth = "${dob.year}-${dob.month.toString().padLeft(2, '0')}-${dob.day.toString().padLeft(2, '0')}";
    }
    
    // Format height correctly (remove space after apostrophe)
    String? formattedHeight;
    if (userModel.height != null) {
      // Replace "X' Y\"" with "X'Y\"" (remove space after apostrophe)
      formattedHeight = userModel.height!.replaceAll("' ", "'");
    }
    
    // Convert UserModel to API request format
    final Map<String, dynamic> requestBody = {
      'name': userModel.name,
      'last_name': userModel.lastName ?? '',
      'date_of_birth': formattedDateOfBirth,
      'latitude': userModel.latitude,
      'longitude': userModel.longitude,
      'gender': userModel.gender?.name,
      'dating_intention': userModel.datingIntention?.name,
      'height': formattedHeight,
      'hometown': userModel.hometown,
      'job_title': userModel.jobTitle,
      'education': userModel.education,
      'religious_beliefs': userModel.religiousBeliefs?.name,
      'drinking_habit': userModel.drinkingHabit?.name,
      'smoking_habit': userModel.smokingHabit?.name,
      'prompts': userModel.prompts.map((prompt) => {
        'category': prompt.category.value,
        'question': prompt.question.value,
        'answer': prompt.answer,
      }).toList(),
    };
    
    // Make the API request
    final response = await _apiService.post(
      '/api/profile',
      body: requestBody,
      headers: headers,
    );
    
    return response['success'] == true;
  } on ApiException {
    rethrow;
  } catch (e) {
    throw ApiException('Failed to update profile: ${e.toString()}');
  }
}

Future<UserModel> fetchUserProfile() async {
    try {
      // Get the saved token
      final token = await TokenStorage.getToken();
      
      if (token == null || token.isEmpty) {
        throw ApiException('Authentication token is missing');
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      // Make the API request
      final response = await _apiService.get(
        '/get-profile',
        headers: headers,
      );
      
      if (response['success'] == true && response['user'] != null) {
        return UserModel.fromJson(response['user']);
      } else {
        throw ApiException('Failed to fetch user profile');
      }
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error fetching user profile: ${e.toString()}');
    }
  }

}



================================================
File: services/api_service.dart
================================================

// File: services/api_service.dart
import 'dart:convert';

/// Abstract class defining the API service interface
abstract class ApiService {
  /// Base URL for all API requests
  String get baseUrl;

  /// Makes a GET request to the specified endpoint
  Future<Map<String, dynamic>> get(String endpoint, {Map<String, String>? headers});

  /// Makes a POST request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a PUT request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a DELETE request to the specified endpoint
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  });

  /// Adds authorization token to headers
  Map<String, String> addAuthToken(Map<String, String>? headers, String token);
}

/// Exception thrown when API requests fail
class ApiException implements Exception {
  final String message;
  final int? statusCode;

  ApiException(this.message, {this.statusCode});

  @override
  String toString() => 'ApiException: $message ${statusCode != null ? '(Status code: $statusCode)' : ''}';
}



================================================
File: services/http_service.dart
================================================

// File: services/http_service.dart
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'api_service.dart';

/// Implementation of ApiService using the http package
class HttpService implements ApiService {
  @override
  final String baseUrl;

  HttpService({required this.baseUrl});

  @override
  Map<String, String> addAuthToken(Map<String, String>? headers, String token) {
    final updatedHeaders = {...(headers ?? {})};
    updatedHeaders['Authorization'] = 'Bearer $token';
    print(updatedHeaders);
    return updatedHeaders;
  }

  @override
  Future<Map<String, dynamic>> get(String endpoint, {Map<String, String>? headers}) async {
    try {
      final response = await http.get(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      throw ApiException('Failed to perform GET request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.post(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform POST request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.put(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform PUT request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  }) async {
    try {
      final request = http.Request('DELETE', Uri.parse('$baseUrl$endpoint'));
      
      request.headers.addAll({
        'Content-Type': 'application/json',
        ...?headers,
      });
      
      if (body != null) {
        request.body = json.encode(body);
      }
      
      final streamedResponse = await request.send();
      final response = await http.Response.fromStream(streamedResponse);
      
      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform DELETE request: ${e.toString()}');
    }
  }

  /// Handle the HTTP response and convert to a standardized format
  Map<String, dynamic> _handleResponse(http.Response response) {
    try {
      final responseData = json.decode(response.body) as Map<String, dynamic>;
      
      if (response.statusCode >= 200 && response.statusCode < 300) {
        return responseData;
      } else {
        // Extract only the actual error message from the API response
        String errorMessage;
        
        if (responseData.containsKey('message')) {
          // Use the message directly from the response
          errorMessage = responseData['message'].toString();
        } else if (responseData.containsKey('error')) {
          // Some APIs use 'error' property
          errorMessage = responseData['error'].toString();
        } else {
          // Fallback error message
          errorMessage = 'An error occurred (Status: ${response.statusCode})';
        }
        
        throw ApiException(errorMessage, statusCode: response.statusCode);
      }
    } on FormatException {
      throw ApiException('Invalid response format', statusCode: response.statusCode);
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to process response: ${e.toString()}', statusCode: response.statusCode);
    }
  }
}



================================================
File: utils/app_enums.dart
================================================
enum Gender {
  man('man', 'Man'),
  woman('woman', 'Woman'),
  bisexual('bisexual', 'Bisexual'),
  lesbian('lesbian', 'Lesbian'),
  gay('gay', 'Gay');

  final String value;
  final String label;
  const Gender(this.value, this.label);
}

enum DatingIntention {
  lifePartner('lifePartner', 'Life partner'),
  longTerm('longTerm', 'Long-term relationship'),
  longTermOpenShort('longTermOpenShort', 'Long-term relationship, open to short'),
  shortTermOpenLong('shortTermOpenLong', 'Short-term relationship, open to long'),
  shortTerm('shortTerm', 'Short-term relationship'),
  figuringOut('figuringOut', 'Figuring out my dating goals');

  final String value;
  final String label;
  const DatingIntention(this.value, this.label);
}

enum Religion {
  agnostic('agnostic', 'Agnostic'),
  atheist('atheist', 'Atheist'),
  buddhist('buddhist', 'Buddhist'),
  christian('christian', 'Christian'),
  hindu('hindu', 'Hindu'),
  jain('jain', 'Jain'),
  jewish('jewish', 'Jewish'),
  muslim('muslim', 'Muslim'),
  zoroastrian('zoroastrian', 'Zoroastrian'),
  sikh('sikh', 'Sikh'),
  spiritual('spiritual', 'Spiritual');

  final String value;
  final String label;
  const Religion(this.value, this.label);
}

enum DrinkingSmokingHabits {
  yes('yes', 'Yes'),
  sometimes('sometimes', 'Sometimes'),
  no('no', 'No');

  final String value;
  final String label;
  const DrinkingSmokingHabits(this.value, this.label);
}

enum PromptCategory {
  storyTime('storyTime', 'Story time'),
  myType('myType', 'My type'),
  gettingPersonal('gettingPersonal', 'Getting personal'),
  dateVibes('dateVibes', 'Date vibes');

  final String value;
  final String label;
  const PromptCategory(this.value, this.label);

  List<PromptType> getPrompts() {
    switch (this) {
      case PromptCategory.storyTime:
        return [
          PromptType.twoTruthsAndALie,
          PromptType.worstIdea,
          PromptType.biggestRisk,
          PromptType.biggestDateFail,
          PromptType.neverHaveIEver,
          PromptType.bestTravelStory,
          PromptType.weirdestGift,
          PromptType.mostSpontaneous,
          PromptType.oneThingNeverDoAgain,
        ];
      case PromptCategory.myType:
        return [
          PromptType.nonNegotiable,
          PromptType.hallmarkOfGoodRelationship,
          PromptType.lookingFor,
          PromptType.weirdlyAttractedTo,
          PromptType.allIAskIsThatYou,
          PromptType.wellGetAlongIf,
          PromptType.wantSomeoneWho,
          PromptType.greenFlags,
          PromptType.sameTypeOfWeird,
          PromptType.fallForYouIf,
          PromptType.bragAboutYou,
        ];
      case PromptCategory.gettingPersonal:
        return [
          PromptType.oneThingYouShouldKnow,
          PromptType.loveLanguage,
          PromptType.dorkiestThing,
          PromptType.dontHateMeIf,
          PromptType.geekOutOn,
          PromptType.ifLovingThisIsWrong,
          PromptType.keyToMyHeart,
          PromptType.wontShutUpAbout,
          PromptType.shouldNotGoOutWithMeIf,
          PromptType.whatIfIToldYouThat,
        ];
      case PromptCategory.dateVibes:
        return [
          PromptType.togetherWeCould,
          PromptType.firstRoundIsOnMeIf,
          PromptType.whatIOderForTheTable,
          PromptType.bestSpotInTown,
          PromptType.bestWayToAskMeOut,
        ];
    }
  }
}

enum PromptType {
  twoTruthsAndALie('twoTruthsAndALie', 'Two truths and a lie'),
  worstIdea('worstIdea', 'Worst idea I\'ve ever had'),
  biggestRisk('biggestRisk', 'Biggest risk I\'ve taken'),
  biggestDateFail('biggestDateFail', 'My biggest date fail'),
  neverHaveIEver('neverHaveIEver', 'Never have I ever'),
  bestTravelStory('bestTravelStory', 'Best travel story'),
  weirdestGift('weirdestGift', 'Weirdest gift I\'ve given or received'),
  mostSpontaneous('mostSpontaneous', 'Most spontaneous thing I\'ve done'),
  oneThingNeverDoAgain('oneThingNeverDoAgain', 'One thing I\'ll never do again'),
  nonNegotiable('nonNegotiable', 'Something that\'s non-negotiable for me is'),
  hallmarkOfGoodRelationship('hallmarkOfGoodRelationship', 'The hallmark of a good relationship is'),
  lookingFor('lookingFor', 'I\'m looking for'),
  weirdlyAttractedTo('weirdlyAttractedTo', 'I\'m weirdly attracted to'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  wellGetAlongIf('wellGetAlongIf', 'We\'ll get along if'),
  wantSomeoneWho('wantSomeoneWho', 'I want someone who'),
  greenFlags('greenFlags', 'Green flags I look out for'),
  sameTypeOfWeird('sameTypeOfWeird', 'We\'re the same type of weird if'),
  fallForYouIf('fallForYouIf', 'I\'d fall for you if'),
  bragAboutYou('bragAboutYou', 'I\'ll brag about you to my friends if'),
  oneThingYouShouldKnow('oneThingYouShouldKnow', 'The one thing you should know about me is'),
  loveLanguage('loveLanguage', 'My Love Language is'),
  dorkiestThing('dorkiestThing', 'The dorkiest thing about me is'),
  dontHateMeIf('dontHateMeIf', 'Don\'t hate me if I'),
  geekOutOn('geekOutOn', 'I geek out on'),
  ifLovingThisIsWrong('ifLovingThisIsWrong', 'If loving this is wrong, I don\'t want to be right'),
  keyToMyHeart('keyToMyHeart', 'The key to my heart is'),
  wontShutUpAbout('wontShutUpAbout', 'I won\'t shut up about'),
  shouldNotGoOutWithMeIf('shouldNotGoOutWithMeIf', 'You should *not* go out with me if'),
  whatIfIToldYouThat('whatIfIToldYouThat', 'What if I told you that'),
  togetherWeCould('togetherWeCould', 'Together, we could'),
  firstRoundIsOnMeIf('firstRoundIsOnMeIf', 'First round is on me if'),
  whatIOderForTheTable('whatIOderForTheTable', 'What I order for the table'),
  bestSpotInTown('bestSpotInTown', 'I know the best spot in town for'),
  bestWayToAskMeOut('bestWayToAskMeOut', 'The best way to ask me out is by');

  final String value;
  final String label;
  const PromptType(this.value, this.label);

  PromptCategory getCategory() {
    for (var category in PromptCategory.values) {
      if (category.getPrompts().contains(this)) {
        return category;
      }
    }
    return PromptCategory.storyTime; // Default category if not found
  }

}

enum AudioPrompt {
  canWeTalkAbout('canWeTalkAbout', 'Can we talk about?'),
  captionThisPhoto('captionThisPhoto', 'Caption this photo'),
  caughtInTheAct('caughtInTheAct', 'Caught in the act'),
  changeMyMindAbout('changeMyMindAbout', 'Change my mind about'),
  chooseOurFirstDate('chooseOurFirstDate', 'Choose our first date'),
  commentIfYouveBeenHere('commentIfYouveBeenHere', 'Comment if you\'ve been here'),
  cookWithMe('cookWithMe', 'Cook with me'),
  datingMeIsLike('datingMeIsLike', 'Dating me is like'),
  datingMeWillLookLike('datingMeWillLookLike', 'Dating me will look like'),
  doYouAgreeOrDisagreeThat('doYouAgreeOrDisagreeThat', 'Do you agree or disagree that'),
  dontHateMeIfI('dontHateMeIfI', 'Don\'t hate me if I'),
  dontJudgeMe('dontJudgeMe', 'Don\'t judge me'),
  mondaysAmIRight('mondaysAmIRight', 'Mondays... am I right?'),
  aBoundaryOfMineIs('aBoundaryOfMineIs', 'A boundary of mine is'),
  aDailyEssential('aDailyEssential', 'A daily essential'),
  aDreamHomeMustInclude('aDreamHomeMustInclude', 'A dream home must include'),
  aFavouriteMemoryOfMine('aFavouriteMemoryOfMine', 'A favourite memory of mine'),
  aFriendsReviewOfMe('aFriendsReviewOfMe', 'A friend\'s review of me'),
  aLifeGoalOfMine('aLifeGoalOfMine', 'A life goal of mine'),
  aQuickRantAbout('aQuickRantAbout', 'A quick rant about'),
  aRandomFactILoveIs('aRandomFactILoveIs', 'A random fact I love is'),
  aSpecialTalentOfMine('aSpecialTalentOfMine', 'A special talent of mine'),
  aThoughtIRecentlyHadInTheShower('aThoughtIRecentlyHadInTheShower', 'A thought I recently had in the shower'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  guessWhereThisPhotoWasTaken('guessWhereThisPhotoWasTaken', 'Guess where this photo was taken'),
  helpMeIdentifyThisPhotoBomber('helpMeIdentifyThisPhotoBomber', 'Help me identify this photo bomber'),
  hiFromMeAndMyPet('hiFromMeAndMyPet', 'Hi from me and my pet'),
  howIFightTheSundayScaries('howIFightTheSundayScaries', 'How I fight the Sunday scaries'),
  howHistoryWillRememberMe('howHistoryWillRememberMe', 'How history will remember me'),
  howMyFriendsSeeMe('howMyFriendsSeeMe', 'How my friends see me'),
  howToPronounceMyName('howToPronounceMyName', 'How to pronounce my name'),
  iBeatMyBluesBy('iBeatMyBluesBy', 'I beat my blues by'),
  iBetYouCant('iBetYouCant', 'I bet you can\'t'),
  iCanTeachYouHowTo('iCanTeachYouHowTo', 'I can teach you how to'),
  iFeelFamousWhen('iFeelFamousWhen', 'I feel famous when'),
  iFeelMostSupportedWhen('iFeelMostSupportedWhen', 'I feel most supported when');

  final String value;
  final String label;
  const AudioPrompt(this.value, this.label);
}



================================================
File: utils/env_config.dart
================================================

// File: utils/env_config.dart
import 'package:flutter_dotenv/flutter_dotenv.dart';

class EnvConfig {
  static String get apiBaseUrl => 
    dotenv.get('API_BASE_URL', fallback: 'http://10.61.67.128:8080');
}



================================================
File: utils/token_storage.dart
================================================

// File: utils/token_storage.dart
import 'package:shared_preferences/shared_preferences.dart';

class TokenStorage {
  static const String _tokenKey = 'auth_token';
  
  // Save the JWT token
  static Future<bool> saveToken(String token) async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.setString(_tokenKey, token);
  }
  
  // Get the stored JWT token
  static Future<String?> getToken() async {
    final prefs = await SharedPreferences.getInstance();
    print(prefs.getString(_tokenKey));
    return prefs.getString(_tokenKey);
  }
  
  // Remove the stored token (for logout)
  static Future<bool> removeToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.remove(_tokenKey);
  }
  
  // Check if a token exists
  static Future<bool> hasToken() async {
    final token = await getToken();
    return token != null && token.isNotEmpty;
  }
}



================================================
File: views/audioprompt.dart
================================================
// views/audioprompt.dart
import 'package:dtx/providers/audio_upload_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/audiopromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:record/record.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'dart:io';
import '../providers/user_provider.dart';
import '../views/home.dart';

class VoicePromptScreen extends ConsumerStatefulWidget {
  const VoicePromptScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<VoicePromptScreen> createState() => _VoicePromptScreenState();
}

class _VoicePromptScreenState extends ConsumerState<VoicePromptScreen> {
  final AudioRecorder _audioRecorder = AudioRecorder();
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isRecording = false;
  String _recordingTime = "0:00 / 0:30";
  String? _audioPath;
  bool _isPlaying = false;
  DateTime? _startTime;
  bool _isSaving = false;
  bool _isUploading = false;

  @override
  void initState() {
    super.initState();
    _initializeAudioSession();
    // Add listener for playback completion
    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) {
        setState(() => _isPlaying = false);
      }
    });
  }

  Future<void> _initializeAudioSession() async {
    final status = await Permission.microphone.request();
    if (!status.isGranted) {
      throw 'Microphone permission not granted';
    }
  }

  Future<void> _startRecording() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      _audioPath =
          '${directory.path}/voice_prompt_${DateTime.now().millisecondsSinceEpoch}.m4a';

      await _audioRecorder.start(
        const RecordConfig(encoder: AudioEncoder.aacLc),
        path: _audioPath!,
      );

      _startTime = DateTime.now();
      setState(() => _isRecording = true);

      // Update timer every second
      Stream.periodic(const Duration(seconds: 1)).listen((_) {
        if (!_isRecording || !mounted) return;

        final duration = DateTime.now().difference(_startTime!).inSeconds;
        if (duration >= 30) {
          _stopRecording();
          return;
        }

        setState(() {
          _recordingTime = "0:${duration.toString().padLeft(2, '0')} / 0:30";
        });
      });
    } catch (e) {
      print('Recording error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Recording failed: ${e.toString()}')),
      );
    }
  }

  Future<void> _stopRecording() async {
    try {
      await _audioRecorder.stop();
      setState(() => _isRecording = false);
      
      // Save the file path to the provider instead of creating the file immediately
      if (_audioPath != null) {
        // Just save the path - don't create the media model yet
        ref.read(audioUploadProvider.notifier).setRecordingPath(_audioPath!);
      }
    } catch (e) {
      print('Stop recording error: $e');
    }
  }

  Future<void> _playRecording() async {
    if (_audioPath == null || !File(_audioPath!).existsSync()) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No recording available')),
      );
      return;
    }

    try {
      if (_isPlaying) {
        await _audioPlayer.stop();
        setState(() => _isPlaying = false);
      } else {
        await _audioPlayer.play(DeviceFileSource(_audioPath!));
        setState(() => _isPlaying = true);
      }
    } catch (e) {
      print('Playback error: $e');
      setState(() => _isPlaying = false);
    }
  }

  void _selectPrompt() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const AudioSelectPromptScreen()),
    ).then((_) {
      // Refresh UI after selecting a prompt
      setState(() {});
    });
  }

  // Upload audio and save profile
// Upload audio and save profile
Future<void> _uploadAudioAndSaveProfile() async {
  print('[VoicePrompt] Starting _uploadAudioAndSaveProfile');
  
  if (_isRecording) {
    print('[VoicePrompt] Currently recording, stopping...');
    await _stopRecording();
    print('[VoicePrompt] Recording stopped');
    
    // Give a small delay to ensure recording is fully stopped
    print('[VoicePrompt] Waiting 200ms for recording cleanup');
    await Future.delayed(const Duration(milliseconds: 200));
  }

  // Verify we have a recording
  if (_audioPath == null) {
    print('[VoicePrompt] ERROR: _audioPath is null');
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Please record your voice first')),
    );
    return;
  }
  
  final audioFile = File(_audioPath!);
  if (!audioFile.existsSync()) {
    print('[VoicePrompt] ERROR: Audio file does not exist at path: $_audioPath');
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Recording file not found')),
    );
    return;
  } else {
    final fileSize = audioFile.lengthSync();
    print('[VoicePrompt] Audio file exists, size: ${fileSize / 1024} KB');
  }

  // Verify prompt is selected
  final selectedPrompt = ref.read(audioUploadProvider.notifier).selectedPrompt;
  print('[VoicePrompt] Selected prompt: ${selectedPrompt?.value}');
  
  if (selectedPrompt == null) {
    print('[VoicePrompt] ERROR: No prompt selected');
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Please select a prompt category')),
    );
    return;
  }

  // Show loading state
  print('[VoicePrompt] Setting loading states to true');
  setState(() {
    _isUploading = true;
    _isSaving = true;
  });

  try {
    // Upload the audio file
    print('[VoicePrompt] Starting audio upload');
    final audioUploadNotifier = ref.read(audioUploadProvider.notifier);
    final audioUploaded = await audioUploadNotifier.uploadAudioAndSaveToProfile();
    print('[VoicePrompt] Audio upload result: $audioUploaded');
    
    if (!mounted) {
      print('[VoicePrompt] Widget not mounted after upload, returning');
      return;
    }
    
    if (audioUploaded) {
      // Now save the complete profile
      print('[VoicePrompt] Audio uploaded successfully, saving profile');
      final userNotifier = ref.read(userProvider.notifier);
      final profileSaved = await userNotifier.saveProfile();
      print('[VoicePrompt] Profile save result: $profileSaved');
      
      if (profileSaved) {
        // Navigate to home screen
        if (mounted) {
          print('[VoicePrompt] Profile saved successfully, navigating to HomeScreen');
          Navigator.of(context).pushAndRemoveUntil(
            MaterialPageRoute(builder: (_) => const HomeScreen()),
            (route) => false, // Clear all previous routes
          );
        } else {
          print('[VoicePrompt] Widget not mounted after profile save');
        }
      } else {
        if (mounted) {
          print('[VoicePrompt] ERROR: Failed to save profile');
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Failed to save profile. Please try again.')),
          );
        }
      }
    } else {
      if (mounted) {
        print('[VoicePrompt] ERROR: Failed to upload audio');
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to upload audio. Please try again.')),
        );
      }
    }
  } catch (e, stack) {
    print('[VoicePrompt] EXCEPTION during upload/save: $e');
    print('[VoicePrompt] Stack trace: $stack');
    
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: ${e.toString()}')),
      );
    }
  } finally {
    print('[VoicePrompt] Resetting loading states');
    if (mounted) {
      setState(() {
        _isUploading = false;
        _isSaving = false;
      });
    } else {
      print('[VoicePrompt] Widget not mounted in finally block');
    }
  }
}
  @override
  Widget build(BuildContext context) {
    final selectedPrompt = ref.watch(audioUploadProvider.notifier).selectedPrompt;
    
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 40),
              // Progress dots with mic icon
              Row(
                children: [
                  Container(
                    height: 8,
                    width: 8,
                    decoration: const BoxDecoration(
                      color: Colors.black,
                      shape: BoxShape.circle,
                    ),
                  ),
                  const SizedBox(width: 4),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      border:
                          Border.all(color: const Color(0xFF8b5cf6), width: 2),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(
                      Icons.mic,
                      color: Color(0xFF8b5cf6),
                      size: 24,
                    ),
                  ),
                  const SizedBox(width: 4),
                  Container(
                    height: 8,
                    width: 8,
                    decoration: BoxDecoration(
                      color: Colors.grey[300],
                      shape: BoxShape.circle,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 40),

              // Title
              const Text(
                'Add a Voice Prompt to\nyour profile',
                style: TextStyle(
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  height: 1.2,
                ),
              ),

              const SizedBox(height: 32),

              // Prompt Selection Button
              GestureDetector(
                onTap: _selectPrompt,
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(color: Colors.grey[300]!),
                  ),
                  child: Row(
                    children: [
                      Expanded(
                        child: Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                          child: Text(
                            selectedPrompt?.label ?? 'Select a prompt',
                            style: TextStyle(
                              color: selectedPrompt != null ? Colors.black : Colors.grey[600],
                              fontSize: 16,
                            ),
                          ),
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(right: 16),
                        child: Icon(
                          Icons.arrow_drop_down,
                          color: Colors.grey[800],
                        ),
                      ),
                    ],
                  ),
                ),
              ),

              const SizedBox(height: 24),

              // Recording Container
              Expanded(
                child: GestureDetector(
                  onTap: () =>
                      _isRecording ? _stopRecording() : _startRecording(),
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(24),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(color: Colors.grey[300]!),
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          _recordingTime,
                          style: TextStyle(
                            color: Colors.grey[400],
                            fontSize: 18,
                          ),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          _isRecording
                              ? 'Recording...'
                              : 'Tap to start recording',
                          style: TextStyle(
                            color: Colors.grey[400],
                            fontSize: 18,
                          ),
                        ),
                        const SizedBox(height: 32),
                        Container(
                          padding: const EdgeInsets.all(24),
                          decoration: BoxDecoration(
                            color: _isRecording
                                ? Colors.red
                                : const Color(0xFF8b5cf6),
                            shape: BoxShape.circle,
                          ),
                          child: Icon(
                            _isRecording ? Icons.stop : Icons.mic,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),

              const SizedBox(height: 16),

              // Play Sample Button
              if (_audioPath != null)
                Center(
                  child: TextButton.icon(
                    onPressed: _playRecording,
                    icon: Icon(
                      _isPlaying ? Icons.stop : Icons.play_arrow,
                      color: const Color(0xFF8b5cf6),
                    ),
                    label: Text(
                      _isPlaying ? 'Stop playing' : 'Play recording',
                      style: const TextStyle(
                        color: Color(0xFF8b5cf6),
                        fontSize: 16,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ),

              const SizedBox(height: 16),

              // Next Button
              Align(
                alignment: Alignment.centerRight,
                child: Container(
                  margin: const EdgeInsets.only(bottom: 24),
                  child: _isSaving || _isUploading
                      ? const CircularProgressIndicator(
                          color: Color(0xFF8b5cf6),
                        )
                      : FloatingActionButton(
                          onPressed: _uploadAudioAndSaveProfile,
                          backgroundColor: const Color(0xFF8b5cf6),
                          child: const Icon(
                            Icons.arrow_forward,
                            color: Colors.white,
                          ),
                        ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  @override
  void dispose() {
    _audioRecorder.dispose();
    _audioPlayer.dispose();
    super.dispose();
  }
}



================================================
File: views/audiopromptsselect.dart
================================================
// views/audiopromptsselect.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/providers/audio_upload_provider.dart';

class AudioSelectPromptScreen extends ConsumerWidget {
  const AudioSelectPromptScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentPrompt = ref.watch(audioUploadProvider.notifier).selectedPrompt;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    "Select a Prompt",
                    style: TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () => Navigator.pop(context),
                    child: const Icon(Icons.close, size: 24),
                  ),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                itemCount: AudioPrompt.values.length,
                itemBuilder: (context, index) {
                  final prompt = AudioPrompt.values[index];
                  final isSelected = prompt == currentPrompt;
                  
                  return GestureDetector(
                    onTap: () {
                      ref.read(audioUploadProvider.notifier).setSelectedPrompt(prompt);
                      Navigator.pop(context);
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                        color: isSelected ? const Color(0xFFEDE9FE) : null,
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              prompt.label,
                              style: TextStyle(
                                fontSize: 18,
                                color: isSelected ? const Color(0xFF8B5CF6) : Colors.black87,
                                fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                              ),
                            ),
                          ),
                          if (isSelected)
                            const Icon(
                              Icons.check_circle,
                              color: Color(0xFF8B5CF6),
                            ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dating_intentions.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';
import '../providers/user_provider.dart';
import 'height.dart';

class DatingIntentionsScreen extends ConsumerStatefulWidget {
  const DatingIntentionsScreen({super.key});

  @override
  ConsumerState<DatingIntentionsScreen> createState() =>
      _DatingIntentionsScreenState();
}

class _DatingIntentionsScreenState
    extends ConsumerState<DatingIntentionsScreen> {
  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.02),
                  Text(
                    "What's your dating intention?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.065,
                      fontWeight: FontWeight.bold,
                      color: Colors.black,
                    ),
                  ),
                  SizedBox(height: 65),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                physics: const BouncingScrollPhysics(),
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                itemCount: DatingIntention.values.length,
                itemBuilder: (context, index) {
                  return _buildOption(DatingIntention.values[index]);
                },
              ),
            ),
            Align(
              alignment: Alignment.centerRight,
              child: Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                child: GestureDetector(
                  onTap: userState.datingIntention != null
                      ? () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                                builder: (context) => HeightSelectionScreen()),
                          );
                        }
                      : null,
                  child: Container(
                    width: 56,
                    height: 56,
                    decoration: BoxDecoration(
                      color: userState.datingIntention != null
                          ? const Color(0xFF8B5CF6)
                          : Colors.grey.shade300,
                      shape: BoxShape.circle,
                      boxShadow: [
                        if (userState.datingIntention != null)
                          BoxShadow(
                            color: Colors.black.withOpacity(0.2),
                            spreadRadius: 1,
                            blurRadius: 8,
                          ),
                      ],
                    ),
                    child: Icon(
                      Icons.arrow_forward_rounded,
                      size: 28,
                      color: userState.datingIntention != null
                          ? Colors.white
                          : Colors.grey.shade500,
                    ),
                  ),
                ),
              ),
            ),
            SizedBox(height: screenSize.height * 0.04),
          ],
        ),
      ),
    );
  }

  Widget _buildOption(DatingIntention intention) {
    final bool isSelected =
        ref.watch(userProvider).datingIntention == intention;

    return GestureDetector(
      onTap: () {
        ref.read(userProvider.notifier).updateDatingIntention(intention);
      },
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 16),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.transparent,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade300,
            width: 1.5,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Text(
                intention.label,
                style: GoogleFonts.poppins(
                  fontSize: intention.label.length > 20 ? 14 : 16,
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                  color: isSelected ? Colors.white : Colors.black,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            if (isSelected)
              const Icon(
                Icons.check_circle,
                color: Colors.white,
                size: 24,
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dob.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/location.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class DateOfBirthScreen extends ConsumerStatefulWidget {
  const DateOfBirthScreen({super.key});

  @override
  ConsumerState<DateOfBirthScreen> createState() => _DateOfBirthScreenState();
}

class _DateOfBirthScreenState extends ConsumerState<DateOfBirthScreen> {
  final TextEditingController _dayController = TextEditingController();
  final TextEditingController _monthController = TextEditingController();
  final TextEditingController _yearController = TextEditingController();

  final FocusNode _dayFocusNode = FocusNode();
  final FocusNode _monthFocusNode = FocusNode();
  final FocusNode _yearFocusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    _dayFocusNode.addListener(() {
      if (!_dayFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _monthFocusNode.addListener(() {
      if (!_monthFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _yearFocusNode.addListener(() {
      if (!_yearFocusNode.hasFocus) {
        _validateInputs();
      }
    });
  }

  @override
  void dispose() {
    _dayController.dispose();
    _monthController.dispose();
    _yearController.dispose();
    _dayFocusNode.dispose();
    _monthFocusNode.dispose();
    _yearFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.1),
                Text(
                  "What's your date of birth?",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.08,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    _buildDateInput(
                      "DD",
                      _dayController,
                      _dayFocusNode,
                      2,
                      _monthFocusNode,
                    ),
                    _buildDateInput(
                      "MM",
                      _monthController,
                      _monthFocusNode,
                      2,
                      _yearFocusNode,
                    ),
                    _buildDateInput(
                      "YYYY",
                      _yearController,
                      _yearFocusNode,
                      4,
                      null,
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.03),
                Text(
                  "We use this to calculate the age on your profile.",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.04,
                    color: Colors.white70,
                  ),
                ),
                if (error?.type == ErrorType.validation)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      error!.message,
                      style: GoogleFonts.poppins(
                        color: Colors.redAccent,
                        fontSize: screenSize.width * 0.035,
                      ),
                    ),
                  ),
                const Spacer(),
                _buildNextButton(screenSize),
                SizedBox(height: screenSize.height * 0.05),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDateInput(
    String hint,
    TextEditingController controller,
    FocusNode focusNode,
    int maxLength,
    FocusNode? nextFocusNode,
  ) {
    return Expanded(
      flex: maxLength == 4 ? 2 : 1,
      child: TextField(
        controller: controller,
        focusNode: focusNode,
        keyboardType: TextInputType.number,
        maxLength: maxLength,
        style: GoogleFonts.poppins(
          fontSize: 24,
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
        decoration: InputDecoration(
          hintText: hint,
          hintStyle: GoogleFonts.poppins(
            fontSize: 24,
            fontWeight: FontWeight.w500,
            color: Colors.white70,
          ),
          counterText: "",
          enabledBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white54, width: 2.0),
          ),
          focusedBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white, width: 2.5),
          ),
        ),
        textAlign: TextAlign.center,
        onChanged: (value) {
          if (value.length == maxLength) {
            focusNode.unfocus();
            if (nextFocusNode != null) {
              FocusScope.of(context).requestFocus(nextFocusNode);
            }
          }
          _validateInputs();
        },
      ),
    );
  }

  void _validateInputs() {
    ref.read(errorProvider.notifier).clearError();
    final day = int.tryParse(_dayController.text) ?? 0;
    final month = int.tryParse(_monthController.text) ?? 0;
    final year = int.tryParse(_yearController.text) ?? 0;

    if (_dayController.text.isEmpty ||
        _monthController.text.isEmpty ||
        _yearController.text.isEmpty) return;

    if (day < 1 || day > 31) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid day"),
          );
      return;
    }

    if (month < 1 || month > 12) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid month"),
          );
      return;
    }

    try {
      final date = DateTime(year, month, day);
      ref.read(userProvider.notifier).updateDateOfBirth(date);
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid date combination"),
          );
    }
  }

  Widget _buildNextButton(Size screenSize) {
    final isValid = _dayController.text.length == 2 &&
        _monthController.text.length == 2 &&
        _yearController.text.length == 4 &&
        ref.read(errorProvider) == null;

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: isValid ? _handleNext : null,
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: isValid ? Colors.white : Colors.grey.shade400,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: const EdgeInsets.all(16),
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24,
          color: isValid ? const Color(0xFF8B5CF6) : Colors.white54,
        ),
      ),
    );
  }

  void _handleNext() {
    final date = DateTime(
      int.parse(_yearController.text),
      int.parse(_monthController.text),
      int.parse(_dayController.text),
    );

    ref.read(userProvider.notifier).updateDateOfBirth(date);
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const LocationInputScreen()),
    );
  }
}



================================================
File: views/drinking.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/smoking.dart';

class DrinkingScreen extends ConsumerStatefulWidget {
  const DrinkingScreen({super.key});

  @override
  ConsumerState<DrinkingScreen> createState() => _DrinkingScreenState();
}

class _DrinkingScreenState extends ConsumerState<DrinkingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedDrinkingHabit;
  bool _isOptionSelected = false;
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF8F9FA),
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: const Icon(
                      Icons.local_bar_rounded,
                      color: Color(0xFF8B5CF6),
                      size: 48,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.03),
                  Text(
                    "Do you drink?",
                    textAlign: TextAlign.left,
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.08,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF1A1A1A),
                      height: 1.1,
                    ),
                  ),
                  Text(
                    "Select your drinking habits",
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey[600],
                      height: 1.5,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.04),
                  Expanded(
                    child: ListView.separated(
                      itemCount: DrinkingSmokingHabits.values.length,
                      separatorBuilder: (context, index) =>
                          const SizedBox(height: 12),
                      itemBuilder: (context, index) {
                        final habit = DrinkingSmokingHabits.values[index];
                        return _buildDrinkingOptionTile(
                          screenSize: screenSize,
                          title: habit.label,
                          value: habit,
                        );
                      },
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding:
                          EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: AnimatedScale(
                        scale: _isOptionSelected ? 1.0 : 0.95,
                        duration: const Duration(milliseconds: 200),
                        child: GestureDetector(
                          onTap: () {
                            if (_isOptionSelected) {
                              FocusScope.of(context)
                                  .unfocus(); // Close the keyboard
                              ref
                                  .read(userProvider.notifier)
                                  .updateDrinkingHabit(_selectedDrinkingHabit);
                              Navigator.push(
                                  context,
                                  MaterialPageRoute(
                                      builder: (context) =>
                                          const SmokingScreen()));
                            } else {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(
                                    "Please select an option",
                                    style: GoogleFonts.poppins(),
                                  ),
                                  backgroundColor: Colors.red[400],
                                  behavior: SnackBarBehavior.floating,
                                ),
                              );
                            }
                          },
                          child: Container(
                            width: 70,
                            height: 70,
                            decoration: BoxDecoration(
                              color: _isOptionSelected
                                  ? const Color(0xFF8B5CF6)
                                  : Colors.grey.shade300,
                              borderRadius: BorderRadius.circular(35),
                              boxShadow: _isOptionSelected
                                  ? [
                                      BoxShadow(
                                        color: const Color(0xFF8B5CF6)
                                            .withOpacity(0.3),
                                        blurRadius: 8,
                                        offset: const Offset(0, 4),
                                      ),
                                    ]
                                  : null,
                            ),
                            child: Icon(
                              Icons.arrow_forward_rounded,
                              color: _isOptionSelected
                                  ? Colors.white
                                  : Colors.grey.shade600,
                              size: 32,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildDrinkingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedDrinkingHabit == value;

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedDrinkingHabit = value;
            _isOptionSelected = true;
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/gender.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';
import '../providers/user_provider.dart';
import 'dating_intentions.dart';

class GenderSelectionScreen extends ConsumerStatefulWidget {
  const GenderSelectionScreen({super.key});

  @override
  ConsumerState<GenderSelectionScreen> createState() =>
      _GenderSelectionScreenState();
}

class _GenderSelectionScreenState extends ConsumerState<GenderSelectionScreen> {
  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.03),
              Text(
                "Which gender best\ndescribes you?",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.065,
                  fontWeight: FontWeight.bold,
                  color: Colors.black,
                  height: 1.2,
                ),
              ),
              SizedBox(height: screenSize.height * 0.09),
              Column(
                children: Gender.values
                    .map((gender) => _buildOption(gender))
                    .toList(),
              ),
              const Spacer(),
              Align(
                alignment: Alignment.centerRight,
                child: GestureDetector(
                  onTap: userState.gender != null
                      ? () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                                builder: (context) =>
                                    const DatingIntentionsScreen()),
                          );
                        }
                      : null,
                  child: Container(
                    width: screenSize.width * 0.15,
                    height: screenSize.width * 0.15,
                    decoration: BoxDecoration(
                      color: userState.gender != null
                          ? const Color(0xFF8B5CF6)
                          : Colors.grey.shade300,
                      shape: BoxShape.circle,
                      boxShadow: [
                        if (userState.gender != null)
                          BoxShadow(
                            color: Colors.grey.shade400,
                            spreadRadius: 2,
                            blurRadius: 8,
                            offset: const Offset(0, 4),
                          ),
                      ],
                    ),
                    child: Icon(
                      Icons.arrow_forward_rounded,
                      size: 28,
                      color:
                          userState.gender != null ? Colors.white : Colors.grey,
                    ),
                  ),
                ),
              ),
              SizedBox(height: screenSize.height * 0.04),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOption(Gender gender) {
    final bool isSelected = ref.watch(userProvider).gender == gender;

    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Material(
        borderRadius: BorderRadius.circular(12),
        elevation: isSelected ? 2 : 0,
        child: InkWell(
          onTap: () {
            ref.read(userProvider.notifier).updateGender(gender);
          },
          borderRadius: BorderRadius.circular(12),
          child: Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
            decoration: BoxDecoration(
              color: isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade50,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: isSelected ? Colors.transparent : Colors.grey.shade300,
                width: 1,
              ),
            ),
            child: Text(
              gender.label,
              style: GoogleFonts.poppins(
                fontSize: 16,
                fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
                color: isSelected ? Colors.white : Colors.grey.shade800,
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/height.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';
import '../providers/user_provider.dart';
import 'hometown.dart';

class HeightSelectionScreen extends ConsumerStatefulWidget {
  const HeightSelectionScreen({super.key});

  @override
  ConsumerState<HeightSelectionScreen> createState() =>
      _HeightSelectionScreenState();
}

class _HeightSelectionScreenState extends ConsumerState<HeightSelectionScreen> {
  String _unit = "FT"; // Default unit is Feet
  int _selectedFeetIndex = 0; // Start at the first index
  int _selectedCmIndex = 30; // Start at 150 cm (index 30)

  // Define the starting and ending points explicitly
  int _startFeet = 4;
  int _startInches = 0;
  int _endFeet = 6;
  int _endInches = 5;

  List<String>? _feetValues; // Declare as nullable
  List<String> _cmValues = List.generate(81, (index) => "${120 + index} cm");

  // Function to convert CM to Feet and Inches string
  String _cmToFeet(int cm) {
    double totalInches = cm * 0.393701;
    int feet = (totalInches / 12).floor();
    int inches =
        (totalInches % 12).round(); // Round inches to nearest whole number
    if (inches == 12) {
      // Handle cases where inches round up to 12
      feet++;
      inches = 0;
    }
    return "$feet' $inches\"";
  }

  @override
  void initState() {
    super.initState();
    _feetValues = List.generate(
      ((_endFeet * 12) + _endInches) - ((_startFeet * 12) + _startInches) + 1,
      (index) {
        int totalInches = ((_startFeet * 12) + _startInches) + index;
        int feet = totalInches ~/ 12;
        int inches = totalInches % 12;
        return "$feet' $inches\"";
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        // Use appropriate values for the current unit
        final List<String> currentValues =
            _unit == "FT" ? _feetValues! : _cmValues;
        int currentIndex =
            _unit == "FT" ? _selectedFeetIndex : _selectedCmIndex;

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4), // Light background
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(
                      height: screenSize.height * 0.06), // Increased spacing

                  // Title
                  Center(
                    child: Text(
                      "How tall are you?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width *
                            0.1, // Increased font size for title
                        fontWeight: FontWeight.w700, // More bold title
                        color: const Color(0xFF333333), // Darker title color
                      ),
                    ),
                  ),

                  SizedBox(
                      height: screenSize.height *
                          0.05), // Increased spacing below title

                  // Height Selector
                  Expanded(
                    child: ListWheelScrollView.useDelegate(
                      itemExtent:
                          70, // Increased item extent for better spacing
                      diameterRatio: 1.3, // Adjusted for better visual
                      physics: const FixedExtentScrollPhysics(),
                      onSelectedItemChanged: (index) {
                        setState(() {
                          if (_unit == "FT") {
                            _selectedFeetIndex = index;
                          } else {
                            _selectedCmIndex = index;
                          }
                          _updateHeight(ref);
                        });
                      },
                      childDelegate: ListWheelChildBuilderDelegate(
                        childCount: currentValues.length,
                        builder: (context, index) {
                          final isSelected = index == currentIndex;
                          return Center(
                            child: Text(
                              currentValues[index],
                              style: GoogleFonts.poppins(
                                fontSize: isSelected
                                    ? 30
                                    : 22, // Larger font sizes for list items
                                fontWeight: isSelected
                                    ? FontWeight.w600
                                    : FontWeight.w400, // Adjusted weight
                                color: isSelected
                                    ? const Color(0xFF8B5CF6)
                                    : Colors.grey
                                        .shade700, // Highlighted selected color, darker unselected
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                  ),

                  SizedBox(
                      height: screenSize.height *
                          0.03), // Reduced spacing above buttons

                  // Unit Toggle Buttons - Improved UI
                  Padding(
                    padding: EdgeInsets.symmetric(
                        horizontal: screenSize.width *
                            0.1), // Add horizontal padding for buttons
                    child: Row(
                      mainAxisAlignment:
                          MainAxisAlignment.spaceAround, // Space buttons evenly
                      children: [
                        _buildUnitButton("FT", screenSize),
                        _buildUnitButton("CM", screenSize),
                      ],
                    ),
                  ),

                  SizedBox(
                      height: screenSize.height *
                          0.04), // Spacing before forward button

                  // Forward Button - More prominent and centered
                  Center(
                    child: GestureDetector(
                      onTap: userState.height != null
                          ? () {
                              Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) => HometownScreen()),
                              );
                            }
                          : null,
                      child: Container(
                        width: 70, // Even larger button
                        height: 70,
                        decoration: BoxDecoration(
                          color: userState.height != null
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey.shade400,
                          borderRadius:
                              BorderRadius.circular(35), // More rounded
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32, // Larger icon
                        ),
                      ),
                    ),
                  ),
                  SizedBox(
                      height:
                          screenSize.height * 0.06), // Increased bottom spacing
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildUnitButton(String unit, Size screenSize) {
    final isSelected = _unit == unit;
    return GestureDetector(
      onTap: () {
        setState(() {
          _unit = unit;
        });
      },
      child: Container(
        padding: EdgeInsets.symmetric(
            vertical: 12,
            horizontal: screenSize.width * 0.08), // Dynamic horizontal padding
        decoration: BoxDecoration(
          color: isSelected
              ? const Color(0xFF8B5CF6)
              : Colors.white, // White background for unselected
          border: Border.all(color: Colors.grey.shade300), // Subtle border
          borderRadius: BorderRadius.circular(30), // Even more rounded corners
          boxShadow: [
            // Subtle shadow for depth
            BoxShadow(
              color: Colors.grey.withOpacity(0.15),
              spreadRadius: 0,
              blurRadius: 3,
              offset: const Offset(0, 2), // changes position of shadow
            ),
          ],
        ),
        child: Text(
          unit,
          style: GoogleFonts.poppins(
            fontSize: 18, // Larger font size for buttons
            fontWeight: isSelected
                ? FontWeight.w600
                : FontWeight.w500, // Slightly bolder for selected
            color: isSelected
                ? Colors.white
                : const Color(0xFF555555), // Darker text for unselected
          ),
        ),
      ),
    );
  }

  void _updateHeight(WidgetRef ref) {
    String savedHeightFeet;
    String selectedValue = _unit == "FT"
        ? _feetValues![_selectedFeetIndex]
        : _cmValues[_selectedCmIndex];

    if (_unit == "CM") {
      savedHeightFeet =
          _cmToFeet(int.parse(selectedValue.replaceAll(" cm", "")));
    } else {
      savedHeightFeet = selectedValue;
    }

    ref.read(userProvider.notifier).updateHeight(savedHeightFeet);
  }
}



================================================
File: views/home.dart
================================================
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/verification_message_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen>
    with SingleTickerProviderStateMixin {
  Offset _dragOffset = Offset.zero;
  double _angle = 0;
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
  }

  void _onPanUpdate(DragUpdateDetails details) {
    setState(() {
      _dragOffset += details.delta;
      _angle = (_dragOffset.dx / 50).clamp(-0.3, 0.3);
    });
  }

  void _onPanEnd(DragEndDetails details) {
    final screenWidth = MediaQuery.of(context).size.width;
    if (_dragOffset.dx.abs() > screenWidth * 0.4) {
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => const VerificationMessageScreen(),
        ),
      );
      setState(() {
        _dragOffset = Offset.zero;
        _angle = 0;
      });
    } else {
      setState(() {
        _dragOffset = Offset.zero;
        _angle = 0;
      });
    }
  }

  void _navigateToProfile() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const ProfileScreen()),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey[100],
      body: SafeArea(
        child: Column(
          children: [
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
              decoration: BoxDecoration(
                color: Colors.white,
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.05),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    "Peeple",
                    style: GoogleFonts.pacifico(
                      fontSize: 24,
                      color: const Color(0xFF8B5CF6),
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  Row(
                    children: [
                      _buildTopBarIcon(Icons.person, "Profile", _navigateToProfile),
                      const SizedBox(width: 16),
                      _buildTopBarIcon(Icons.chat_bubble_outline_rounded, "Messages", () {}),
                    ],
                  ),
                ],
              ),
            ),

            Expanded(
              child: Stack(
                alignment: Alignment.bottomCenter,
                children: [
                  Transform.translate(
                    offset: _dragOffset,
                    child: Transform(
                      transform: Matrix4.identity()
                        ..setEntry(3, 2, 0.001)
                        ..rotateZ(_angle)
                        ..translate(0.0, 0.0, 0.0),
                      alignment: Alignment.bottomCenter,
                      child: GestureDetector(
                        onPanUpdate: _onPanUpdate,
                        onPanEnd: _onPanEnd,
                        child: Card(
                          margin: const EdgeInsets.all(16),
                          elevation: 8,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(16),
                          ),
                          child: ClipRRect(
                            borderRadius: BorderRadius.circular(16),
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Expanded(
                                  child: Stack(
                                    fit: StackFit.expand,
                                    children: [
                                      Container(
                                        decoration: BoxDecoration(
                                          gradient: LinearGradient(
                                            begin: Alignment.topRight,
                                            end: Alignment.bottomLeft,
                                            colors: [
                                              Colors.purple.shade200,
                                              Colors.blue.shade200,
                                            ],
                                          ),
                                        ),
                                        child: const Icon(Icons.person,
                                            size: 100, color: Colors.white),
                                      ),
                                      Positioned(
                                        bottom: 0,
                                        left: 0,
                                        right: 0,
                                        height: 240,
                                        child: Container(
                                          decoration: BoxDecoration(
                                            gradient: LinearGradient(
                                              begin: Alignment.topCenter,
                                              end: Alignment.bottomCenter,
                                              colors: [
                                                Colors.transparent,
                                                Colors.black.withOpacity(0.8),
                                              ],
                                            ),
                                          ),
                                        ),
                                      ),
                                      Positioned(
                                        bottom: 16,
                                        left: 16,
                                        right: 16,
                                        child: Column(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: [
                                            const Row(
                                              children: [
                                                Text(
                                                  'Sarah',
                                                  style: TextStyle(
                                                    color: Colors.white,
                                                    fontSize: 32,
                                                    fontWeight: FontWeight.bold,
                                                  ),
                                                ),
                                                SizedBox(width: 8),
                                                Text(
                                                  '25',
                                                  style: TextStyle(
                                                    color: Colors.white,
                                                    fontSize: 28,
                                                  ),
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 8),
                                            Row(
                                              children: [
                                                Icon(Icons.work,
                                                    color: Colors.white
                                                        .withOpacity(0.9),
                                                    size: 16),
                                                const SizedBox(width: 4),
                                                Text(
                                                  'Software Developer',
                                                  style: TextStyle(
                                                    color: Colors.white
                                                        .withOpacity(0.9),
                                                    fontSize: 16,
                                                  ),
                                                ),
                                                const SizedBox(width: 16),
                                                Icon(Icons.location_on,
                                                    color: Colors.white
                                                        .withOpacity(0.9),
                                                    size: 16),
                                                const SizedBox(width: 4),
                                                Text(
                                                  '5 miles away',
                                                  style: TextStyle(
                                                    color: Colors.white
                                                        .withOpacity(0.9),
                                                    fontSize: 16,
                                                  ),
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 12),
                                            Wrap(
                                              spacing: 8,
                                              runSpacing: 8,
                                              children: [
                                                _buildInterestChip('Travel'),
                                                _buildInterestChip('Photography'),
                                                _buildInterestChip('Cooking'),
                                                _buildInterestChip('Reading'),
                                              ],
                                            ),
                                            const SizedBox(height: 12),
                                            Text(
                                              'Coffee enthusiast. Adventure seeker. Book lover. Looking for someone to share adventures with! 🌟',
                                              style: TextStyle(
                                                color: Colors.white
                                                    .withOpacity(0.9),
                                                fontSize: 14,
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),

            Padding(
              padding: const EdgeInsets.symmetric(vertical: 16),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  _buildActionButton(Icons.close, Colors.red),
                  _buildActionButton(Icons.star, const Color(0xFF8B5CF6)),
                  _buildActionButton(Icons.favorite, Colors.green),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTopBarIcon(IconData icon, String tooltip, VoidCallback onPressed) {
    return Container(
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: Colors.grey[50],
      ),
      child: IconButton(
        icon: Icon(icon, color: const Color(0xFF8B5CF6), size: 22),
        tooltip: tooltip,
        onPressed: onPressed,
      ),
    );
  }

  Widget _buildInterestChip(String label) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.2),
        borderRadius: BorderRadius.circular(20),
      ),
      child: Text(
        label,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 12,
        ),
      ),
    );
  }

  Widget _buildActionButton(IconData icon, Color color) {
    return GestureDetector(
      onTap: () {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => const VerificationMessageScreen(),
          ),
        );
      },
      child: Container(
        width: 60,
        height: 60,
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: Colors.white,
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 8,
              spreadRadius: 2,
            ),
          ],
        ),
        child: Icon(icon, color: color, size: 30),
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}



================================================
File: views/hometown.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/job.dart';

class HometownScreen extends ConsumerStatefulWidget {
  const HometownScreen({super.key});

  @override
  ConsumerState<HometownScreen> createState() => _HometownScreenState();
}

class _HometownScreenState extends ConsumerState<HometownScreen> {
  final TextEditingController _hometownController = TextEditingController();

  @override
  void dispose() {
    _hometownController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4),
          body: SafeArea(
            child: Padding(
              padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),

                  // Top Navigation Bar with Skip Button
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      IconButton(
                        icon: Icon(
                          Icons.home_rounded,
                          color: const Color(0xFF8B5CF6),
                          size: 32,
                        ),
                        onPressed: () {
                          // Handle home button action
                        },
                      ),
                      // Skip Button - Top Right
                      TextButton(
                        onPressed: () {
                          ref.read(userProvider.notifier).updateHometown(null);
                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const JobTitleScreen())
                          );
                        },
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600, // Subdued color
                          padding: EdgeInsets.zero, // Remove default padding
                          minimumSize: Size.zero, // Make button size adjust to text
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap, // Reduce tap target size
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                            fontSize: 16, // Smaller font size than title
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),

                  SizedBox(height: screenSize.height * 0.07),

                  // Question Text
                  Text(
                    "Where's your home\ntown?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.1,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF333333),
                      height: 1.1,
                    ),
                  ),

                  SizedBox(height: screenSize.height * 0.05),

                  // Text Field
                  Padding(
                    padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                    child: TextField(
                      controller: _hometownController,
                      style: GoogleFonts.poppins(
                        fontSize: 22,
                        color: Colors.black87,
                      ),
                      decoration: InputDecoration(
                        hintText: "Udaipur",
                        hintStyle: GoogleFonts.poppins(
                          fontSize: 22,
                          color: Colors.grey.shade500,
                        ),
                        border: const UnderlineInputBorder(
                          borderSide: BorderSide(color: Colors.grey, width: 1.0),
                        ),
                        focusedBorder: const UnderlineInputBorder(
                          borderSide: BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                        ),
                      ),
                    ),
                  ),

                  const Spacer(),

                  // Forward Button
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: GestureDetector(
                        onTap: () {
                          String? hometown; // Changed to String? to allow null
                          if (_hometownController.text.isNotEmpty) {
                            hometown = _hometownController.text;
                            ref.read(userProvider.notifier).updateHometown(hometown);
                          } else {
                            hometown = null; // Set to null if text field is empty
                          }

                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const JobTitleScreen())
                          );
                        },
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: const Color(0xFF8B5CF6),
                            borderRadius: BorderRadius.circular(35),
                          ),
                          child: const Icon(
                            Icons.arrow_forward_rounded,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}



================================================
File: views/job.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/study.dart';

class JobTitleScreen extends ConsumerStatefulWidget {
  const JobTitleScreen({super.key});

  @override
  ConsumerState<JobTitleScreen> createState() => _JobTitleScreenState();
}

class _JobTitleScreenState extends ConsumerState<JobTitleScreen> {
  final TextEditingController _jobTitleController = TextEditingController();

  @override
  void dispose() {
    _jobTitleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4),
          body: SafeArea(
            child: Padding(
              padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),

                  // Top Navigation Bar with Skip Button
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.person_rounded, color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {
                          // Handle home button action
                        },
                      ),
                      // Skip Button - Top Right
                      TextButton(
                        onPressed: () {
                          ref.read(userProvider.notifier).updateJobTitle(null);
                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const StudyLocationScreen())
                          );
                        },
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),

                  SizedBox(height: screenSize.height * 0.07),

                  // Question Text
                  Text(
                    "What's your job title?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.1,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF333333),
                      height: 1.1,
                    ),
                  ),

                  SizedBox(height: screenSize.height * 0.05),

                  // Text Field
                  Padding(
                    padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                    child: TextField(
                      controller: _jobTitleController,
                      style: GoogleFonts.poppins(
                        fontSize: 22,
                        color: Colors.black87,
                      ),
                      decoration: InputDecoration(
                        hintText: "SDE",
                        hintStyle: GoogleFonts.poppins(
                          fontSize: 22,
                          color: Colors.grey.shade500,
                        ),
                        border: const UnderlineInputBorder(
                          borderSide: BorderSide(color: Colors.grey, width: 1.0),
                        ),
                        focusedBorder: const UnderlineInputBorder(
                          borderSide: BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                        ),
                      ),
                    ),
                  ),

                  const Spacer(),

                  // Forward Button
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: GestureDetector(
                        onTap: () {
                          String? jobTitle;
                          if (_jobTitleController.text.isNotEmpty) {
                            jobTitle = _jobTitleController.text;
                            ref.read(userProvider.notifier).updateJobTitle(jobTitle);
                          } else {
                            jobTitle = null;
                          }

                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const StudyLocationScreen())
                          );
                        },
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: const Color(0xFF8B5CF6),
                            borderRadius: BorderRadius.circular(35),
                          ),
                          child: const Icon(
                            Icons.arrow_forward_rounded,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}



================================================
File: views/location.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:app_settings/app_settings.dart';
import '../providers/location_provider.dart';
import '../providers/error_provider.dart';
import 'gender.dart';

class LocationInputScreen extends ConsumerStatefulWidget {
  const LocationInputScreen({super.key});

  @override
  ConsumerState<LocationInputScreen> createState() =>
      _LocationInputScreenState();
}

class _LocationInputScreenState extends ConsumerState<LocationInputScreen> {
  late final MapController _mapController;

  @override
  void initState() {
    super.initState();
    _mapController = MapController();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(locationProvider.notifier).fetchCurrentLocation();
    });
  }

  void _onMapReady() {
    ref.read(locationProvider.notifier).setMapReady(true);
    _moveToCurrentLocation();
  }

  void _moveToCurrentLocation() {
    final locationState = ref.read(locationProvider);
    if (locationState.isMapReady) {
      _mapController.move(
        LatLng(locationState.latitude, locationState.longitude),
        _mapController.camera.zoom,
      );
    }
  }

  Future<void> _showLocationServiceDialog() async {
    return showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(
            'Location Services Required',
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
          ),
          content: SingleChildScrollView(
            child: ListBody(
              children: <Widget>[
                Text(
                  'To show you relevant places around you, we need access to your location.',
                  style: GoogleFonts.poppins(),
                ),
                const SizedBox(height: 15),
                Text(
                  'Please enable location services in your device settings.',
                  style: GoogleFonts.poppins(),
                ),
              ],
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: Text(
                'Open Settings',
                style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6)),
              ),
              onPressed: () {
                Navigator.pop(context);
                ref.read(locationProvider.notifier).openLocationSettings();
              },
            ),
            TextButton(
              child: Text(
                'Retry',
                style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6)),
              ),
              onPressed: () {
                Navigator.pop(context);
                ref.read(errorProvider.notifier).clearError();
                ref.read(locationProvider.notifier).fetchCurrentLocation();
              },
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final locationState = ref.watch(locationProvider);
    final error = ref.watch(errorProvider);

    // Show location service dialog if needed
    if (error?.type == ErrorType.locationService) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _showLocationServiceDialog();
      });
    }

    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.04),
              Center(
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: List.generate(
                    10,
                    (index) => Container(
                      margin: const EdgeInsets.symmetric(horizontal: 2),
                      width: 8,
                      height: 8,
                      decoration: BoxDecoration(
                        color: index < 5
                            ? const Color(0xFF8B5CF6)
                            : Colors.grey.shade300,
                        shape: BoxShape.circle,
                      ),
                    ),
                  ),
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              Row(
                children: [
                  const Icon(
                    Icons.location_on_outlined,
                    color: Colors.black,
                    size: 28,
                  ),
                  const SizedBox(width: 10),
                  Text(
                    "Where do you live?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.07,
                      fontWeight: FontWeight.bold,
                      color: Colors.black,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 10),
              Text(
                "Only the neighbourhood name will appear on your profile.",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey.shade600,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              Expanded(
                child: !locationState.isLoading
                    ? Stack(
                        children: [
                          Container(
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(12),
                              border: Border.all(color: Colors.grey.shade300),
                            ),
                            clipBehavior: Clip.hardEdge,
                            child: FlutterMap(
                              mapController: _mapController,
                              options: MapOptions(
                                initialCenter: LatLng(locationState.latitude,
                                    locationState.longitude),
                                initialZoom: 14.0,
                                onTap: (tapPosition, latlng) {
                                  ref
                                      .read(locationProvider.notifier)
                                      .updateLocation(
                                        latlng.latitude,
                                        latlng.longitude,
                                      );
                                },
                                onMapReady: _onMapReady,
                              ),
                              children: [
                                TileLayer(
                                  urlTemplate:
                                      'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                                  subdomains: const ['a', 'b', 'c'],
                                ),
                                MarkerLayer(
                                  markers: [
                                    Marker(
                                      point: LatLng(locationState.latitude,
                                          locationState.longitude),
                                      width: 40,
                                      height: 40,
                                      child: const Icon(
                                        Icons.location_on,
                                        color: Color(0xFF8B5CF6),
                                        size: 40,
                                      ),
                                    ),
                                  ],
                                ),
                              ],
                            ),
                          ),
                          Positioned(
                            bottom: 16,
                            right: 16,
                            child: FloatingActionButton(
                              onPressed: () => ref
                                  .read(locationProvider.notifier)
                                  .useCachedLocation(),
                              backgroundColor: const Color(0xFF8B5CF6),
                              child: Icon(
                                  locationState.isFetching
                                      ? Icons.location_searching
                                      : Icons.my_location,
                                  color: Colors.white),
                            ),
                          ),
                        ],
                      )
                    : const Center(
                        child: CircularProgressIndicator(
                          color: Color(0xFF8B5CF6),
                        ),
                      ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              Align(
                alignment: Alignment.centerRight,
                child: GestureDetector(
                  onTap: () {
                    Navigator.push(
                        context,
                        MaterialPageRoute(
                            builder: (context) =>
                                const GenderSelectionScreen()));
                  },
                  child: Container(
                    width: screenSize.width * 0.15,
                    height: screenSize.width * 0.15,
                    decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6),
                      shape: BoxShape.circle,
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.2),
                          spreadRadius: 2,
                          blurRadius: 8,
                          offset: const Offset(0, 4),
                        ),
                      ],
                    ),
                    child: const Icon(
                      Icons.arrow_forward_rounded,
                      size: 28,
                      color: Colors.white,
                    ),
                  ),
                ),
              ),
              SizedBox(height: screenSize.height * 0.04),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _mapController.dispose();
    super.dispose();
  }
}



================================================
File: views/media.dart
================================================
import 'dart:io';
import 'dart:typed_data';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/views/religion.dart';
import 'package:dtx/views/prompt.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:get_thumbnail_video/video_thumbnail.dart'; // Updated package
import 'package:reorderable_grid_view/reorderable_grid_view.dart';
import 'package:dotted_border/dotted_border.dart';
import 'package:get_thumbnail_video/index.dart';

import '../models/error_model.dart'; // NEW import

class MediaPickerScreen extends ConsumerStatefulWidget {
  const MediaPickerScreen({super.key});

  @override
  ConsumerState<MediaPickerScreen> createState() => _MediaPickerState();
}

class _MediaPickerState extends ConsumerState<MediaPickerScreen> {
  late List<MediaFile> _selectedMedia;
  late List<UniqueKey> _itemKeys;
  bool _isForwardButtonEnabled = false;
  final _thumbnailCache = <String, Uint8List>{};
  bool _isUploading = false; // Add this new variable

  final Set<String> _allowedImageMime = {
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/jpg'
  };

  final Set<String> _allowedVideoMime = {
    'video/mp4',
    'video/quicktime',
    'video/x-msvideo',
    'video/mpeg',
    'video/3gpp',
    'video/mp2t'
  };

  final Set<String> _allowedImageExtensions = {
    'jpg',
    'jpeg',
    'png',
    'gif',
    'webp',
    'bmp',
    'tiff'
  };

  final Set<String> _allowedVideoExtensions = {
    'mp4',
    'mov',
    'avi',
    'mpeg',
    'mpg',
    '3gp',
    'ts',
    'mkv'
  };

  @override
  void initState() {
    super.initState();
    _selectedMedia = List.generate(
        6, (index) => MediaFile(file: null, type: MediaType.image));
    _itemKeys = List.generate(6, (index) => UniqueKey());
  }

  @override
  void dispose() {
    _thumbnailCache.clear();
    super.dispose();
  }

Future<void> _pickMedia(int index) async {
  final ImagePicker picker = ImagePicker();
  final XFile? media = await picker.pickMedia();

  if (media != null) {
    final mimeType = media.mimeType?.toLowerCase();
    final extension = media.path.split('.').last.toLowerCase();
    final filePath = media.path.replaceFirst('file://', '');
    final file = File(filePath);
    
    final isValidImage = _allowedImageMime.contains(mimeType) || 
                       _allowedImageExtensions.contains(extension);
    final isValidVideo = _allowedVideoMime.contains(mimeType) || 
                       _allowedVideoExtensions.contains(extension);
    // Check file size
    final fileSize = await file.length();
    final isImage = _allowedImageMime.contains(mimeType) ||
        _allowedImageExtensions.contains(extension);
    final isVideo = _allowedVideoMime.contains(mimeType) ||
        _allowedVideoExtensions.contains(extension);
        
    // Size validation (10MB for images, 50MB for videos)
    if (isImage && fileSize > 10 * 1024 * 1024) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      _clearInvalidInput(index);
      return;
    }
    
    if (isVideo && fileSize > 50 * 1024 * 1024) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Video is too large. Maximum size is 50 MB."),
      );
      _clearInvalidInput(index);
      return;
    }

    // Existing validation logic...
    if (index == 0 && !isValidImage) {
      await _showErrorDialog(context, isMainImage: true);
      _clearInvalidInput(index);
      return;
    }

    if (!isValidImage && !isValidVideo) {
      await _showErrorDialog(context);
      _clearInvalidInput(index);
      return;
    }

    setState(() {
      _selectedMedia[index] = MediaFile(
        file: File(filePath),
        type: isValidVideo ? MediaType.video : MediaType.image,
      );
      _updateForwardButtonState();
    });
  }
}

  Future<void> _showErrorDialog(BuildContext context,
      {bool isMainImage = false}) async {
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(isMainImage ? 'Invalid Main Image' : 'Invalid File Type'),
        content: Text(isMainImage
            ? 'Main image must be an image file.\nAllowed formats: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF'
            : 'Allowed formats:\n• Images: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF\n• Videos: MP4, MOV, AVI, MPEG, 3GP, TS, MKV'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _clearInvalidInput(int index) {
    setState(() {
      _selectedMedia[index] = MediaFile(file: null, type: MediaType.image);
      _updateForwardButtonState();
    });
  }

  void _reorderMedia(int oldIndex, int newIndex) {
    if (oldIndex == 0 || newIndex == 0) return;

    setState(() {
      final MediaFile item = _selectedMedia.removeAt(oldIndex);
      final UniqueKey key = _itemKeys.removeAt(oldIndex);

      if (oldIndex < newIndex) newIndex -= 1;

      _selectedMedia.insert(newIndex, item);
      _itemKeys.insert(newIndex, key);
    });
  }

  void _updateForwardButtonState() {
    int selectedCount =
        _selectedMedia.where((media) => media.file != null).length;
    setState(() {
      _isForwardButtonEnabled = selectedCount >= 3;
    });
  }

  @override
  Widget build(BuildContext context) {
    final errorState = ref.watch(errorProvider);
    final screenSize = MediaQuery.of(context).size;

    return Scaffold(
      backgroundColor: const Color(0xFFFAFAFA), // Lighter background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.03),
              // Enhanced header section
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Icon(
                  Icons.photo_library_rounded,
                  color: const Color(0xFF8B5CF6),
                  size: 48,
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              // Enhanced title
              Text(
                "Create Your Gallery",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  letterSpacing: -0.5,
                ),
              ),
              // Enhanced subtitle
              Text(
                "Select at least 3 photos or videos",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey[600],
                  fontWeight: FontWeight.w500,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              // Enhanced grid view
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(20),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  padding: const EdgeInsets.all(16),
                  child: ReorderableGridView.count(
                    crossAxisCount: 2,
                    mainAxisSpacing: 16,
                    crossAxisSpacing: 16,
                    childAspectRatio: 0.95,
                    shrinkWrap: true,
                    physics: const BouncingScrollPhysics(),
                    children: List.generate(
                        6, (index) => _buildMediaPlaceholder(index)),
                    onReorder: _reorderMedia,
                  ),
                ),
              ),
              // Add this right below the Expanded widget containing the grid view
if (ref.watch(errorProvider) != null)
  Padding(
    padding: const EdgeInsets.symmetric(vertical: 8.0),
    child: Text(
      ref.watch(errorProvider)!.message,
      style: GoogleFonts.poppins(
        color: Colors.red,
        fontSize: 14,
      ),
    ),
  ),

              // Enhanced bottom section
              Container(
                padding: EdgeInsets.symmetric(
                  vertical: screenSize.height * 0.02,
                  horizontal: screenSize.width * 0.04,
                ),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.05),
                      blurRadius: 10,
                      offset: const Offset(0, -4),
                    ),
                  ],
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          "${_selectedMedia.where((media) => media.file != null).length}/6 Selected",
                          style: GoogleFonts.poppins(
                            fontSize: screenSize.width * 0.04,
                            fontWeight: FontWeight.w600,
                            color: const Color(0xFF8B5CF6),
                          ),
                        ),
                        Text(
                          "Minimum 3 required",
                          style: GoogleFonts.poppins(
                            fontSize: screenSize.width * 0.035,
                            color: Colors.grey[600],
                          ),
                        ),
                      ],
                    ),
                    // Enhanced forward button
GestureDetector(
  onTap: () async {
    if (_isForwardButtonEnabled && !_isUploading) {
      setState(() {
        _isUploading = true;
      });
      
      // Transfer selected media to the upload provider
      for (int i = 0; i < _selectedMedia.length; i++) {
        if (_selectedMedia[i].file != null) {
          final file = _selectedMedia[i].file!;
          final fileName = file.path.split('/').last;
          final fileType = _selectedMedia[i].type == MediaType.image 
              ? 'image/jpeg' 
              : 'video/mp4';
          
          ref.read(mediaUploadProvider.notifier).setMediaFile(i, file);
        }
      }
      
      // Start upload process
      final success = await ref.read(mediaUploadProvider.notifier).uploadAllMedia();
      
      setState(() {
        _isUploading = false;
      });
      
      if (success) {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => const ProfileAnswersScreen(),
          ),
        );
      }
    }
  },
  child: AnimatedContainer(
    duration: const Duration(milliseconds: 200),
    width: 60,
    height: 60,
    decoration: BoxDecoration(
      color: _isForwardButtonEnabled && !_isUploading
          ? const Color(0xFF8B5CF6)
          : Colors.grey[300],
      borderRadius: BorderRadius.circular(30),
      boxShadow: _isForwardButtonEnabled && !_isUploading
          ? [
              BoxShadow(
                color: const Color(0xFF8B5CF6).withOpacity(0.3),
                blurRadius: 8,
                offset: const Offset(0, 4),
              ),
            ]
          : null,
    ),
    child: _isUploading 
        ? const CircularProgressIndicator(color: Colors.white)
        : Icon(
            Icons.arrow_forward_rounded,
            color: _isForwardButtonEnabled ? Colors.white : Colors.grey[500],
            size: 28,
          ),
  ),
)
                  ],
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMediaPlaceholder(int index) {
    final media = _selectedMedia[index];
    return GestureDetector(
      key: _itemKeys[index],
      onTap: () => _pickMedia(index),
      child: DottedBorder(
        dashPattern: const [6, 3],
        color: index == 0
            ? const Color(0xFF8B5CF6)
            : const Color(0xFF8B5CF6).withOpacity(0.6),
        strokeWidth: 2,
        borderType: BorderType.RRect,
        radius: const Radius.circular(16),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (media.file != null)
                media.type == MediaType.image
                    ? ClipRRect(
                        borderRadius: BorderRadius.circular(16),
                        child: Image.file(
                          media.file!,
                          fit: BoxFit.cover,
                        ),
                      )
                    : VideoThumbnailWidget(
                        file: media.file!,
                        cache: _thumbnailCache,
                      ),
              if (media.file == null)
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        index == 0
                            ? Icons.add_photo_alternate_rounded
                            : Icons.add_rounded,
                        color: const Color(0xFF8B5CF6).withOpacity(0.6),
                        size: 36,
                      ),
                      if (index == 0)
                        Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: Text(
                            "Main Photo",
                            style: GoogleFonts.poppins(fontSize: 14),
                          ),
                        ),
                    ],
                  ),
                ),
              if (media.type == MediaType.video && media.file != null)
                Container(
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      begin: Alignment.bottomCenter,
                      end: Alignment.topCenter,
                      colors: [
                        Colors.black.withOpacity(0.6),
                        Colors.transparent,
                      ],
                    ),
                  ),
                ),
              if (media.type == MediaType.video && media.file != null)
                const Center(
                  child: Icon(
                    Icons.play_circle_fill_rounded,
                    color: Colors.white,
                    size: 48,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class MediaFile {
  final File? file;
  final MediaType type;

  MediaFile({this.file, required this.type});
}

enum MediaType { image, video }

class VideoThumbnailWidget extends StatefulWidget {
  final File file;
  final Map<String, Uint8List> cache;

  const VideoThumbnailWidget({
    super.key,
    required this.file,
    required this.cache,
  });

  @override
  State<VideoThumbnailWidget> createState() => _VideoThumbnailWidgetState();
}

class _VideoThumbnailWidgetState extends State<VideoThumbnailWidget> {
  Uint8List? _thumbnail;

  @override
  void initState() {
    super.initState();
    _loadThumbnail();
  }

  Future<void> _loadThumbnail() async {
    final filePath = widget.file.path;
    if (widget.cache.containsKey(filePath)) {
      setState(() {
        _thumbnail = widget.cache[filePath];
      });
      return;
    }

    final thumbnail = await VideoThumbnail.thumbnailData(
      video: filePath,
      quality: 100,
    );

    if (thumbnail != null) {
      widget.cache[filePath] = thumbnail;
      setState(() {
        _thumbnail = thumbnail;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return _thumbnail != null
        ? ClipRRect(
            borderRadius: BorderRadius.circular(16),
            child: Image.memory(
              _thumbnail!,
              fit: BoxFit.cover,
            ),
          )
        : const Center(
            child: CircularProgressIndicator(),
          );
  }
}



================================================
File: views/name.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/dob.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class NameInputScreen extends ConsumerStatefulWidget {
  const NameInputScreen({super.key});

  @override
  ConsumerState<NameInputScreen> createState() => _NameInputScreenState();
}

class _NameInputScreenState extends ConsumerState<NameInputScreen> {
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;

  @override
  void initState() {
    super.initState();
    final user = ref.read(userProvider);
    _firstNameController = TextEditingController(text: user.name);
    _lastNameController = TextEditingController(text: user.lastName ?? '');
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      child: const Icon(
                        Icons.badge_outlined,
                        size: 28,
                        color: Colors.white,
                      ),
                    ),
                    const SizedBox(width: 10),
                    Text(
                      "What's your name?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width * 0.06,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.04),
                _buildFirstNameInput(error, screenSize),
                SizedBox(height: screenSize.height * 0.03),
                _buildLastNameInput(screenSize),
                const Spacer(),
                _buildNextButton(screenSize, error),
                SizedBox(height: screenSize.height * 0.04),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFirstNameInput(AppError? error, Size screenSize) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          decoration: BoxDecoration(
            border: Border(
              bottom: BorderSide(
                color: error?.type == ErrorType.validation
                    ? Colors.red
                    : Colors.white54,
                width: 1.5,
              ),
            ),
          ),
          child: TextField(
            controller: _firstNameController,
            style: GoogleFonts.poppins(
              fontSize: screenSize.width * 0.05,
              fontWeight: FontWeight.w500,
              color: Colors.white,
            ),
            cursorColor: Colors.white,
            decoration: InputDecoration(
              labelText: "First name (required)",
              labelStyle: GoogleFonts.poppins(
                fontSize: screenSize.width * 0.042,
                color: Colors.white54,
              ),
              border: InputBorder.none,
            ),
            onChanged: (value) => _updateName(value, _lastNameController.text),
          ),
        ),
        if (error?.type == ErrorType.validation)
          Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Text(
              error!.message,
              style: GoogleFonts.poppins(
                color: Colors.redAccent,
                fontSize: screenSize.width * 0.035,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildLastNameInput(Size screenSize) {
    return TextField(
      controller: _lastNameController,
      style: GoogleFonts.poppins(
        fontSize: screenSize.width * 0.05,
        fontWeight: FontWeight.w500,
        color: Colors.white,
      ),
      cursorColor: Colors.white,
      decoration: InputDecoration(
        labelText: "Last name (optional)",
        labelStyle: GoogleFonts.poppins(
          fontSize: screenSize.width * 0.042,
          color: Colors.white54,
        ),
        enabledBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white54, width: 1.5),
        ),
        focusedBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white, width: 2.0),
        ),
      ),
      onChanged: (value) => _updateName(_firstNameController.text, value),
    );
  }

  Widget _buildNextButton(Size screenSize, AppError? error) {
    final isValid = ref.read(userProvider.notifier).isNameValid();

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: error == null && isValid
            ? () => _handleNextButton()
            : null, // Disable button if there are errors
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: error != null || !isValid
              ? Colors.grey.shade400 // Disable button if there are errors
              : Colors.white,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: EdgeInsets.all(16), // Adjusted padding
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24, // Adjusted icon size
          color: error != null || !isValid
              ? Colors.white54 // Change icon color when disabled
              : const Color(0xFF8B5CF6),
        ),
      ),
    );
  }

  void _updateName(String firstName, String lastName) {
    ref.read(userProvider.notifier).updateName(firstName, lastName);
  }

  void _handleNextButton() {
    ref.read(errorProvider.notifier).clearError();
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DateOfBirthScreen()),
    );
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    super.dispose();
  }
}



================================================
File: views/otp.dart
================================================
import 'package:dtx/views/name.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:pin_code_fields/pin_code_fields.dart';
import 'dart:async';
import '../providers/auth_provider.dart';
import '../providers/error_provider.dart';
import 'phone.dart';

class OtpVerificationScreen extends ConsumerStatefulWidget {
  const OtpVerificationScreen({super.key});

  @override
  ConsumerState<OtpVerificationScreen> createState() => _OtpVerificationScreenState();
}

class _OtpVerificationScreenState extends ConsumerState<OtpVerificationScreen> {
  final TextEditingController _otpController = TextEditingController();
  bool _isResendVisible = false;
  bool _isButtonEnabled = false;
  bool _isVerifying = false;
  Timer? _timer;
  int _remainingTime = 60;

  @override
  void initState() {
    super.initState();
    _startResendTimer(); // Start the countdown when the screen loads
  }

  void _startResendTimer() {
    setState(() {
      _remainingTime = 60;
      _isResendVisible = false;
    });
    
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_remainingTime > 0) {
        if (mounted) {
          setState(() {
            _remainingTime--;
          });
        }
      } else {
        if (mounted) {
          setState(() {
            _isResendVisible = true;
          });
        }
        _timer?.cancel();
      }
    });
  }

  @override
  void dispose() {
    _otpController.dispose(); // Dispose safely
    _timer?.cancel(); // Cancel the timer
    super.dispose();
  }

  void _onOtpChanged(String value) {
    setState(() {
      _isButtonEnabled = value.length == 6;
    });
  }

  void _resendOtp() async {
    final authState = ref.read(authProvider);
    if (authState.unverifiedPhone != null) {
      setState(() {
        _isResendVisible = false;
      });
      
      await ref.read(authProvider.notifier).sendOtp(authState.unverifiedPhone!);
      _startResendTimer();
    }
  }

  void _verifyOtp() async {
    final authState = ref.read(authProvider);
    if (authState.unverifiedPhone != null && _otpController.text.length == 6) {
      setState(() {
        _isVerifying = true;
      });
      
      final success = await ref.read(authProvider.notifier).verifyOtp(
        authState.unverifiedPhone!,
        _otpController.text,
      );
      
      setState(() {
        _isVerifying = false;
      });
      
      if (success) {
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => const NameInputScreen()),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final authState = ref.watch(authProvider);
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.08), // Top padding

                // Title: Enter your verification code
                Text(
                  "Enter your\nverification code",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.09, // Large title font size
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),

                SizedBox(height: screenSize.height * 0.02),

                // Subtitle: Sent to phone number Edit
                Row(
                  children: [
                    // Phone number text
                    Text(
                      "Sent to ${authState.unverifiedPhone ?? ''}",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width * 0.045,
                        color: Colors.white70,
                      ),
                    ),
                    const SizedBox(width: 8),

                    // Edit button
                    GestureDetector(
                      onTap: () {
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                            builder: (context) => const PhoneInputScreen(),
                          ),
                        );
                      },
                      child: Text(
                        "Edit",
                        style: GoogleFonts.poppins(
                          fontSize: screenSize.width * 0.045,
                          color: const Color(0xFFFFFFFF),
                          fontWeight: FontWeight.w600,
                          decoration: TextDecoration.underline,
                        ),
                      ),
                    ),
                  ],
                ),

                SizedBox(height: screenSize.height * 0.05),

                // OTP Input Fields
                PinCodeTextField(
                  length: 6,
                  controller: _otpController,
                  appContext: context,
                  keyboardType: TextInputType.number,
                  cursorColor: Colors.white,
                  textStyle: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.06,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                  pinTheme: PinTheme(
                    shape: PinCodeFieldShape.underline,
                    fieldHeight: screenSize.height * 0.08,
                    fieldWidth: screenSize.width * 0.1,
                    activeColor: Colors.white,
                    inactiveColor: Colors.white54,
                    selectedColor: Colors.white,
                    errorBorderColor: Colors.redAccent,
                  ),
                  onChanged: _onOtpChanged,
                ),

                if (error != null)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      error.message,
                      style: GoogleFonts.poppins(
                        color: Colors.redAccent,
                        fontSize: screenSize.width * 0.04,
                      ),
                    ),
                  ),

                SizedBox(height: screenSize.height * 0.02),

                // Resend OTP or Countdown timer
                Center(
                  child: _isResendVisible
                      ? GestureDetector(
                          onTap: _resendOtp,
                          child: Text(
                            "Resend OTP",
                            style: GoogleFonts.poppins(
                              fontSize: screenSize.width * 0.045,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                        )
                      : Text(
                          "Resend OTP in $_remainingTime seconds",
                          style: GoogleFonts.poppins(
                            fontSize: screenSize.width * 0.045,
                            color: Colors.white70,
                          ),
                        ),
                ),

                const Spacer(),

                // Next button: Enabled only when 6 digits are entered
                Center(
                  child: authState.isLoading || _isVerifying
                      ? const CircularProgressIndicator(color: Colors.white)
                      : GestureDetector(
                          onTap: _isButtonEnabled ? _verifyOtp : null,
                          child: Container(
                            width: screenSize.width * 0.18,
                            height: screenSize.width * 0.18,
                            decoration: BoxDecoration(
                              color: _isButtonEnabled ? Colors.white : Colors.white38,
                              shape: BoxShape.circle,
                              boxShadow: [
                                if (_isButtonEnabled)
                                  BoxShadow(
                                    color: const Color(0xFF4C1D95).withOpacity(0.6),
                                    spreadRadius: 2,
                                    blurRadius: 8,
                                    offset: const Offset(0, 4), // Shadow position
                                  ),
                              ],
                            ),
                            child: Icon(
                              Icons.arrow_forward_rounded,
                              size: 28,
                              color: _isButtonEnabled
                                  ? const Color(0xFF8B5CF6)
                                  : Colors.grey.shade400,
                            ),
                          ),
                        ),
                ),

                SizedBox(height: screenSize.height * 0.05), // Space below
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/phone.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../providers/auth_provider.dart';
import '../providers/error_provider.dart';
import 'otp.dart';

class PhoneInputScreen extends ConsumerStatefulWidget {
  const PhoneInputScreen({super.key});

  @override
  ConsumerState<PhoneInputScreen> createState() => _PhoneInputScreenState();
}

class _PhoneInputScreenState extends ConsumerState<PhoneInputScreen> {
  final TextEditingController _phoneController = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  bool _isSubmitting = false;

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final authState = ref.watch(authProvider);
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.08),
                Text(
                  "What's your\nphone number?",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.09,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
                SizedBox(height: screenSize.height * 0.02),
                Text(
                  "You'll receive an OTP on this number.",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.045,
                    color: Colors.white70,
                  ),
                ),
                SizedBox(height: screenSize.height * 0.05),
                Container(
                  padding:
                      EdgeInsets.symmetric(vertical: screenSize.height * 0.015),
                  decoration: BoxDecoration(
                    border: Border(
                      bottom: BorderSide(
                        width: 2.5,
                        color: error?.type == ErrorType.validation
                            ? Colors.red
                            : const Color(0xFFFFFFFF),
                      ),
                    ),
                  ),
                  child: Row(
                    children: [
                      Text(
                        "+91",
                        style: GoogleFonts.poppins(
                          fontSize: screenSize.width * 0.06,
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                        ),
                      ),
                      SizedBox(width: screenSize.width * 0.02),
                      Expanded(
                        child: TextField(
                          focusNode: _focusNode,
                          controller: _phoneController,
                          keyboardType: TextInputType.phone,
                          style: GoogleFonts.poppins(
                            fontSize: screenSize.width * 0.06,
                            fontWeight: FontWeight.w500,
                            color: Colors.white,
                          ),
                          cursorColor: Colors.white,
                          decoration: InputDecoration(
                            hintText: "Enter phone number",
                            hintStyle: GoogleFonts.poppins(
                              fontSize: screenSize.width * 0.05,
                              color: Colors.white70,
                            ),
                            border: InputBorder.none,
                          ),
                          onChanged: (value) {
                            ref.read(authProvider.notifier).verifyPhone(value);
                          },
                        ),
                      ),
                    ],
                  ),
                ),
                if (error?.type == ErrorType.validation || error?.type == ErrorType.server)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      error!.message,
                      style: GoogleFonts.poppins(
                        color: Colors.redAccent,
                        fontSize: screenSize.width * 0.04,
                      ),
                    ),
                  ),
                const Spacer(),
                Center(
                  child: authState.isLoading
                      ? const CircularProgressIndicator(color: Colors.white)
                      : GestureDetector(
                          onTap: authState.unverifiedPhone != null && !_isSubmitting
                              ? () async {
                                  setState(() {
                                    _isSubmitting = true;
                                  });
                                  
                                  final success = await ref.read(authProvider.notifier)
                                      .sendOtp(authState.unverifiedPhone!);
                                      
                                  setState(() {
                                    _isSubmitting = false;
                                  });
                                  
                                  if (success) {
                                    Navigator.push(
                                      context,
                                      MaterialPageRoute(
                                        builder: (context) =>
                                            const OtpVerificationScreen(),
                                      ),
                                    );
                                  }
                                }
                              : null,
                          child: Container(
                            width: screenSize.width * 0.18,
                            height: screenSize.width * 0.18,
                            decoration: BoxDecoration(
                              color: authState.unverifiedPhone != null && !_isSubmitting
                                  ? Colors.white
                                  : Colors.grey.shade400,
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withOpacity(0.2),
                                  spreadRadius: 2,
                                  blurRadius: 8,
                                  offset: const Offset(0, 4),
                                ),
                              ],
                            ),
                            child: Icon(
                              Icons.arrow_forward_rounded,
                              size: 28,
                              color: authState.unverifiedPhone != null && !_isSubmitting
                                  ? const Color(0xFF8B5CF6)
                                  : Colors.grey.shade600,
                            ),
                          ),
                        ),
                ),
                SizedBox(height: screenSize.height * 0.05),
              ],
            ),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _phoneController.dispose();
    _focusNode.dispose();
    super.dispose();
  }
}



================================================
File: views/profile_screens.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/providers/user_provider.dart';

class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isPlaying = false;
  String? _currentAudioUrl;
  final PageController _pageController = PageController();
  int _currentImageIndex = 0;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(userProvider.notifier).fetchProfile();
    });

    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted) {
        setState(() {
          _isPlaying = state == PlayerState.playing;
        });
      }
    });

    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) {
        setState(() {
          _isPlaying = false;
        });
      }
    });
  }

  @override
  void dispose() {
    _audioPlayer.dispose();
    _pageController.dispose();
    super.dispose();
  }

  // Helper function to capitalize first letter
  String capitalizeFirstLetter(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }

  Future<void> _playOrPauseAudio(String audioUrl) async {
    try {
      if (_isPlaying && _currentAudioUrl == audioUrl) {
        await _audioPlayer.pause();
        setState(() {
          _isPlaying = false;
        });
      } else if (_currentAudioUrl == audioUrl) {
        await _audioPlayer.resume();
        setState(() {
          _isPlaying = true;
        });
      } else {
        setState(() => _isPlaying = false);
        await _audioPlayer.stop();
        await _audioPlayer.play(UrlSource(audioUrl));
        setState(() {
          _isPlaying = true;
          _currentAudioUrl = audioUrl;
        });
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error playing audio: ${e.toString()}')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = ref.watch(userProvider);
    final isLoading = ref.watch(userLoadingProvider);
    final age = user.dateOfBirth != null
        ? DateTime.now().difference(user.dateOfBirth!).inDays ~/ 365
        : null;

    if (isLoading && user.name == null) {
      return Scaffold(
        backgroundColor: Colors.white,
        body: Center(
          child: CircularProgressIndicator(
            color: const Color(0xFF8B5CF6),
          ),
        ),
      );
    }

    // Capitalize first letter of name and lastName if available
    final capitalizedName = user.name != null ? capitalizeFirstLetter(user.name!) : null;
    final capitalizedLastName = user.lastName != null ? capitalizeFirstLetter(user.lastName!) : null;

    return Scaffold(
      backgroundColor: Colors.white,
      // No AppBar - removed as requested
      body: RefreshIndicator(
        color: const Color(0xFF8B5CF6),
        onRefresh: () => ref.read(userProvider.notifier).fetchProfile(),
        child: CustomScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          slivers: [
            // Top space for status bar
            SliverToBoxAdapter(
              child: SizedBox(height: MediaQuery.of(context).padding.top + 16),
            ),
            
            // Main content
            SliverPadding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              sliver: SliverList(
                delegate: SliverChildListDelegate([
                  // Back and Edit buttons at top
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      // Back button
                      IconButton(
                        icon: Container(
                          padding: const EdgeInsets.all(8),
                          decoration: BoxDecoration(
                            color: Colors.grey[100],
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Icon(
                            Icons.arrow_back,
                            color: const Color(0xFF8B5CF6),
                            size: 20,
                          ),
                        ),
                        onPressed: () {
                          Navigator.of(context).pop();
                        },
                      ),
                      // Edit button
                      IconButton(
                        icon: Container(
                          padding: const EdgeInsets.all(8),
                          decoration: BoxDecoration(
                            color: Colors.grey[100],
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Icon(
                            Icons.edit_outlined,
                            color: const Color(0xFF8B5CF6),
                            size: 20,
                          ),
                        ),
                        onPressed: () {
                          // Edit profile action
                        },
                      ),
                    ],
                  ),
                  
                  _buildProfileHeader(capitalizedName, capitalizedLastName, age, user),
                  const SizedBox(height: 24),
                  _buildMediaGallery(user.mediaUrls ?? []),
                  const SizedBox(height: 32),
                  
                  if (user.datingIntention != null) 
                    _buildInfoSection("Looking for", user.datingIntention!.label),
                  
                  const SizedBox(height: 24),
                  _buildPromptSection(user.prompts),
                  const SizedBox(height: 32),
                  
                  if (user.audioPrompt != null) 
                    _buildAudioPrompt(user.audioPrompt!),
                  
                  const SizedBox(height: 32),
                  _buildPersonalDetailsSection(user),
                  const SizedBox(height: 40),
                ]),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildProfileHeader(String? name, String? lastName, int? age, UserModel user) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '${name ?? "Your Profile"} ${lastName ?? ""} ${age != null ? "• $age" : ""}',
          style: GoogleFonts.poppins(
            fontSize: 48,
            fontWeight: FontWeight.w800,
            color: const Color(0xFF1A1A1A),
            height: 1.1,
          ),
        ),
        const SizedBox(height: 12),
        // Add a subtle themed divider
        Container(
          width: 60,
          height: 4,
          decoration: BoxDecoration(
            color: const Color(0xFF8B5CF6),
            borderRadius: BorderRadius.circular(2),
          ),
        ),
        const SizedBox(height: 16),
        if (user.gender != null || user.hometown != null)
          Wrap(
            spacing: 12,
            runSpacing: 8,
            children: [
              if (user.gender != null)
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6).withOpacity(0.1),
                    borderRadius: BorderRadius.circular(20),
                    border: Border.all(color: const Color(0xFF8B5CF6).withOpacity(0.3)),
                  ),
                  child: Text(
                    user.gender!.label,
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                      color: const Color(0xFF8B5CF6),
                    ),
                  ),
                ),
              if (user.hometown != null)
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6).withOpacity(0.1),
                    borderRadius: BorderRadius.circular(20),
                    border: Border.all(color: const Color(0xFF8B5CF6).withOpacity(0.3)),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        Icons.location_on_outlined,
                        size: 16,
                        color: const Color(0xFF8B5CF6),
                      ),
                      const SizedBox(width: 4),
                      Text(
                        user.hometown!,
                        style: GoogleFonts.poppins(
                          fontSize: 14,
                          fontWeight: FontWeight.w500,
                          color: const Color(0xFF8B5CF6),
                        ),
                      ),
                    ],
                  ),
                ),
            ],
          ),
      ],
    );
  }

  Widget _buildMediaGallery(List<String> images) {
    if (images.isEmpty) {
      return _buildEmptySection(
        "Photos",
        "Add photos to your profile",
        Icons.add_photo_alternate_outlined,
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          height: 400,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(24),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.1),
                blurRadius: 20,
                offset: const Offset(0, 8),
              ),
            ],
          ),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(24),
            child: Stack(
              children: [
                PageView.builder(
                  controller: _pageController,
                  itemCount: images.length,
                  onPageChanged: (index) {
                    setState(() {
                      _currentImageIndex = index;
                    });
                  },
                  itemBuilder: (context, index) {
                    return Image.network(
                      images[index],
                      fit: BoxFit.cover,
                      errorBuilder: (context, error, stackTrace) {
                        return Container(
                          color: Colors.grey[200],
                          child: Center(
                            child: Icon(
                              Icons.broken_image_outlined,
                              color: Colors.grey[400],
                              size: 48,
                            ),
                          ),
                        );
                      },
                      loadingBuilder: (context, child, loadingProgress) {
                        if (loadingProgress == null) return child;
                        return Center(
                          child: CircularProgressIndicator(
                            color: const Color(0xFF8B5CF6),
                            value: loadingProgress.expectedTotalBytes != null
                                ? loadingProgress.cumulativeBytesLoaded /
                                    loadingProgress.expectedTotalBytes!
                                : null,
                          ),
                        );
                      },
                    );
                  },
                ),
                // Gradient overlay at bottom for better text visibility
                Positioned(
                  bottom: 0,
                  left: 0,
                  right: 0,
                  height: 120,
                  child: Container(
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        colors: [
                          Colors.transparent,
                          Colors.black.withOpacity(0.5),
                        ],
                      ),
                    ),
                  ),
                ),
                // Page indicator dots
                Positioned(
                  bottom: 20,
                  left: 0,
                  right: 0,
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: List.generate(
                      images.length,
                      (index) => AnimatedContainer(
                        duration: const Duration(milliseconds: 200),
                        width: _currentImageIndex == index ? 24 : 8,
                        height: 8,
                        margin: const EdgeInsets.symmetric(horizontal: 4),
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(4),
                          color: _currentImageIndex == index
                              ? const Color(0xFF8B5CF6)
                              : Colors.white.withOpacity(0.6),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildInfoSection(String title, String content) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: 16),
      decoration: BoxDecoration(
        border: Border(
          bottom: BorderSide(color: const Color(0xFF8B5CF6).withOpacity(0.2), width: 1.5),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: GoogleFonts.poppins(
              fontSize: 16,
              fontWeight: FontWeight.w500,
              color: const Color(0xFF8B5CF6),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            content,
            style: GoogleFonts.poppins(
              fontSize: 18,
              fontWeight: FontWeight.w600,
              color: const Color(0xFF1A1A1A),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPromptSection(List<Prompt> prompts) {
    if (prompts.isEmpty) {
      return _buildEmptySection(
        "About Me",
        "Add prompts to tell others about yourself",
        Icons.chat_bubble_outline,
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          "About Me",
          style: GoogleFonts.poppins(
            fontSize: 24,
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
          ),
        ),
        const SizedBox(height: 16),
        ...prompts.map((prompt) => _buildPromptCard(prompt)).toList(),
      ],
    );
  }

  Widget _buildPromptCard(Prompt prompt) {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.grey[200]!),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            prompt.question.label,
            style: GoogleFonts.poppins(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: const Color(0xFF8B5CF6),
            ),
          ),
          const SizedBox(height: 10),
          Text(
            prompt.answer,
            style: GoogleFonts.poppins(
              fontSize: 16,
              color: const Color(0xFF1A1A1A),
              height: 1.5,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAudioPrompt(AudioPromptModel audio) {
    final bool isThisPlaying = _currentAudioUrl == audio.audioUrl && _isPlaying;
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          "Voice Prompt",
          style: GoogleFonts.poppins(
            fontSize: 24,
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
          ),
        ),
        const SizedBox(height: 16),
        GestureDetector(
          onTap: () => _playOrPauseAudio(audio.audioUrl),
          child: Container(
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.grey[50],
              borderRadius: BorderRadius.circular(20),
              border: Border.all(color: Colors.grey[200]!),
              boxShadow: [
                BoxShadow(
                  color: Colors.grey.withOpacity(0.05),
                  blurRadius: 10,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: Row(
              children: [
                Container(
                  width: 56,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Icon(
                    isThisPlaying ? Icons.pause : Icons.play_arrow,
                    color: Colors.white,
                    size: 28,
                  ),
                ),
                const SizedBox(width: 20),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        audio.prompt.label,
                        style: GoogleFonts.poppins(
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                          color: const Color(0xFF1A1A1A),
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        isThisPlaying ? "Playing..." : "Tap to listen",
                        style: GoogleFonts.poppins(
                          fontSize: 14,
                          color: Colors.grey[600],
                        ),
                      ),
                    ],
                  ),
                ),
                  if (isThisPlaying)
                  Row(
                    children: List.generate(
                      3,
                      (index) => Container(
                        margin: const EdgeInsets.symmetric(horizontal: 2),
                        width: 4,
                        height: 16 + (index * 8),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(2),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildPersonalDetailsSection(UserModel user) {
    final hasDetails = user.height != null || 
                      user.religiousBeliefs != null || 
                      user.jobTitle != null || 
                      user.education != null || 
                      user.drinkingHabit != null || 
                      user.smokingHabit != null;
    
    if (!hasDetails) return const SizedBox.shrink();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          "Personal Details",
          style: GoogleFonts.poppins(
            fontSize: 24,
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
          ),
        ),
        const SizedBox(height: 16),
        Wrap(
          spacing: 12,
          runSpacing: 12,
          children: [
            if (user.height != null) 
              _buildDetailChip(Icons.height, "Height: ${user.height}"),
            if (user.religiousBeliefs != null) 
              _buildDetailChip(Icons.church_outlined, user.religiousBeliefs!.label),
            if (user.jobTitle != null) 
              _buildDetailChip(Icons.work_outline, user.jobTitle!),
            if (user.education != null) 
              _buildDetailChip(Icons.school_outlined, user.education!),
            if (user.drinkingHabit != null) 
              _buildDetailChip(Icons.local_bar_outlined, user.drinkingHabit!.label),
            if (user.smokingHabit != null) 
              _buildDetailChip(Icons.smoking_rooms_outlined, user.smokingHabit!.label),
          ],
        ),
      ],
    );
  }

  Widget _buildDetailChip(IconData icon, String label) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.grey[200]!),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 18,
            color: const Color(0xFF8B5CF6),
          ),
          const SizedBox(width: 8),
          Text(
            label,
            style: GoogleFonts.poppins(
              fontSize: 14,
              fontWeight: FontWeight.w500,
              color: Colors.grey[800],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptySection(String title, String message, IconData icon) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      margin: const EdgeInsets.only(bottom: 24),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.grey[200]!),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            title,
            style: GoogleFonts.poppins(
              fontSize: 20,
              fontWeight: FontWeight.w600,
              color: const Color(0xFF1A1A1A),
            ),
          ),
          const SizedBox(height: 16),
          Icon(
            icon,
            size: 48,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            message,
            textAlign: TextAlign.center,
            style: GoogleFonts.poppins(
              fontSize: 16,
              color: Colors.grey[600],
            ),
          ),
        ],
      ),
    );
  }
}



================================================
File: views/prompt.dart
================================================
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/audiopromptsselect.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/textpromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';

class ProfileAnswersScreen extends ConsumerStatefulWidget {
  const ProfileAnswersScreen({super.key});

  @override
  ConsumerState<ProfileAnswersScreen> createState() =>
      _ProfileAnswersScreenState();
}

class _ProfileAnswersScreenState extends ConsumerState<ProfileAnswersScreen> {
  bool _isForwardButtonEnabled = false;

  void _updateForwardButtonState() {
    final userState = ref.watch(userProvider);
    final prompts = userState.prompts;
    bool hasValidPrompt =
        prompts.any((prompt) => prompt.answer.trim().isNotEmpty);
    setState(() {
      _isForwardButtonEnabled = hasValidPrompt;
    });
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _updateForwardButtonState();
    });
  }

  void _handlePromptTap(Prompt? prompt, int index) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => TextSelectPromptScreen(
          editIndex: prompt != null ? index : null,
        ),
      ),
    ).then((_) => _updateForwardButtonState());
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);
    final prompts = userState.prompts;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 40),
              Text(
                "Profile Prompts",
                style: GoogleFonts.poppins(
                  fontSize: 36,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 12),
              Text(
                "Share three interesting facts about yourself",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 40),
              Expanded(
                child: ListView.separated(
                  itemCount: 3,
                  separatorBuilder: (_, __) => const SizedBox(height: 24),
                  itemBuilder: (context, index) {
                    final prompt =
                        index < prompts.length ? prompts[index] : null;
                    return _buildPromptCard(prompt, index);
                  },
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Text(
                    "At least 1 prompt required",
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      color: Colors.grey[600],
                      fontStyle: FontStyle.italic,
                    ),
                  ),
                  _buildForwardButton(),
                ],
              ),
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPromptCard(Prompt? prompt, int index) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: prompt != null ? const Color(0xFF8B5CF6) : Colors.grey[300]!,
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(16),
          onTap: () => _handlePromptTap(prompt, index),
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        prompt?.question.label ?? "Add a prompt",
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                    Icon(
                      prompt != null ? Icons.edit : Icons.add,
                      color: const Color(0xFF8B5CF6),
                      size: 24,
                    ),
                  ],
                ),
                if (prompt?.answer.isNotEmpty ?? false) ...[
                  const SizedBox(height: 12),
                  Text(
                    prompt!.answer,
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildForwardButton() {
    return GestureDetector(
      onTap: _isForwardButtonEnabled
          ? () => Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const VoicePromptScreen(),
                ),
              )
          : null,
      child: Container(
        width: 70,
        height: 70,
        decoration: BoxDecoration(
          color: _isForwardButtonEnabled
              ? const Color(0xFF8B5CF6)
              : Colors.grey.shade400,
          borderRadius: BorderRadius.circular(35),
          boxShadow: [
            BoxShadow(
              color: const Color(0xFF8B5CF6).withOpacity(0.3),
              blurRadius: 12,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          color: _isForwardButtonEnabled ? Colors.white : Colors.grey.shade600,
          size: 32,
        ),
      ),
    );
  }
}



================================================
File: views/religion.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/drinking.dart';

class ReligionScreen extends ConsumerStatefulWidget {
  const ReligionScreen({super.key});

  @override
  ConsumerState<ReligionScreen> createState() => _ReligionScreenState();
}

class _ReligionScreenState extends ConsumerState<ReligionScreen> {
  Religion? _selectedReligion;

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4),
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const SizedBox(width: 32),
                      const SizedBox(width: 48),
                    ],
                  ),
                  SizedBox(height: screenSize.height * 0.07),
                  Text(
                    "What are your religious beliefs?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.1,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF333333),
                      height: 1.1,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.05),
                  Wrap(
                    spacing: screenSize.width * 0.03,
                    runSpacing: screenSize.height * 0.015,
                    children: Religion.values
                        .map((religion) =>
                            _buildReligionButton(religion, screenSize))
                        .toList(),
                  ),
                  const Spacer(),
                  Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        GestureDetector(
                          onTap: _selectedReligion != null
                              ? () {
                                  FocusScope.of(context)
                                      .unfocus(); // Close the keyboard
                                  ref
                                      .read(userProvider.notifier)
                                      .updateReligiousBeliefs(
                                          _selectedReligion);
                                  Navigator.push(
                                      context,
                                      MaterialPageRoute(
                                          builder: (context) =>
                                              const DrinkingScreen()));
                                }
                              : null,
                          child: Container(
                            width: 70,
                            height: 70,
                            decoration: BoxDecoration(
                              color: _selectedReligion != null
                                  ? const Color(0xFF8B5CF6)
                                  : Colors.grey.shade300,
                              borderRadius: BorderRadius.circular(35),
                            ),
                            child: const Icon(
                              Icons.arrow_forward_rounded,
                              color: Colors.white,
                              size: 32,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildReligionButton(Religion religion, Size screenSize) {
    bool isSelected = _selectedReligion == religion;
    return GestureDetector(
      onTap: () => setState(() => _selectedReligion = religion),
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.015),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
          borderRadius: BorderRadius.circular(25),
          border: Border.all(color: Colors.grey.shade300, width: 1.0),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              religion.label,
              style: GoogleFonts.poppins(
                fontSize: 18,
                fontWeight: FontWeight.w500,
                color: isSelected ? Colors.white : Colors.black87,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/selfie_capture_screen.dart
================================================
// File: views/selfie_capture_screen.dart
import 'dart:async';
import 'dart:io';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/views/verification_pending_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:camera/camera.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class SelfieCaptureScreen extends ConsumerStatefulWidget {
  const SelfieCaptureScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<SelfieCaptureScreen> createState() => _SelfieCaptureScreenState();
}

class _SelfieCaptureScreenState extends ConsumerState<SelfieCaptureScreen>
    with WidgetsBindingObserver {
  CameraController? _cameraController;
  List<CameraDescription> _cameras = [];
  bool _isCameraInitialized = false;
  bool _hasError = false;
  double _aspectRatio = 1.0;
  bool _isUploading = false; // Track uploading state

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initializeCamera();
  }

  Future<void> _initializeCamera() async {
    try {
      _cameras = await availableCameras();
      if (_cameras.isEmpty) throw Exception('No cameras available');

      final frontCamera = _cameras.firstWhere(
        (camera) => camera.lensDirection == CameraLensDirection.front,
        orElse: () => _cameras.first,
      );

      _cameraController = CameraController(
        frontCamera,
        ResolutionPreset.medium,
        enableAudio: false,
      );

      await _cameraController!.initialize();
      
      final previewSize = _cameraController!.value.previewSize!;
      _aspectRatio = previewSize.width / previewSize.height;

      if (mounted) setState(() => _isCameraInitialized = true);
      
    } catch (e) {
      if (mounted) setState(() => _hasError = true);
      print('Camera Error: $e');
    }
  }

  Widget _buildCameraPreview() {
    if (_hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, color: Colors.white, size: 50),
            const SizedBox(height: 20),
            Text(
              'Camera Error',
              style: GoogleFonts.poppins(color: Colors.white, fontSize: 20),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: _initializeCamera,
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF8B5CF6),
              ),
              child: Text(
                'Retry',
                style: GoogleFonts.poppins(color: Colors.white),
              ),
            ),
          ],
        ),
      );
    }

    if (!_isCameraInitialized || _cameraController == null) {
      return const Center(
        child: CircularProgressIndicator(color: Color(0xFF8B5CF6)),
      );
    }

    return AspectRatio(
      aspectRatio: _aspectRatio,
      child: CameraPreview(_cameraController!),
    );
  }

  Future<void> _captureImage() async {
    if (!_isCameraInitialized || _cameraController == null) return;

    try {
      setState(() => _isUploading = true);

      final image = await _cameraController!.takePicture();
      final imageFile = File(image.path);

      // Set verification image in provider
      ref.read(mediaUploadProvider.notifier).setVerificationImage(imageFile);

      // Upload verification image
      final success = await ref.read(mediaUploadProvider.notifier).uploadVerificationImage();

      setState(() => _isUploading = false);

      if (success) {
        // Navigate to verification pending screen
        if (mounted) {
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (context) => const VerificationPendingScreen()),
          );
        }
      } else {
        // Handle upload failure
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to upload verification image. Please try again.')),
        );
      }
    } catch (e) {
      setState(() => _isUploading = false);
      print('Capture Error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Capture Error: ${e.toString()}')),
      );
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _cameraController?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Stack(
          children: [
            Column(
              children: [
                // Header
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.arrow_back, color: Colors.white),
                        onPressed: () => Navigator.pop(context),
                      ),
                      Text(
                        "Take Selfie",
                        style: GoogleFonts.poppins(
                          color: Colors.white,
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
                Expanded(
                  child: _buildCameraPreview(),
                ),
              ],
            ),

            // Loading indicator overlay
            if (_isUploading)
              Container(
                color: Colors.black.withOpacity(0.5),
                child: const Center(
                  child: CircularProgressIndicator(
                    color: Color(0xFF8B5CF6),
                  ),
                ),
              ),
          ],
        ),
      ),
      floatingActionButton: !_isUploading ? FloatingActionButton(
        backgroundColor: const Color(0xFF8B5CF6),
        onPressed: _captureImage,
        child: const Icon(Icons.camera_alt, color: Colors.white),
      ) : null,
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
    );
  }
}



================================================
File: views/smoking.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/media.dart';

class SmokingScreen extends ConsumerStatefulWidget {
  const SmokingScreen({super.key});

  @override
  ConsumerState<SmokingScreen> createState() => _SmokingScreenState();
}

class _SmokingScreenState extends ConsumerState<SmokingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedSmokingHabit;
  bool _isOptionSelected = false;
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF8F9FA),
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: const Icon(
                      Icons.smoking_rooms_rounded,
                      color: Color(0xFF8B5CF6),
                      size: 48,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.03),
                  Text(
                    "Do you smoke?",
                    textAlign: TextAlign.left,
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.08,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF1A1A1A),
                      height: 1.1,
                    ),
                  ),
                  Text(
                    "Select your smoking habits",
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey[600],
                      height: 1.5,
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.04),
                  Expanded(
                    child: ListView.separated(
                      itemCount: DrinkingSmokingHabits.values.length,
                      separatorBuilder: (context, index) =>
                          const SizedBox(height: 12),
                      itemBuilder: (context, index) {
                        final habit = DrinkingSmokingHabits.values[index];
                        return _buildSmokingOptionTile(
                          screenSize: screenSize,
                          title: habit.label,
                          value: habit,
                        );
                      },
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding:
                          EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: AnimatedScale(
                        scale: _isOptionSelected ? 1.0 : 0.95,
                        duration: const Duration(milliseconds: 200),
                        child: GestureDetector(
                          onTap: () {
                            if (_isOptionSelected) {
                              FocusScope.of(context)
                                  .unfocus(); // Close the keyboard
                              ref
                                  .read(userProvider.notifier)
                                  .updateSmokingHabit(_selectedSmokingHabit);
                              Navigator.push(
                                  context,
                                  MaterialPageRoute(
                                      builder: (context) =>
                                          const MediaPickerScreen()));
                            } else {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text(
                                    "Please select an option",
                                    style: GoogleFonts.poppins(),
                                  ),
                                  backgroundColor: Colors.red[400],
                                  behavior: SnackBarBehavior.floating,
                                ),
                              );
                            }
                          },
                          child: Container(
                            width: 70,
                            height: 70,
                            decoration: BoxDecoration(
                              color: _isOptionSelected
                                  ? const Color(0xFF8B5CF6)
                                  : Colors.grey.shade300,
                              borderRadius: BorderRadius.circular(35),
                              boxShadow: _isOptionSelected
                                  ? [
                                      BoxShadow(
                                        color: const Color(0xFF8B5CF6)
                                            .withOpacity(0.3),
                                        blurRadius: 8,
                                        offset: const Offset(0, 4),
                                      ),
                                    ]
                                  : null,
                            ),
                            child: Icon(
                              Icons.arrow_forward_rounded,
                              color: _isOptionSelected
                                  ? Colors.white
                                  : Colors.grey.shade600,
                              size: 32,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildSmokingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedSmokingHabit == value;

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedSmokingHabit = value;
            _isOptionSelected = true;
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/splash_screen.dart
================================================
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/views/home.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/views/phone.dart';
import 'package:dtx/views/youtube.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnim;
  late Animation<double> _scaleAnim;
  late Animation<double> _rotateAnim;
  bool _animationComplete = false;
  bool _statusCheckComplete = false;
  AuthStatus _authStatus = AuthStatus.unknown;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
    _checkAuthStatus();
  }

  void _setupAnimation() {
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 2),
    );

    _fadeAnim = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.0, 1.0, curve: Curves.linear),
      ),
    );

    _scaleAnim = Tween<double>(begin: 0.5, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const ElasticOutCurve(1.5),
      ),
    );

    _rotateAnim = Tween<double>(begin: 0, end: 2 * 3.14159).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const ElasticOutCurve(1.5),
      ),
    );

    _controller.forward();

    // Mark animation as complete after 2.5 seconds
    Future.delayed(const Duration(milliseconds: 2500), () {
      if (mounted) {
        setState(() {
          _animationComplete = true;
        });
        _navigateIfReady();
      }
    });
  }

  Future<void> _checkAuthStatus() async {
    try {
      // Get the status without updating the state during splash screen check
      final status = await ref
          .read(authProvider.notifier)
          .checkAuthStatus(updateState: false);

      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          setState(() {
            _authStatus = status;
            _statusCheckComplete = true;
          });
          _navigateIfReady();
        }
      });
    } catch (e) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          setState(() {
            _authStatus = AuthStatus.login;
            _statusCheckComplete = true;
          });
          _navigateIfReady();
        }
      });
    }
  }

  void _navigateIfReady() {
    // Only navigate if both animation has played sufficiently and status check is done
    if (_animationComplete && _statusCheckComplete) {
      Widget destination;

      switch (_authStatus) {
        case AuthStatus.home:
          destination = const HomeScreen();
          break;
        case AuthStatus.onboarding:
          destination = const NameInputScreen();
          break;
        case AuthStatus.login:
        case AuthStatus.unknown:
        default:
          // destination = const PhoneInputScreen();
          destination = const YoutubeSignInScreen();
          break;
      }

      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (_) => destination),
      );
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final Size screenSize = MediaQuery.of(context).size;
    final double responsiveFontSize =
        screenSize.height * 0.1; // ~7% of screen height
    final double subtitleFontSize =
        screenSize.height * 0.02; // ~2% of screen height
    final double bottomPadding = screenSize.height * 0.05; // 5% from bottom

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF4C1D95), Color(0xFF7C3AED), Color(0xFF8B5CF6)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Stack(
          children: [
            Center(
              child: AnimatedBuilder(
                animation: _controller,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Transform.scale(
                      scale: _scaleAnim.value,
                      child: Transform.rotate(
                        angle: _rotateAnim.value,
                        child: FittedBox(
                          fit: BoxFit.scaleDown,
                          child: Text(
                            'Peeple',
                            style: GoogleFonts.pacifico(
                              fontSize: responsiveFontSize,
                              color: Colors.white,
                              shadows: [
                                Shadow(
                                  color: Colors.black.withOpacity(0.75),
                                  blurRadius: screenSize.width *
                                      0.03, // 3% of screen width
                                  offset: Offset(
                                    screenSize.width * 0.005, // 0.5% of width
                                    screenSize.height * 0.005, // 0.5% of height
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
            Positioned(
              bottom: bottomPadding,
              left: 0,
              right: 0,
              child: AnimatedBuilder(
                animation: _fadeAnim,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Text(
                      'Connect. Share. Thrive.',
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: subtitleFontSize,
                        fontWeight: FontWeight.w300,
                      ),
                    ),
                  );
                },
              ),
            ),
            // Show loading indicator if status check is taking time
            if (_animationComplete && !_statusCheckComplete)
              Positioned(
                bottom: bottomPadding + 40,
                left: 0,
                right: 0,
                child: Center(
                  child: SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/study.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/religion.dart';

class StudyLocationScreen extends ConsumerStatefulWidget {
  const StudyLocationScreen({super.key});

  @override
  ConsumerState<StudyLocationScreen> createState() =>
      _StudyLocationScreenState();
}

class _StudyLocationScreenState extends ConsumerState<StudyLocationScreen> {
  final TextEditingController _studyLocationController =
      TextEditingController();

  @override
  void dispose() {
    _studyLocationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;

    return Consumer(
      builder: (context, ref, child) {
        final userState = ref.watch(userProvider);

        return Scaffold(
          backgroundColor: const Color(0xFFF4F4F4),
          body: SafeArea(
            child: Padding(
              padding:
                  EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenSize.height * 0.04),

                  // Top Navigation Bar with Skip Button
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.school_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {
                          // Handle home button action
                        },
                      ),
                      // Skip Button - Top Right
                      TextButton(
                        onPressed: () {
                          FocusScope.of(context)
                              .unfocus(); // Close the keyboard
                          ref.read(userProvider.notifier).updateEducation(null);
                          Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) =>
                                      const ReligionScreen()));
                        },
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),

                  SizedBox(height: screenSize.height * 0.07),

                  // Question Text
                  Text(
                    "Where did you study?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.1,
                      fontWeight: FontWeight.w700,
                      color: const Color(0xFF333333),
                      height: 1.1,
                    ),
                  ),

                  SizedBox(height: screenSize.height * 0.05),

                  // Text Field
                  Padding(
                    padding: EdgeInsets.symmetric(
                        horizontal: screenSize.width * 0.02),
                    child: TextField(
                      controller: _studyLocationController,
                      style: GoogleFonts.poppins(
                        fontSize: 22,
                        color: Colors.black87,
                      ),
                      decoration: InputDecoration(
                        hintText: "your college",
                        hintStyle: GoogleFonts.poppins(
                          fontSize: 22,
                          color: Colors.grey.shade500,
                        ),
                        border: const UnderlineInputBorder(
                          borderSide:
                              BorderSide(color: Colors.grey, width: 1.0),
                        ),
                        focusedBorder: const UnderlineInputBorder(
                          borderSide:
                              BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                        ),
                      ),
                    ),
                  ),

                  const Spacer(),

                  // Forward Button
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Padding(
                      padding:
                          EdgeInsets.only(bottom: screenSize.height * 0.04),
                      child: GestureDetector(
                        onTap: () {
                          FocusScope.of(context)
                              .unfocus(); // Close the keyboard

                          String? education;
                          if (_studyLocationController.text.isNotEmpty) {
                            education = _studyLocationController.text;
                            ref
                                .read(userProvider.notifier)
                                .updateEducation(education);
                          } else {
                            education = null;
                          }

                          Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) =>
                                      const ReligionScreen()));
                        },
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: const Color(0xFF8B5CF6),
                            borderRadius: BorderRadius.circular(35),
                          ),
                          child: const Icon(
                            Icons.arrow_forward_rounded,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}



================================================
File: views/textpromptsselect.dart
================================================
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';

class TextSelectPromptScreen extends StatefulWidget {
  final int? editIndex;

  const TextSelectPromptScreen({
    super.key,
    this.editIndex,
  });

  @override
  State<TextSelectPromptScreen> createState() => _TextSelectPromptScreenState();
}

class _TextSelectPromptScreenState extends State<TextSelectPromptScreen> {
  PromptCategory selectedCategory = PromptCategory.storyTime;
  bool showAllPrompts = false;
  PromptType? selectedPrompt;

  List<PromptType> get currentPrompts {
    if (showAllPrompts) {
      return PromptCategory.values
          .expand((category) => category.getPrompts())
          .toList();
    }
    return selectedCategory.getPrompts();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  GestureDetector(
                    onTap: () {
                      setState(() {
                        showAllPrompts = !showAllPrompts;
                      });
                    },
                    child: Text(
                      'View all',
                      style: TextStyle(
                        color: const Color(0xFF8b5cf6),
                        fontSize: 16,
                        fontWeight:
                            showAllPrompts ? FontWeight.bold : FontWeight.w500,
                      ),
                    ),
                  ),
                  const Text(
                    'Prompts',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () => Navigator.pop(context),
                    child: const Icon(Icons.close),
                  ),
                ],
              ),
            ),
            if (!showAllPrompts)
              SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: Row(
                  children: PromptCategory.values.map((category) {
                    final isSelected = category == selectedCategory;
                    return Padding(
                      padding: const EdgeInsets.only(right: 8),
                      child: GestureDetector(
                        onTap: () =>
                            setState(() => selectedCategory = category),
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 20,
                            vertical: 10,
                          ),
                          decoration: BoxDecoration(
                            color: isSelected
                                ? const Color(0xFF8b5cf6)
                                : Colors.white,
                            borderRadius: BorderRadius.circular(20),
                            border: Border.all(
                              color: const Color(0xFF8b5cf6),
                              width: 1,
                            ),
                          ),
                          child: Text(
                            category.label,
                            style: TextStyle(
                              color: isSelected
                                  ? Colors.white
                                  : const Color(0xFF8b5cf6),
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ),
            const SizedBox(height: 16),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: currentPrompts.length,
                itemBuilder: (context, index) {
                  final promptType = currentPrompts[index];
                  return GestureDetector(
                    onTap: () {
                      final category = promptType.getCategory();
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => WriteAnswerScreen(
                            category: category,
                            question: promptType,
                            editIndex: widget.editIndex,
                          ),
                        ),
                      );
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                      ),
                      child: Text(
                        promptType.label,
                        style: const TextStyle(
                          fontSize: 16,
                          color: Colors.black87,
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/verification_message_screen.dart
================================================

import 'package:dtx/views/home.dart';
import 'package:dtx/views/selfie_capture_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationMessageScreen extends StatelessWidget {
  const VerificationMessageScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40), // Top spacing
              // Illustration or Icon
              Container(
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  shape: BoxShape.circle,
                ),
                child: Center(
                  child: Icon(
                    Icons.verified_user_outlined,
                    size: 100,
                    color: const Color(0xFF8B5CF6),
                  ),
                ),
              ),
              const SizedBox(height: 32),
              // Title
              Text(
                "Profile Verification",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 16),
              // Subtitle/Description
              Text(
                "We are verifying your profile to ensure that no one else can use your photo. This helps us keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),
              const Spacer(), // Pushes the button to the bottom
              // Continue Button
              GestureDetector(
onTap: () {
  // Navigate to HomeScreen
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(builder: (context) => const SelfieCaptureScreen(),
  ));
},
                child: Container(
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 32), // Bottom spacing
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/verification_pending_screen.dart
================================================

import 'dart:io';
import 'package:dtx/views/home.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationPendingScreen extends StatelessWidget {
  final File? selfieImage;
  
  const VerificationPendingScreen({
    Key? key,
    this.selfieImage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40),
              
              // Selfie preview in a circular frame
              Container(
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: const Color(0xFF8B5CF6),
                    width: 4,
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: const Color(0xFF8B5CF6).withOpacity(0.2),
                      blurRadius: 15,
                      spreadRadius: 5,
                    ),
                  ],
                ),
                child: ClipOval(
                  child: selfieImage != null
                      ? Image.file(
                          selfieImage!,
                          fit: BoxFit.cover,
                        )
                      : Container(
                          color: Colors.grey[200],
                          child: Icon(
                            Icons.person,
                            size: 80,
                            color: Colors.grey[400],
                          ),
                        ),
                ),
              ),
              
              const SizedBox(height: 32),
              
              // Title
              Text(
                "Verification in Progress",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              
              const SizedBox(height: 16),
              
              // Description
              Text(
                "We're verifying your profile to ensure no one else can use your photos. This helps keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),
              
              const SizedBox(height: 24),
              
              // Status indicator
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 20,
                  vertical: 12,
                ),
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          Color(0xFF8B5CF6),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Text(
                      "Verification in progress",
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF8B5CF6),
                      ),
                    ),
                  ],
                ),
              ),
              
              const Spacer(),
              
              // Continue Button
              GestureDetector(
                onTap: () {
                  Navigator.pushAndRemoveUntil(
                    context,
                    MaterialPageRoute(
                      builder: (context) => const HomeScreen(),
                    ),
                    (route) => false,
                  );
                },
                child: Container(
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue Swiping",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),
              
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/writeprompt.dart
================================================
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/prompt.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/models/user_model.dart';

class WriteAnswerScreen extends ConsumerStatefulWidget {
  final PromptCategory category;
  final PromptType question;
  final int? editIndex;

  const WriteAnswerScreen({
    super.key,
    required this.category,
    required this.question,
    this.editIndex,
  });

  @override
  ConsumerState<WriteAnswerScreen> createState() => _WriteAnswerScreenState();
}

class _WriteAnswerScreenState extends ConsumerState<WriteAnswerScreen> {
  late final TextEditingController _answerController;

  @override
  void initState() {
    super.initState();
    _answerController = TextEditingController();
    _loadExistingAnswer();

    // Add listener to update UI when text changes
    _answerController.addListener(() {
      setState(() {}); // This triggers a rebuild when text changes
    });
  }

  void _loadExistingAnswer() {
    if (widget.editIndex != null) {
      final prompts = ref.read(userProvider).prompts;
      if (widget.editIndex! < prompts.length) {
        _answerController.text = prompts[widget.editIndex!].answer;
      }
    }
  }

  void _saveAnswer() {
    if (_answerController.text.trim().isNotEmpty) {
      final newPrompt = Prompt(
        category: widget.category,
        question: widget.question,
        answer: _answerController.text.trim(),
      );

      if (widget.editIndex != null) {
        ref.read(userProvider.notifier).updatePromptAtIndex(
              widget.editIndex!,
              newPrompt,
            );
      } else {
        ref.read(userProvider.notifier).addPrompt(newPrompt);
      }

                          Navigator.push(
                              context,
                              MaterialPageRoute(builder: (context) => const ProfileAnswersScreen()
                          ));
    }
  }

  @override
  void dispose() {
    _answerController.dispose(); // Clean up the controller
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 1,
        centerTitle: true,
        title: const Text(
          'Write Answer',
          style: TextStyle(
            color: Colors.black,
            fontSize: 18,
            fontWeight: FontWeight.w700,
          ),
        ),
        leadingWidth: 80,
        leading: GestureDetector(
          onTap: () => Navigator.pop(context),
          child: const Center(
            child: Text(
              'Cancel',
              style: TextStyle(
                color: Color(0xFF8B5CF6),
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed:
                _answerController.text.trim().isNotEmpty ? _saveAnswer : null,
            child: Text(
              'Done',
              style: TextStyle(
                color: _answerController.text.trim().isNotEmpty
                    ? const Color(0xFF8B5CF6)
                    : const Color(0xFF8B5CF6).withOpacity(0.5),
                fontSize: 16,
                fontWeight: FontWeight.w700,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          const SizedBox(height: 64),
          Container(
            margin: const EdgeInsets.symmetric(horizontal: 16),
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: const Color(0xFF8B5CF6).withOpacity(0.3),
                width: 2,
              ),
              boxShadow: [
                BoxShadow(
                  color: Colors.grey.withOpacity(0.1),
                  spreadRadius: 2,
                  blurRadius: 8,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: Text(
                    widget.question.label,
                    style: const TextStyle(
                      fontSize: 17,
                      fontWeight: FontWeight.w600,
                      color: Colors.black87,
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Icon(
                  Icons.edit_rounded,
                  color: const Color(0xFF8B5CF6).withOpacity(0.8),
                  size: 24,
                ),
              ],
            ),
          ),
          const SizedBox(height: 54),
          Container(
            height: 200,
            margin: const EdgeInsets.symmetric(horizontal: 16),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: const Color(0xFFE5E7EB),
                width: 1.5,
              ),
            ),
            child: Stack(
              children: [
                Padding(
                  padding: const EdgeInsets.all(16),
                  child: TextField(
                    controller: _answerController,
                    maxLength: 255,
                    maxLines: null,
                    style: const TextStyle(
                      fontSize: 16,
                      color: Colors.black87,
                      height: 1.4,
                    ),
                    decoration: const InputDecoration(
                      border: InputBorder.none,
                      hintText: 'Type your answer here...',
                      hintStyle: TextStyle(
                        color: Color(0xFF94A3B8),
                        fontSize: 16,
                        fontWeight: FontWeight.w400,
                      ),
                      counterText: '',
                    ),
                  ),
                ),
                Positioned(
                  right: 16,
                  bottom: 16,
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.grey[100],
                      borderRadius: BorderRadius.circular(6),
                    ),
                    child: Text(
                      '${_answerController.text.length}/255',
                      style: const TextStyle(
                        color: Color(0xFF64748B),
                        fontSize: 13,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),
        ],
      ),
    );
  }
}



================================================
File: views/youtube.dart
================================================
import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:flutter/services.dart'; // Required for Clipboard

// --- Configuration (kept outside the widget for clarity) ---

// Define the necessary YouTube scope
const List<String> _scopes = <String>[
  'https://www.googleapis.com/auth/youtube.readonly',
];

// Instantiate GoogleSignIn with the defined scopes
// You might want to manage this instance more globally in your app
// (e.g., using a service locator or provider) if other parts need it,
// but keeping it here works for a self-contained screen.
final GoogleSignIn _googleSignIn = GoogleSignIn(
  scopes: _scopes,
);

// --- Screen Widget ---

class YoutubeSignInScreen extends StatefulWidget {
  // You can add parameters here if needed, e.g., callbacks for when login succeeds/fails
  // final VoidCallback? onLoginSuccess;
  // final Function(String)? onTokenReceived;

  const YoutubeSignInScreen({
    super.key,
    // this.onLoginSuccess,
    // this.onTokenReceived,
  });

  @override
  State<YoutubeSignInScreen> createState() => _YoutubeSignInScreenState();
}

class _YoutubeSignInScreenState extends State<YoutubeSignInScreen> {
  GoogleSignInAccount? _currentUser;
  String _message = 'Not logged in';
  String? _accessToken; // To store the access token
  bool _isSigningIn = false; // To prevent multiple sign-in attempts
  bool _isFetchingToken = false; // To show progress while getting token

  @override
  void initState() {
    super.initState();

    // Listen for user changes (e.g., sign out from elsewhere or successful sign-in)
    _googleSignIn.onCurrentUserChanged.listen((GoogleSignInAccount? account) {
      // Important: Check if the widget is still mounted before calling setState
      if (mounted) {
        _updateUser(account);
      }
    }).onError((error) {
      // Handle stream errors if necessary
      print("Error listening to user changes: $error");
      if (mounted) {
        setState(() {
          _message = "Error listening for user changes.";
          _currentUser = null;
          _accessToken = null;
        });
      }
    });

    // Try silent sign-in on screen initialization
    // Make sure this doesn't interfere with other login logic in your app
    _googleSignIn.signInSilently().then((account) {
      // No need to call _updateUser here, the listener above will handle it
    }).catchError((err) {
      print('Error during silent sign-in attempt: $err');
      // Don't necessarily show an error here, silent sign-in failing is common
      if (mounted) {
        setState(() {
          _message = 'Not logged in (silent sign-in failed or not available)';
        });
      }
    });
  }

  @override
  void dispose() {
    // It's generally good practice to cancel stream subscriptions,
    // though onCurrentUserChanged might be managed internally by the plugin.
    // If you had custom StreamSubscriptions, you'd cancel them here.
    super.dispose();
  }

  void _updateUser(GoogleSignInAccount? account) async {
    // Check mounted again just to be safe, especially with async operations
    if (!mounted) return;

    setState(() {
      _currentUser = account;
      _accessToken = null; // Reset token when user changes
      _isFetchingToken = account != null; // Start fetching if user is not null
      if (_currentUser != null) {
        _message =
            "Logged in as ${_currentUser!.displayName ?? _currentUser!.email}";
      } else {
        _message = "Not logged in";
      }
    });

    // If user is logged in, get the access token
    if (_currentUser != null) {
      await _getAccessToken();
    }
  }

  // Function to get the access token
  Future<void> _getAccessToken() async {
    if (_currentUser == null) return;

    // Ensure mounted check before async operation and setState
    if (!mounted) return;

    setState(() {
      _isFetchingToken = true; // Show loading indicator
    });

    try {
      final GoogleSignInAuthentication auth =
          await _currentUser!.authentication;
      if (mounted) {
        // Check again after await
        setState(() {
          _accessToken = auth.accessToken;
          _isFetchingToken = false; // Hide loading indicator
          print("Access Token: $_accessToken"); // Print for debugging
          print("ID Token: ${auth.idToken}"); // Also available
          // Optional: Call a callback if provided via widget constructor
          // widget.onTokenReceived?.call(_accessToken!);
        });
      }
    } catch (err) {
      print('Error getting authentication token: $err');
      if (mounted) {
        // Check again after await
        setState(() {
          _message = 'Error getting token: $err';
          _accessToken = null;
          _isFetchingToken = false; // Hide loading indicator
        });
      }
    }
  }

  // Sign-in function
  Future<void> _handleSignIn() async {
    if (_isSigningIn) return; // Prevent double taps

    if (!mounted) return;
    setState(() {
      _isSigningIn = true;
      _message = "Signing in..."; // Provide feedback
    });

    try {
      // Start the sign-in process
      await _googleSignIn.signIn();
      // The onCurrentUserChanged listener will handle the update upon success.
      // If signIn() returns null (user cancelled), the listener will also get null.
    } catch (error) {
      print('Error signing in: $error');
      if (mounted) {
        // Check after await
        setState(() {
          _message = 'Error signing in: $error';
          _accessToken = null; // Clear token on error
        });
      }
    } finally {
      if (mounted) {
        // Check in finally block
        setState(() {
          _isSigningIn = false; // Allow sign-in attempts again
          // If _currentUser is still null here, sign-in likely failed or was cancelled
          if (_currentUser == null && !_message.startsWith("Error")) {
            _message = "Sign in cancelled or failed.";
          }
        });
      }
    }
  }

  // Sign-out function
  Future<void> _handleSignOut() async {
    if (!mounted) return;

    setState(() {
      _message = "Signing out...";
    });

    try {
      // Disconnect removes permissions, signOut just logs out locally
      await _googleSignIn.disconnect();
      // The onCurrentUserChanged listener handles the UI update.
    } catch (error) {
      print('Error signing out: $error');
      if (mounted) {
        // Check after await
        setState(() {
          // Restore user info if disconnect fails? Or keep logged-out state?
          // Keeping logged-out state might be less confusing.
          _message = 'Error signing out: $error';
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Determine button states
    final bool canSignIn = !_isSigningIn && _currentUser == null;
    final bool canSignOut = _currentUser != null;
    final bool showTokenInfo = _currentUser != null;
    final bool showCopyButton = _accessToken != null;

    return Scaffold(
      // You might want to remove this AppBar if the screen is embedded
      // within another Scaffold that already has one.
      appBar: AppBar(
        title: const Text('YouTube Account Login'),
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment:
                CrossAxisAlignment.center, // Center items horizontally
            children: <Widget>[
              // Display User Info or Status Message
              if (showTokenInfo) ...[
                ListTile(
                  leading: GoogleUserCircleAvatar(identity: _currentUser!),
                  title: Text(_currentUser!.displayName ?? 'No Name'),
                  subtitle: Text(_currentUser!.email),
                  contentPadding: EdgeInsets.zero, // Adjust padding if needed
                ),
                const SizedBox(height: 20),
                const Text("Access Token:",
                    style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 5),
                if (_isFetchingToken)
                  const Padding(
                    padding: EdgeInsets.symmetric(vertical: 10.0),
                    child: CircularProgressIndicator(),
                  )
                else if (_accessToken != null)
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey.shade300),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: SelectableText(
                      _accessToken!,
                      style: const TextStyle(fontSize: 12),
                      textAlign: TextAlign.center,
                      maxLines: 5, // Limit display lines if needed
                      scrollPhysics:
                          const ClampingScrollPhysics(), // Prevent scrolling within text box
                    ),
                  )
                else
                  const Text("Could not retrieve token.",
                      style:
                          TextStyle(color: Colors.red)), // Show if fetch failed
                const SizedBox(height: 10),
                ElevatedButton.icon(
                  icon: const Icon(Icons.copy, size: 16),
                  label: const Text('Copy Token'),
                  onPressed: showCopyButton
                      ? () {
                          Clipboard.setData(ClipboardData(text: _accessToken!));
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text('Access Token Copied!'),
                                duration: Duration(seconds: 2)),
                          );
                        }
                      : null, // Disable button if no token
                ),
              ] else ...[
                // Show Status Message when logged out or during sign-in process
                Text(_message, textAlign: TextAlign.center),
                const SizedBox(height: 20),
              ],

              const Spacer(), // Pushes buttons towards the bottom if desired

              // Sign In / Sign Out Buttons
              if (canSignIn)
                ElevatedButton.icon(
                  icon: const Icon(Icons.login),
                  label: const Text('Sign In with Google'),
                  onPressed: _handleSignIn,
                  style: ElevatedButton.styleFrom(
                      minimumSize:
                          const Size(200, 40)), // Ensure decent button size
                )
              else if (_isSigningIn)
                const CircularProgressIndicator() // Show progress during sign-in action
              else if (canSignOut)
                ElevatedButton.icon(
                  icon: const Icon(Icons.logout),
                  label: const Text('Sign Out & Disconnect'),
                  onPressed: _handleSignOut,
                  style: ElevatedButton.styleFrom(
                      backgroundColor:
                          Colors.redAccent, // Indicate destructive action
                      minimumSize: const Size(200, 40)),
                ),
              const SizedBox(height: 20), // Add some padding at the bottom
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/core/error_handler.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/models/error_model.dart';

class GlobalErrorHandler extends ConsumerWidget {
  final Widget child;
  const GlobalErrorHandler({super.key, required this.child});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final error = ref.watch(errorProvider);

    return Stack(
      children: [
        child,
        if (error != null) _buildErrorOverlay(context, error, ref),
      ],
    );
  }

  Widget _buildErrorOverlay(
      BuildContext context, AppError error, WidgetRef ref) {
    return Positioned.fill(
      child: Material(
        color: Colors.black54,
        child: Center(
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 20),
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  error.message,
                  style: const TextStyle(fontSize: 16),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () =>
                      ref.read(errorProvider.notifier).clearError(),
                  child: const Text('OK'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


