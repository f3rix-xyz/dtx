Directory structure:
└── lib/
    ├── main.dart
    ├── models/
    │   ├── auth_model.dart
    │   ├── error_model.dart
    │   ├── feed_models.dart
    │   ├── filter_model.dart
    │   ├── like_models.dart
    │   ├── location_model.dart
    │   ├── media_upload_model.dart
    │   └── user_model.dart
    ├── providers/
    │   ├── audio_player_provider.dart
    │   ├── audio_upload_provider.dart
    │   ├── auth_provider.dart
    │   ├── error_provider.dart
    │   ├── feed_provider.dart
    │   ├── filter_provider.dart
    │   ├── liker_profile_provider.dart
    │   ├── location_provider.dart
    │   ├── media_upload_provider.dart
    │   ├── recieved_likes_provider.dart
    │   ├── service_provider.dart
    │   └── user_provider.dart
    ├── repositories/
    │   ├── auth_repository.dart
    │   ├── auth_status_repository.dart
    │   ├── filter_repository.dart
    │   ├── like_repository.dart
    │   ├── media_repository.dart
    │   └── user_repository.dart
    ├── services/
    │   ├── api_service.dart
    │   └── http_service.dart
    ├── utils/
    │   ├── app_enums.dart
    │   ├── env_config.dart
    │   └── token_storage.dart
    ├── views/
    │   ├── audioprompt.dart
    │   ├── audiopromptsselect.dart
    │   ├── chat_screen.dart
    │   ├── dating_intentions.dart
    │   ├── dob.dart
    │   ├── drinking.dart
    │   ├── filter_settings_dialog.dart
    │   ├── gender.dart
    │   ├── google_sign_in_screen.dart
    │   ├── height.dart
    │   ├── home.dart
    │   ├── hometown.dart
    │   ├── job.dart
    │   ├── liker_profile_screen.dart
    │   ├── location.dart
    │   ├── main_navigation_screen.dart
    │   ├── media.dart
    │   ├── name.dart
    │   ├── profile_screens.dart
    │   ├── prompt.dart
    │   ├── religion.dart
    │   ├── selfie_capture_screen.dart
    │   ├── settings_screen.dart
    │   ├── smoking.dart
    │   ├── splash_screen.dart
    │   ├── study.dart
    │   ├── textpromptsselect.dart
    │   ├── verification_message_screen.dart
    │   ├── verification_pending_screen.dart
    │   ├── who_liked_you_screen.dart
    │   ├── writeprompt.dart
    │   ├── youtube.dart
    │   └── core/
    │       └── error_handler.dart
    └── widgets/
        ├── basic_liker_profile_card.dart
        ├── full_liker_profile_card.dart
        └── home_profile_card.dart

================================================
File: main.dart
================================================
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/gender.dart';
import 'package:dtx/views/height.dart';
import 'package:dtx/views/home.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/prompt.dart';
import 'package:flutter/material.dart';
import 'package:dtx/views/splash_screen.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

void main() async {
  // Ensure Flutter is initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Load environment variables
  await dotenv.load(fileName: ".env");

  runApp(
    // Adding ProviderScope at the root of the app
    const ProviderScope(
      child: MyApp(),
    ),
  );
}

// Change StatelessWidget to ConsumerWidget to use Riverpod
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp(
      title: 'DTX',
      debugShowCheckedModeBanner: false, // Optional: removes debug banner
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // You can add more theme configurations here
      ),
      // You can change the home screen here based on your flow
      // For example, start with PhoneInputScreen for authentication flow
      home: const SplashScreen(),
    );
  }
}



================================================
File: models/auth_model.dart
================================================
// File: models/auth_model.dart

// --- UPDATED ENUM ---
enum AuthStatus {
  login, // Needs to log in (no valid token or check failed)
  onboarding1, // Logged in, needs location/gender
  onboarding2, // Logged in, location/gender set, needs main profile details
  home, // Fully authenticated and onboarded
  unknown, // Initial state or error during status check
}
// --- END UPDATED ENUM ---

class AuthState {
  // --- REMOVED FIELDS ---
  // final String? unverifiedPhone;
  // final String? verificationId;
  // final int? resendTimer;
  // --- END REMOVED FIELDS ---

  final bool isLoading;
  final String? error; // Keep error for general auth errors
  final String? jwtToken;
  final AuthStatus authStatus;

  const AuthState({
    this.isLoading = false,
    this.error,
    this.jwtToken,
    this.authStatus = AuthStatus.unknown, // Default to unknown
  });

  AuthState copyWith({
    bool? isLoading,
    String? Function()? error,
    String? Function()? jwtToken, // Function to allow setting null
    AuthStatus? authStatus,
  }) {
    return AuthState(
      isLoading: isLoading ?? this.isLoading,
      error: error != null ? error() : this.error,
      jwtToken: jwtToken != null ? jwtToken() : this.jwtToken,
      authStatus: authStatus ?? this.authStatus,
    );
  }

  // Check if user is considered authenticated (has a token)
  bool get isAuthenticated => jwtToken != null && jwtToken!.isNotEmpty;
}



================================================
File: models/error_model.dart
================================================
enum ErrorType { network, validation, auth, generic, locationService, server }

class AppError {
  final String message;
  final ErrorType type;
  final DateTime timestamp;

  AppError({
    required this.message,
    required this.type,
  }) : timestamp = DateTime.now();

  factory AppError.network(String message) => AppError(
        message: message,
        type: ErrorType.network,
      );

  factory AppError.validation(String message) => AppError(
        message: message,
        type: ErrorType.validation,
      );

  factory AppError.auth(String message) => AppError(
        message: message,
        type: ErrorType.auth,
      );

  factory AppError.locationService(String message) => AppError(
        message: message,
        type: ErrorType.locationService,
      );

  factory AppError.server(String message) => AppError(
        message: message,
        type: ErrorType.server,
      );

  factory AppError.generic(String message) => AppError(
        message: message,
        type: ErrorType.generic, // Use the generic type
      );
}



================================================
File: models/feed_models.dart
================================================
import 'package:dtx/utils/app_enums.dart';

// --- REMOVED QuickFeedProfile ---

// --- FeedProfile (Kept for potential reuse, but not directly used by HomeScreen anymore) ---
// Consider removing if truly unused later.
class FeedProfile {
  final int id;
  final String? name;
  final String? lastName;
  final DateTime? dateOfBirth;
  final List<String>? mediaUrls;
  final Gender? gender;
  final double? distanceKm;

  FeedProfile({
    required this.id,
    this.name,
    this.lastName,
    this.dateOfBirth,
    this.mediaUrls,
    this.gender,
    this.distanceKm,
  });

  String get firstName => name ?? '';

  int? get age {
    if (dateOfBirth == null) return null;
    final now = DateTime.now();
    int age = now.year - dateOfBirth!.year;
    if (now.month < dateOfBirth!.month ||
        (now.month == dateOfBirth!.month && now.day < dateOfBirth!.day)) {
      age--;
    }
    return age < 18 ? null : age;
  }

  String? get firstMediaUrl {
    if (mediaUrls != null &&
        mediaUrls!.isNotEmpty &&
        mediaUrls![0].isNotEmpty) {
      return mediaUrls![0];
    }
    return null;
  }

  factory FeedProfile.fromJson(Map<String, dynamic> json) {
    DateTime? parseDate(dynamic dateField) {
      if (dateField is Map &&
          dateField['Valid'] == true &&
          dateField['Time'] != null) {
        try {
          return DateTime.parse(dateField['Time'] as String);
        } catch (e) {
          return null;
        }
      } else if (dateField is String) {
        // Handle direct string date
        try {
          return DateTime.parse(dateField);
        } catch (e) {
          return null;
        }
      }
      return null;
    }

    List<String>? parseMediaUrls(dynamic urls) {
      if (urls is List) {
        return List<String>.from(
            urls.where((item) => item is String && item.isNotEmpty));
      }
      return null;
    }

    Gender? parseGender(dynamic genderField) {
      String? genderStr;
      if (genderField is Map &&
          genderField['Valid'] == true &&
          genderField['GenderEnum'] != null) {
        genderStr = genderField['GenderEnum'] as String?;
      } else if (genderField is String) {
        genderStr = genderField;
      }

      if (genderStr != null) {
        if (genderStr == 'man') return Gender.man;
        if (genderStr == 'woman') return Gender.woman;
      }
      return null;
    }

    return FeedProfile(
      id: json['id'] as int? ?? 0,
      name: (json['name'] is Map && json['name']['Valid'])
          ? json['name']['String'] as String?
          : json['name'] as String?, // Handle direct string
      lastName: (json['last_name'] is Map && json['last_name']['Valid'])
          ? json['last_name']['String'] as String?
          : json['last_name'] as String?, // Handle direct string
      dateOfBirth: parseDate(json['date_of_birth']),
      mediaUrls: parseMediaUrls(json['media_urls']),
      gender: parseGender(json['gender']),
      distanceKm: (json['distance_km'] as num?)?.toDouble(),
    );
  }
}



================================================
File: models/filter_model.dart
================================================
// lib/models/filter_model.dart
import 'package:dtx/utils/app_enums.dart'; // For Gender enum (ensure correct import if needed)

// --- NEW: Enum for Gender Preference in Filters ---
// Aligns with backend Go enum values ('man', 'woman')
enum FilterGenderPref {
  man('man'),
  woman('woman');

  final String value;
  const FilterGenderPref(this.value);

  // Helper to convert string from API/JSON back to enum
  static FilterGenderPref? fromValue(String? value) {
    if (value == null) return null;
    try {
      return FilterGenderPref.values.firstWhere(
        (e) => e.value.toLowerCase() == value.toLowerCase(),
      );
    } catch (e) {
      return null; // Return null if value doesn't match any enum
    }
  }
}
// --- END NEW ---

class FilterSettings {
  final int? userId; // Keep user ID if needed to associate filters
  final FilterGenderPref? whoYouWantToSee; // Updated type
  final int? radiusKm;
  final bool? activeToday;
  final int? ageMin;
  final int? ageMax;
  final DateTime? createdAt; // Optional: For informational purposes
  final DateTime? updatedAt; // Optional: For informational purposes

  // Define default values (you might want to adjust these)
  static const FilterGenderPref defaultGenderPref = FilterGenderPref.woman;
  static const int defaultRadius = 50; // e.g., 50 km
  static const bool defaultActiveToday = false;
  static const int defaultAgeMin = 18;
  static const int defaultAgeMax = 55;

  const FilterSettings({
    this.userId,
    this.whoYouWantToSee = defaultGenderPref, // Default to show women
    this.radiusKm = defaultRadius,
    this.activeToday = defaultActiveToday,
    this.ageMin = defaultAgeMin,
    this.ageMax = defaultAgeMax,
    this.createdAt,
    this.updatedAt,
  });

  // Check if the current settings are the default ones
  bool get isDefault {
    return whoYouWantToSee == defaultGenderPref &&
        radiusKm == defaultRadius &&
        activeToday == defaultActiveToday &&
        ageMin == defaultAgeMin &&
        ageMax == defaultAgeMax;
  }

  // copyWith method for immutability
  FilterSettings copyWith({
    int? userId,
    FilterGenderPref? Function()? whoYouWantToSee, // Use nullable functions
    int? Function()? radiusKm,
    bool? Function()? activeToday,
    int? Function()? ageMin,
    int? Function()? ageMax,
    DateTime? createdAt, // Optional: For informational purposes
    DateTime? updatedAt, // Optional: For informational purposes
  }) {
    return FilterSettings(
      userId: userId ?? this.userId,
      whoYouWantToSee:
          whoYouWantToSee != null ? whoYouWantToSee() : this.whoYouWantToSee,
      radiusKm: radiusKm != null ? radiusKm() : this.radiusKm,
      activeToday: activeToday != null ? activeToday() : this.activeToday,
      ageMin: ageMin != null ? ageMin() : this.ageMin,
      ageMax: ageMax != null ? ageMax() : this.ageMax,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  // Convert to JSON for API requests (align keys with backend)
  Map<String, dynamic> toJsonForApi() {
    final Map<String, dynamic> data = {};
    // Only include fields that are non-null or should be sent
    if (whoYouWantToSee != null)
      data['whoYouWantToSee'] = whoYouWantToSee!.value;
    if (radiusKm != null) data['radius'] = radiusKm;
    if (activeToday != null) data['activeToday'] = activeToday;
    if (ageMin != null) data['ageMin'] = ageMin;
    if (ageMax != null) data['ageMax'] = ageMax;
    return data;
  }

  // Factory to parse from JSON API response
  factory FilterSettings.fromJson(Map<String, dynamic> json) {
    // Helper to safely parse nullable integers from potential pgtype structure
    int? parseInt(dynamic field) {
      if (field is Map &&
          field['Valid'] == true &&
          field['Int32'] != null &&
          field['Int32'] is num) {
        return (field['Int32'] as num).toInt();
      }
      // Handle direct int case if backend sends it sometimes
      if (field is int) return field;
      return null;
    }

    // Helper to safely parse gender preference from potential pgtype structure
    FilterGenderPref? parseGenderPref(dynamic field) {
      if (field is Map &&
          field['Valid'] == true &&
          field['GenderEnum'] != null) {
        return FilterGenderPref.fromValue(field['GenderEnum'] as String?);
      }
      // Handle direct string case
      if (field is String) {
        return FilterGenderPref.fromValue(field);
      }
      return null;
    }

    DateTime? parseDateTime(String? dateString) {
      if (dateString == null) return null;
      try {
        return DateTime.parse(dateString);
      } catch (_) {
        return null; // Return null if parsing fails
      }
    }

    // Adapt the keys ('WhoYouWantToSee', 'RadiusKm', etc.) to match your exact API response structure
    // Use the helpers for nullable fields
    final FilterGenderPref? parsedGender =
        parseGenderPref(json['WhoYouWantToSee']); // Check API response key case
    final int? parsedRadius =
        parseInt(json['RadiusKm']); // Check API response key case
    final int? parsedAgeMin =
        parseInt(json['AgeMin']); // Check API response key case
    final int? parsedAgeMax =
        parseInt(json['AgeMax']); // Check API response key case
    // Assuming 'ActiveToday' is sent as a direct boolean or pgtype.Bool
    final bool? parsedActive = (json['ActiveToday'] is Map &&
            json['ActiveToday']['Valid'] == true)
        ? json['ActiveToday']['Bool'] as bool?
        : (json['ActiveToday'] is bool ? json['ActiveToday'] as bool? : null);

    return FilterSettings(
      userId: json['UserID'], // Assume UserID is directly available
      whoYouWantToSee: parsedGender ??
          FilterSettings.defaultGenderPref, // Fallback to default
      radiusKm: parsedRadius ?? FilterSettings.defaultRadius,
      activeToday: parsedActive ?? FilterSettings.defaultActiveToday,
      ageMin: parsedAgeMin ?? FilterSettings.defaultAgeMin,
      ageMax: parsedAgeMax ?? FilterSettings.defaultAgeMax,
      createdAt: parseDateTime(json['CreatedAt'] as String?),
      updatedAt: parseDateTime(json['UpdatedAt'] as String?),
    );
  }
}



================================================
File: models/like_models.dart
================================================
// File: models/like_models.dart
import 'package:dtx/models/user_model.dart'; // Import UserProfileData definition source
import 'package:dtx/utils/app_enums.dart'; // For GenderEnum if needed
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Only needed if UserProfileData uses Riverpod types directly, unlikely.

// --- Enums (from Phase 8) ---
enum ContentLikeType {
  /* ... */
  media('media'),
  promptStory('prompt_story'),
  promptMytype('prompt_mytype'),
  promptGettingpersonal('prompt_gettingpersonal'),
  promptDatevibes('prompt_datevibes'),
  audioPrompt('audio_prompt');

  final String value;
  const ContentLikeType(this.value);
  static ContentLikeType? fromValue(String? value) {
    if (value == null) return null;
    return ContentLikeType.values.firstWhere((e) => e.value == value,
        orElse: () => ContentLikeType.media);
  }
}

enum LikeInteractionType {
  /* ... */
  standard('standard'),
  rose('rose');

  final String value;
  const LikeInteractionType(this.value);
  static LikeInteractionType? fromValue(String? value) {
    if (value == null) return null;
    return LikeInteractionType.values.firstWhere((e) => e.value == value,
        orElse: () => LikeInteractionType.standard);
  }
}

// --- Custom Exceptions (from Phase 8) ---
class LikeLimitExceededException implements Exception {
  /* ... */ final String message;
  LikeLimitExceededException([this.message = 'Daily like limit reached.']);
  @override
  String toString() => message;
}

class InsufficientRosesException implements Exception {
  /* ... */ final String message;
  InsufficientRosesException([this.message = 'You don\'t have enough Roses.']);
  @override
  String toString() => message;
}

// --- Liker Data Structures ---

// Structure for Full Profile Liker (Matches API Response `full_profiles` item)
class FullProfileLiker {
  final int likerUserId;
  final String? likeComment; // Nullable string
  final bool isRose;
  final DateTime? likedAt; // Parsed timestamp
  final UserProfileData profile; // Embedded full profile data

  FullProfileLiker({
    required this.likerUserId,
    this.likeComment,
    required this.isRose,
    this.likedAt,
    required this.profile,
  });

  factory FullProfileLiker.fromJson(Map<String, dynamic> json) {
    DateTime? parseTimestamp(dynamic ts) {
      if (ts is String) {
        try {
          return DateTime.parse(ts).toLocal();
        } catch (_) {} // Parse and convert to local time
      }
      return null;
    }

    // Safely get comment string
    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        // Handle direct string just in case
        return commentField;
      }
      return null;
    }

    return FullProfileLiker(
      likerUserId: json['liker_user_id'] as int? ?? 0,
      likeComment: getComment(json['like_comment']),
      isRose: json['is_rose'] as bool? ??
          (json['interaction_type'] ==
              'rose'), // Check interaction_type if is_rose missing
      likedAt: parseTimestamp(json['liked_at']),
      // Assuming 'profile' contains the full UserProfileData structure
      profile: UserProfileData.fromJson(
          json['profile'] as Map<String, dynamic>? ?? {}),
    );
  }
}

// Structure for Basic Profile Liker (Matches API Response `other_likers` item)
class BasicProfileLiker {
  final int likerUserId;
  final String name; // Should ideally always have a name
  final String? firstProfilePicUrl; // Nullable string
  final String? likeComment; // Nullable string
  final bool isRose;
  final DateTime? likedAt; // Parsed timestamp

  BasicProfileLiker({
    required this.likerUserId,
    required this.name,
    this.firstProfilePicUrl,
    this.likeComment,
    required this.isRose,
    this.likedAt,
  });

  factory BasicProfileLiker.fromJson(Map<String, dynamic> json) {
    DateTime? parseTimestamp(dynamic ts) {
      if (ts is String) {
        try {
          return DateTime.parse(ts).toLocal();
        } catch (_) {}
      }
      return null;
    }

    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        return commentField;
      }
      return null;
    }

    String? getPicUrl(dynamic urls) {
      if (urls is List && urls.isNotEmpty && urls[0] is String) {
        return urls[0];
      }
      return null;
    }

    String buildName(dynamic nameField, dynamic lastNameField) {
      String firstName = (nameField is Map && nameField['Valid'] == true)
          ? nameField['String'] ?? ''
          : '';
      String lastName = (lastNameField is Map && lastNameField['Valid'] == true)
          ? lastNameField['String'] ?? ''
          : '';
      return '$firstName $lastName'.trim(); // Combine and trim whitespace
    }

    return BasicProfileLiker(
      likerUserId: json['liker_user_id'] as int? ?? 0,
      name: buildName(json['name'], json['last_name']), // Build name safely
      firstProfilePicUrl: getPicUrl(json['media_urls']), // Get first URL safely
      likeComment: getComment(json['like_comment']),
      isRose: json['is_rose'] as bool? ?? (json['interaction_type'] == 'rose'),
      likedAt: parseTimestamp(json['liked_at']),
    );
  }
}

class LikeInteractionDetails {
  final String? likeComment; // Nullable string
  final bool isRose;

  LikeInteractionDetails({
    this.likeComment,
    required this.isRose,
  });

  factory LikeInteractionDetails.fromJson(Map<String, dynamic> json) {
    String? getComment(dynamic commentField) {
      if (commentField is Map && commentField['Valid'] == true) {
        return commentField['String'] as String?;
      } else if (commentField is String) {
        return commentField;
      }
      return null;
    }

    return LikeInteractionDetails(
      likeComment: getComment(
          json['comment']), // Assuming key is 'comment' from GetLikeDetailsRow
      isRose: json['interaction_type'] ==
          LikeInteractionType.rose.value, // Check interaction_type
    );
  }
}

// --- Placeholder for UserProfileData (if not defined elsewhere) ---
// IMPORTANT: Ensure this structure *exactly* matches the one expected
// by FullProfileLiker.fromJson and used in views/profile_screens.dart
// It should contain all fields returned by GET /get-profile.
// For simplicity, re-using UserModel might work if its fromJson handles the /get-profile structure.

class UserProfileData extends UserModel {
  // If UserProfileData needs fields BEYOND UserModel, add them here.
  // Example: final int matchScore;

  UserProfileData({
    // Inherit all fields from UserModel
    super.name,
    super.lastName,
    super.email,
    super.phoneNumber,
    super.dateOfBirth,
    super.latitude,
    super.longitude,
    super.gender,
    super.datingIntention,
    super.height,
    super.hometown,
    super.jobTitle,
    super.education,
    super.religiousBeliefs,
    super.drinkingHabit,
    super.smokingHabit,
    super.mediaUrls,
    super.prompts = const [],
    super.audioPrompt,
    super.verificationStatus,
    super.verificationPic,
    super.role,
    // Add any extra fields here:
    // required this.matchScore,
  });

  factory UserProfileData.fromJson(Map<String, dynamic> json) {
    // Parse UserModel fields using its factory
    final userModel = UserModel.fromJson(json);

    // Parse any additional fields specific to UserProfileData
    // final int score = json['match_score'] as int? ?? 0;

    return UserProfileData(
      name: userModel.name, lastName: userModel.lastName,
      email: userModel.email,
      phoneNumber: userModel.phoneNumber, dateOfBirth: userModel.dateOfBirth,
      latitude: userModel.latitude, longitude: userModel.longitude,
      gender: userModel.gender,
      datingIntention: userModel.datingIntention, height: userModel.height,
      hometown: userModel.hometown,
      jobTitle: userModel.jobTitle, education: userModel.education,
      religiousBeliefs: userModel.religiousBeliefs,
      drinkingHabit: userModel.drinkingHabit,
      smokingHabit: userModel.smokingHabit,
      mediaUrls: userModel.mediaUrls, prompts: userModel.prompts,
      audioPrompt: userModel.audioPrompt,
      verificationStatus: userModel.verificationStatus,
      verificationPic: userModel.verificationPic,
      role: userModel.role,
      // Assign additional fields:
      // matchScore: score,
    );
  }
}



================================================
File: models/location_model.dart
================================================
class LocationState {
  final bool isLoading;
  final bool isFetching;
  final double latitude;
  final double longitude;
  final double? cachedLatitude;
  final double? cachedLongitude;
  final bool isMapReady;

  LocationState({
    this.isLoading = true,
    this.isFetching = false,
    this.latitude = 19.2183, // Default location
    this.longitude = 73.0864,
    this.cachedLatitude,
    this.cachedLongitude,
    this.isMapReady = false,
  });

  LocationState copyWith({
    bool? isLoading,
    bool? isFetching,
    double? latitude,
    double? longitude,
    double? cachedLatitude,
    double? cachedLongitude,
    bool? isMapReady,
  }) {
    return LocationState(
      isLoading: isLoading ?? this.isLoading,
      isFetching: isFetching ?? this.isFetching,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      cachedLatitude: cachedLatitude ?? this.cachedLatitude,
      cachedLongitude: cachedLongitude ?? this.cachedLongitude,
      isMapReady: isMapReady ?? this.isMapReady,
    );
  }
}



================================================
File: models/media_upload_model.dart
================================================

// models/media_upload_model.dart
import 'dart:io';

enum UploadStatus {
  idle,
  inProgress,
  success,
  failed,
}

class MediaUploadModel {
  final File file;
  final String fileName;
  final String fileType;
  final String? presignedUrl;
  final UploadStatus status;
  final String? errorMessage;
  
  MediaUploadModel({
    required this.file,
    required this.fileName,
    required this.fileType,
    this.presignedUrl,
    this.status = UploadStatus.idle,
    this.errorMessage,
  });
  
  MediaUploadModel copyWith({
    File? file,
    String? fileName,
    String? fileType,
    String? Function()? presignedUrl,
    UploadStatus? status,
    String? Function()? errorMessage,
  }) {
    return MediaUploadModel(
      file: file ?? this.file,
      fileName: fileName ?? this.fileName,
      fileType: fileType ?? this.fileType,
      presignedUrl: presignedUrl != null ? presignedUrl() : this.presignedUrl,
      status: status ?? this.status,
      errorMessage: errorMessage != null ? errorMessage() : this.errorMessage,
    );
  }
}



================================================
File: models/user_model.dart
================================================
// File: lib/models/user_model.dart
import 'package:dtx/utils/app_enums.dart';
// No need for 'dart:convert' import here unless used elsewhere in this specific file

// --- Prompt Class --- (No changes needed)
class Prompt {
  final PromptCategory category;
  final PromptType question;
  final String answer;

  Prompt({
    required this.category,
    required this.question,
    required this.answer,
  });

  Map<String, dynamic> toJson() => {
        'category': category.value,
        'question': question.value,
        'answer': answer,
      };

  factory Prompt.fromJson(Map<String, dynamic> json) {
    PromptCategory category = PromptCategory.values
        .firstWhere((e) => e.value == json['category'], orElse: () {
      print(
          "Warning: Unknown prompt category '${json['category']}', defaulting to storyTime.");
      return PromptCategory.storyTime;
    });
    PromptType question = PromptType.values
        .firstWhere((e) => e.value == json['question'], orElse: () {
      print(
          "Warning: Unknown prompt question '${json['question']}' for category '${category.value}', defaulting.");
      return category.getPrompts().isNotEmpty
          ? category.getPrompts().first
          : PromptType.twoTruthsAndALie; // A fallback default
    });

    return Prompt(
      category: category,
      question: question,
      answer: json['answer'] ?? '',
    );
  }

  Prompt copyWith({String? answer}) {
    return Prompt(
      category: category,
      question: question,
      answer: answer ?? this.answer,
    );
  }

  @override
  String toString() {
    return 'Prompt(question: ${question.label}, answer: $answer)';
  }
}

// --- AudioPromptModel Class --- (No changes needed)
class AudioPromptModel {
  final AudioPrompt prompt;
  final String audioUrl; // Renamed from answer for clarity

  AudioPromptModel({
    required this.prompt,
    required this.audioUrl, // Renamed
  });

  // --- UPDATED toJson for PATCH ---
  Map<String, dynamic> toJson() => {
        'question': prompt.value, // Key expected by PATCH
        'answer_url': audioUrl, // Key expected by PATCH
      };
  // --- END UPDATED toJson ---

  factory AudioPromptModel.fromJson(Map<String, dynamic> json) {
    // Parse Question (assuming it's always a map)
    final promptValue =
        json['audio_prompt_question']?['AudioPrompt'] as String?;
    final bool isPromptValid =
        json['audio_prompt_question']?['Valid'] as bool? ?? false;

    if (!isPromptValid || promptValue == null) {
      throw const FormatException(
          'Invalid or missing audio prompt question data in JSON');
    }

    AudioPrompt prompt = AudioPrompt.values
        .firstWhere((e) => e.value == promptValue, orElse: () {
      print(
          "Warning: Unknown audio prompt '$promptValue', defaulting to aBoundaryOfMineIs.");
      return AudioPrompt.aBoundaryOfMineIs;
    });

    // Parse Answer (handle both String and Map)
    String? audioUrlValue;
    dynamic answerField = json['audio_prompt_answer'];

    if (answerField is String) {
      audioUrlValue = answerField;
    } else if (answerField is Map) {
      if (answerField['Valid'] == true && answerField['String'] is String) {
        audioUrlValue = answerField['String'] as String;
      }
    }

    if (audioUrlValue == null || audioUrlValue.isEmpty) {
      throw const FormatException(
          'Invalid or missing audio prompt answer data in JSON');
    }

    return AudioPromptModel(
      prompt: prompt,
      audioUrl: audioUrlValue, // Use renamed field
    );
  }
}

// --- UserModel Class ---
class UserModel {
  final int? id;
  final String? name;
  final String? lastName;
  final String? phoneNumber;
  final String? email;
  final DateTime? dateOfBirth;
  final double? latitude;
  final double? longitude;
  final Gender? gender;
  final DatingIntention? datingIntention;
  final String? height;
  final String? hometown;
  final String? jobTitle;
  final String? education;
  final Religion? religiousBeliefs;
  final DrinkingSmokingHabits? drinkingHabit;
  final DrinkingSmokingHabits? smokingHabit;
  final List<String>? mediaUrls;
  final List<Prompt> prompts;
  final AudioPromptModel? audioPrompt;
  final String? verificationStatus;
  final String? verificationPic;
  final String? role;
  // --- NEW: Internal flag for media changes ---
  final bool mediaChangedDuringEdit; // Track if media screen was edited

  UserModel({
    this.id,
    this.name,
    this.lastName,
    this.phoneNumber,
    this.email,
    this.dateOfBirth,
    this.latitude,
    this.longitude,
    this.gender,
    this.datingIntention,
    this.height,
    this.hometown,
    this.jobTitle,
    this.education,
    this.religiousBeliefs,
    this.drinkingHabit,
    this.smokingHabit,
    this.mediaUrls,
    this.prompts = const [],
    this.audioPrompt,
    this.verificationStatus,
    this.verificationPic,
    this.role,
    this.mediaChangedDuringEdit = false, // Default to false
  });

  int? get age {
    if (dateOfBirth == null) return null;
    final now = DateTime.now();
    int age = now.year - dateOfBirth!.year;
    if (now.month < dateOfBirth!.month ||
        (now.month == dateOfBirth!.month && now.day < dateOfBirth!.day)) {
      age--;
    }
    return age < 18 ? null : age;
  }

  String? get firstMediaUrl {
    if (mediaUrls != null &&
        mediaUrls!.isNotEmpty &&
        mediaUrls![0].isNotEmpty) {
      return mediaUrls![0];
    }
    return null;
  }

  // toJson remains the same (might be useful for other things)
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'last_name': lastName,
        'phone_number': phoneNumber,
        'email': email,
        'date_of_birth': dateOfBirth?.toIso8601String().split('T').first,
        'latitude': latitude,
        'longitude': longitude,
        'gender': gender?.value,
        'dating_intention': datingIntention?.value,
        'height': height,
        'hometown': hometown,
        'job_title': jobTitle,
        'education': education,
        'religious_beliefs': religiousBeliefs?.value,
        'drinking_habit': drinkingHabit?.value,
        'smoking_habit': smokingHabit?.value,
        'media_urls': mediaUrls,
        'prompts': prompts.map((prompt) => prompt.toJson()).toList(),
        // Use AudioPromptModel's toJson which is now formatted for PATCH
        'audio_prompt': audioPrompt?.toJson(),
        'verification_status': verificationStatus,
        'verification_pic': verificationPic,
        'role': role,
      };

  // toJsonForProfileUpdate remains the same (for onboarding step 2 POST)
  Map<String, dynamic> toJsonForProfileUpdate() {
    String? formattedDate(DateTime? dt) {
      if (dt == null) return null;
      return "${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')}";
    }

    String? formattedHeight(String? h) {
      // Height format conversion is likely handled by the backend on POST
      // but we can keep the frontend format consistent if needed.
      return h?.replaceAll("' ", "'"); // Example: ensure single space
    }

    final Map<String, dynamic> data = {};
    if (name != null) data['name'] = name;
    data['last_name'] = lastName ?? ""; // Send empty string if null for POST
    if (dateOfBirth != null) data['date_of_birth'] = formattedDate(dateOfBirth);
    if (datingIntention != null)
      data['dating_intention'] = datingIntention!.value;
    if (height != null) data['height'] = formattedHeight(height);
    if (hometown != null) data['hometown'] = hometown;
    if (jobTitle != null) data['job_title'] = jobTitle;
    if (education != null) data['education'] = education;
    if (religiousBeliefs != null)
      data['religious_beliefs'] = religiousBeliefs!.value;
    if (drinkingHabit != null) data['drinking_habit'] = drinkingHabit!.value;
    if (smokingHabit != null) data['smoking_habit'] = smokingHabit!.value;
    if (prompts.isNotEmpty)
      data['prompts'] = prompts.map((p) => p.toJson()).toList();
    // Note: Audio prompt and media are handled by separate endpoints during initial onboarding POSTs
    return data;
  }

  // --- NEW: toJsonForEdit for PATCH request ---
  Map<String, dynamic> toJsonForEdit() {
    String? formattedHeight(String? h) {
      // Apply formatting consistent with API expectation if needed
      return h?.replaceAll("' ", "'"); // Example
    }

    final Map<String, dynamic> data = {};
    // --- ONLY include fields that are editable and have values ---
    // Non-editable: name, last_name, dob, gender, location
    if (datingIntention != null)
      data['dating_intention'] = datingIntention!.value;
    if (height != null && height!.isNotEmpty)
      data['height'] = formattedHeight(height);
    if (hometown != null && hometown!.isNotEmpty) data['hometown'] = hometown;
    if (jobTitle != null && jobTitle!.isNotEmpty) data['job_title'] = jobTitle;
    if (education != null && education!.isNotEmpty)
      data['education'] = education;
    if (religiousBeliefs != null)
      data['religious_beliefs'] = religiousBeliefs!.value;
    if (drinkingHabit != null) data['drinking_habit'] = drinkingHabit!.value;
    if (smokingHabit != null) data['smoking_habit'] = smokingHabit!.value;

    // Handle optional fields where null means "remove"
    if (hometown == null)
      data['hometown'] = null; // Explicitly set to null if cleared
    if (jobTitle == null) data['job_title'] = null;
    if (education == null) data['education'] = null;

    // Always include prompts, even if empty, to allow removal
    data['prompts'] = prompts.map((p) => p.toJson()).toList();

    // Include audio_prompt only if it exists
    if (audioPrompt != null) {
      data['audio_prompt'] = audioPrompt!.toJson(); // Uses the corrected toJson
    } else {
      // To remove audio prompt, explicitly send null
      data['audio_prompt'] = null;
    }

    // Always include media_urls (even if empty after edit)
    data['media_urls'] = mediaUrls ?? [];

    return data;
  }
  // --- END NEW ---

  // fromJson remains the same
  factory UserModel.fromJson(Map<String, dynamic> json) {
    // --- Helper Functions ---
    String? getString(dynamic field) {
      if (field is Map && field['Valid'] == true && field['String'] != null) {
        return field['String'] as String?;
      } else if (field is String) {
        return field;
      } else if (field is int || field is double) {
        return field.toString();
      }
      return null;
    }

    String? getHeight(dynamic field) {
      if (field is Map && field['Valid'] == true && field['String'] != null) {
        return field['String'] as String?;
      } else if (field is String) {
        // Backend might send "5' 11\"" or "5'11\""
        return field.replaceAll("' ",
            "'"); // Standardize to single space or no space? Check API doc.
      } else if (field is int || field is double) {
        // Convert cm/inches if backend sends numeric height sometimes
        double totalInches = (field as num) * 0.393701;
        int feet = (totalInches / 12).floor();
        int inches = (totalInches % 12).round();
        if (inches == 12) {
          feet++;
          inches = 0;
        }
        return "$feet' $inches\""; // Ensure this format matches API exactly
      }
      return null;
    }

    String? getEnumString(dynamic field, String key) {
      if (field is Map && field['Valid'] == true && field[key] != null) {
        return field[key] as String?;
      } else if (field is String) {
        // Handle direct string enums
        return field;
      }
      return null;
    }

    DateTime? getDate(dynamic field) {
      String? dateStr;
      if (field is Map && field['Valid'] == true && field['Time'] != null) {
        dateStr = field['Time'] as String?;
      } else if (field is String) {
        dateStr = field;
      }
      if (dateStr != null) {
        try {
          if (dateStr.contains('T')) {
            return DateTime.parse(dateStr.split('T').first);
          } else if (RegExp(r'^\d{4}-\d{2}-\d{2}$').hasMatch(dateStr)) {
            return DateTime.parse(dateStr);
          }
        } catch (e) {
          print("Error parsing date: $e, value: $field");
        }
      }
      return null;
    }

    double? getDouble(dynamic field) {
      if (field is Map && field['Valid'] == true && field['Float64'] != null) {
        return (field['Float64'] as num?)?.toDouble();
      } else if (field is num) {
        return field.toDouble();
      }
      return null;
    }

    T? parseEnum<T>(List<T> enumValues, dynamic field, String key) {
      // Use getEnumString which handles both map and direct string
      final valueStr = getEnumString(field, key);
      if (valueStr != null) {
        for (final enumValue in enumValues) {
          try {
            // Assuming enums have a '.value' getter holding the string representation
            if ((enumValue as dynamic).value.toString() == valueStr) {
              return enumValue;
            }
          } catch (e) {
            // This catch block is tricky if enums don't uniformly have '.value'
            // Consider a more robust mapping if enums are inconsistent.
            // print("Error accessing '.value' for enum ${T.toString()} (value: $valueStr): $e");
            // Fallback: Check toString() representation (less reliable)
            if (enumValue.toString().split('.').last == valueStr) {
              // print("Fallback enum match using toString() for $valueStr");
              return enumValue;
            }
          }
        }
        print("Warning: Enum value '$valueStr' not found in ${T.toString()}.");
        return null;
      }
      return null;
    }

    List<String>? getMediaUrls(dynamic field) {
      if (field is List<dynamic>) {
        final urls = field
            .where((item) => item is String && item.isNotEmpty)
            .map((item) => item as String)
            .toList();
        return urls.isNotEmpty ? urls : null;
      } else if (field is List<String>) {
        // Handle case where it's already List<String>
        return field.where((s) => s.isNotEmpty).toList().isNotEmpty
            ? field
            : null;
      }
      return null;
    }

    int? getId(dynamic idField) {
      if (idField is int) {
        return idField;
      }
      if (idField is String) {
        return int.tryParse(idField);
      }
      if (idField is Map &&
          idField['Valid'] == true &&
          idField['Int64'] != null) {
        if (idField['Int64'] is num) {
          return (idField['Int64'] as num).toInt();
        }
      }
      return null;
    }

    List<Prompt> getPrompts(Map<String, dynamic> json) {
      List<Prompt> parsedPrompts = [];
      if (json['prompts'] is List) {
        final List<dynamic> promptList = json['prompts'];
        for (var promptData in promptList) {
          if (promptData is Map<String, dynamic>) {
            try {
              final parsedPrompt = Prompt.fromJson(promptData);
              // Ensure answer is not just whitespace before adding
              if (parsedPrompt.answer.trim().isNotEmpty) {
                parsedPrompts.add(parsedPrompt);
              } else {
                print(
                    "[UserModel fromJson] Skipping prompt with empty answer: ${promptData['question']}");
              }
            } catch (e) {
              print(
                  "[UserModel fromJson] Error parsing prompt: $e, data: $promptData");
            }
          }
        }
      }
      // API allows max 3, but frontend should handle this limit upstream.
      // Here we just parse what's given.
      return parsedPrompts;
    }

    // --- REVISED getAudioPrompt Helper ---
    AudioPromptModel? getAudioPrompt(Map<String, dynamic> json, int? userId) {
      final questionData =
          json['AudioPromptQuestion'] ?? json['audio_prompt_question'];
      final answerData =
          json['AudioPromptAnswer'] ?? json['audio_prompt_answer'];

      // 1. Check Question Validity
      bool isQuestionValid = questionData is Map &&
          questionData['Valid'] == true &&
          questionData['AudioPrompt'] is String &&
          (questionData['AudioPrompt'] as String).isNotEmpty;

      if (!isQuestionValid) return null; // No valid question, no audio prompt

      // 2. Check Answer Validity (String or Valid Map with non-empty String)
      String? audioUrlValue;
      if (answerData is String && answerData.isNotEmpty) {
        audioUrlValue = answerData;
      } else if (answerData is Map &&
          answerData['Valid'] == true &&
          answerData['String'] is String &&
          (answerData['String'] as String).isNotEmpty) {
        audioUrlValue = answerData['String'] as String;
      }

      if (audioUrlValue == null)
        return null; // No valid answer, no audio prompt

      // 3. If BOTH are valid, attempt to create the model using the Factory
      try {
        // The factory now handles the map structure directly
        return AudioPromptModel.fromJson({
          'audio_prompt_question': questionData,
          'audio_prompt_answer': answerData,
        });
      } catch (e) {
        print(
            "[UserModel fromJson getAudioPrompt ID: $userId] Error creating AudioPromptModel: $e");
        print(" -> Question Data: $questionData");
        print(" -> Answer Data: $answerData");
        return null;
      }
    }
    // --- END REVISED getAudioPrompt Helper ---

    // --- Parse using helpers ---
    final int? currentUserId =
        getId(json['id'] ?? json['ID']); // Get ID for logging
    final parsedUser = UserModel(
      id: currentUserId, // Use the extracted ID
      name: getString(json['name'] ?? json['Name']),
      lastName: getString(json['last_name'] ?? json['LastName']),
      email: json['email'] as String? ?? json['Email'] as String?,
      phoneNumber: getString(json['phone_number'] ?? json['PhoneNumber']),
      dateOfBirth: getDate(json['date_of_birth'] ?? json['DateOfBirth']),
      latitude: getDouble(json['latitude'] ?? json['Latitude']),
      longitude: getDouble(json['longitude'] ?? json['Longitude']),
      gender: parseEnum(
          Gender.values, json['gender'] ?? json['Gender'], 'GenderEnum'),
      datingIntention: parseEnum(
          DatingIntention.values,
          json['dating_intention'] ?? json['DatingIntention'],
          'DatingIntention'),
      height: getHeight(json['height'] ?? json['Height']),
      hometown: getString(json['hometown'] ?? json['Hometown']),
      jobTitle: getString(json['job_title'] ?? json['JobTitle']),
      education: getString(json['education'] ?? json['Education']),
      religiousBeliefs: parseEnum(Religion.values,
          json['religious_beliefs'] ?? json['ReligiousBeliefs'], 'Religion'),
      drinkingHabit: parseEnum(
          DrinkingSmokingHabits.values,
          json['drinking_habit'] ?? json['DrinkingHabit'],
          'DrinkingSmokingHabits'),
      smokingHabit: parseEnum(
          DrinkingSmokingHabits.values,
          json['smoking_habit'] ?? json['SmokingHabit'],
          'DrinkingSmokingHabits'),
      mediaUrls: getMediaUrls(json['media_urls'] ?? json['MediaUrls']),
      verificationStatus: json['verification_status'] as String? ??
          json['VerificationStatus'] as String?,
      verificationPic:
          getString(json['verification_pic'] ?? json['VerificationPic']),
      role: json['role'] as String? ?? json['Role'] as String?,
      audioPrompt: getAudioPrompt(json, currentUserId), // Pass ID to helper
      prompts: getPrompts(json),
    );

    // Remove debug print unless needed
    // print("--- Parsed UserModel (Audio Prompt Check) ---");
    // print("ID: ${parsedUser.id}");
    // print("Name: ${parsedUser.name}");
    // print("Audio Prompt Parsed: ${parsedUser.audioPrompt != null}");
    // if (parsedUser.audioPrompt != null) {
    //   print("  -> Question: ${parsedUser.audioPrompt!.prompt.label}");
    //   print("  -> URL: ${parsedUser.audioPrompt!.audioUrl}");
    // }
    // print("------------------------------------------");

    return parsedUser;
  }

  // copyWith needs update for mediaChangedDuringEdit
  UserModel copyWith({
    int? Function()? id,
    String? Function()? name,
    String? Function()? lastName,
    String? Function()? phoneNumber,
    String? Function()? email,
    DateTime? Function()? dateOfBirth,
    double? Function()? latitude,
    double? Function()? longitude,
    Gender? Function()? gender,
    DatingIntention? Function()? datingIntention,
    String? Function()? height,
    String? Function()? hometown,
    String? Function()? jobTitle,
    String? Function()? education,
    Religion? Function()? religiousBeliefs,
    DrinkingSmokingHabits? Function()? drinkingHabit,
    DrinkingSmokingHabits? Function()? smokingHabit,
    List<String>? Function()? mediaUrls,
    List<Prompt>? prompts,
    AudioPromptModel? Function()? audioPrompt,
    String? Function()? verificationStatus,
    String? Function()? verificationPic,
    String? Function()? role,
    bool? mediaChangedDuringEdit, // <<< ADDED parameter
  }) {
    return UserModel(
      id: id != null ? id() : this.id,
      name: name != null ? name() : this.name,
      lastName: lastName != null ? lastName() : this.lastName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      email: email != null ? email() : this.email,
      dateOfBirth: dateOfBirth != null ? dateOfBirth() : this.dateOfBirth,
      latitude: latitude != null ? latitude() : this.latitude,
      longitude: longitude != null ? longitude() : this.longitude,
      gender: gender != null ? gender() : this.gender,
      datingIntention:
          datingIntention != null ? datingIntention() : this.datingIntention,
      height: height != null ? height() : this.height,
      hometown: hometown != null ? hometown() : this.hometown,
      jobTitle: jobTitle != null ? jobTitle() : this.jobTitle,
      education: education != null ? education() : this.education,
      religiousBeliefs:
          religiousBeliefs != null ? religiousBeliefs() : this.religiousBeliefs,
      drinkingHabit:
          drinkingHabit != null ? drinkingHabit() : this.drinkingHabit,
      smokingHabit: smokingHabit != null ? smokingHabit() : this.smokingHabit,
      mediaUrls: mediaUrls != null ? mediaUrls() : this.mediaUrls,
      prompts: prompts ?? List.from(this.prompts),
      audioPrompt: audioPrompt != null ? audioPrompt() : this.audioPrompt,
      verificationStatus: verificationStatus != null
          ? verificationStatus()
          : this.verificationStatus,
      verificationPic:
          verificationPic != null ? verificationPic() : this.verificationPic,
      role: role != null ? role() : this.role,
      // Pass the value or use existing
      mediaChangedDuringEdit:
          mediaChangedDuringEdit ?? this.mediaChangedDuringEdit,
    );
  }

  // isProfileValid for onboarding step 2 POST
  bool isProfileValid() {
    final dobValid = dateOfBirth != null &&
        DateTime.now().difference(dateOfBirth!).inDays >= (18 * 365.25);
    // Location/Gender validation is handled in onboarding step 1
    return name != null &&
        name!.trim().isNotEmpty &&
        name!.trim().length >= 3 &&
        dobValid &&
        datingIntention != null; // Added dating intention check for step 2
    // Removed location/gender check here as it's handled earlier
  }

  // isLocationValid remains the same (used in onboarding step 1)
  bool isLocationValid() {
    return latitude != null &&
        longitude != null &&
        latitude != 0.0 &&
        longitude != 0.0;
  }
}



================================================
File: providers/audio_player_provider.dart
================================================

// providers/audio_player_provider.dart
import 'package:audioplayers/audioplayers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

enum AudioPlayerState {
  idle,
  loading,
  playing,
  paused,
  completed,
  error,
}

final audioPlayerStateProvider = StateProvider<AudioPlayerState>((ref) => AudioPlayerState.idle);
final currentAudioUrlProvider = StateProvider<String?>((ref) => null);

final audioPlayerProvider = Provider<AudioPlayer>((ref) {
  final player = AudioPlayer();
  
  player.onPlayerComplete.listen((_) {
    ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.completed;
  });
  
  player.onPlayerStateChanged.listen((state) {
    if (state == PlayerState.playing) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.playing;
    } else if (state == PlayerState.paused) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.paused;
    } else if (state == PlayerState.stopped) {
      ref.read(audioPlayerStateProvider.notifier).state = AudioPlayerState.idle;
    }
  });
  
  // Handle cleanup when the provider is disposed
  ref.onDispose(() {
    player.dispose();
  });
  
  return player;
});

class AudioPlayerNotifier extends StateNotifier<AudioPlayerState> {
  final Ref ref;
  final AudioPlayer _player;
  
  AudioPlayerNotifier(this.ref)
      : _player = ref.read(audioPlayerProvider),
        super(AudioPlayerState.idle);
  
  Future<void> play(String url) async {
    try {
      // If another audio is playing, stop it
      if (state == AudioPlayerState.playing) {
        await _player.stop();
      }
      
      state = AudioPlayerState.loading;
      ref.read(currentAudioUrlProvider.notifier).state = url;
      
      await _player.play(UrlSource(url));
      // State will be updated via listener in audioPlayerProvider
    } catch (e) {
      print("Error playing audio: $e");
      state = AudioPlayerState.error;
    }
  }
  
  Future<void> pause() async {
    if (state == AudioPlayerState.playing) {
      await _player.pause();
      // State will be updated via listener
    }
  }
  
  Future<void> resume() async {
    if (state == AudioPlayerState.paused) {
      await _player.resume();
      // State will be updated via listener
    }
  }
  
  Future<void> stop() async {
    await _player.stop();
    ref.read(currentAudioUrlProvider.notifier).state = null;
    // State will be updated via listener
  }
}

final audioPlayerControllerProvider = StateNotifierProvider<AudioPlayerNotifier, AudioPlayerState>((ref) {
  return AudioPlayerNotifier(ref);
});



================================================
File: providers/audio_upload_provider.dart
================================================
// providers/audio_upload_provider.dart
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../models/user_model.dart';
import '../repositories/media_repository.dart';
import '../utils/app_enums.dart';
import 'error_provider.dart';
import 'service_provider.dart';
import 'user_provider.dart';

final audioUploadProvider = StateNotifierProvider<AudioUploadNotifier, MediaUploadModel?>(
  (ref) {
    print('[AudioUpload] Initializing AudioUploadProvider');
    final mediaRepository = ref.watch(mediaRepositoryProvider);
    return AudioUploadNotifier(ref, mediaRepository);
  },
);

class AudioUploadNotifier extends StateNotifier<MediaUploadModel?> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  AudioPrompt? _selectedPrompt;
  String? _recordingPath;

  // Initialize with null (no audio uploaded yet)
  AudioUploadNotifier(this.ref, this._mediaRepository) : super(null) {
    print('[AudioUpload] AudioUploadNotifier created');
  }

  // Max audio size (10 MB)
  static const int _maxAudioSizeBytes = 10 * 1024 * 1024;

  // Supported audio MIME types
static final Set<String> _supportedAudioTypes = {
  'audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/webm',
  'audio/aac', 'audio/x-m4a', 'audio/x-aiff', 'audio/flac',
  'audio/mp4'  // Add this line to support M4A files
};

  // Save the recording path for later use
  void setRecordingPath(String path) {
    print('[AudioUpload] Setting recording path: $path');
    _recordingPath = path;
  }

  // Prepare audio file with validation
  bool prepareAudioFile() {
    print('[AudioUpload] Preparing audio file');
    print('[AudioUpload] Recording path: $_recordingPath');
    print('[AudioUpload] Selected prompt: ${_selectedPrompt?.value}');
    
    if (_recordingPath == null || _selectedPrompt == null) {
      print('[AudioUpload] ERROR: Missing recording path or prompt');
      return false;
    }
    
    final file = File(_recordingPath!);
    if (!file.existsSync()) {
      print('[AudioUpload] ERROR: File does not exist at path: $_recordingPath');
      return false;
    }
    
    try {
      // Validate file size
      final fileSize = file.lengthSync();
      print('[AudioUpload] File size: ${fileSize / 1024} KB');
      
      if (fileSize > _maxAudioSizeBytes) {
        print('[AudioUpload] ERROR: File too large: ${fileSize / 1024 / 1024} MB (max: ${_maxAudioSizeBytes / 1024 / 1024} MB)');
        ref.read(errorProvider.notifier).setError(
              AppError.validation("Audio is too large. Maximum size is 10 MB."),
            );
        return false;
      }

      // Detect MIME type
      final fileName = path.basename(file.path);
      final mimeType = lookupMimeType(file.path) ?? 'audio/mpeg';
      print('[AudioUpload] Filename: $fileName');
      print('[AudioUpload] MIME type: $mimeType');

      // Validate audio type
      if (!_supportedAudioTypes.contains(mimeType)) {
        print('[AudioUpload] ERROR: Unsupported audio format: $mimeType');
        ref.read(errorProvider.notifier).setError(
              AppError.validation("Unsupported audio format. Please use MP3, WAV, OGG, or other common audio formats."),
            );
        return false;
      }

      // Update state
      print('[AudioUpload] Creating MediaUploadModel');
      state = MediaUploadModel(
        file: file,
        fileName: fileName,
        fileType: mimeType,
        status: UploadStatus.idle,
      );
      
      print('[AudioUpload] Audio file prepared successfully');
      return true;
    } catch (e, stack) {
      print('[AudioUpload] ERROR preparing audio file: $e');
      print('[AudioUpload] Stack trace: $stack');
      return false;
    }
  }

  // Clear audio file
  void clearAudio() {
    print('[AudioUpload] Clearing audio state');
    state = null;
    _recordingPath = null;
    _selectedPrompt = null;
  }

  // Upload audio and save to user profile
  Future<bool> uploadAudioAndSaveToProfile() async {
    print('[AudioUpload] Starting uploadAudioAndSaveToProfile');
    
    if (state == null || _selectedPrompt == null) {
      print('[AudioUpload] State or prompt is null, attempting to prepare file');
      final prepared = prepareAudioFile();
      if (!prepared) {
        print('[AudioUpload] Failed to prepare audio file');
        return false;
      }
    }

    try {
      print('[AudioUpload] Clearing any previous errors');
      ref.read(errorProvider.notifier).clearError();

      // Update state to show upload in progress
      print('[AudioUpload] Setting state to UPLOADING');
      state = state!.copyWith(status: UploadStatus.inProgress);

      // Get presigned URL for audio
      print('[AudioUpload] Getting presigned URL for ${state!.fileName}');
      final presignedUrlResponse = await _mediaRepository.getAudioPresignedUrl(
        state!.fileName,
        state!.fileType,
        _selectedPrompt!,
      );
      
      print('[AudioUpload] Received presigned URL response: ${presignedUrlResponse.toString().substring(0, 100)}...');

      // Update state with presigned URL
      print('[AudioUpload] Updating state with presigned URL');
      state = state!.copyWith(
        presignedUrl: () => presignedUrlResponse['url'],
      );

      // Upload audio to S3
      print('[AudioUpload] Uploading file to S3');
      bool success = await _mediaRepository.uploadFileToS3(state!);
      print('[AudioUpload] Initial upload result: $success');

      // If failed, retry
      if (!success) {
        print('[AudioUpload] Initial upload failed, retrying...');
        success = await _mediaRepository.retryUpload(state!);
        print('[AudioUpload] Retry upload result: $success');
      }

      // Update state with result
      print('[AudioUpload] Setting final upload status: ${success ? "SUCCESS" : "FAILED"}');
      state = state!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload audio',
      );

      if (success) {
        // Create AudioPromptModel
        print('[AudioUpload] Creating AudioPromptModel with prompt: ${_selectedPrompt!.value}');
        final audioPromptModel = AudioPromptModel(
          prompt: _selectedPrompt!,
          audioUrl: presignedUrlResponse['url'],
        );

        // Add to user model
        print('[AudioUpload] Updating user model with audio prompt');
        ref.read(userProvider.notifier).updateAudioPrompt(audioPromptModel);
        print('[AudioUpload] User model updated successfully');
      }

      return success;
    } catch (e, stack) {
      print('[AudioUpload] ERROR during upload: $e');
      print('[AudioUpload] Stack trace: $stack');
      
      if (state != null) {
        state = state!.copyWith(
          status: UploadStatus.failed,
          errorMessage: () => 'Failed to upload audio: ${e.toString()}',
        );
      }
      return false;
    }
  }

  // Get the selected prompt
  AudioPrompt? get selectedPrompt => _selectedPrompt;

  // Set the selected prompt
  void setSelectedPrompt(AudioPrompt prompt) {
    print('[AudioUpload] Setting selected prompt: ${prompt.value}');
    _selectedPrompt = prompt;
  }
}



================================================
File: providers/auth_provider.dart
================================================
// File: providers/auth_provider.dart
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import providers to invalidate
import 'package:dtx/providers/filter_provider.dart';
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../models/error_model.dart';
import '../repositories/auth_repository.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import 'error_provider.dart';
import 'service_provider.dart';

// Provider for GoogleSignIn instance (remains the same)
final googleSignInProvider = Provider<GoogleSignIn>((ref) {
  return GoogleSignIn(
    scopes: ['email', 'profile'],
  );
});

// AuthProvider definition (remains the same)
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final authRepository = ref.watch(authRepositoryProvider);
  // *** Pass ref to the notifier ***
  return AuthNotifier(ref, authRepository);
});

class AuthNotifier extends StateNotifier<AuthState> {
  // *** Store the Ref object ***
  final Ref ref;
  final AuthRepository _authRepository;

  // *** Modify constructor to accept Ref ***
  AuthNotifier(this.ref, this._authRepository) : super(const AuthState()) {
    _loadTokenAndCheckStatus();
  }

  // _loadTokenAndCheckStatus, checkAuthStatus, signInWithGoogle remain the same

  Future<void> _loadTokenAndCheckStatus() async {
    print('[AuthNotifier] Loading token and checking initial status...');
    state = state.copyWith(isLoading: true);
    final token = await TokenStorage.getToken();
    if (token != null && token.isNotEmpty) {
      print(
          '[AuthNotifier] Token found, setting in state and checking status.');
      state = state.copyWith(jwtToken: () => token);
      await checkAuthStatus(updateState: true); // Check status if token exists
    } else {
      print('[AuthNotifier] No token found, setting state to login.');
      // If no token, status is definitely login
      state = state.copyWith(
          isLoading: false, authStatus: AuthStatus.login, jwtToken: () => null);
    }
  }

  Future<AuthStatus> checkAuthStatus({bool updateState = true}) async {
    print('[AuthNotifier checkAuthStatus] Called. updateState: $updateState');
    if (updateState) {
      state = state.copyWith(isLoading: true, error: () => null);
    }

    // Use token from state if available, otherwise try storage
    final token = state.jwtToken ?? await TokenStorage.getToken();

    // If still no token, return login status immediately
    if (token == null || token.isEmpty) {
      print(
          '[AuthNotifier checkAuthStatus] No token available, returning login status.');
      if (updateState) {
        state = state.copyWith(
            isLoading: false,
            authStatus: AuthStatus.login,
            jwtToken: () => null);
      }
      return AuthStatus.login;
    }

    try {
      final backendStatus = await _authRepository.checkAuthStatus(token);
      print(
          '[AuthNotifier checkAuthStatus] Backend status received: $backendStatus');

      if (updateState) {
        state = state.copyWith(
          isLoading: false,
          authStatus: backendStatus,
          // Keep the token in state if status is not login
          // No need to clear token here unless backendStatus is login
          jwtToken: backendStatus == AuthStatus.login ? () => null : null,
        );
        if (backendStatus == AuthStatus.login) {
          print(
              '[AuthNotifier checkAuthStatus] Status is login, removing token from storage.');
          await TokenStorage.removeToken(); // Also remove from storage
        }
      }
      print(
          '[AuthNotifier checkAuthStatus] Finished. Returning: $backendStatus');
      return backendStatus;
    } catch (e) {
      print('[AuthNotifier checkAuthStatus] Error: $e');
      if (updateState) {
        state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login, // Default to login on error
          error: () => 'Failed to check status: ${e.toString()}',
          jwtToken: () => null, // Clear token on error
        );
        print(
            '[AuthNotifier checkAuthStatus] Error occurred, removing token from storage.');
        await TokenStorage.removeToken(); // Also remove from storage
      }
      return AuthStatus.login; // Return login on error
    }
  }

  Future<AuthStatus> signInWithGoogle() async {
    print('[AuthNotifier signInWithGoogle] Attempting Google Sign-In...');
    state = state.copyWith(isLoading: true, error: () => null);
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors

    try {
      final googleSignIn = ref.read(googleSignInProvider);
      final googleUser = await googleSignIn.signIn(); // Prompts user

      if (googleUser == null) {
        print('[AuthNotifier signInWithGoogle] User cancelled Google Sign-In.');
        state = state.copyWith(isLoading: false, authStatus: AuthStatus.login);
        return AuthStatus.login; // User cancelled
      }

      print(
          '[AuthNotifier signInWithGoogle] Google Sign-In successful for: ${googleUser.email}');
      final googleAuth = await googleUser.authentication;
      final googleAccessToken = googleAuth.accessToken;

      if (googleAccessToken == null) {
        print(
            '[AuthNotifier signInWithGoogle] Failed to get Google Access Token.');
        throw ApiException('Could not retrieve access token from Google.');
      }

      print(
          '[AuthNotifier signInWithGoogle] Verifying Google Access Token with backend...');
      final appJwt = await _authRepository.verifyGoogleToken(googleAccessToken);
      print(
          '[AuthNotifier signInWithGoogle] Backend verification successful. App JWT received.');

      await TokenStorage.saveToken(appJwt);
      print('[AuthNotifier signInWithGoogle] App JWT saved to storage.');

      // IMPORTANT: After successful login and getting the JWT,
      // immediately check the status with the backend to know the next step.
      state = state.copyWith(jwtToken: () => appJwt); // Set token in state
      print(
          '[AuthNotifier signInWithGoogle] JWT set in state. Checking auth status...');
      final finalStatus = await checkAuthStatus(
          updateState: true); // Update state with final status

      print(
          '[AuthNotifier signInWithGoogle] Sign-in process complete. Final Status: $finalStatus');
      return finalStatus; // Return the status determined by checkAuthStatus
    } on ApiException catch (e) {
      print('[AuthNotifier signInWithGoogle] API Exception: ${e.message}');
      state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login,
          error: () => e.message);
      ref.read(errorProvider.notifier).setError(AppError.auth(e.message));
      await logout(); // Clear any potentially saved invalid token
      return AuthStatus.login;
    } catch (e) {
      print(
          '[AuthNotifier signInWithGoogle] Unexpected Error: ${e.toString()}');
      state = state.copyWith(
          isLoading: false,
          authStatus: AuthStatus.login,
          error: () => 'An unexpected error occurred during sign-in.');
      ref.read(errorProvider.notifier).setError(
          AppError.auth("An unexpected error occurred. Please try again."));
      await logout(); // Clear any potentially saved invalid token
      return AuthStatus.login;
    }
  }

  // Logout user
  Future<void> logout() async {
    print('[AuthNotifier] Logging out...');
    final currentToken = state.jwtToken ?? await TokenStorage.getToken();

    try {
      final googleSignIn = ref.read(googleSignInProvider);
      await googleSignIn.signOut(); // Sign out from Google
      await googleSignIn.disconnect().catchError((e) {
        // Catch errors during disconnect specifically, as it can sometimes fail
        print('[AuthNotifier] Non-critical error during Google disconnect: $e');
      });
    } catch (e) {
      print('[AuthNotifier] Error during Google Sign Out: $e');
      // Decide if you want to proceed with app logout even if Google logout fails
    } finally {
      await TokenStorage.removeToken(); // Remove app token *always*
      print('[AuthNotifier] Token removed from storage.');

      // Reset auth state *first*
      state = const AuthState(authStatus: AuthStatus.login);
      print('[AuthNotifier] Auth state reset to login.');

      // *** Invalidate other user-specific providers ***
      print('[AuthNotifier] Invalidating user-specific providers...');
      ref.invalidate(userProvider);
      ref.invalidate(feedProvider);
      ref.invalidate(receivedLikesProvider);
      ref.invalidate(filterProvider);
      // Add any other providers that store user-specific data here
      // e.g., ref.invalidate(chatProvider);
      // e.g., ref.invalidate(likerProfileProvider); // .family needs specific handling if needed globally
      print('[AuthNotifier] Providers invalidated.');

      // Optionally, you could call a backend logout endpoint if you have one
      // if (currentToken != null) {
      //   try {
      //     await _authRepository.logoutBackend(currentToken);
      //     print('[AuthNotifier] Backend logout successful.');
      //   } catch (e) {
      //     print('[AuthNotifier] Backend logout failed (non-critical): $e');
      //   }
      // }

      print('[AuthNotifier] Local logout complete.');
    }
  }
}



================================================
File: providers/error_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/error_model.dart';

final errorProvider = StateNotifierProvider<ErrorNotifier, AppError?>((ref) {
  return ErrorNotifier();
});

class ErrorNotifier extends StateNotifier<AppError?> {
  ErrorNotifier() : super(null);

  void setError(AppError error) => state = error;
  void clearError() => state = null;
}



================================================
File: providers/feed_provider.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/user_model.dart'; // Use full UserModel
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/user_repository.dart';
import 'package:dtx/services/api_service.dart';
// Removed FeedType import
import 'package:flutter_riverpod/flutter_riverpod.dart';

// --- Removed QuickFeedState ---

// --- Home Feed State ---
class HomeFeedState {
  final bool isLoading;
  final List<UserModel> profiles; // Use full UserModel for Home Feed
  final AppError? error;
  final bool hasFetchedOnce; // Track if initial fetch happened
  final bool hasMore; // Track if API indicates more profiles available

  const HomeFeedState({
    this.isLoading = false, // Start not loading until fetch is called
    this.profiles = const [],
    this.error,
    this.hasFetchedOnce = false,
    this.hasMore = true, // Assume more initially
  });

  HomeFeedState copyWith({
    bool? isLoading,
    List<UserModel>? profiles,
    AppError? Function()? error,
    bool? hasFetchedOnce,
    bool? hasMore,
  }) {
    return HomeFeedState(
      isLoading: isLoading ?? this.isLoading,
      profiles: profiles ?? this.profiles,
      error: error != null ? error() : this.error,
      hasFetchedOnce: hasFetchedOnce ?? this.hasFetchedOnce,
      hasMore: hasMore ?? this.hasMore,
    );
  }
}

// --- Simplified Feed Notifier (Only Home Feed) ---
class FeedNotifier extends StateNotifier<HomeFeedState> {
  final UserRepository _userRepository;
  final Ref _ref;

  FeedNotifier(this._userRepository, this._ref) : super(const HomeFeedState());

  Future<void> fetchFeed({bool forceRefresh = false}) async {
    print("[FeedNotifier] fetchFeed called. forceRefresh: $forceRefresh");

    if (state.isLoading) {
      print("[FeedNotifier] Skipping fetch (already loading).");
      return;
    }
    // If already fetched and not forcing refresh, and we have profiles or know there are no more, skip
    if (state.hasFetchedOnce &&
        !forceRefresh &&
        (state.profiles.isNotEmpty || !state.hasMore)) {
      print(
          "[FeedNotifier] Skipping fetch (already fetched & no force required). Has Profiles: ${state.profiles.isNotEmpty}, Has More: ${state.hasMore}");
      return;
    }

    state = state.copyWith(isLoading: true, error: () => null);

    try {
      // Directly fetch home feed profiles
      final result = await _userRepository
          .fetchHomeFeed(); // Assuming repo returns Map now
      final profiles = result['profiles'] as List<UserModel>;
      final hasMore =
          result['has_more'] as bool? ?? false; // Default to false if missing

      print(
          "[FeedNotifier] Fetched ${profiles.length} home profiles. Has More: $hasMore");
      if (!mounted) return;

      state = HomeFeedState(
        isLoading: false,
        profiles: profiles,
        error: null,
        hasFetchedOnce: true, // Mark as fetched
        hasMore: hasMore, // Update hasMore status
      );
    } on ApiException catch (e) {
      print("[FeedNotifier] API Exception: ${e.message}");
      if (!mounted) return;
      state = state.copyWith(
        isLoading: false,
        error: () => AppError.server(e.message),
        hasFetchedOnce:
            true, // Mark as fetched even on error to prevent reload loops
        hasMore: false, // Assume no more on error
      );
    } catch (e) {
      print("[FeedNotifier] Unexpected Error: ${e.toString()}");
      if (!mounted) return;
      state = state.copyWith(
        isLoading: false,
        error: () => AppError.generic("Failed to load feed."),
        hasFetchedOnce: true,
        hasMore: false,
      );
    }
  }

  // Method to remove a profile after interaction
  void removeProfile(int userId) {
    print("[FeedNotifier] Removing profile ID: $userId");
    if (!mounted) return;
    final updatedProfiles =
        state.profiles.where((profile) => profile.id != userId).toList();

    state = state.copyWith(profiles: updatedProfiles);

    // Optional: Fetch more if the list gets too small and we know there are more
    if (updatedProfiles.length < 3 && state.hasMore && !state.isLoading) {
      print(
          "[FeedNotifier] Profile list low (<3) and hasMore=true, fetching more...");
      fetchFeed(); // Fetch more without forcing refresh
    } else if (updatedProfiles.isEmpty && !state.hasMore) {
      print("[FeedNotifier] Profile list empty and hasMore=false.");
      // State already reflects empty list
    }
  }
}

// --- Provider Definition ---
final feedProvider = StateNotifierProvider<FeedNotifier, HomeFeedState>((ref) {
  final userRepository = ref.watch(userRepositoryProvider);
  return FeedNotifier(userRepository, ref);
});



================================================
File: providers/filter_provider.dart
================================================
// lib/providers/filter_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/filter_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// --- REMOVED: filterLoadingProvider - manage loading within the notifier ---

// --- StateNotifier Provider ---
final filterProvider =
    StateNotifierProvider<FilterNotifier, FilterSettings>((ref) {
  final filterRepository = ref.watch(filterRepositoryProvider);
  return FilterNotifier(ref, filterRepository);
});

// --- StateNotifier ---
class FilterNotifier extends StateNotifier<FilterSettings> {
  final Ref ref;
  final FilterRepository _filterRepository;
  bool _isLoading = false; // Internal loading state
  bool get isLoading => _isLoading; // Getter for UI

  FilterNotifier(this.ref, this._filterRepository)
      : super(const FilterSettings()) {
    // Optionally load filters on initialization if needed, or rely on UI trigger
    // loadFilters();
  }

  // Load filters from the repository
  Future<void> loadFilters({bool forceRemote = false}) async {
    // Prevent multiple fetches if already loading or if data exists and not forced
    if (_isLoading || (state != const FilterSettings() && !forceRemote)) {
      return;
    }
    _setLoading(true);
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors

    try {
      final filters = await _filterRepository.fetchFilters();
      if (mounted) {
        state = filters; // Update state
      }
    } catch (e) {
      if (mounted) {
        ref
            .read(errorProvider.notifier)
            .setError(AppError.generic("Could not load filter settings."));
        // Don't reset to default, keep previous state or handle error UI
      }
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  // Save filters to the repository
  Future<bool> saveFilters(FilterSettings newFilters) async {
    if (_isLoading) return false;
    _setLoading(true);
    ref.read(errorProvider.notifier).clearError();
    final previousState = state; // Keep old state in case of failure
    state = newFilters; // Optimistically update UI

    try {
      final success = await _filterRepository.updateFilters(newFilters);
      if (!success) {
        // If API returns false, revert state and show error
        if (mounted) {
          state = previousState;
          ref
              .read(errorProvider.notifier)
              .setError(AppError.server("Failed to save filters."));
        }
        return false;
      }
      return true; // Success
    } on ApiException catch (e) {
      if (mounted) {
        state = previousState; // Revert state on error
        ref.read(errorProvider.notifier).setError(AppError.server(e.message));
      }
      return false;
    } catch (e) {
      if (mounted) {
        state = previousState; // Revert state on error
        ref
            .read(errorProvider.notifier)
            .setError(AppError.generic("An unexpected error occurred."));
      }
      return false;
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  // Helper to manage internal loading state
  void _setLoading(bool loading) {
    // Could add notifyListeners() if using ChangeNotifier, but not needed for StateNotifier
    if (_isLoading != loading) {
      _isLoading = loading;
      // No need to call setState or notifyListeners for StateNotifier's internal state
    }
  }

  // Method to update a single filter value directly (e.g., from slider/switch)
  // Ensures immutability by using copyWith
  void updateSingleFilter<T>(T value, FilterField field) {
    if (_isLoading) return; // Prevent updates while saving/loading
    state = state.copyWith(
      whoYouWantToSee: field == FilterField.whoYouWantToSee
          ? () => value as FilterGenderPref? // Cast to correct type
          : null, // Return null for other fields
      radiusKm: field == FilterField.radiusKm ? () => value as int? : null,
      activeToday:
          field == FilterField.activeToday ? () => value as bool? : null,
      ageMin: field == FilterField.ageMin ? () => value as int? : null,
      ageMax: field == FilterField.ageMax ? () => value as int? : null,
    );
  }
}

// Enum to identify which filter field is being updated
enum FilterField { whoYouWantToSee, radiusKm, activeToday, ageMin, ageMax }



================================================
File: providers/liker_profile_provider.dart
================================================
// File: providers/liker_profile_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State Definition
class LikerProfileState {
  final bool isLoading;
  final UserProfileData? profile;
  final LikeInteractionDetails? likeDetails;
  final AppError? error;

  const LikerProfileState({
    this.isLoading = true, // Start loading
    this.profile,
    this.likeDetails,
    this.error,
  });

  LikerProfileState copyWith({
    bool? isLoading,
    UserProfileData? Function()? profile, // Nullable functions
    LikeInteractionDetails? Function()? likeDetails,
    AppError? Function()? error,
  }) {
    return LikerProfileState(
      isLoading: isLoading ?? this.isLoading,
      profile: profile != null ? profile() : this.profile,
      likeDetails: likeDetails != null ? likeDetails() : this.likeDetails,
      error: error != null ? error() : this.error,
    );
  }
}

// StateNotifier Definition
class LikerProfileNotifier extends StateNotifier<LikerProfileState> {
  final LikeRepository _likeRepository;
  final int _likerUserId;

  LikerProfileNotifier(this._likeRepository, this._likerUserId)
      : super(const LikerProfileState()) {
    fetchProfile(); // Fetch profile on initialization
  }

  Future<void> fetchProfile() async {
    print(
        "[LikerProfileNotifier] Fetching profile for liker ID: $_likerUserId");
    // Don't clear profile/details on refetch, only on error maybe?
    state = state.copyWith(isLoading: true, error: () => null);
    try {
      final result = await _likeRepository.fetchLikerProfile(_likerUserId);
      final profileData = result['profile'] as UserProfileData?;
      final likeDetailsData = result['likeDetails'] as LikeInteractionDetails?;

      if (profileData != null && likeDetailsData != null) {
        print("[LikerProfileNotifier] Fetch successful.");
        state = state.copyWith(
          isLoading: false,
          profile: () => profileData,
          likeDetails: () => likeDetailsData,
          error: () => null,
        );
      } else {
        // This case should ideally be caught by the repository throwing an exception
        print(
            "[LikerProfileNotifier] Fetch failed: Repository returned null data.");
        state = state.copyWith(
            isLoading: false,
            error: () => AppError.server("Failed to load profile data."));
      }
    } on ApiException catch (e) {
      print("[LikerProfileNotifier] API Exception: ${e.message}");
      // Handle 404 Not Found specifically maybe
      if (e.statusCode == 404) {
        state = state.copyWith(
            isLoading: false,
            error: () => AppError.server(
                "Profile not found or you were not liked by this user."));
      } else {
        state = state.copyWith(
            isLoading: false, error: () => AppError.server(e.message));
      }
    } catch (e) {
      print("[LikerProfileNotifier] Unexpected Error: ${e.toString()}");
      state = state.copyWith(
          isLoading: false,
          error: () => AppError.generic("Failed to load profile."));
    }
  }
}

// Provider Definition (.family)
final likerProfileProvider =
    StateNotifierProvider.family<LikerProfileNotifier, LikerProfileState, int>(
        (ref, likerUserId) {
  final likeRepository = ref.watch(likeRepositoryProvider);
  return LikerProfileNotifier(likeRepository, likerUserId);
});



================================================
File: providers/location_provider.dart
================================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:geolocator/geolocator.dart';
import '../models/error_model.dart';
import '../models/location_model.dart';
import 'error_provider.dart';
import 'user_provider.dart';

final locationProvider =
    StateNotifierProvider<LocationNotifier, LocationState>((ref) {
  return LocationNotifier(ref);
});

class LocationNotifier extends StateNotifier<LocationState> {
  final Ref ref;

  LocationNotifier(this.ref) : super(LocationState());

  void setMapReady(bool ready) {
    state = state.copyWith(isMapReady: ready);
  }

  Future<void> openLocationSettings() async {
    try {
      await Geolocator.openLocationSettings();
    } catch (e) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.network("Failed to open location settings"));
    }
  }

  Future<void> fetchCurrentLocation() async {
    // Clear any existing errors
    ref.read(errorProvider.notifier).clearError();

    // Reset state for fresh fetch
    state = state.copyWith(
      isFetching: true,
      isLoading: true,
      cachedLatitude: null,
      cachedLongitude: null,
    );

    try {
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        ref.read(errorProvider.notifier).setError(
            AppError.locationService("Location services are disabled"));
        state = state.copyWith(isLoading: false);
        return;
      }

      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          ref
              .read(errorProvider.notifier)
              .setError(AppError.validation("Location permissions are denied"));
          state = state.copyWith(isLoading: false);
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Location permissions are permanently denied"));
        state = state.copyWith(isLoading: false);
        return;
      }

      Position position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.high);

      final newLatitude = position.latitude;
      final newLongitude = position.longitude;

      // Update user provider with the location
      ref.read(userProvider.notifier).updateLocation(newLatitude, newLongitude);

      state = state.copyWith(
        latitude: newLatitude,
        longitude: newLongitude,
        cachedLatitude: newLatitude,
        cachedLongitude: newLongitude,
        isLoading: false,
      );
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
          AppError.network("Failed to fetch location: ${e.toString()}"));
      state = state.copyWith(isLoading: false);
    } finally {
      state = state.copyWith(isFetching: false);
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(latitude: latitude, longitude: longitude);
    ref.read(userProvider.notifier).updateLocation(latitude, longitude);
  }

  void useCachedLocation() {
    if (state.cachedLatitude != null && state.cachedLongitude != null) {
      updateLocation(state.cachedLatitude!, state.cachedLongitude!);
    }
  }
}



================================================
File: providers/media_upload_provider.dart
================================================
import 'dart:io';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:mime/mime.dart';
import '../models/error_model.dart';
import '../models/media_upload_model.dart';
import '../repositories/media_repository.dart';
import 'error_provider.dart';
import 'service_provider.dart';

final mediaUploadProvider = StateNotifierProvider<MediaUploadNotifier, List<MediaUploadModel?>>((ref) {
  final mediaRepository = ref.watch(mediaRepositoryProvider);
  return MediaUploadNotifier(ref, mediaRepository);
});

class MediaUploadNotifier extends StateNotifier<List<MediaUploadModel?>> {
  final Ref ref;
  final MediaRepository _mediaRepository;
  
  // Initialize with 6 null slots for media
  MediaUploadNotifier(this.ref, this._mediaRepository) : super(List.filled(6, null));
  
  // File size limits in bytes
  static const int _maxImageSizeBytes = 10 * 1024 * 1024; // 10 MB
  static const int _maxVideoSizeBytes = 50 * 1024 * 1024; // 50 MB

  MediaUploadModel? _verificationImage;

  MediaUploadModel? get verificationImage => _verificationImage;

  void setVerificationImage(File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'image/jpeg';

    final isImage = mimeType.startsWith('image/');

    if (!isImage) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Only image files are allowed."),
      );
      return;
    }

    if (fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }

    // Update state
    _verificationImage = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
  }

  void clearVerificationImage() {
    _verificationImage = null;
  }

  Future<bool> uploadVerificationImage() async {
    if (_verificationImage == null) return false;

    try {
      // Clear any existing errors
      ref.read(errorProvider.notifier).clearError();

      // Get presigned URL
      final presignedUrl = await _mediaRepository.getVerificationPresignedUrl(
        _verificationImage!.fileName,
        _verificationImage!.fileType,
      );

      // Update verification image with presigned URL
      _verificationImage = _verificationImage!.copyWith(
        presignedUrl: () => presignedUrl,
        status: UploadStatus.inProgress,
      );

      // Upload the file
      final success = await _mediaRepository.uploadFileToS3(_verificationImage!);

      // Update status
      _verificationImage = _verificationImage!.copyWith(
        status: success ? UploadStatus.success : UploadStatus.failed,
        errorMessage: success ? () => null : () => 'Failed to upload verification image',
      );

      return success;
    } on ApiException catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => e.message,
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.message),
      );
      return false;
    } catch (e) {
      _verificationImage = _verificationImage!.copyWith(
        status: UploadStatus.failed,
        errorMessage: () => 'An unexpected error occurred. Please try again.',
      );
      ref.read(errorProvider.notifier).setError(
        AppError.auth("An unexpected error occurred. Please try again."),
      );
      return false;
    }
  }
  
  // Add or update media at a specific index
  void setMediaFile(int index, File file) {
    // Validate file size
    final fileSize = file.lengthSync();
    final fileName = path.basename(file.path);
    final mimeType = lookupMimeType(file.path) ?? 'application/octet-stream';
    
    final isImage = mimeType.startsWith('image/');
    final isVideo = mimeType.startsWith('video/');
    
    // Size validation
    if (isImage && fileSize > _maxImageSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Image is too large. Maximum size is 10 MB."),
      );
      return;
    }
    
    if (isVideo && fileSize > _maxVideoSizeBytes) {
      ref.read(errorProvider.notifier).setError(
        AppError.validation("Video is too large. Maximum size is 50 MB."),
      );
      return;
    }
    
    // Update state
    final updatedState = [...state];
    updatedState[index] = MediaUploadModel(
      file: file,
      fileName: fileName,
      fileType: mimeType,
    );
    state = updatedState;
  }
  
  // Remove media at a specific index
  void removeMedia(int index) {
    final updatedState = [...state];
    updatedState[index] = null;
    state = updatedState;
  }
  
  // Get all non-null media items
  List<MediaUploadModel> getMediaItems() {
    return state.whereType<MediaUploadModel>().toList();
  }
  
  // Check if we have minimum required media (3)
  bool hasMinimumMedia() {
    return getMediaItems().length >= 3;
  }
  
  // Upload all media
  Future<bool> uploadAllMedia() async {
    final mediaItems = getMediaItems();
    if (mediaItems.isEmpty) return false;
    
    try {
      // Prepare file details for presigned URL request
      final fileDetails = mediaItems.map((item) => {
        'filename': item.fileName,
        'type': item.fileType,
      }).toList();
      
  print("lauda lassan 2");
      // Get presigned URLs
      final presignedUrlsResponse = await _mediaRepository.getPresignedUrls(fileDetails);
      
      // Update media items with presigned URLs
      final updatedState = [...state];
      for (int i = 0; i < mediaItems.length; i++) {
        final index = state.indexOf(mediaItems[i]);
        if (index >= 0 && index < presignedUrlsResponse.length) {
          updatedState[index] = mediaItems[i].copyWith(
            presignedUrl: () => presignedUrlsResponse[i]['url'],
            status: UploadStatus.inProgress,
          );
        }
      }
      state = updatedState;
      
      // Upload each file
      bool allSucceeded = true;
      for (int i = 0; i < mediaItems.length; i++) {
        final mediaItem = state.firstWhere(
          (item) => item?.fileName == mediaItems[i].fileName,
          orElse: () => null,
        );
        
        if (mediaItem != null) {
          final index = state.indexOf(mediaItem);
          bool success = false;
          
          try {
            success = await _mediaRepository.uploadFileToS3(mediaItem);
          } catch (e) {
            print('Initial upload failed: $e');
            success = false;
          }
          
          // Retry if failed
          if (!success) {
            success = await _mediaRepository.retryUpload(mediaItem);
          }
          
          // Update state with result
          final newUpdatedState = [...state];
          newUpdatedState[index] = mediaItem.copyWith(
            status: success ? UploadStatus.success : UploadStatus.failed,
            errorMessage: success ? () => null : () => 'Failed to upload',
          );
          state = newUpdatedState;
          
          if (!success) allSucceeded = false;
        }
      }
      
      return allSucceeded;
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
        AppError.auth(e.toString()),
      );
      return false;
    }
  }
}



================================================
File: providers/recieved_likes_provider.dart
================================================
// File: providers/received_likes_provider.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State definition remains the same
class ReceivedLikesState {
  final bool isLoading;
  final List<FullProfileLiker> fullProfiles;
  final List<BasicProfileLiker> otherLikers;
  final AppError? error;

  const ReceivedLikesState({
    this.isLoading = false, // Start NOT loading initially
    this.fullProfiles = const [],
    this.otherLikers = const [],
    this.error,
  });

  ReceivedLikesState copyWith({
    bool? isLoading,
    List<FullProfileLiker>? fullProfiles,
    List<BasicProfileLiker>? otherLikers,
    AppError? Function()? error,
  }) {
    return ReceivedLikesState(
      isLoading: isLoading ?? this.isLoading,
      fullProfiles: fullProfiles ?? this.fullProfiles,
      otherLikers: otherLikers ?? this.otherLikers,
      error: error != null ? error() : this.error,
    );
  }
}

// StateNotifier definition
class ReceivedLikesNotifier extends StateNotifier<ReceivedLikesState> {
  final LikeRepository _likeRepository;

  ReceivedLikesNotifier(this._likeRepository)
      : super(const ReceivedLikesState());

  Future<void> fetchLikes() async {
    // Prevent concurrent fetches if already loading
    if (state.isLoading) {
      print("[ReceivedLikesNotifier] fetchLikes skipped, already loading.");
      return;
    }

    print("[ReceivedLikesNotifier] fetchLikes called. Setting isLoading=true.");
    state = state.copyWith(
        isLoading: true, error: () => null); // Set loading true *here*

    try {
      print(
          "[ReceivedLikesNotifier] Calling _likeRepository.fetchReceivedLikes()...");
      final result = await _likeRepository.fetchReceivedLikes();
      print(
          "[ReceivedLikesNotifier] Repository call finished. Result received.");

      // Ensure component is still mounted before modifying state
      if (!mounted) {
        print(
            "[ReceivedLikesNotifier] Component unmounted after fetch. Aborting state update.");
        return;
      }

      final fullProfiles = result['full'] as List<FullProfileLiker>? ?? [];
      final otherLikers = result['other'] as List<BasicProfileLiker>? ?? [];
      print(
          "[ReceivedLikesNotifier] fetchLikes success. Full: ${fullProfiles.length}, Other: ${otherLikers.length}. Setting isLoading=false.");

      state = state.copyWith(
        isLoading: false, // Set loading false on success
        fullProfiles: fullProfiles,
        otherLikers: otherLikers,
        error: () => null,
      );
    } on ApiException catch (e) {
      print(
          "[ReceivedLikesNotifier] fetchLikes API Exception: ${e.message}. Setting isLoading=false.");
      if (mounted) {
        state = state.copyWith(
            isLoading: false, // Set loading false on error
            error: () => AppError.server(e.message));
      } else {
        print(
            "[ReceivedLikesNotifier] Component unmounted after API exception.");
      }
    } catch (e, stacktrace) {
      // Catch generic errors and stacktrace
      print(
          "[ReceivedLikesNotifier] fetchLikes Unexpected Error: ${e.toString()}. Setting isLoading=false.");
      print(
          "[ReceivedLikesNotifier] Stacktrace: $stacktrace"); // Log stacktrace
      if (mounted) {
        state = state.copyWith(
            isLoading: false, // Set loading false on error
            error: () => AppError.generic("Failed to load likes."));
      } else {
        print(
            "[ReceivedLikesNotifier] Component unmounted after unexpected error.");
      }
    }
    // Removed finally block as isLoading=false is handled in try/catch
  }
}

// Provider definition
final receivedLikesProvider =
    StateNotifierProvider<ReceivedLikesNotifier, ReceivedLikesState>((ref) {
  final likeRepository = ref.watch(likeRepositoryProvider);
  return ReceivedLikesNotifier(likeRepository);
});



================================================
File: providers/service_provider.dart
================================================
// File: providers/service_provider.dart
import 'package:dtx/repositories/filter_repository.dart';
import 'package:dtx/repositories/user_repository.dart';
import 'package:dtx/repositories/media_repository.dart';
import 'package:dtx/repositories/like_repository.dart'; // *** ADDED Import ***
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/api_service.dart';
import '../services/http_service.dart';
import '../repositories/auth_repository.dart';
import '../utils/env_config.dart';

// API Service provider
final apiServiceProvider = Provider<ApiService>((ref) {
  return HttpService(baseUrl: EnvConfig.apiBaseUrl);
});

// Auth Repository provider
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AuthRepository(apiService);
});

// Media Repository provider
final mediaRepositoryProvider = Provider<MediaRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return MediaRepository(apiService, ref);
});

// User Repository provider
final userRepositoryProvider = Provider<UserRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return UserRepository(apiService);
});

// *** ADDED: Like Repository Provider ***
final likeRepositoryProvider = Provider<LikeRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return LikeRepository(apiService);
});

final filterRepositoryProvider = Provider<FilterRepository>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return FilterRepository(apiService);
});
// *** END ADDED ***



================================================
File: providers/user_provider.dart
================================================
// File: providers/user_provider.dart
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:latlong2/latlong.dart'; // Keep if used
import '../models/error_model.dart';
import '../models/user_model.dart';
import '../utils/app_enums.dart';

final userLoadingProvider = StateProvider<bool>((ref) => false);

final userProvider = StateNotifierProvider<UserNotifier, UserModel>((ref) {
  return UserNotifier(ref);
});

class UserNotifier extends StateNotifier<UserModel> {
  final Ref ref;

  UserNotifier(this.ref) : super(UserModel());

  Future<bool> fetchProfile() async {
    // Only set loading true if profile is actually empty
    bool shouldShowLoading = state.id == null;
    if (shouldShowLoading) ref.read(userLoadingProvider.notifier).state = true;
    ref.read(errorProvider.notifier).clearError();

    try {
      final userRepository = ref.read(userRepositoryProvider);
      final userModel = await userRepository.fetchUserProfile();
      state = userModel; // Direct assignment from fetch is fine
      if (shouldShowLoading)
        ref.read(userLoadingProvider.notifier).state = false;
      return true;
    } on ApiException catch (e) {
      if (shouldShowLoading)
        ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
            AppError.server(e.message), // Use server error type
          );
      return false;
    } catch (e) {
      if (shouldShowLoading)
        ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(
            AppError.generic(
                "Failed to load profile: ${e.toString()}"), // Use generic
          );
      return false;
    }
  }

  // --- NO CHANGE: name, dob, location, gender updates are NOT used for editing ---
  void updateName(String firstName, String? lastName) {
    // This logic is only for onboarding validation
    ref.read(errorProvider.notifier).clearError();
    if (firstName.isEmpty || firstName.trim().length < 3) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("First name must be at least 3 characters"),
          );
      // Don't update state if invalid during onboarding
      // For edit, we rely on the ProfileScreen to handle this before save
      return;
    }
    state = state.copyWith(
      name: () => firstName.trim(),
      lastName: () => lastName?.trim(),
    );
  }

  void updateDateOfBirth(DateTime date) {
    // This logic is only for onboarding validation
    ref.read(errorProvider.notifier).clearError();
    final today = DateTime.now();
    final age = today.difference(date).inDays ~/ 365.25;

    if (date.year < 1900 || date.isAfter(today)) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Invalid year"));
      return;
    }
    if (age < 18) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("You must be at least 18 years old"));
      return;
    }
    try {
      final validatedDate = DateTime(date.year, date.month, date.day);
      state = state.copyWith(dateOfBirth: () => validatedDate);
    } catch (e) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Invalid date combination"));
    }
  }

  void updateLocation(double latitude, double longitude) {
    state = state.copyWith(
      latitude: () => latitude,
      longitude: () => longitude,
    );
  }

  void updateGender(Gender? gender) {
    state = state.copyWith(gender: () => gender);
  }
  // --- END NO CHANGE ---

  LatLng getCurrentLocation() {
    return LatLng(state.latitude ?? 19.2183, state.longitude ?? 73.0864);
  }

  bool isLocationValid() {
    return state.latitude != null &&
        state.longitude != null &&
        state.latitude != 0.0 &&
        state.longitude != 0.0;
  }

  bool isNameValid() => (state.name?.trim().length ?? 0) >= 3;

  // --- Editable Fields ---
  void updateDatingIntention(DatingIntention? intention) {
    state = state.copyWith(datingIntention: () => intention);
  }

  bool isDatingIntentionSelected() {
    return state.datingIntention != null;
  }

  void updateHeight(String height) {
    state = state.copyWith(height: () => height);
  }

  bool isHeightSelected() {
    return state.height != null && state.height!.isNotEmpty;
  }

  void updateHometown(String? hometown) {
    // Allow setting to null for clearing
    state = state.copyWith(hometown: () => hometown?.trim());
  }

  bool isHometownSelected() {
    return state.hometown != null && state.hometown!.isNotEmpty;
  }

  void updateJobTitle(String? jobTitle) {
    // Allow setting to null for clearing
    state = state.copyWith(jobTitle: () => jobTitle?.trim());
  }

  void updateEducation(String? education) {
    // Allow setting to null for clearing
    state = state.copyWith(education: () => education?.trim());
  }

  void updateReligiousBeliefs(Religion? religion) {
    state = state.copyWith(religiousBeliefs: () => religion);
  }

  void updateDrinkingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(drinkingHabit: () => habit);
  }

  void updateSmokingHabit(DrinkingSmokingHabits? habit) {
    state = state.copyWith(smokingHabit: () => habit);
  }

  void addPrompt(Prompt prompt) {
    if (prompt.answer.trim().isEmpty) return;
    if (state.prompts.length >= 3) return;
    final updatedPrompts = List<Prompt>.from(state.prompts)..add(prompt);
    state = state.copyWith(prompts: updatedPrompts);
  }

  void updatePromptAtIndex(int index, Prompt newPrompt) {
    if (newPrompt.answer.trim().isEmpty) return;
    final updatedPrompts = List<Prompt>.from(state.prompts);
    if (index >= 0 && index < updatedPrompts.length) {
      updatedPrompts[index] = newPrompt;
      state = state.copyWith(prompts: updatedPrompts);
    }
  }

  void removePromptAtIndex(int index) {
    final updatedPrompts = List<Prompt>.from(state.prompts);
    if (index >= 0 && index < updatedPrompts.length) {
      updatedPrompts.removeAt(index);
      state = state.copyWith(prompts: updatedPrompts);
    }
  }

  void updateAudioPrompt(AudioPromptModel? audioPrompt) {
    state = state.copyWith(audioPrompt: () => audioPrompt);
  }

  // --- Media Updates (for edit mode) ---
  void updateMediaUrls(List<String> urls) {
    // Directly update the URLs list (typically after upload during save)
    state = state.copyWith(mediaUrls: () => urls);
    // Reset the change flag after URLs are explicitly updated post-save
    state = state.copyWith(mediaChangedDuringEdit: false);
  }

  void setMediaChangedFlag(bool changed) {
    // This flag is set by ProfileScreen when returning from MediaPickerScreen in edit mode
    state = state.copyWith(mediaChangedDuringEdit: changed);
    print("[UserNotifier] Media changed flag set to: $changed");
  }
  // --- End Media Updates ---

  // saveProfile remains for ONBOARDING STEP 2 (POST request)
  Future<bool> saveProfile() async {
    print("[UserNotifier saveProfile] Called (for onboarding step 2 - POST).");
    ref.read(userLoadingProvider.notifier).state = true;
    ref.read(errorProvider.notifier).clearError();

    if (!state.isProfileValid()) {
      // Uses onboarding validation
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Please complete all required profile fields."),
          );
      ref.read(userLoadingProvider.notifier).state = false;
      return false;
    }

    try {
      final userRepository = ref.read(userRepositoryProvider);
      // This now internally calls updateProfileDetails (POST) with the correct payload
      final success = await userRepository.updateProfile(state);

      ref.read(userLoadingProvider.notifier).state = false;
      if (!success && ref.read(errorProvider) == null) {
        // Check if error already set
        ref
            .read(errorProvider.notifier)
            .setError(AppError.server("Failed to save profile."));
      }
      return success;
    } on ApiException catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref.read(errorProvider.notifier).setError(AppError.server(e.message));
      return false;
    } catch (e) {
      ref.read(userLoadingProvider.notifier).state = false;
      ref
          .read(errorProvider.notifier)
          .setError(AppError.generic("An unexpected error occurred."));
      return false;
    }
  }

  bool isProfileValid() {
    // For onboarding step 2 POST
    return state.isProfileValid(); // Delegate to UserModel's method
  }
}



================================================
File: repositories/auth_repository.dart
================================================
// File: repositories/auth_repository.dart
import '../models/auth_model.dart'; // Keep for AuthStatus enum
import '../services/api_service.dart';

class AuthRepository {
  final ApiService _apiService;

  AuthRepository(this._apiService);

  // --- REMOVED METHODS ---
  // Future<bool> sendOtp(String phoneNumber) async { ... }
  // Future<String> verifyOtp(String phoneNumber, String otpCode) async { ... }
  // --- END REMOVED METHODS ---

  // --- NEW METHOD ---
  /// Verifies Google Access Token with the backend and returns the App JWT.
  Future<String> verifyGoogleToken(String googleAccessToken) async {
    final String methodName = 'verifyGoogleToken';
    print('[AuthRepository $methodName] Verifying Google token...');
    try {
      final response = await _apiService.post(
        '/api/auth/google/verify', // Endpoint from API documentation
        body: {'accessToken': googleAccessToken},
      );

      if (response['success'] == true && response['token'] != null) {
        print(
            '[AuthRepository $methodName] Google token verified, got App JWT.');
        return response['token'].toString();
      } else {
        final message = response['message']?.toString() ??
            'Verification failed, no token received.';
        print('[AuthRepository $methodName] Verification failed: $message');
        throw ApiException(
            message); // Throw with message from backend if available
      }
    } on ApiException catch (e) {
      print(
          '[AuthRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode})');
      // Re-throw API exceptions to be handled by the provider
      rethrow;
    } catch (e) {
      print('[AuthRepository $methodName] Unexpected Error: ${e.toString()}');
      // Wrap other errors in ApiException
      throw ApiException(
          'An unexpected error occurred during Google verification: ${e.toString()}');
    }
  }
  // --- END NEW METHOD ---

  // Check authentication status - Updated to handle new states
  Future<AuthStatus> checkAuthStatus(String? token) async {
    final String methodName = 'checkAuthStatus';
    print('[AuthRepository $methodName] Starting auth status check.');

    if (token == null || token.isEmpty) {
      print(
          '[AuthRepository $methodName] No token provided, returning login status.');
      return AuthStatus.login;
    }

    try {
      final headers = {'Authorization': 'Bearer $token'};
      print('[AuthRepository $methodName] Making request to /api/auth-status.');
      final response =
          await _apiService.get('/api/auth-status', headers: headers);

      print('[AuthRepository $methodName] Received response: $response');

      if (response['success'] == true && response['status'] != null) {
        final statusString = response['status'].toString().toLowerCase();
        switch (statusString) {
          case 'home':
            print('[AuthRepository $methodName] Status: home');
            return AuthStatus.home;
          case 'onboarding1': // Handle new state
            print('[AuthRepository $methodName] Status: onboarding1');
            return AuthStatus.onboarding1;
          case 'onboarding2': // Handle new state
            print('[AuthRepository $methodName] Status: onboarding2');
            return AuthStatus.onboarding2;
          default:
            // If backend returns an unexpected status, treat as login
            print(
                '[AuthRepository $methodName] Status: unknown ($statusString), defaulting to login.');
            return AuthStatus.login;
        }
      } else {
        // If success is false or status is missing, treat as login needed
        print(
            '[AuthRepository $methodName] API response indicates failure or missing status, returning login.');
        return AuthStatus.login;
      }
    } on ApiException catch (e) {
      // If API returns 401/403 or other errors indicating invalid session, treat as login needed
      print(
          '[AuthRepository $methodName] API Exception: ${e.message} (Status: ${e.statusCode}), returning login.');
      return AuthStatus.login;
    } catch (e) {
      print(
          '[AuthRepository $methodName] Unexpected Error: ${e.toString()}, returning unknown.');
      return AuthStatus.unknown; // Indicate an issue occurred during the check
    }
  }
}



================================================
File: repositories/auth_status_repository.dart
================================================
// File: repositories/auth_status_repository.dart
import '../services/api_service.dart';
import '../utils/token_storage.dart';

enum AuthStatus {
  home,       // User authenticated with complete profile
  onboarding, // User authenticated but profile incomplete
  login,      // User not authenticated or invalid token
  unknown     // Error or initial state
}

class AuthStatusRepository {
  final ApiService _apiService;
  
  AuthStatusRepository(this._apiService);
  
  Future<AuthStatus> checkAuthStatus() async {
    try {
      // Get the saved token
      final token = await TokenStorage.getToken();
      
      if (token == null || token.isEmpty) {
        return AuthStatus.login;
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      // Make the API request
      final response = await _apiService.get(
        '/api/auth-status',
        headers: headers,
      );
      
      if (response['success'] == true) {
        final status = response['status']?.toString().toLowerCase();
        
        if (status == 'home') {
          return AuthStatus.home;
        } else if (status == 'onboarding') {
          return AuthStatus.onboarding;
        }
      }
      
      // Default to login if status is not recognized or success is false
      return AuthStatus.login;
    } on ApiException catch (e) {
      print('Auth status check failed: $e');
      // For authentication errors, redirect to login
      return AuthStatus.login;
    } catch (e) {
      print('Unexpected error during auth status check: $e');
      return AuthStatus.unknown;
    }
  }
}



================================================
File: repositories/filter_repository.dart
================================================
// lib/repositories/filter_repository.dart
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/token_storage.dart';

class FilterRepository {
  final ApiService _apiService;

  FilterRepository(this._apiService);

  Future<FilterSettings> fetchFilters() async {
    final String methodName = 'fetchFilters';
    print('[FilterRepository $methodName] Fetching filters...');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};

      // *** Log the raw response from the API ***
      final response =
          await _apiService.get('/api/get-filters', headers: headers);
      print('[FilterRepository $methodName] Raw API Response: $response');
      // *** End Log ***

      if (response['success'] == true) {
        if (response['filters'] != null &&
            response['filters'] is Map<String, dynamic>) {
          print('[FilterRepository $methodName] Filters found, parsing...');
          // Parsing happens within the factory now
          return FilterSettings.fromJson(
              response['filters'] as Map<String, dynamic>);
        } else {
          print(
              '[FilterRepository $methodName] Filters not set by API, returning defaults.');
          return const FilterSettings(); // Return default settings
        }
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch filters (API success false).';
        print('[FilterRepository $methodName] Fetch failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[FilterRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      print(
          '[FilterRepository $methodName] Returning default filters due to API Exception.');
      return const FilterSettings(); // Return default on API error
    } catch (e) {
      print('[FilterRepository $methodName] Unexpected Error: $e');
      print(
          '[FilterRepository $methodName] Returning default filters due to Unexpected Error.');
      return const FilterSettings(); // Return default on unexpected errors
    }
  }

  Future<bool> updateFilters(FilterSettings filters) async {
    // ... (updateFilters remains the same as previous version) ...
    final String methodName = 'updateFilters';
    print('[FilterRepository $methodName] Updating filters...');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = filters.toJsonForApi();
      print('[FilterRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/filters', body: body, headers: headers);
      print('[FilterRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print('[FilterRepository $methodName] Filters updated successfully.');
        return true;
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to update filters.';
        print('[FilterRepository $methodName] Update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[FilterRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[FilterRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while updating filters: ${e.toString()}');
    }
  }
}



================================================
File: repositories/like_repository.dart
================================================
// File: repositories/like_repository.dart
import '../models/like_models.dart';
import '../models/error_model.dart'; // Import AppError if needed by provider
import '../services/api_service.dart';
import '../utils/token_storage.dart';

class LikeRepository {
  final ApiService _apiService;

  LikeRepository(this._apiService);

  // likeContent(...) method remains the same
  Future<bool> likeContent({
    required int likedUserId,
    required ContentLikeType contentType,
    required String contentIdentifier,
    required LikeInteractionType interactionType,
    String? comment,
  }) async {
    final String methodName = 'likeContent';
    print(
        '[LikeRepository $methodName] Liking UserID: $likedUserId, Type: ${contentType.value}, Identifier: $contentIdentifier, Interaction: ${interactionType.value}');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'liked_user_id': likedUserId,
        'content_type': contentType.value,
        'content_identifier': contentIdentifier,
        'interaction_type': interactionType.value,
        if (comment != null && comment.trim().isNotEmpty)
          'comment': comment.trim(),
      };
      print('[LikeRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/like', body: body, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      if (e.statusCode == 403) {
        if (e.message.toLowerCase().contains('limit reached'))
          throw LikeLimitExceededException(e.message);
        else if (e.message.toLowerCase().contains('insufficient consumables') ||
            e.message.toLowerCase().contains('rose'))
          throw InsufficientRosesException(e.message);
      }
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while liking content: ${e.toString()}');
    }
  }

  // dislikeUser(...) method remains the same
  Future<bool> dislikeUser({required int dislikedUserId}) async {
    final String methodName = 'dislikeUser';
    print('[LikeRepository $methodName] Disliking UserID: $dislikedUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');
      final headers = {'Authorization': 'Bearer $token'};
      final body = {'disliked_user_id': dislikedUserId};
      print('[LikeRepository $methodName] Request Body: $body');
      final response =
          await _apiService.post('/api/dislike', body: body, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');
      return response['success'] == true;
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while disliking user: ${e.toString()}');
    }
  }

  // --- Fetch Received Likes ---
  Future<Map<String, List<dynamic>>> fetchReceivedLikes() async {
    final String methodName = 'fetchReceivedLikes';
    print(
        '[LikeRepository $methodName] Fetching received likes...'); // Log Start
    try {
      final token = await TokenStorage.getToken();
      if (token == null) {
        print(
            '[LikeRepository $methodName] Error: Authentication token missing.');
        throw ApiException('Authentication token missing');
      }

      final headers = {'Authorization': 'Bearer $token'};
      print(
          '[LikeRepository $methodName] Making GET request to /api/likes/received...'); // Log API call
      final response =
          await _apiService.get('/api/likes/received', headers: headers);
      print(
          '[LikeRepository $methodName] API Response received: $response'); // Log Response

      if (response['success'] == true) {
        print(
            '[LikeRepository $methodName] Parsing successful response...'); // Log Parsing Start
        final List<FullProfileLiker> fullProfiles =
            (response['full_profiles'] as List? ?? [])
                .map((data) {
                  try {
                    // Add inner try-catch for parsing individual items
                    return FullProfileLiker.fromJson(
                        data as Map<String, dynamic>);
                  } catch (e) {
                    print(
                        "[LikeRepository $methodName] Error parsing FullProfileLiker: $e, Data: $data");
                    return null; // Return null for problematic items
                  }
                })
                .whereType<FullProfileLiker>() // Filter out nulls
                .toList();

        final List<BasicProfileLiker> otherLikers =
            (response['other_likers'] as List? ?? [])
                .map((data) {
                  try {
                    return BasicProfileLiker.fromJson(
                        data as Map<String, dynamic>);
                  } catch (e) {
                    print(
                        "[LikeRepository $methodName] Error parsing BasicProfileLiker: $e, Data: $data");
                    return null;
                  }
                })
                .whereType<BasicProfileLiker>() // Filter out nulls
                .toList();

        print(
            '[LikeRepository $methodName] Parsed ${fullProfiles.length} full, ${otherLikers.length} basic profiles.');
        return {'full': fullProfiles, 'other': otherLikers};
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch received likes.';
        print(
            '[LikeRepository $methodName] Fetch failed in API response: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception caught: ${e.message}, Status: ${e.statusCode}');
      rethrow; // Re-throw API exceptions to be handled by the provider
    } catch (e, stacktrace) {
      // Catch other errors and stacktrace
      print('[LikeRepository $methodName] Unexpected Error caught: $e');
      print(
          '[LikeRepository $methodName] Stacktrace: $stacktrace'); // Log stacktrace
      throw ApiException(
          'An unexpected error occurred while fetching likes: ${e.toString()}');
    }
  }

  // fetchLikerProfile(...) method remains the same
  Future<Map<String, dynamic>> fetchLikerProfile(int likerUserId) async {
    final String methodName = 'fetchLikerProfile';
    print(
        '[LikeRepository $methodName] Fetching profile for liker ID: $likerUserId');
    try {
      final token = await TokenStorage.getToken();
      if (token == null) throw ApiException('Authentication token missing');

      final headers = {'Authorization': 'Bearer $token'};
      final endpoint = '/api/liker-profile/$likerUserId';
      print('[LikeRepository $methodName] Making GET request to: $endpoint');

      final response = await _apiService.get(endpoint, headers: headers);
      print('[LikeRepository $methodName] API Response: $response');

      if (response['success'] == true &&
          response['profile'] != null &&
          response['like_details'] != null) {
        if (response['profile'] is Map<String, dynamic> &&
            response['like_details'] is Map<String, dynamic>) {
          final profileData = UserProfileData.fromJson(
              response['profile'] as Map<String, dynamic>);
          final likeDetailsData = LikeInteractionDetails.fromJson(
              response['like_details'] as Map<String, dynamic>);
          print(
              '[LikeRepository $methodName] Successfully parsed profile and like details.');
          return {'profile': profileData, 'likeDetails': likeDetailsData};
        } else {
          print(
              '[LikeRepository $methodName] Error: Invalid data format in response.');
          throw ApiException('Invalid data format received for liker profile.');
        }
      } else {
        final message = response['message']?.toString() ??
            'Failed to fetch liker profile or like details.';
        print('[LikeRepository $methodName] Fetch failed: $message');
        throw ApiException(message, statusCode: response['statusCode'] as int?);
      }
    } on ApiException catch (e) {
      print(
          '[LikeRepository $methodName] API Exception: ${e.message}, Status: ${e.statusCode}');
      rethrow;
    } catch (e) {
      print('[LikeRepository $methodName] Unexpected Error: $e');
      throw ApiException(
          'An unexpected error occurred while fetching the liker profile: ${e.toString()}');
    }
  }
}



================================================
File: repositories/media_repository.dart
================================================
// File: repositories/media_repository.dart
import 'dart:convert';
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/utils/token_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:http_parser/http_parser.dart';
import 'package:path/path.dart' as path;
import '../models/media_upload_model.dart';
import '../services/api_service.dart';

class MediaRepository {
  final ApiService _apiService;
  final Ref? ref;
  
  MediaRepository(this._apiService, [this.ref]);
  
  // Get presigned URLs for uploading files
  Future<List<Map<String, dynamic>>> getPresignedUrls(List<Map<String, String>> fileDetails) async {
    try {
      // Get the token either from the provider or storage
      String? token;
      if (ref != null) {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      }
      
      if (token == null) {
        // Fallback to token storage if not available from provider
        token = await TokenStorage.getToken();
      }
      
      if (token == null) {
        throw ApiException('Authentication token is missing');
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      final response = await _apiService.post(
        '/upload',
        body: {
          'files': fileDetails,
        },
        headers: headers,
      );
      
      if (response['uploads'] != null) {
        return List<Map<String, dynamic>>.from(response['uploads']);
      } else {
        throw ApiException('Failed to get presigned URLs');
      }
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error getting presigned URLs: ${e.toString()}');
    }
  }

  // Get presigned URL for audio upload
  Future<Map<String, dynamic>> getAudioPresignedUrl(String filename, String fileType, AudioPrompt prompt) async {
    try {
      // Get the token either from the provider or storage
      String? token;
      if (ref != null) {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      }
      
      if (token == null) {
        // Fallback to token storage if not available from provider
        token = await TokenStorage.getToken();
      }
      
      if (token == null) {
        throw ApiException('Authentication token is missing');
      }
      
      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };
      
      final response = await _apiService.post(
        '/audio',
        body: {
          'filename': filename,
          'type': fileType,
          'prompt': prompt.value,
        },
        headers: headers,
      );
      
      return response;
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error getting audio presigned URL: ${e.toString()}');
    }
  }

    // Get presigned URL for verification photo upload
  Future<String> getVerificationPresignedUrl(String filename, String fileType) async {
    try {
      // Get the token either from the provider or storage
      String? token;
      if (ref != null) {
        final authState = ref!.read(authProvider);
        token = authState.jwtToken;
      }

      if (token == null) {
        // Fallback to token storage if not available from provider
        token = await TokenStorage.getToken();
      }

      if (token == null) {
        throw ApiException('Authentication token is missing');
      }

      // Create auth headers
      final headers = {
        'Authorization': 'Bearer $token',
      };

      final response = await _apiService.post(
        '/verify',
        body: {
          'filename': filename,
          'type': fileType,
        },
        headers: headers,
      );

      if (response['upload_url'] != null) {
        return response['upload_url'];
      } else {
        throw ApiException('Failed to get verification presigned URL');
      }
    } on ApiException {
      rethrow;
    } catch (e) {
      throw ApiException('Error getting verification presigned URL: ${e.toString()}');
    }
  }
  
  // Upload a file to S3 using presigned URL
// Upload a file to S3 using presigned URL
Future<bool> uploadFileToS3(MediaUploadModel mediaUpload) async {
  if (mediaUpload.presignedUrl == null) {
    throw ApiException('Missing presigned URL for upload');
  }

  final file = mediaUpload.file;
  final contentType = mediaUpload.fileType;
  final filePath = file.path;

  try {
    print('⏫ Starting S3 upload for: ${mediaUpload.fileName}');
    print('📁 File path: $filePath');
    print('📦 Content-Type: $contentType');
    print('📏 File size: ${(await file.length()) / 1024} KB');
    print('🔗 Presigned URL: ${mediaUpload.presignedUrl}');

    final client = HttpClient();
    final request = await client.putUrl(Uri.parse(mediaUpload.presignedUrl!));
    
    // Set headers from curl example
    request.headers.set(HttpHeaders.contentTypeHeader, contentType);
    request.contentLength = await file.length();

    // Add debug headers
    print('📨 Request headers:');
    request.headers.forEach((name, values) {
      print('   $name: ${values.join(', ')}');
    });

    // Pipe file content directly
    final fileStream = file.openRead();
    await request.addStream(fileStream);
    final response = await request.close();

    // Get response details
    final statusCode = response.statusCode;
    final responseHeaders = response.headers;
    final responseBody = await response.transform(utf8.decoder).join();

    print('📩 Upload response:');
    print('   Status: $statusCode');
    print('   Headers:');
    responseHeaders.forEach((name, values) {
      print('     $name: ${values.join(', ')}');
    });
    print('   Body: $responseBody');

    if (statusCode != HttpStatus.ok) {
      print('❌ Upload failed with status $statusCode');
      return false;
    }

    print('✅ Upload successful for ${mediaUpload.fileName}');
    return true;
  } catch (e, stack) {
    print('‼️ Critical upload error: $e');
    print('🛑 Stack trace: $stack');
    return false;
  }
}

  // Retry failed uploads with exponential backoff
  Future<bool> retryUpload(MediaUploadModel mediaUpload, {int maxRetries = 3}) async {
    int retryCount = 0;
    int backoffMs = 1000; // Start with 1 second
    
    while (retryCount < maxRetries) {
      try {
        final success = await uploadFileToS3(mediaUpload);
        if (success) return true;
      } catch (e) {
        print('Retry $retryCount failed: $e');
      }
      
      retryCount++;
      if (retryCount < maxRetries) {
        // Exponential backoff
        await Future.delayed(Duration(milliseconds: backoffMs));
        backoffMs *= 2; // Double the wait time for next retry
      }
    }
    
    return false;
  }
}



================================================
File: repositories/user_repository.dart
================================================
// File: lib/repositories/user_repository.dart
import '../models/user_model.dart';
import '../services/api_service.dart';
import '../utils/token_storage.dart';
import '../utils/app_enums.dart';

class UserRepository {
  final ApiService _apiService;

  UserRepository(this._apiService);

  // updateLocationGender remains the same
  Future<bool> updateLocationGender(
      double lat, double lon, Gender gender) async {
    final String methodName = 'updateLocationGender';
    print(
        '[UserRepository $methodName] Called with lat: $lat, lon: $lon, gender: ${gender.value}');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};
      final body = {
        'latitude': lat,
        'longitude': lon,
        'gender': gender.value,
      };

      print(
          '[UserRepository $methodName] Making POST request to /api/profile/location-gender');
      final response = await _apiService.post(
        '/api/profile/location-gender',
        body: body,
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print(
            '[UserRepository $methodName] Location/Gender update successful.');
        return true;
      } else {
        final message = response['message']?.toString() ??
            'Failed to update location and gender.';
        print(
            '[UserRepository $methodName] Location/Gender update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while updating location/gender: ${e.toString()}');
    }
  }

  // updateProfileDetails remains the same (used for onboarding step 2)
  Future<bool> updateProfileDetails(Map<String, dynamic> profileData) async {
    final String methodName = 'updateProfileDetails';
    print('[UserRepository $methodName] Called.');
    // Remove any lingering null values which might cause issues with JSON encoding or backend validation
    profileData.removeWhere((key, value) => value == null);
    print('[UserRepository $methodName] Payload to send: $profileData');

    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making POST request to /api/profile');
      final response = await _apiService.post(
        '/api/profile', // The endpoint for main profile details
        body: profileData, // Send the prepared data
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print(
            '[UserRepository $methodName] Profile details update successful.');
        return true;
      } else {
        final message = response['message']?.toString() ??
            'Failed to update profile details.';
        print(
            '[UserRepository $methodName] Profile details update failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while updating profile details: ${e.toString()}');
    }
  }

  // --- ADDED editProfile METHOD ---
  Future<bool> editProfile(Map<String, dynamic> profileData) async {
    final String methodName = 'editProfile';
    print('[UserRepository $methodName] Called.');
    // Remove any lingering null values (important for PATCH)
    profileData.removeWhere((key, value) => value == null);
    print(
        '[UserRepository $methodName] Payload to send via PATCH: $profileData');

    // Ensure there's actually something to update
    if (profileData.isEmpty) {
      print(
          '[UserRepository $methodName] No changes detected. Skipping API call.');
      // Consider returning a specific value or message? For now, true as nothing failed.
      return true; // Or throw ApiException("No changes to save.") if preferred
    }

    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }
      final headers = {'Authorization': 'Bearer $token'};

      print(
          '[UserRepository $methodName] Making PATCH request to /api/profile/edit');
      final response = await _apiService.patch(
        '/api/profile/edit', // The specific PATCH endpoint
        body: profileData,
        headers: headers,
      );

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        print('[UserRepository $methodName] Profile edit successful.');
        return true;
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to edit profile.';
        print('[UserRepository $methodName] Profile edit failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while editing profile: ${e.toString()}');
    }
  }
  // --- END ADDED editProfile METHOD ---

  // fetchHomeFeed remains the same
  Future<Map<String, dynamic>> fetchHomeFeed() async {
    final String methodName = 'fetchHomeFeed';
    print('[UserRepository $methodName] Called.');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making GET request to /api/homefeed');
      final response = await _apiService.get('/api/homefeed', headers: headers);

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true) {
        final profilesList =
            response['profiles'] as List? ?? []; // Handle null case
        final profiles = profilesList
            .map((profileJson) =>
                UserModel.fromJson(profileJson as Map<String, dynamic>))
            .toList();
        final hasMore = response['has_more'] as bool? ??
            false; // Default to false if missing

        print(
            '[UserRepository $methodName] Home feed fetch successful. Count: ${profiles.length}, Has More: $hasMore');
        return {'profiles': profiles, 'has_more': hasMore};
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch home feed.';
        print('[UserRepository $methodName] Home feed fetch failed: $message');
        // Handle case where 'profiles' might be null but success is true (empty feed)
        if (response['success'] == true &&
            (response['profiles'] == null ||
                (response['profiles'] is List &&
                    (response['profiles'] as List).isEmpty))) {
          print('[UserRepository $methodName] Feed is empty.');
          return {
            'profiles': <UserModel>[],
            'has_more': false
          }; // Return empty list and has_more=false
        }
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while fetching the home feed: ${e.toString()}');
    }
  }

  // fetchUserProfile remains the same
  Future<UserModel> fetchUserProfile() async {
    final String methodName = 'fetchUserProfile';
    print('[UserRepository $methodName] Called.');
    try {
      final token = await TokenStorage.getToken();
      if (token == null || token.isEmpty) {
        print(
            '[UserRepository $methodName] Error: Authentication token is missing.');
        throw ApiException('Authentication token is missing');
      }

      final headers = {'Authorization': 'Bearer $token'};

      print('[UserRepository $methodName] Making GET request to /get-profile');
      final response = await _apiService.get('/get-profile', headers: headers);

      print('[UserRepository $methodName] API Response: $response');
      if (response['success'] == true && response['user'] != null) {
        print('[UserRepository $methodName] Profile fetch successful.');
        if (response['user'] is Map<String, dynamic>) {
          return UserModel.fromJson(response['user'] as Map<String, dynamic>);
        } else {
          print(
              '[UserRepository $methodName] Error: Invalid user data format in response.');
          throw ApiException('Invalid user data format received from server.');
        }
      } else {
        final message =
            response['message']?.toString() ?? 'Failed to fetch user profile.';
        print('[UserRepository $methodName] Profile fetch failed: $message');
        throw ApiException(message);
      }
    } on ApiException catch (e) {
      print('[UserRepository $methodName] API Exception: ${e.message}');
      rethrow;
    } catch (e) {
      print('[UserRepository $methodName] Unexpected Error: ${e.toString()}');
      throw ApiException(
          'An unexpected error occurred while fetching the profile: ${e.toString()}');
    }
  }

  // updateProfile (DEPRECATED for edit - keep for onboarding step 2)
  // This uses the POST /api/profile endpoint
  Future<bool> updateProfile(UserModel userModel) async {
    print(
        "[UserRepository updateProfile] Calling updateProfileDetails (POST)...");
    Map<String, dynamic> profileData = userModel.toJsonForProfileUpdate();
    return await updateProfileDetails(profileData);
  }
}



================================================
File: services/api_service.dart
================================================
// File: services/api_service.dart
import 'dart:convert';

/// Abstract class defining the API service interface
abstract class ApiService {
  /// Base URL for all API requests
  String get baseUrl;

  /// Makes a GET request to the specified endpoint
  Future<Map<String, dynamic>> get(String endpoint,
      {Map<String, String>? headers});

  /// Makes a POST request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a PUT request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a PATCH request to the specified endpoint with the provided body
  Future<Map<String, dynamic>> patch(
    // <<< ADDED
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  });

  /// Makes a DELETE request to the specified endpoint
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  });

  /// Adds authorization token to headers
  Map<String, String> addAuthToken(Map<String, String>? headers, String token);
}

/// Exception thrown when API requests fail
class ApiException implements Exception {
  final String message;
  final int? statusCode;

  ApiException(this.message, {this.statusCode});

  @override
  String toString() =>
      'ApiException: $message ${statusCode != null ? '(Status code: $statusCode)' : ''}';
}



================================================
File: services/http_service.dart
================================================
// File: services/http_service.dart
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'api_service.dart';

/// Implementation of ApiService using the http package
class HttpService implements ApiService {
  @override
  final String baseUrl;

  HttpService({required this.baseUrl});

  @override
  Map<String, String> addAuthToken(Map<String, String>? headers, String token) {
    final updatedHeaders = {...(headers ?? {})};
    updatedHeaders['Authorization'] = 'Bearer $token';
    print(updatedHeaders);
    return updatedHeaders;
  }

  @override
  Future<Map<String, dynamic>> get(String endpoint,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      throw ApiException('Failed to perform GET request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> post(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.post(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform POST request: ${e.toString()}');
    }
  }

  @override
  Future<Map<String, dynamic>> put(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.put(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform PUT request: ${e.toString()}');
    }
  }

  // --- ADDED PATCH METHOD ---
  @override
  Future<Map<String, dynamic>> patch(
    String endpoint, {
    required Map<String, dynamic> body,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await http.patch(
        Uri.parse('$baseUrl$endpoint'),
        headers: {
          'Content-Type': 'application/json',
          ...?headers,
        },
        body: json.encode(body),
      );
      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform PATCH request: ${e.toString()}');
    }
  }
  // --- END ADDED PATCH METHOD ---

  @override
  Future<Map<String, dynamic>> delete(
    String endpoint, {
    Map<String, dynamic>? body,
    Map<String, String>? headers,
  }) async {
    try {
      final request = http.Request('DELETE', Uri.parse('$baseUrl$endpoint'));

      request.headers.addAll({
        'Content-Type': 'application/json',
        ...?headers,
      });

      if (body != null) {
        request.body = json.encode(body);
      }

      final streamedResponse = await request.send();
      final response = await http.Response.fromStream(streamedResponse);

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('No internet connection');
    } catch (e) {
      if (e is ApiException) rethrow;
      throw ApiException('Failed to perform DELETE request: ${e.toString()}');
    }
  }

  /// Handle the HTTP response and convert to a standardized format
  Map<String, dynamic> _handleResponse(http.Response response) {
    try {
      // Allow empty body for success codes like 204 No Content
      if (response.statusCode >= 200 && response.statusCode < 300) {
        if (response.body.isEmpty) {
          return {'success': true, 'message': 'Operation successful'};
        }
        final responseData = json.decode(response.body) as Map<String, dynamic>;
        return responseData;
      } else {
        // Attempt to decode body even for errors, as it might contain error details
        Map<String, dynamic>? responseData;
        try {
          if (response.body.isNotEmpty) {
            responseData = json.decode(response.body) as Map<String, dynamic>;
          }
        } on FormatException {
          // Ignore format exception if body isn't valid JSON
          print("Warning: Non-JSON error response body: ${response.body}");
        }

        // Extract only the actual error message from the API response
        String errorMessage;

        if (responseData != null && responseData.containsKey('message')) {
          // Use the message directly from the response
          errorMessage = responseData['message'].toString();
        } else if (responseData != null && responseData.containsKey('error')) {
          // Some APIs use 'error' property
          errorMessage = responseData['error'].toString();
        } else {
          // Fallback error message including status code and reason phrase
          errorMessage =
              'Request failed: ${response.statusCode} ${response.reasonPhrase ?? ''}';
        }

        throw ApiException(errorMessage, statusCode: response.statusCode);
      }
    } on FormatException {
      // This catches JSON decoding errors for successful responses (shouldn't happen often)
      throw ApiException('Invalid response format received from server.',
          statusCode: response.statusCode);
    } catch (e) {
      // Catch other errors like network issues during response handling
      if (e is ApiException)
        rethrow; // Re-throw if it's already an ApiException
      throw ApiException('Failed to process response: ${e.toString()}',
          statusCode: response.statusCode);
    }
  }
}



================================================
File: utils/app_enums.dart
================================================
// File: lib/utils/app_enums.dart
// Import the correct location of ContentLikeType
import 'package:dtx/models/like_models.dart' show ContentLikeType;

enum Gender {
  man('man', 'Man'),
  woman('woman', 'Woman');

  final String value;
  final String label;
  const Gender(this.value, this.label);
}

enum DatingIntention {
  lifePartner('lifePartner', 'Life partner'),
  longTerm('longTerm', 'Long-term relationship'),
  longTermOpenShort(
      'longTermOpenShort', 'Long-term, open to short'), // Shortened label
  shortTermOpenLong(
      'shortTermOpenLong', 'Short-term, open to long'), // Shortened label
  shortTerm('shortTerm', 'Short-term relationship'),
  figuringOut('figuringOut', 'Figuring out my dating goals');

  final String value;
  final String label;
  const DatingIntention(this.value, this.label);
}

enum Religion {
  agnostic('agnostic', 'Agnostic'),
  atheist('atheist', 'Atheist'),
  buddhist('buddhist', 'Buddhist'),
  christian('christian', 'Christian'),
  hindu('hindu', 'Hindu'),
  jain('jain', 'Jain'),
  jewish('jewish', 'Jewish'),
  muslim('muslim', 'Muslim'),
  zoroastrian('zoroastrian', 'Zoroastrian'),
  sikh('sikh', 'Sikh'),
  spiritual('spiritual', 'Spiritual');

  final String value;
  final String label;
  const Religion(this.value, this.label);
}

enum DrinkingSmokingHabits {
  yes('yes', 'Yes'),
  sometimes('sometimes', 'Sometimes'),
  no('no', 'No');

  final String value;
  final String label;
  const DrinkingSmokingHabits(this.value, this.label);
}

enum PromptCategory {
  storyTime('storyTime', 'Story time'),
  myType('myType', 'My type'),
  gettingPersonal('gettingPersonal', 'Getting personal'),
  dateVibes('dateVibes', 'Date vibes');

  final String value;
  final String label;
  const PromptCategory(this.value, this.label);

  // --- ADDED: contentType Getter ---
  // This getter uses the ContentLikeType defined in like_models.dart
  ContentLikeType get contentType {
    switch (this) {
      case PromptCategory.storyTime:
        return ContentLikeType.promptStory;
      case PromptCategory.myType:
        return ContentLikeType.promptMytype;
      case PromptCategory.gettingPersonal:
        return ContentLikeType.promptGettingpersonal;
      case PromptCategory.dateVibes:
        return ContentLikeType.promptDatevibes;
    }
  }
  // --- END ADDED ---

  List<PromptType> getPrompts() {
    switch (this) {
      case PromptCategory.storyTime:
        return [
          PromptType.twoTruthsAndALie,
          PromptType.worstIdea,
          PromptType.biggestRisk,
          PromptType.biggestDateFail,
          PromptType.neverHaveIEver,
          PromptType.bestTravelStory,
          PromptType.weirdestGift,
          PromptType.mostSpontaneous,
          PromptType.oneThingNeverDoAgain,
        ];
      case PromptCategory.myType:
        return [
          PromptType.nonNegotiable,
          PromptType.hallmarkOfGoodRelationship,
          PromptType.lookingFor,
          PromptType.weirdlyAttractedTo,
          PromptType.allIAskIsThatYou,
          PromptType.wellGetAlongIf,
          PromptType.wantSomeoneWho,
          PromptType.greenFlags,
          PromptType.sameTypeOfWeird,
          PromptType.fallForYouIf,
          PromptType.bragAboutYou,
        ];
      case PromptCategory.gettingPersonal:
        return [
          PromptType.oneThingYouShouldKnow,
          PromptType.loveLanguage,
          PromptType.dorkiestThing,
          PromptType.dontHateMeIf,
          PromptType.geekOutOn,
          PromptType.ifLovingThisIsWrong,
          PromptType.keyToMyHeart,
          PromptType.wontShutUpAbout,
          PromptType.shouldNotGoOutWithMeIf,
          PromptType.whatIfIToldYouThat,
        ];
      case PromptCategory.dateVibes:
        return [
          PromptType.togetherWeCould,
          PromptType.firstRoundIsOnMeIf,
          PromptType.whatIOrderForTheTable,
          PromptType.bestSpotInTown,
          PromptType.bestWayToAskMeOut,
        ];
    }
  }
}

enum PromptType {
  // Story Time
  twoTruthsAndALie('twoTruthsAndALie', 'Two truths and a lie'),
  worstIdea('worstIdea', 'Worst idea I\'ve ever had'),
  biggestRisk('biggestRisk', 'Biggest risk I\'ve taken'),
  biggestDateFail('biggestDateFail', 'My biggest date fail'),
  neverHaveIEver('neverHaveIEver', 'Never have I ever'),
  bestTravelStory('bestTravelStory', 'Best travel story'),
  weirdestGift('weirdestGift', 'Weirdest gift I\'ve given or received'),
  mostSpontaneous('mostSpontaneous', 'Most spontaneous thing I\'ve done'),
  oneThingNeverDoAgain(
      'oneThingNeverDoAgain', 'One thing I\'ll never do again'),
  // My Type
  nonNegotiable('nonNegotiable', 'Something that\'s non-negotiable for me is'),
  hallmarkOfGoodRelationship(
      'hallmarkOfGoodRelationship', 'The hallmark of a good relationship is'),
  lookingFor('lookingFor', 'I\'m looking for'),
  weirdlyAttractedTo('weirdlyAttractedTo', 'I\'m weirdly attracted to'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  wellGetAlongIf('wellGetAlongIf', 'We\'ll get along if'),
  wantSomeoneWho('wantSomeoneWho', 'I want someone who'),
  greenFlags('greenFlags', 'Green flags I look out for'),
  sameTypeOfWeird('sameTypeOfWeird', 'We\'re the same type of weird if'),
  fallForYouIf('fallForYouIf', 'I\'d fall for you if'),
  bragAboutYou('bragAboutYou', 'I\'ll brag about you to my friends if'),
  // Getting Personal
  oneThingYouShouldKnow(
      'oneThingYouShouldKnow', 'The one thing you should know about me is'),
  loveLanguage('loveLanguage', 'My Love Language is'),
  dorkiestThing('dorkiestThing', 'The dorkiest thing about me is'),
  dontHateMeIf('dontHateMeIf', 'Don\'t hate me if I'),
  geekOutOn('geekOutOn', 'I geek out on'),
  ifLovingThisIsWrong('ifLovingThisIsWrong',
      'If loving this is wrong, I don\'t want to be right'),
  keyToMyHeart('keyToMyHeart', 'The key to my heart is'),
  wontShutUpAbout('wontShutUpAbout', 'I won\'t shut up about'),
  shouldNotGoOutWithMeIf(
      'shouldNotGoOutWithMeIf', 'You should *not* go out with me if'),
  whatIfIToldYouThat('whatIfIToldYouThat', 'What if I told you that'),
  // Date Vibes
  togetherWeCould('togetherWeCould', 'Together, we could'),
  firstRoundIsOnMeIf('firstRoundIsOnMeIf', 'First round is on me if'),
  whatIOrderForTheTable('whatIOrderForTheTable',
      'What I order for the table'), // Corrected enum value and label
  bestSpotInTown('bestSpotInTown', 'I know the best spot in town for'),
  bestWayToAskMeOut('bestWayToAskMeOut', 'The best way to ask me out is by');

  final String value;
  final String label;
  const PromptType(this.value, this.label);

  PromptCategory getCategory() {
    for (var category in PromptCategory.values) {
      if (category.getPrompts().contains(this)) {
        return category;
      }
    }
    print("Warning: PromptType '$value' does not belong to a known category.");
    return PromptCategory.storyTime; // Defaulting
  }
}

enum AudioPrompt {
  canWeTalkAbout('canWeTalkAbout', 'Can we talk about?'),
  captionThisPhoto('captionThisPhoto', 'Caption this photo'),
  caughtInTheAct('caughtInTheAct', 'Caught in the act'),
  changeMyMindAbout('changeMyMindAbout', 'Change my mind about'),
  chooseOurFirstDate('chooseOurFirstDate', 'Choose our first date'),
  commentIfYouveBeenHere(
      'commentIfYouveBeenHere', 'Comment if you\'ve been here'),
  cookWithMe('cookWithMe', 'Cook with me'),
  datingMeIsLike('datingMeIsLike', 'Dating me is like'),
  datingMeWillLookLike('datingMeWillLookLike', 'Dating me will look like'),
  doYouAgreeOrDisagreeThat(
      'doYouAgreeOrDisagreeThat', 'Do you agree or disagree that'),
  dontHateMeIfI('dontHateMeIfI', 'Don\'t hate me if I'),
  dontJudgeMe('dontJudgeMe', 'Don\'t judge me'),
  mondaysAmIRight('mondaysAmIRight', 'Mondays... am I right?'),
  aBoundaryOfMineIs('aBoundaryOfMineIs', 'A boundary of mine is'),
  aDailyEssential('aDailyEssential', 'A daily essential'),
  aDreamHomeMustInclude('aDreamHomeMustInclude', 'A dream home must include'),
  aFavouriteMemoryOfMine(
      'aFavouriteMemoryOfMine', 'A favourite memory of mine'),
  aFriendsReviewOfMe('aFriendsReviewOfMe', 'A friend\'s review of me'),
  aLifeGoalOfMine('aLifeGoalOfMine', 'A life goal of mine'),
  aQuickRantAbout('aQuickRantAbout', 'A quick rant about'),
  aRandomFactILoveIs('aRandomFactILoveIs', 'A random fact I love is'),
  aSpecialTalentOfMine('aSpecialTalentOfMine', 'A special talent of mine'),
  aThoughtIRecentlyHadInTheShower('aThoughtIRecentlyHadInTheShower',
      'A thought I recently had in the shower'),
  allIAskIsThatYou('allIAskIsThatYou', 'All I ask is that you'),
  guessWhereThisPhotoWasTaken(
      'guessWhereThisPhotoWasTaken', 'Guess where this photo was taken'),
  helpMeIdentifyThisPhotoBomber(
      'helpMeIdentifyThisPhotoBomber', 'Help me identify this photo bomber'),
  hiFromMeAndMyPet('hiFromMeAndMyPet', 'Hi from me and my pet'),
  howIFightTheSundayScaries(
      'howIFightTheSundayScaries', 'How I fight the Sunday scaries'),
  howHistoryWillRememberMe(
      'howHistoryWillRememberMe', 'How history will remember me'),
  howMyFriendsSeeMe('howMyFriendsSeeMe', 'How my friends see me'),
  howToPronounceMyName('howToPronounceMyName', 'How to pronounce my name'),
  iBeatMyBluesBy('iBeatMyBluesBy', 'I beat my blues by'),
  iBetYouCant('iBetYouCant', 'I bet you can\'t'),
  iCanTeachYouHowTo('iCanTeachYouHowTo', 'I can teach you how to'),
  iFeelFamousWhen('iFeelFamousWhen', 'I feel famous when'),
  iFeelMostSupportedWhen(
      'iFeelMostSupportedWhen', 'I feel most supported when');

  final String value;
  final String label;
  const AudioPrompt(this.value, this.label);
}



================================================
File: utils/env_config.dart
================================================

// File: utils/env_config.dart
import 'package:flutter_dotenv/flutter_dotenv.dart';

class EnvConfig {
  static String get apiBaseUrl => 
    dotenv.get('API_BASE_URL', fallback: 'http://10.61.67.128:8080');
}



================================================
File: utils/token_storage.dart
================================================

// File: utils/token_storage.dart
import 'package:shared_preferences/shared_preferences.dart';

class TokenStorage {
  static const String _tokenKey = 'auth_token';
  
  // Save the JWT token
  static Future<bool> saveToken(String token) async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.setString(_tokenKey, token);
  }
  
  // Get the stored JWT token
  static Future<String?> getToken() async {
    final prefs = await SharedPreferences.getInstance();
    print(prefs.getString(_tokenKey));
    return prefs.getString(_tokenKey);
  }
  
  // Remove the stored token (for logout)
  static Future<bool> removeToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.remove(_tokenKey);
  }
  
  // Check if a token exists
  static Future<bool> hasToken() async {
    final token = await getToken();
    return token != null && token.isNotEmpty;
  }
}



================================================
File: views/audioprompt.dart
================================================
// File: lib/views/audioprompt.dart
import 'dart:async';
import 'dart:io'; // Keep for File checks

import 'package:audioplayers/audioplayers.dart';
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/media_upload_model.dart';
import 'package:dtx/models/auth_model.dart'; // Keep for AuthStatus check
import 'package:dtx/models/user_model.dart';
import 'package:dtx/providers/audio_upload_provider.dart';
import 'package:dtx/providers/auth_provider.dart'; // Keep for status check
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/media_upload_provider.dart'; // <<< ADDED for general media
import 'package:dtx/providers/service_provider.dart'; // Keep for repository access
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/audiopromptsselect.dart';
import 'package:dtx/views/main_navigation_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:record/record.dart';

class VoicePromptScreen extends ConsumerStatefulWidget {
  final bool isEditing;

  const VoicePromptScreen({
    Key? key,
    this.isEditing = false,
  }) : super(key: key);

  @override
  ConsumerState<VoicePromptScreen> createState() => _VoicePromptScreenState();
}

class _VoicePromptScreenState extends ConsumerState<VoicePromptScreen> {
  final AudioRecorder _audioRecorder = AudioRecorder();
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isRecording = false;
  String _recordingTime = "0:00 / 0:30";
  String? _audioPath;
  bool _isPlaying = false;
  DateTime? _startTime;
  Timer? _recordingTimer;
  bool _isSaving = false;
  AudioPrompt? _selectedPrompt;
  String? _existingAudioUrl;

  @override
  void initState() {
    super.initState();
    if (widget.isEditing) {
      final existingPromptModel = ref.read(userProvider).audioPrompt;
      if (existingPromptModel != null) {
        _selectedPrompt = existingPromptModel.prompt;
        _existingAudioUrl = existingPromptModel.audioUrl;
        ref
            .read(audioUploadProvider.notifier)
            .setSelectedPrompt(_selectedPrompt!);
      }
    } else {
      ref.read(audioUploadProvider.notifier).clearAudio();
    }
    _initializeAudioSession();
    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) setState(() => _isPlaying = false);
    });
    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted && state != PlayerState.playing) {
        if (_isPlaying && state != PlayerState.paused) {
          setState(() => _isPlaying = false);
        }
      }
    });
  }

  Future<void> _initializeAudioSession() async {
    /* ... same as before ... */ print(
        "[VoicePromptScreen] Requesting microphone permission...");
    final status = await Permission.microphone.request();
    print("[VoicePromptScreen] Microphone permission status: $status");
    if (!status.isGranted && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Microphone permission is required.')),
      );
    }
  }

  Future<void> _startRecording() async {
    /* ... same as before ... */ setState(() {
      _existingAudioUrl = null;
      _audioPath = null;
      _recordingTime = "0:00 / 0:30";
    });
    ref.read(audioUploadProvider.notifier).clearAudio();
    if (!await _audioRecorder.hasPermission()) {
      print("[VoicePromptScreen] Start Recording: Permission denied.");
      if (mounted)
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Microphone permission denied.')));
      return;
    }
    if (_isPlaying) {
      await _audioPlayer.stop();
      setState(() => _isPlaying = false);
    }
    try {
      print("[VoicePromptScreen] Starting recording...");
      final directory = await getApplicationDocumentsDirectory();
      final newPath =
          '${directory.path}/voice_prompt_${DateTime.now().millisecondsSinceEpoch}.m4a';
      print("[VoicePromptScreen] Recording path set to: $newPath");
      await _audioRecorder.start(
          const RecordConfig(encoder: AudioEncoder.aacLc),
          path: newPath);
      _audioPath = newPath;
      _startTime = DateTime.now();
      if (!mounted) return;
      setState(() => _isRecording = true);
      print("[VoicePromptScreen] Recording started.");
      _recordingTimer?.cancel();
      _recordingTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
        if (!_isRecording || !mounted || _startTime == null) {
          timer.cancel();
          return;
        }
        final duration = DateTime.now().difference(_startTime!).inSeconds;
        if (duration >= 30) {
          timer.cancel();
          _stopRecording();
          return;
        }
        if (mounted) {
          setState(() {
            _recordingTime = "0:${duration.toString().padLeft(2, '0')} / 0:30";
          });
        }
      });
    } catch (e) {
      print('[VoicePromptScreen] Recording error: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Recording failed: ${e.toString()}')));
        setState(() => _isRecording = false);
      }
    }
  }

  Future<void> _stopRecording() async {
    /* ... same as before ... */ if (!_isRecording) return;
    _recordingTimer?.cancel();
    try {
      final path = await _audioRecorder.stop();
      print('[VoicePromptScreen] Recording stopped. Path from recorder: $path');
      if (path != null) {
        final file = File(path);
        if (!await file.exists() || await file.length() == 0) {
          print(
              '[VoicePromptScreen] Error: Recording file is missing or empty after stop.');
          if (mounted)
            ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                content: Text('Failed to save recording. Please try again.')));
          setState(() {
            _isRecording = false;
            _audioPath = null;
            _recordingTime = "0:00 / 0:30";
          });
          return;
        }
        _audioPath = path;
        if (mounted) {
          setState(() {
            _isRecording = false;
          });
          ref.read(audioUploadProvider.notifier).setRecordingPath(_audioPath!);
          print(
              "[VoicePromptScreen] Recording path saved to provider: $_audioPath");
        }
      } else {
        print("[VoicePromptScreen] Stop recording returned null path.");
        if (mounted) {
          setState(() => _isRecording = false);
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Failed to save recording.')),
          );
        }
      }
    } catch (e) {
      print('[VoicePromptScreen] Stop recording error: $e');
      if (mounted) {
        setState(() => _isRecording = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error stopping recording: ${e.toString()}')),
        );
      }
    }
  }

  Future<void> _playRecording() async {
    /* ... same as before ... */ final String? pathOrUrlToPlay =
        _audioPath ?? _existingAudioUrl;
    print(
        "[VoicePromptScreen] Play recording requested. Source: $pathOrUrlToPlay");
    if (pathOrUrlToPlay == null) {
      print("[VoicePromptScreen] Playback Error: No audio source available.");
      if (mounted)
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
            content:
                Text('Please record or ensure existing audio is loaded.')));
      return;
    }
    if (_audioPath != null) {
      final file = File(_audioPath!);
      if (!await file.exists() || await file.length() == 0) {
        print(
            "[VoicePromptScreen] Playback Error: File is missing or empty at $_audioPath");
        if (mounted)
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
              content: Text('Recording file error. Please record again.')));
        setState(() => _audioPath = null);
        return;
      }
    }
    try {
      final Source audioSource = _audioPath != null
          ? DeviceFileSource(_audioPath!)
          : UrlSource(pathOrUrlToPlay);
      if (_isPlaying) {
        print("[VoicePromptScreen] Pausing playback.");
        await _audioPlayer.pause();
      } else {
        if (_audioPlayer.state == PlayerState.playing ||
            _audioPlayer.state == PlayerState.paused) {
          await _audioPlayer.stop();
        }
        print("[VoicePromptScreen] Starting playback from: $pathOrUrlToPlay");
        await _audioPlayer.play(audioSource);
      }
    } catch (e) {
      print('[VoicePromptScreen] Playback error: $e');
      if (mounted) {
        setState(() => _isPlaying = false);
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Playback failed: ${e.toString()}')));
      }
    }
  }

  void _selectPrompt() {
    /* ... same as before ... */ if (_isPlaying) {
      _audioPlayer.pause();
    }
    print("[VoicePromptScreen] Navigating to select audio prompt.");
    Navigator.push(
      context,
      MaterialPageRoute(
          builder: (context) => AudioSelectPromptScreen(
                isEditing: widget.isEditing,
              )),
    ).then((_) {
      if (mounted) {
        setState(() {
          _selectedPrompt =
              ref.read(audioUploadProvider.notifier).selectedPrompt;
        });
        print(
            "[VoicePromptScreen] Returned from prompt selection. Selected: ${_selectedPrompt?.label}");
      }
    });
  }

  // --- *** MODIFIED SAVE METHOD *** ---
  Future<void> _saveProfileAndNavigate() async {
    print(
        '[VoicePromptScreen] Starting _saveProfileAndNavigate (isEditing: ${widget.isEditing})');
    final errorNotifier = ref.read(errorProvider.notifier);
    final userNotifier = ref.read(userProvider.notifier);
    final authNotifier =
        ref.read(authProvider.notifier); // Needed for status check
    errorNotifier.clearError();

    // Refresh local selected prompt state
    setState(() {
      _selectedPrompt = ref.read(audioUploadProvider.notifier).selectedPrompt;
    });

    if (_selectedPrompt == null) {
      print('[VoicePromptScreen] Validation Error: No audio prompt selected.');
      errorNotifier
          .setError(AppError.validation("Please select an audio prompt."));
      return;
    }

    bool isNewAudioRecording =
        _audioPath != null && File(_audioPath!).existsSync();
    bool audioPrepared = false;
    MediaUploadModel? audioUploadModel;
    String? finalAudioUrl =
        _existingAudioUrl; // Start with existing URL if editing

    // --- Audio Preparation (only if NEW recording exists) ---
    if (isNewAudioRecording) {
      print(
          '[VoicePromptScreen] New audio recording found at $_audioPath. Preparing for upload.');
      ref.read(audioUploadProvider.notifier).setRecordingPath(_audioPath!);
      audioPrepared = ref.read(audioUploadProvider.notifier).prepareAudioFile();
      if (!audioPrepared) {
        print('[VoicePromptScreen] Audio file preparation/validation failed.');
        return; // Error should be set by prepareAudioFile
      }
      audioUploadModel = ref.read(audioUploadProvider); // Get prepared model
      if (audioUploadModel == null) {
        print('[VoicePromptScreen] Error: Audio prepared but model is null.');
        errorNotifier
            .setError(AppError.generic("Error preparing audio model."));
        return;
      }
    } else if (_existingAudioUrl == null && !widget.isEditing) {
      // If onboarding and no existing URL AND no new recording, require recording
      print(
          '[VoicePromptScreen] Validation Error: No audio recorded for onboarding.');
      errorNotifier.setError(
          AppError.validation("Please record your voice prompt answer."));
      return;
    } else if (_existingAudioUrl != null) {
      print('[VoicePromptScreen] Using existing audio URL: $_existingAudioUrl');
    }
    // If editing and neither new nor existing audio, allow saving without audio (nulls it out later)

    setState(() => _isSaving = true);

    try {
      // --- *** STEP 1: Upload General Media (ONLY during ONBOARDING) *** ---
      if (!widget.isEditing) {
        print(
            "[VoicePromptScreen Onboarding] Attempting to upload general media...");
        final mediaSuccess =
            await ref.read(mediaUploadProvider.notifier).uploadAllMedia();
        if (!mediaSuccess) {
          print("[VoicePromptScreen Onboarding] General media upload failed.");
          // Error likely set by mediaUploadProvider, but set a generic one if not
          if (ref.read(errorProvider) == null) {
            errorNotifier
                .setError(AppError.server("Failed to upload photos/videos."));
          }
          throw ApiException(
              "Media upload failed during onboarding."); // Stop the process
        }
        print(
            "[VoicePromptScreen Onboarding] General media upload successful.");
      }
      // --- *** END General Media Upload Step *** ---

      // --- STEP 2: Upload Audio (if new recording exists) ---
      bool audioUploadedSuccessfully = true;
      if (isNewAudioRecording && audioPrepared && audioUploadModel != null) {
        print('[VoicePromptScreen] Attempting audio upload...');
        // Use the dedicated provider method which also updates userNotifier internally
        audioUploadedSuccessfully = await ref
            .read(audioUploadProvider.notifier)
            .uploadAudioAndSaveToProfile();

        if (!audioUploadedSuccessfully) {
          print('[VoicePromptScreen] Audio upload failed.');
          // Error should be set by audioUploadProvider
          throw ApiException("Audio upload failed."); // Stop the process
        }
        // Get the new URL from the successful upload state
        finalAudioUrl = ref
            .read(audioUploadProvider)
            ?.presignedUrl; // Read state AFTER upload
        print(
            '[VoicePromptScreen] Audio upload successful. New URL: $finalAudioUrl');
      } else if (!isNewAudioRecording && _existingAudioUrl != null) {
        // No NEW audio upload needed, just ensure user model is updated with existing URL and selected prompt
        print(
            '[VoicePromptScreen] No new audio upload needed. Updating user model with existing URL.');
        final currentAudioModel = AudioPromptModel(
            prompt: _selectedPrompt!, audioUrl: _existingAudioUrl!);
        userNotifier.updateAudioPrompt(currentAudioModel);
        finalAudioUrl = _existingAudioUrl; // Keep track of the URL
      } else if (widget.isEditing &&
          !isNewAudioRecording &&
          _existingAudioUrl == null) {
        print(
            '[VoicePromptScreen Editing] No existing or new audio. Setting audio prompt to null.');
        userNotifier.updateAudioPrompt(
            null); // Explicitly set to null when editing and no audio is provided
        finalAudioUrl = null;
      }
      // --- END Audio Upload Step ---

      // --- STEP 3: Save Profile (POST for Onboarding, PATCH for Editing) ---
      bool profileSaved = false;
      if (widget.isEditing) {
        print('[VoicePromptScreen Editing] Saving profile changes (PATCH)...');
        final latestUserState = ref.read(userProvider);
        final payload = latestUserState.toJsonForEdit();
        // Ensure audio prompt in payload is correct (null if removed, new URL if uploaded, existing if kept)
        if (finalAudioUrl != null) {
          payload['audio_prompt'] = AudioPromptModel(
                  prompt: _selectedPrompt!, audioUrl: finalAudioUrl)
              .toJson();
        } else {
          payload['audio_prompt'] = null; // Ensure it's null if no audio
        }
        // Media URLs are handled by the PATCH endpoint itself based on userProvider state
        // which was updated in MediaPickerScreen edit flow

        print("[VoicePromptScreen Editing] PATCH Payload: $payload");
        profileSaved =
            await ref.read(userRepositoryProvider).editProfile(payload);
      } else {
        // Onboarding flow
        print(
            '[VoicePromptScreen Onboarding] Saving profile details (POST)...');
        // The POST /api/profile doesn't take media/audio URLs.
        // Those uploads happened earlier and are linked via token.
        profileSaved = await userNotifier.saveProfile(); // Uses the POST method
      }
      // --- END Save Profile Step ---

      // --- STEP 4: Navigation ---
      if (profileSaved) {
        print('[VoicePromptScreen] Profile save successful.');
        if (widget.isEditing) {
          print("[VoicePromptScreen Editing] Popping back.");
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                  content: Text("Audio prompt updated!"),
                  backgroundColor: Colors.green),
            );
            Navigator.of(context).pop(); // Pop back to ProfileScreen
          }
        } else {
          // Onboarding success
          final finalStatus =
              await authNotifier.checkAuthStatus(updateState: true);
          if (mounted) {
            print(
                '[VoicePromptScreen Onboarding] Navigating to MainNavigationScreen. Status: $finalStatus');
            Navigator.of(context).pushAndRemoveUntil(
              MaterialPageRoute(builder: (_) => const MainNavigationScreen()),
              (route) => false,
            );
          }
        }
      } else {
        print('[VoicePromptScreen] Profile save failed.');
        // Error should be set by saveProfile/editProfile method
        if (mounted && ref.read(errorProvider) == null) {
          errorNotifier
              .setError(AppError.server("Failed to save profile changes."));
        }
      }
      // --- END Navigation ---
    } on ApiException catch (e) {
      print(
          '[VoicePromptScreen] Save Process Failed: API Exception - ${e.message}');
      if (mounted) errorNotifier.setError(AppError.server(e.message));
    } catch (e, stack) {
      // Catch unexpected errors
      print('[VoicePromptScreen] Save Process Failed: Unexpected Error - $e');
      print(stack); // Log stack trace
      if (mounted)
        errorNotifier.setError(AppError.generic(
            "An unexpected error occurred. Please try again."));
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }
  // --- *** END MODIFIED SAVE METHOD *** ---

  @override
  Widget build(BuildContext context) {
    // Build method layout remains the same, logic for enabling button updated
    final errorState = ref.watch(errorProvider);
    final bool hasSelection = _selectedPrompt != null;
    final bool hasAudioSource = _audioPath != null || _existingAudioUrl != null;
    final bool canSave = hasSelection &&
        (hasAudioSource ||
            (widget.isEditing &&
                _existingAudioUrl == null &&
                _audioPath == null)) &&
        !_isRecording; // Allow saving null in edit mode

    // --- UI Code (Mostly unchanged, uses local state _selectedPrompt, _audioPath, _existingAudioUrl) ---
    return Scaffold(
      /* ... Scaffold setup ... */
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(
                /* ... Header for Edit/Onboarding ... */
                padding: const EdgeInsets.only(top: 10.0, bottom: 10.0),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      const SizedBox(width: 48),
                    Text(
                      widget.isEditing ? "Edit Voice Prompt" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canSave && !_isSaving
                            ? _saveProfileAndNavigate
                            : null,
                        child: _isSaving
                            ? const SizedBox(
                                width: 20,
                                height: 20,
                                child:
                                    CircularProgressIndicator(strokeWidth: 2))
                            : Text(
                                "Done",
                                style: GoogleFonts.poppins(
                                  color: canSave
                                      ? const Color(0xFF8B5CF6)
                                      : Colors.grey,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                      )
                    else
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              if (!widget.isEditing) ...[
                /* ... Onboarding Dots ... */ const SizedBox(height: 10),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: List.generate(
                      3,
                      (index) => Container(
                            margin: const EdgeInsets.symmetric(horizontal: 4),
                            height: 10,
                            width: 10,
                            decoration: BoxDecoration(
                              color: index < 2
                                  ? Colors.grey[300]
                                  : const Color(0xFF8b5cf6),
                              shape: BoxShape.circle,
                            ),
                          )),
                ),
                const SizedBox(height: 20),
              ],
              Text(
                widget.isEditing
                    ? 'Edit your Voice Prompt'
                    : 'Add a Voice Prompt\nto your profile',
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing ? 28 : 32,
                  fontWeight: FontWeight.bold,
                  height: 1.2,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 12),
              Text(
                widget.isEditing
                    ? "Select a prompt and record your answer."
                    : "Let potential matches hear your voice!",
                style:
                    GoogleFonts.poppins(fontSize: 16, color: Colors.grey[600]),
              ),
              const SizedBox(height: 32),
              GestureDetector(
                /* ... Prompt Selection Row ... */
                onTap: _selectPrompt,
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: Colors.grey[300]!),
                    boxShadow: [
                      BoxShadow(
                          color: Colors.grey.withOpacity(0.1),
                          blurRadius: 5,
                          offset: const Offset(0, 2))
                    ],
                  ),
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          _selectedPrompt?.label ?? 'Select a prompt *',
                          style: GoogleFonts.poppins(
                            color: _selectedPrompt != null
                                ? Colors.black87
                                : Colors.grey[600],
                            fontSize: 16,
                            fontWeight: _selectedPrompt != null
                                ? FontWeight.w500
                                : FontWeight.normal,
                          ),
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(left: 8),
                        child: Icon(Icons.arrow_drop_down_rounded,
                            color: Colors.grey[800], size: 28),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 24),
              Expanded(
                child: GestureDetector(
                  /* ... Recording Area ... */
                  onTap: _isRecording ? null : _startRecording,
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(24),
                    decoration: BoxDecoration(
                      color: Colors.grey[50],
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(color: Colors.grey[200]!),
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          _recordingTime,
                          style: GoogleFonts.poppins(
                              color: Colors.grey[500], fontSize: 18),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          _isRecording
                              ? 'Recording...'
                              : (_audioPath == null && _existingAudioUrl == null
                                  ? 'Tap microphone to start (Max 30s)'
                                  : 'Tap microphone to re-record'),
                          textAlign: TextAlign.center,
                          style: GoogleFonts.poppins(
                              color: Colors.grey[600], fontSize: 16),
                        ),
                        const Spacer(),
                        GestureDetector(
                          onTap:
                              _isRecording ? _stopRecording : _startRecording,
                          child: Container(
                            padding: const EdgeInsets.all(24),
                            decoration: BoxDecoration(
                              color: _isRecording
                                  ? Colors.redAccent
                                  : const Color(0xFF8b5cf6),
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                    color: (_isRecording
                                            ? Colors.redAccent
                                            : const Color(0xFF8b5cf6))
                                        .withOpacity(0.3),
                                    blurRadius: 10,
                                    offset: const Offset(0, 4))
                              ],
                            ),
                            child: Icon(
                                _isRecording
                                    ? Icons.stop_rounded
                                    : Icons.mic_rounded,
                                color: Colors.white,
                                size: 36),
                          ),
                        ),
                        const Spacer(),
                        if ((_audioPath != null &&
                                File(_audioPath!).existsSync()) ||
                            _existingAudioUrl != null)
                          TextButton.icon(
                            onPressed: _playRecording,
                            style: TextButton.styleFrom(
                                foregroundColor: const Color(0xFF8b5cf6)),
                            icon: Icon(_isPlaying
                                ? Icons.pause_rounded
                                : Icons.play_arrow_rounded),
                            label: Text(
                              _isPlaying
                                  ? 'Pause'
                                  : 'Play ${_audioPath != null ? "recording" : "existing"}',
                              style: GoogleFonts.poppins(
                                  fontSize: 16, fontWeight: FontWeight.w500),
                            ),
                          )
                        else
                          const SizedBox(height: 48),
                      ],
                    ),
                  ),
                ),
              ),
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.only(top: 12.0, bottom: 8.0),
                  child: Center(
                    child: Text(
                      errorState.message,
                      style: GoogleFonts.poppins(
                          color: Colors.redAccent, fontSize: 14),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
              const SizedBox(height: 16),
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.centerRight,
                  child: Padding(
                    padding: const EdgeInsets.only(bottom: 24.0),
                    child: _isSaving
                        ? const CircularProgressIndicator(
                            color: Color(0xFF8b5cf6))
                        : FloatingActionButton(
                            heroTag: 'audio_save_fab',
                            onPressed: canSave ? _saveProfileAndNavigate : null,
                            backgroundColor: canSave
                                ? const Color(0xFF8b5cf6)
                                : Colors.grey.shade400,
                            foregroundColor: Colors.white,
                            child: const Icon(Icons.check_rounded),
                          ),
                  ),
                ),
              if (widget.isEditing) const SizedBox(height: 24),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    /* ... same as before ... */ print(
        "[VoicePromptScreen] Disposing screen...");
    _recordingTimer?.cancel();
    try {
      _audioRecorder.dispose();
    } catch (e) {
      print("Error disposing recorder: $e");
    }
    try {
      if (_audioPlayer.state == PlayerState.playing ||
          _audioPlayer.state == PlayerState.paused) {
        _audioPlayer.stop();
      }
      _audioPlayer.dispose();
    } catch (e) {
      print("Error disposing player: $e");
    }
    super.dispose();
  }
}



================================================
File: views/audiopromptsselect.dart
================================================
// File: views/audiopromptsselect.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/providers/audio_upload_provider.dart';

class AudioSelectPromptScreen extends ConsumerWidget {
  final bool isEditing; // <<< ADDED

  const AudioSelectPromptScreen({
    Key? key,
    this.isEditing = false, // <<< ADDED default
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentPrompt =
        ref.watch(audioUploadProvider.notifier).selectedPrompt;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // Add back button if editing? Or rely on close? Let's use close.
                  const SizedBox(width: 24), // Placeholder for alignment
                  const Text(
                    "Select a Prompt",
                    style: TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () => Navigator.pop(context), // Always pop back
                    child: const Icon(Icons.close, size: 24),
                  ),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                itemCount: AudioPrompt.values.length,
                itemBuilder: (context, index) {
                  final prompt = AudioPrompt.values[index];
                  final isSelected = prompt == currentPrompt;

                  return GestureDetector(
                    onTap: () {
                      ref
                          .read(audioUploadProvider.notifier)
                          .setSelectedPrompt(prompt);
                      // Pop back to VoicePromptScreen, which handles further nav
                      Navigator.pop(context);
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                        color: isSelected ? const Color(0xFFEDE9FE) : null,
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              prompt.label,
                              style: TextStyle(
                                fontSize: 18,
                                color: isSelected
                                    ? const Color(0xFF8B5CF6)
                                    : Colors.black87,
                                fontWeight: isSelected
                                    ? FontWeight.w600
                                    : FontWeight.normal,
                              ),
                            ),
                          ),
                          if (isSelected)
                            const Icon(
                              Icons.check_circle,
                              color: Color(0xFF8B5CF6),
                            ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/chat_screen.dart
================================================
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class ChatPlaceholderScreen extends StatelessWidget {
  const ChatPlaceholderScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey[100],
      appBar: AppBar(
        title: Text('Messages',
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 1,
        automaticallyImplyLeading: false, // No back button in a tab screen
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.chat_bubble_outline_rounded,
                size: 80, color: Colors.grey[400]),
            const SizedBox(height: 20),
            Text(
              'Chat Coming Soon!',
              style: GoogleFonts.poppins(fontSize: 18, color: Colors.grey[600]),
            ),
            const SizedBox(height: 10),
            Text(
              'Your conversations with matches will appear here.',
              textAlign: TextAlign.center,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[500]),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dating_intentions.dart
================================================
// File: lib/views/dating_intentions.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/utils/app_enums.dart';
import '../providers/user_provider.dart';
import 'height.dart'; // Keep for onboarding flow

class DatingIntentionsScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const DatingIntentionsScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<DatingIntentionsScreen> createState() =>
      _DatingIntentionsScreenState();
}

class _DatingIntentionsScreenState
    extends ConsumerState<DatingIntentionsScreen> {
  DatingIntention? _selectedIntention; // Local state for selection

  @override
  void initState() {
    super.initState();
    // Load current value if editing
    if (widget.isEditing) {
      _selectedIntention = ref.read(userProvider).datingIntention;
    }
  }

  void _handleNext() {
    if (_selectedIntention != null) {
      ref.read(userProvider.notifier).updateDatingIntention(_selectedIntention);
      if (widget.isEditing) {
        print("[DatingIntentionsScreen] Editing done, popping back.");
        Navigator.of(context).pop(); // Pop back to ProfileScreen
      } else {
        // Original onboarding navigation
        print("[DatingIntentionsScreen] Onboarding next: Height.");
        Navigator.push(
          context,
          MaterialPageRoute(
              builder: (context) => const HeightSelectionScreen()),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // Watch userState only to update UI if needed externally (unlikely here)
    // final userState = ref.watch(userProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            // --- Adjusted Header for Edit Mode ---
            Padding(
              padding: EdgeInsets.only(
                top: screenSize.height * 0.02,
                left: screenSize.width * 0.02,
                right: screenSize.width * 0.06,
              ),
              child: Row(
                mainAxisAlignment: widget.isEditing
                    ? MainAxisAlignment.spaceBetween
                    : MainAxisAlignment.start,
                children: [
                  if (widget.isEditing)
                    IconButton(
                      icon: const Icon(Icons.close, color: Colors.grey),
                      onPressed: () => Navigator.of(context).pop(),
                    )
                  else
                    const SizedBox(
                        width:
                            40), // Placeholder for alignment during onboarding

                  Text(
                    widget.isEditing
                        ? "Edit Intention"
                        : "", // Title only in edit mode
                    style: GoogleFonts.poppins(
                        fontSize: 18, fontWeight: FontWeight.w600),
                  ),
                  if (widget.isEditing)
                    TextButton(
                      onPressed:
                          _selectedIntention != null ? _handleNext : null,
                      child: Text(
                        "Done",
                        style: GoogleFonts.poppins(
                          color: _selectedIntention != null
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    )
                  else
                    const SizedBox(width: 40), // Placeholder during onboarding
                ],
              ),
            ),
            // --- End Adjusted Header ---
            Padding(
              padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06)
                  .copyWith(
                      top: widget.isEditing
                          ? 20
                          : screenSize.height *
                              0.01), // Less top padding if editing
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (!widget.isEditing) // Show title only during onboarding
                    Text(
                      "What's your dating intention?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width * 0.065,
                        fontWeight: FontWeight.bold,
                        color: Colors.black,
                      ),
                    ),
                  SizedBox(height: widget.isEditing ? 30 : 65),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                physics: const BouncingScrollPhysics(),
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                itemCount: DatingIntention.values.length,
                itemBuilder: (context, index) {
                  return _buildOption(DatingIntention.values[index]);
                },
              ),
            ),
            // --- Hide FAB in Edit Mode ---
            if (!widget.isEditing)
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding:
                      EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
                  child: GestureDetector(
                    onTap: _selectedIntention != null
                        ? _handleNext
                        : null, // Use local state
                    child: Container(
                      width: 56,
                      height: 56,
                      decoration: BoxDecoration(
                        color: _selectedIntention != null
                            ? const Color(0xFF8B5CF6)
                            : Colors.grey.shade300,
                        shape: BoxShape.circle,
                        boxShadow: [
                          if (_selectedIntention != null)
                            BoxShadow(
                              color: Colors.black.withOpacity(0.2),
                              spreadRadius: 1,
                              blurRadius: 8,
                            ),
                        ],
                      ),
                      child: Icon(
                        Icons.arrow_forward_rounded,
                        size: 28,
                        color: _selectedIntention != null
                            ? Colors.white
                            : Colors.grey.shade500,
                      ),
                    ),
                  ),
                ),
              ),
            // --- End Hide FAB ---
            SizedBox(height: screenSize.height * 0.04),
          ],
        ),
      ),
    );
  }

  Widget _buildOption(DatingIntention intention) {
    final bool isSelected = _selectedIntention == intention; // Use local state

    return GestureDetector(
      onTap: () {
        setState(() {
          // Update local state
          _selectedIntention = intention;
        });
        // No need to update provider here, only on save/next
      },
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 16),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.transparent,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade300,
            width: 1.5,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Text(
                intention.label,
                style: GoogleFonts.poppins(
                  fontSize: intention.label.length > 20 ? 14 : 16,
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                  color: isSelected ? Colors.white : Colors.black,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            if (isSelected)
              const Icon(
                Icons.check_circle,
                color: Colors.white,
                size: 24,
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/dob.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/dating_intentions.dart';
import 'package:dtx/views/location.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class DateOfBirthScreen extends ConsumerStatefulWidget {
  const DateOfBirthScreen({super.key});

  @override
  ConsumerState<DateOfBirthScreen> createState() => _DateOfBirthScreenState();
}

class _DateOfBirthScreenState extends ConsumerState<DateOfBirthScreen> {
  final TextEditingController _dayController = TextEditingController();
  final TextEditingController _monthController = TextEditingController();
  final TextEditingController _yearController = TextEditingController();

  final FocusNode _dayFocusNode = FocusNode();
  final FocusNode _monthFocusNode = FocusNode();
  final FocusNode _yearFocusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    _dayFocusNode.addListener(() {
      if (!_dayFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _monthFocusNode.addListener(() {
      if (!_monthFocusNode.hasFocus) {
        _validateInputs();
      }
    });
    _yearFocusNode.addListener(() {
      if (!_yearFocusNode.hasFocus) {
        _validateInputs();
      }
    });
  }

  @override
  void dispose() {
    _dayController.dispose();
    _monthController.dispose();
    _yearController.dispose();
    _dayFocusNode.dispose();
    _monthFocusNode.dispose();
    _yearFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.1),
                Text(
                  "What's your date of birth?",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.08,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    _buildDateInput(
                      "DD",
                      _dayController,
                      _dayFocusNode,
                      2,
                      _monthFocusNode,
                    ),
                    _buildDateInput(
                      "MM",
                      _monthController,
                      _monthFocusNode,
                      2,
                      _yearFocusNode,
                    ),
                    _buildDateInput(
                      "YYYY",
                      _yearController,
                      _yearFocusNode,
                      4,
                      null,
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.03),
                Text(
                  "We use this to calculate the age on your profile.",
                  style: GoogleFonts.poppins(
                    fontSize: screenSize.width * 0.04,
                    color: Colors.white70,
                  ),
                ),
                if (error?.type == ErrorType.validation)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      error!.message,
                      style: GoogleFonts.poppins(
                        color: Colors.redAccent,
                        fontSize: screenSize.width * 0.035,
                      ),
                    ),
                  ),
                const Spacer(),
                _buildNextButton(screenSize),
                SizedBox(height: screenSize.height * 0.05),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDateInput(
    String hint,
    TextEditingController controller,
    FocusNode focusNode,
    int maxLength,
    FocusNode? nextFocusNode,
  ) {
    return Expanded(
      flex: maxLength == 4 ? 2 : 1,
      child: TextField(
        controller: controller,
        focusNode: focusNode,
        keyboardType: TextInputType.number,
        maxLength: maxLength,
        style: GoogleFonts.poppins(
          fontSize: 24,
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
        decoration: InputDecoration(
          hintText: hint,
          hintStyle: GoogleFonts.poppins(
            fontSize: 24,
            fontWeight: FontWeight.w500,
            color: Colors.white70,
          ),
          counterText: "",
          enabledBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white54, width: 2.0),
          ),
          focusedBorder: const UnderlineInputBorder(
            borderSide: BorderSide(color: Colors.white, width: 2.5),
          ),
        ),
        textAlign: TextAlign.center,
        onChanged: (value) {
          if (value.length == maxLength) {
            focusNode.unfocus();
            if (nextFocusNode != null) {
              FocusScope.of(context).requestFocus(nextFocusNode);
            }
          }
          _validateInputs();
        },
      ),
    );
  }

  void _validateInputs() {
    ref.read(errorProvider.notifier).clearError();
    final day = int.tryParse(_dayController.text) ?? 0;
    final month = int.tryParse(_monthController.text) ?? 0;
    final year = int.tryParse(_yearController.text) ?? 0;

    if (_dayController.text.isEmpty ||
        _monthController.text.isEmpty ||
        _yearController.text.isEmpty) return;

    if (day < 1 || day > 31) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid day"),
          );
      return;
    }

    if (month < 1 || month > 12) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid month"),
          );
      return;
    }

    try {
      final date = DateTime(year, month, day);
      ref.read(userProvider.notifier).updateDateOfBirth(date);
    } catch (e) {
      ref.read(errorProvider.notifier).setError(
            AppError.validation("Invalid date combination"),
          );
    }
  }

  Widget _buildNextButton(Size screenSize) {
    final isValid = _dayController.text.length == 2 &&
        _monthController.text.length == 2 &&
        _yearController.text.length == 4 &&
        ref.read(errorProvider) == null;

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: isValid ? _handleNext : null,
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: isValid ? Colors.white : Colors.grey.shade400,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: const EdgeInsets.all(16),
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24,
          color: isValid ? const Color(0xFF8B5CF6) : Colors.white54,
        ),
      ),
    );
  }

  void _handleNext() {
    final date = DateTime(
      int.parse(_yearController.text),
      int.parse(_monthController.text),
      int.parse(_dayController.text),
    );

    ref.read(userProvider.notifier).updateDateOfBirth(date);
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DatingIntentionsScreen()),
    );
  }
}



================================================
File: views/drinking.dart
================================================
// File: lib/views/drinking.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/smoking.dart'; // Keep for onboarding flow

class DrinkingScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const DrinkingScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<DrinkingScreen> createState() => _DrinkingScreenState();
}

class _DrinkingScreenState extends ConsumerState<DrinkingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedDrinkingHabit; // Local state
  // Removed _isOptionSelected, use _selectedDrinkingHabit directly
  late AnimationController _controller; // Keep for animations if desired
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );

    // Load initial value if editing
    if (widget.isEditing) {
      _selectedDrinkingHabit = ref.read(userProvider).drinkingHabit;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleNext() {
    if (_selectedDrinkingHabit != null) {
      ref
          .read(userProvider.notifier)
          .updateDrinkingHabit(_selectedDrinkingHabit);
      if (widget.isEditing) {
        print("[DrinkingScreen] Editing done, popping back.");
        Navigator.of(context).pop();
      } else {
        // Original onboarding navigation
        print("[DrinkingScreen] Onboarding next: Smoking.");
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const SmokingScreen()));
      }
    } else {
      // This should not happen if button is properly disabled, but as a fallback
      if (!widget.isEditing) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content:
                Text("Please select an option", style: GoogleFonts.poppins()),
            backgroundColor: Colors.red[400],
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically
    final bool canProceed = _selectedDrinkingHabit != null; // Check local state

    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder icon for onboarding
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: const Icon(Icons.local_bar_rounded,
                            color: Color(0xFF8B5CF6),
                            size: 30), // Slightly smaller icon
                      ),
                    Text(
                      widget.isEditing ? "Edit Drinking Habit" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canProceed ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for onboarding
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.03),
              Text(
                widget.isEditing
                    ? "Edit your drinking habits"
                    : "Do you drink?",
                textAlign: TextAlign.left,
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.07
                      : screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  height: 1.1,
                ),
              ),
              if (!widget.isEditing) // Show subtitle only during onboarding
                Text(
                  "Select your drinking habits",
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    color: Colors.grey[600],
                    height: 1.5,
                  ),
                ),
              SizedBox(height: screenSize.height * 0.04),
              Expanded(
                child: ListView.separated(
                  itemCount: DrinkingSmokingHabits.values.length,
                  separatorBuilder: (context, index) =>
                      const SizedBox(height: 12),
                  itemBuilder: (context, index) {
                    final habit = DrinkingSmokingHabits.values[index];
                    return _buildDrinkingOptionTile(
                      screenSize: screenSize,
                      title: habit.label,
                      value: habit,
                    );
                  },
                ),
              ),
              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: AnimatedScale(
                      scale: canProceed ? 1.0 : 0.95, // Use local state
                      duration: const Duration(milliseconds: 200),
                      child: GestureDetector(
                        onTap: _handleNext, // Use unified handler
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey.shade300,
                            borderRadius: BorderRadius.circular(35),
                            boxShadow: canProceed
                                ? [
                                    BoxShadow(
                                      color: const Color(0xFF8B5CF6)
                                          .withOpacity(0.3),
                                      blurRadius: 8,
                                      offset: const Offset(0, 4),
                                    ),
                                  ]
                                : null,
                          ),
                          child: Icon(
                            Icons.arrow_forward_rounded,
                            color: canProceed
                                ? Colors.white
                                : Colors.grey.shade600,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildDrinkingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedDrinkingHabit == value; // Use local state

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedDrinkingHabit = value; // Update local state
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/filter_settings_dialog.dart
================================================
// File: lib/views/filter_settings_dialog.dart
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class FilterSettingsDialog extends ConsumerStatefulWidget {
  const FilterSettingsDialog({super.key});

  @override
  ConsumerState<FilterSettingsDialog> createState() =>
      _FilterSettingsDialogState();
}

class _FilterSettingsDialogState extends ConsumerState<FilterSettingsDialog> {
  late FilterSettings _currentFilters;
  late RangeValues _currentAgeRange;
  late double _currentRadius;
  bool _isLoading = false; // Local loading state for saving

  @override
  void initState() {
    super.initState();
    // Initialize local state with current provider state when dialog opens
    final initialFilters = ref.read(filterProvider);
    _currentFilters = initialFilters;
    _currentAgeRange = RangeValues(
      initialFilters.ageMin?.toDouble() ??
          FilterSettings.defaultAgeMin.toDouble(),
      initialFilters.ageMax?.toDouble() ??
          FilterSettings.defaultAgeMax.toDouble(),
    );
    _currentRadius = initialFilters.radiusKm?.toDouble() ??
        FilterSettings.defaultRadius.toDouble();
  }

  Future<void> _applyFilters() async {
    if (_isLoading) return; // Prevent double taps

    setState(() => _isLoading = true);

    final newSettings = _currentFilters.copyWith(
      ageMin: () => _currentAgeRange.start.round(),
      ageMax: () => _currentAgeRange.end.round(),
      radiusKm: () => _currentRadius.round(),
      // whoYouWantToSee and activeToday are already updated in _currentFilters via setState
    );

    final success =
        await ref.read(filterProvider.notifier).saveFilters(newSettings);

    // Check if mounted before interacting with context or state
    if (!mounted) return;

    setState(() => _isLoading = false);

    if (success) {
      print(
          "[FilterSettingsDialog] Filters saved successfully. Refreshing feed.");
      // Trigger feed refresh AFTER saving filters
      ref.read(feedProvider.notifier).fetchFeed(forceRefresh: true);
      Navigator.of(context).pop(true); // Pop dialog and indicate success
    } else {
      // Error handling is likely done via the errorProvider in FilterNotifier
      // Optionally show a snackbar here too if desired.
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content:
                Text("Failed to save filters", style: GoogleFonts.poppins())),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // No need to watch provider's loading state directly, use local _isLoading for save button

    return AlertDialog(
      title: Text("Filters",
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
      contentPadding: const EdgeInsets.fromLTRB(20, 20, 20, 0),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // --- Who You Want To See ---
            Text("Show Me:",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: FilterGenderPref.values.map((genderPref) {
                return ChoiceChip(
                  label: Text(genderPref.value[0].toUpperCase() +
                      genderPref.value.substring(1)),
                  selected: _currentFilters.whoYouWantToSee == genderPref,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        // Use copyWith for immutability when updating local state
                        _currentFilters = _currentFilters.copyWith(
                            whoYouWantToSee: () => genderPref);
                      });
                    }
                  },
                  selectedColor: const Color(0xFFEDE9FE),
                  checkmarkColor: const Color(0xFF8B5CF6),
                  labelStyle: GoogleFonts.poppins(
                    color: _currentFilters.whoYouWantToSee == genderPref
                        ? const Color(0xFF8B5CF6)
                        : Colors.black87,
                  ),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                      side: BorderSide(
                          color: _currentFilters.whoYouWantToSee == genderPref
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey.shade300)),
                  backgroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 10),
                );
              }).toList(),
            ),
            const SizedBox(height: 20),

            // --- Age Range ---
            Text("Age Range:",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
            RangeSlider(
              values: _currentAgeRange,
              min: 18,
              max: 70,
              divisions: 52,
              labels: RangeLabels(
                _currentAgeRange.start.round().toString(),
                _currentAgeRange.end.round().toString(),
              ),
              activeColor: const Color(0xFF8B5CF6),
              inactiveColor: const Color(0xFF8B5CF6).withOpacity(0.3),
              onChanged: (RangeValues values) {
                setState(() {
                  if (values.start <= values.end) {
                    _currentAgeRange = values;
                  }
                });
              },
            ),
            Text(
              "${_currentAgeRange.start.round()} - ${_currentAgeRange.end.round()} years",
              style: GoogleFonts.poppins(color: Colors.grey[600], fontSize: 12),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),

            // --- Distance Radius ---
            Text("Distance (km):",
                style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
            Slider(
              value: _currentRadius,
              min: 1,
              max: 500,
              divisions: 499,
              label: _currentRadius.round().toString(),
              activeColor: const Color(0xFF8B5CF6),
              inactiveColor: const Color(0xFF8B5CF6).withOpacity(0.3),
              onChanged: (double value) {
                setState(() {
                  _currentRadius = value;
                });
              },
            ),
            Text(
              "${_currentRadius.round()} km",
              style: GoogleFonts.poppins(color: Colors.grey[600], fontSize: 12),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),

            // --- Active Today ---
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text("Active Today Only:",
                    style: GoogleFonts.poppins(fontWeight: FontWeight.w500)),
                Switch(
                  value: _currentFilters.activeToday ??
                      FilterSettings.defaultActiveToday,
                  activeColor: const Color(0xFF8B5CF6),
                  onChanged: (bool value) {
                    setState(() {
                      _currentFilters =
                          _currentFilters.copyWith(activeToday: () => value);
                    });
                  },
                ),
              ],
            ),
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: Text('Cancel', style: GoogleFonts.poppins(color: Colors.grey)),
          onPressed: () =>
              Navigator.of(context).pop(false), // Indicate no change
        ),
        ElevatedButton(
          style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF8B5CF6),
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20))),
          onPressed: _isLoading ? null : _applyFilters, // Disable while saving
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                      strokeWidth: 2, color: Colors.white))
              : Text('Apply', style: GoogleFonts.poppins()),
        ),
      ],
      actionsPadding: const EdgeInsets.symmetric(horizontal: 15, vertical: 10),
    );
  }
}



================================================
File: views/gender.dart
================================================
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart'; // Import FilterProvider
import 'package:dtx/services/api_service.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:dtx/views/main_navigation_screen.dart'; // Import MainNavigationScreen
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../models/error_model.dart';
import '../providers/user_provider.dart';
import '../providers/error_provider.dart';
import '../providers/service_provider.dart';
// Removed Home import

class GenderSelectionScreen extends ConsumerStatefulWidget {
  const GenderSelectionScreen({super.key});

  @override
  ConsumerState<GenderSelectionScreen> createState() =>
      _GenderSelectionScreenState();
}

class _GenderSelectionScreenState extends ConsumerState<GenderSelectionScreen> {
  bool _isSubmitting = false;

  void _initiateEarlyFetches() {
    print(
        "[GenderSelectionScreen] Initiating early data fetches (Filters, HomeFeed).");
    // Don't await, let them run in background
    ref.read(filterProvider.notifier).loadFilters();
    ref.read(feedProvider.notifier).fetchFeed();
  }

  Future<void> _submitLocationAndGender() async {
    final userState = ref.read(userProvider);
    final errorNotifier = ref.read(errorProvider.notifier);
    final authNotifier = ref.read(authProvider.notifier);

    errorNotifier.clearError();

    if (userState.latitude == null || userState.longitude == null) {
      errorNotifier.setError(
          AppError.validation("Location data is missing. Please go back."));
      return;
    }
    if (userState.gender == null) {
      errorNotifier.setError(AppError.validation("Please select a gender."));
      return;
    }

    setState(() => _isSubmitting = true);

    try {
      final userRepository = ref.read(userRepositoryProvider);
      final success = await userRepository.updateLocationGender(
        userState.latitude!,
        userState.longitude!,
        userState.gender!,
      );

      if (success) {
        print(
            "[GenderSelectionScreen] Location/Gender submitted successfully.");
        final finalStatus =
            await authNotifier.checkAuthStatus(updateState: true);
        print("[GenderSelectionScreen] Auth status updated to: $finalStatus");

        if (mounted) {
          Widget nextScreen;
          // Navigate to MainNavigationScreen if onboarding is complete (status onboarding2 or home)
          if (finalStatus == AuthStatus.onboarding2 ||
              finalStatus == AuthStatus.home) {
            print(
                "[GenderSelectionScreen] Navigating to MainNavigationScreen.");
            _initiateEarlyFetches(); // Start loading data
            nextScreen = const MainNavigationScreen();
          } else {
            // Fallback to GoogleSignInScreen if status is unexpectedly login/unknown
            print(
                "[GenderSelectionScreen] Unexpected status ($finalStatus), navigating to GoogleSignInScreen.");
            nextScreen = const GoogleSignInScreen();
          }

          Navigator.pushAndRemoveUntil(
            context,
            MaterialPageRoute(builder: (context) => nextScreen),
            (Route<dynamic> route) => false,
          );
        }
      } else {
        print(
            "[GenderSelectionScreen] Location/Gender submission failed (API returned false).");
        if (ref.read(errorProvider) == null) {
          errorNotifier
              .setError(AppError.server("Failed to update location/gender."));
        }
      }
    } on ApiException catch (e) {
      print(
          "[GenderSelectionScreen] API Exception during submit: ${e.message}");
      errorNotifier.setError(AppError.server(e.message));
    } catch (e) {
      print(
          "[GenderSelectionScreen] Unexpected error during submit: ${e.toString()}");
      errorNotifier.setError(
          AppError.generic("An unexpected error occurred. Please try again."));
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Build method remains largely the same, only navigation logic changed
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);
    final errorState = ref.watch(errorProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.03),
              Align(
                alignment: Alignment.topLeft,
                child: IconButton(
                  icon: Icon(Icons.arrow_back_ios_new, color: Colors.grey[600]),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              Text(
                "Which gender best\ndescribes you?",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.075,
                  fontWeight: FontWeight.bold,
                  color: Colors.black,
                  height: 1.2,
                ),
              ),
              SizedBox(height: screenSize.height * 0.05),
              Column(
                children: [Gender.man, Gender.woman]
                    .map((gender) => _buildOption(gender))
                    .toList(),
              ),
              const Spacer(),
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.only(bottom: 10.0),
                  child: Text(
                    errorState.message,
                    style: GoogleFonts.poppins(
                        color: Colors.redAccent, fontSize: 14),
                    textAlign: TextAlign.center,
                  ),
                ),
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding: const EdgeInsets.only(bottom: 20.0),
                  child: _isSubmitting
                      ? const CircularProgressIndicator(
                          color: Color(0xFF8B5CF6))
                      : FloatingActionButton(
                          heroTag: 'gender_next_fab',
                          onPressed: userState.gender != null
                              ? _submitLocationAndGender
                              : null,
                          backgroundColor: userState.gender != null
                              ? const Color(0xFF8B5CF6)
                              : Colors.grey.shade300,
                          foregroundColor: Colors.white,
                          child: const Icon(Icons.arrow_forward_rounded),
                        ),
                ),
              ),
              SizedBox(height: screenSize.height * 0.02),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOption(Gender gender) {
    // _buildOption implementation remains the same
    final bool isSelected = ref.watch(userProvider).gender == gender;
    final errorNotifier = ref.read(errorProvider.notifier);

    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: Material(
        borderRadius: BorderRadius.circular(12),
        color: isSelected ? const Color(0xFFEDE9FE) : Colors.grey.shade50,
        elevation: isSelected ? 1 : 0,
        shadowColor: const Color(0xFF8B5CF6).withOpacity(0.3),
        child: InkWell(
          onTap: () {
            errorNotifier.clearError();
            ref.read(userProvider.notifier).updateGender(gender);
          },
          borderRadius: BorderRadius.circular(12),
          child: Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color:
                    isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade300,
                width: isSelected ? 1.5 : 1,
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  gender.label,
                  style: GoogleFonts.poppins(
                    fontSize: 18,
                    fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
                    color: isSelected
                        ? const Color(0xFF8B5CF6)
                        : Colors.grey.shade800,
                  ),
                ),
                if (isSelected)
                  const Icon(
                    Icons.check_circle_outline_rounded,
                    color: Color(0xFF8B5CF6),
                    size: 24,
                  )
                else
                  Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      border:
                          Border.all(color: Colors.grey.shade400, width: 1.5),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/google_sign_in_screen.dart
================================================
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart'; // Import FilterProvider
import 'package:dtx/views/location.dart';
import 'package:dtx/views/main_navigation_screen.dart'; // Import MainNavigationScreen
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/models/auth_model.dart';
// Removed FeedType import
// Removed Home import
// Removed NameInputScreen import

class GoogleSignInScreen extends ConsumerWidget {
  const GoogleSignInScreen({super.key});

  void _initiateEarlyFetches(WidgetRef ref) {
    print(
        "[GoogleSignInScreen] Initiating early data fetches (Filters, HomeFeed).");
    // Don't await, let them run in background
    ref.read(filterProvider.notifier).loadFilters();
    ref.read(feedProvider.notifier).fetchFeed();
  }

  Future<void> _handleSignIn(BuildContext context, WidgetRef ref) async {
    final status = await ref.read(authProvider.notifier).signInWithGoogle();
    if (!context.mounted) return;

    Widget destination;
    switch (status) {
      case AuthStatus.home:
      case AuthStatus.onboarding2: // Both go to main screen now
        print('[GoogleSignInScreen] Navigating to MainNavigationScreen');
        _initiateEarlyFetches(ref); // Start loading data
        destination = const MainNavigationScreen();
        break;
      case AuthStatus.onboarding1:
        print('[GoogleSignInScreen] Navigating to LocationInputScreen');
        destination = const LocationInputScreen();
        break;
      case AuthStatus.login:
      case AuthStatus.unknown:
      default:
        // Stay on this screen if sign-in failed or status is unexpected
        print(
            '[GoogleSignInScreen] Sign in failed or status unknown/login. Staying on screen.');
        return;
    }
    // Use pushReplacement to prevent going back to the sign-in screen
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(builder: (context) => destination),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Build method remains largely the same, only navigation logic changed
    final authState = ref.watch(authProvider);
    final errorState = ref.watch(errorProvider);
    final screenSize = MediaQuery.of(context).size;

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  const Spacer(flex: 2),
                  Text(
                    'Peeple',
                    style: GoogleFonts.pacifico(
                      fontSize: screenSize.width * 0.15,
                      color: Colors.white,
                      shadows: [
                        Shadow(
                          color: Colors.black.withOpacity(0.5),
                          blurRadius: 10,
                          offset: const Offset(2, 2),
                        ),
                      ],
                    ),
                  ),
                  SizedBox(height: screenSize.height * 0.03),
                  Text(
                    'Connect Authentically',
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.045,
                      color: Colors.white.withOpacity(0.8),
                      fontWeight: FontWeight.w300,
                    ),
                  ),
                  const Spacer(flex: 3),
                  if (authState.isLoading)
                    const CircularProgressIndicator(color: Colors.white)
                  else
                    ElevatedButton.icon(
                      icon: Image.asset('assets/google_logo.png',
                          height: 24.0,
                          errorBuilder: (context, error, stackTrace) =>
                              const Icon(Icons.login, size: 24)),
                      label: Text(
                        'Sign In with Google',
                        style: GoogleFonts.poppins(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                            color: Colors.black87),
                      ),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.white,
                        foregroundColor: Colors.black87,
                        minimumSize: const Size(double.infinity, 50),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                      onPressed: () => _handleSignIn(context, ref),
                    ),
                  SizedBox(height: screenSize.height * 0.02),
                  if (errorState != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 15.0),
                      child: Text(
                        errorState.message,
                        textAlign: TextAlign.center,
                        style: GoogleFonts.poppins(
                          color: Colors.redAccent[100],
                          fontSize: 14,
                        ),
                      ),
                    ),
                  const Spacer(flex: 1),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 20.0),
                    child: Text(
                      'By signing in, you agree to our Terms of Service and Privacy Policy.',
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                        fontSize: 12,
                        color: Colors.white.withOpacity(0.6),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/height.dart
================================================
// File: lib/views/height.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
// Removed unused app_enums import
import '../providers/user_provider.dart';
import 'hometown.dart'; // Keep for onboarding flow

class HeightSelectionScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const HeightSelectionScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<HeightSelectionScreen> createState() =>
      _HeightSelectionScreenState();
}

class _HeightSelectionScreenState extends ConsumerState<HeightSelectionScreen> {
  String _unit = "FT"; // Default unit is Feet
  int _selectedFeetIndex = 0; // Start at the first index (4' 0")
  int _selectedCmIndex = 30; // Start at 150 cm (index 30 for 120cm base)

  // Define the starting and ending points explicitly
  int _startFeet = 4;
  int _startInches = 0;
  int _endFeet = 7; // Extended range up to 7'0"
  int _endInches = 0;

  int _startCm = 120;
  int _endCm = 213; // Approx 7'0"

  late List<String> _feetValues;
  late List<String> _cmValues;

  String _initialHeightValue = ''; // Store initial value for comparison/reset

  // Function to convert CM to Feet and Inches string
  String _cmToFeet(int cm) {
    double totalInches = cm * 0.393701;
    int feet = (totalInches / 12).floor();
    int inches = (totalInches % 12).round();
    if (inches == 12) {
      feet++;
      inches = 0;
    }
    return "$feet' $inches\""; // API format
  }

  // Function to convert Feet and Inches string to CM
  int _feetToCm(String feetInchStr) {
    try {
      final parts = feetInchStr.replaceAll('"', '').split("'");
      if (parts.length == 2) {
        final feet = int.tryParse(parts[0]) ?? 0;
        final inches = int.tryParse(parts[1]) ?? 0;
        double totalInches = (feet * 12) + inches.toDouble();
        return (totalInches / 0.393701).round();
      }
    } catch (e) {
      print("Error parsing height $feetInchStr: $e");
    }
    return _startCm; // Default fallback
  }

  @override
  void initState() {
    super.initState();

    // Generate Feet Values (4'0" to 7'0")
    _feetValues = List.generate(
      ((_endFeet * 12) + _endInches) - ((_startFeet * 12) + _startInches) + 1,
      (index) {
        int totalInches = ((_startFeet * 12) + _startInches) + index;
        int feet = totalInches ~/ 12;
        int inches = totalInches % 12;
        return "$feet' $inches\""; // API format
      },
    );

    // Generate CM Values (120cm to 213cm)
    _cmValues = List.generate(
        _endCm - _startCm + 1, (index) => "${_startCm + index} cm");

    // Load initial value if editing
    if (widget.isEditing) {
      final currentHeight = ref.read(userProvider).height;
      _initialHeightValue = currentHeight ?? '';
      if (currentHeight != null && currentHeight.isNotEmpty) {
        // Determine initial unit and index
        if (currentHeight.contains("'")) {
          // Assume FT format
          _unit = "FT";
          _selectedFeetIndex = _feetValues.indexOf(currentHeight);
          if (_selectedFeetIndex == -1) _selectedFeetIndex = 0; // Fallback
        } else if (currentHeight.toLowerCase().contains('cm')) {
          // Assume CM format (unlikely based on save logic, but check)
          _unit = "CM";
          _selectedCmIndex = _cmValues.indexOf(currentHeight);
          if (_selectedCmIndex == -1) _selectedCmIndex = 30; // Fallback ~150cm
        } else {
          // If format is unknown, try parsing as FT
          _unit = "FT";
          _selectedFeetIndex = _feetValues.indexOf(currentHeight);
          if (_selectedFeetIndex == -1) _selectedFeetIndex = 0; // Fallback
        }
      } else {
        // Default if no existing height
        _unit = "FT";
        _selectedFeetIndex = 11; // Default to 5'11" approx
      }
    } else {
      // Default for onboarding
      _unit = "FT";
      _selectedFeetIndex = 11; // Default to 5'11" approx
    }
  }

  void _handleNext() {
    _updateHeight(ref, forceUpdate: true); // Ensure provider is updated
    if (widget.isEditing) {
      print("[HeightSelectionScreen] Editing done, popping back.");
      Navigator.of(context).pop(); // Pop back to ProfileScreen
    } else {
      // Original onboarding navigation
      print("[HeightSelectionScreen] Onboarding next: Hometown.");
      Navigator.push(
        context,
        MaterialPageRoute(builder: (context) => const HometownScreen()),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState =
        ref.watch(userProvider); // Watch for external updates if needed

    // Use appropriate values for the current unit
    final List<String> currentValues = _unit == "FT" ? _feetValues : _cmValues;
    int currentIndex = _unit == "FT" ? _selectedFeetIndex : _selectedCmIndex;

    // Check if the current value in the provider matches the displayed value
    final bool hasValueChanged = (_unit == "FT" &&
            userState.height != _feetValues[currentIndex]) ||
        (_unit == "CM" &&
            userState.height !=
                _cmToFeet(
                    int.parse(_cmValues[currentIndex].replaceAll(" cm", ""))));

    // Determine if the "Done" button should be enabled
    final bool canProceed =
        userState.height != null && userState.height!.isNotEmpty;

    // --- Create FixedExtentScrollController ---
    final scrollController =
        FixedExtentScrollController(initialItem: currentIndex);

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4), // Light background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: widget.isEditing
                      ? MainAxisAlignment.spaceBetween
                      : MainAxisAlignment.start,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      const SizedBox(width: 40), // Placeholder

                    Text(
                      widget.isEditing ? "Edit Height" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canProceed ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      const SizedBox(width: 40), // Placeholder
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(
                  height: widget.isEditing ? 40 : screenSize.height * 0.02),

              // Title (Shown in both modes, slightly smaller in edit)
              Center(
                child: Text(
                  "How tall are you?",
                  style: GoogleFonts.poppins(
                    fontSize: widget.isEditing
                        ? screenSize.width * 0.08
                        : screenSize.width * 0.1,
                    fontWeight: FontWeight.w700, // More bold title
                    color: const Color(0xFF333333), // Darker title color
                  ),
                ),
              ),

              SizedBox(
                  height: screenSize.height *
                      0.05), // Increased spacing below title

              // Height Selector
              Expanded(
                child: ListWheelScrollView.useDelegate(
                  controller: scrollController, // Use the controller
                  itemExtent: 70, // Increased item extent for better spacing
                  diameterRatio: 1.3, // Adjusted for better visual
                  physics: const FixedExtentScrollPhysics(),
                  onSelectedItemChanged: (index) {
                    setState(() {
                      if (_unit == "FT") {
                        _selectedFeetIndex = index;
                      } else {
                        _selectedCmIndex = index;
                      }
                      // Update provider immediately on scroll change
                      _updateHeight(ref);
                    });
                  },
                  childDelegate: ListWheelChildBuilderDelegate(
                    childCount: currentValues.length,
                    builder: (context, index) {
                      final isSelected = index == currentIndex;
                      return Center(
                        child: Text(
                          currentValues[index],
                          style: GoogleFonts.poppins(
                            fontSize: isSelected
                                ? 30
                                : 22, // Larger font sizes for list items
                            fontWeight: isSelected
                                ? FontWeight.w600
                                : FontWeight.w400, // Adjusted weight
                            color: isSelected
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey
                                    .shade700, // Highlighted selected color, darker unselected
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ),

              SizedBox(
                  height: screenSize.height *
                      0.03), // Reduced spacing above buttons

              // Unit Toggle Buttons - Improved UI
              Padding(
                padding: EdgeInsets.symmetric(
                    horizontal: screenSize.width *
                        0.1), // Add horizontal padding for buttons
                child: Row(
                  mainAxisAlignment:
                      MainAxisAlignment.spaceAround, // Space buttons evenly
                  children: [
                    _buildUnitButton("FT", screenSize, scrollController),
                    _buildUnitButton("CM", screenSize, scrollController),
                  ],
                ),
              ),

              SizedBox(
                  height: screenSize.height *
                      0.04), // Spacing before forward button

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Center(
                  child: GestureDetector(
                    onTap: canProceed ? _handleNext : null,
                    child: Container(
                      width: 70, // Even larger button
                      height: 70,
                      decoration: BoxDecoration(
                        color: canProceed
                            ? const Color(0xFF8B5CF6)
                            : Colors.grey.shade400,
                        borderRadius: BorderRadius.circular(35), // More rounded
                      ),
                      child: const Icon(
                        Icons.arrow_forward_rounded,
                        color: Colors.white,
                        size: 32, // Larger icon
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              SizedBox(
                  height: screenSize.height * 0.06), // Increased bottom spacing
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildUnitButton(String unit, Size screenSize,
      FixedExtentScrollController scrollController) {
    final isSelected = _unit == unit;
    return GestureDetector(
      onTap: () {
        if (_unit != unit) {
          // Only update if switching units
          setState(() {
            _unit = unit;
            // Update the scroll position when unit changes
            if (_unit == "FT") {
              // Convert CM index to approximate FT index
              final currentCm = _startCm + _selectedCmIndex;
              final feetStr = _cmToFeet(currentCm);
              _selectedFeetIndex = _feetValues.indexOf(feetStr);
              if (_selectedFeetIndex == -1) _selectedFeetIndex = 11; // Fallback
              // Animate scroll AFTER setState completes
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (scrollController.hasClients) {
                  scrollController.animateToItem(_selectedFeetIndex,
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut);
                }
              });
            } else {
              // Switching to CM
              // Convert FT index to approximate CM index
              final currentFt = _feetValues[_selectedFeetIndex];
              final cmValue = _feetToCm(currentFt);
              _selectedCmIndex = cmValue - _startCm;
              if (_selectedCmIndex < 0 ||
                  _selectedCmIndex >= _cmValues.length) {
                _selectedCmIndex = 30; // Fallback
              }
              // Animate scroll AFTER setState completes
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (scrollController.hasClients) {
                  scrollController.animateToItem(_selectedCmIndex,
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut);
                }
              });
            }
            // Update provider after unit switch and index calculation
            _updateHeight(ref);
          });
        }
      },
      child: Container(
        padding: EdgeInsets.symmetric(
            vertical: 12,
            horizontal: screenSize.width * 0.08), // Dynamic horizontal padding
        decoration: BoxDecoration(
          color: isSelected
              ? const Color(0xFF8B5CF6)
              : Colors.white, // White background for unselected
          border: Border.all(color: Colors.grey.shade300), // Subtle border
          borderRadius: BorderRadius.circular(30), // Even more rounded corners
          boxShadow: [
            // Subtle shadow for depth
            BoxShadow(
              color: Colors.grey.withOpacity(0.15),
              spreadRadius: 0,
              blurRadius: 3,
              offset: const Offset(0, 2), // changes position of shadow
            ),
          ],
        ),
        child: Text(
          unit,
          style: GoogleFonts.poppins(
            fontSize: 18, // Larger font size for buttons
            fontWeight: isSelected
                ? FontWeight.w600
                : FontWeight.w500, // Slightly bolder for selected
            color: isSelected
                ? Colors.white
                : const Color(0xFF555555), // Darker text for unselected
          ),
        ),
      ),
    );
  }

  // Modified to accept forceUpdate flag
  void _updateHeight(WidgetRef ref, {bool forceUpdate = false}) {
    String selectedValue = _unit == "FT"
        ? _feetValues[_selectedFeetIndex]
        : _cmValues[_selectedCmIndex];

    // Convert CM selection to FT' IN" format for saving
    String heightToSave = (_unit == "CM")
        ? _cmToFeet(int.parse(selectedValue.replaceAll(" cm", "")))
        : selectedValue;

    // Only update the provider if the value changed or if forced (e.g., on Done)
    if (forceUpdate || ref.read(userProvider).height != heightToSave) {
      print(
          "[HeightSelectionScreen] Updating height in provider to: $heightToSave");
      ref.read(userProvider.notifier).updateHeight(heightToSave);
    }
  }
}



================================================
File: views/home.dart
================================================
// File: lib/views/home.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/feed_provider.dart';
import 'package:dtx/providers/filter_provider.dart';
import 'package:dtx/providers/service_provider.dart';
import 'package:dtx/providers/user_provider.dart'; // Keep user provider for gender check if needed here (though moved to card)
import 'package:dtx/services/api_service.dart';
import 'package:dtx/views/filter_settings_dialog.dart';
import 'package:dtx/views/name.dart';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/widgets/home_profile_card.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/repositories/like_repository.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/models/filter_model.dart';
import 'package:dtx/utils/app_enums.dart';

class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen> {
  List<UserModel> _feedProfiles = [];
  bool _isInteracting = false; // To show overlay during API call

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final feedState = ref.read(feedProvider);
      if (!feedState.hasFetchedOnce && !feedState.isLoading) {
        print("[HomeScreen initState] Feed not fetched yet, triggering fetch.");
        _fetchFeed();
      } else {
        if (mounted) {
          setState(() {
            _feedProfiles = feedState.profiles;
          });
        }
      }
      final filterState = ref.read(filterProvider);
      final filterNotifier = ref.read(filterProvider.notifier);
      if (filterState == const FilterSettings() && !filterNotifier.isLoading) {
        print(
            "[HomeScreen initState] Filters appear default, triggering load.");
        filterNotifier.loadFilters();
      }
    });
  }

  @override
  void dispose() {
    super.dispose();
  }

  Future<void> _fetchFeed({bool force = false}) async {
    print("[HomeScreen _fetchFeed] Fetching home feed. Force: $force");
    ref.read(errorProvider.notifier).clearError();
    await ref.read(feedProvider.notifier).fetchFeed(forceRefresh: force);
  }

  // Dialog shown if user tries to interact before completing onboarding step 2
  void _showCompleteProfileDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text("Complete Your Profile",
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          content: Text(
              "To interact with profiles, please complete your profile setup.",
              style: GoogleFonts.poppins()),
          actions: <Widget>[
            TextButton(
              child:
                  Text("Later", style: GoogleFonts.poppins(color: Colors.grey)),
              onPressed: () => Navigator.of(dialogContext).pop(),
            ),
            TextButton(
              child: Text("Complete Profile",
                  style: GoogleFonts.poppins(color: Color(0xFF8B5CF6))),
              onPressed: () {
                Navigator.of(dialogContext).pop();
                // Navigate to the first screen of the remaining onboarding flow
                Navigator.push(context,
                    MaterialPageRoute(builder: (_) => const NameInputScreen()));
              },
            ),
          ],
        );
      },
    );
  }

  // Called by HomeProfileCard after a successful interaction
  void _removeTopCard() {
    print("[HomeScreen _removeTopCard] Removing top card.");
    if (!mounted) return;
    if (_feedProfiles.isNotEmpty) {
      ref.read(feedProvider.notifier).removeProfile(_feedProfiles[0].id!);
    }
    // The loading overlay (_isInteracting) is handled in _callLikeRepository
  }

  // This method is passed to the card to handle the actual API call
  // It allows HomeScreen to manage the loading overlay (_isInteracting)
  Future<bool> _callLikeRepository({
    required int targetUserId,
    required ContentLikeType contentType,
    required String contentIdentifier,
    required LikeInteractionType interactionType,
    String? comment,
  }) async {
    // Check if profile is complete before allowing interaction
    final authStatus = ref.read(authProvider).authStatus;
    if (authStatus == AuthStatus.onboarding2) {
      print(
          "[HomeScreen _callLikeRepository] Interaction blocked: Profile incomplete (onboarding2).");
      _showCompleteProfileDialog();
      return false; // Indicate failure
    }

    if (_isInteracting) return false; // Prevent double taps during API call
    if (mounted) setState(() => _isInteracting = true); // Show overlay

    final errorNotifier = ref.read(errorProvider.notifier)..clearError();
    bool success = false;
    try {
      final likeRepo = ref.read(likeRepositoryProvider);
      print(
          "[HomeScreen _callLikeRepository] Calling API: Target $targetUserId, Type: $contentType, ID: $contentIdentifier, Interaction: $interactionType, Comment: ${comment != null}");
      success = await likeRepo.likeContent(
          likedUserId: targetUserId,
          contentType: contentType,
          contentIdentifier: contentIdentifier,
          interactionType: interactionType,
          comment: comment);

      if (!success) {
        // If API returns false, check if an error was already set by repo/service
        if (mounted && ref.read(errorProvider) == null) {
          print(
              "[HomeScreen _callLikeRepository] API returned false, setting generic error.");
          errorNotifier.setError(
              AppError.server("Could not send ${interactionType.value}."));
        }
      } else {
        print("[HomeScreen _callLikeRepository] API call successful.");
      }
    } on LikeLimitExceededException catch (e) {
      print("[HomeScreen _callLikeRepository] Like Limit Error: ${e.message}");
      errorNotifier.setError(AppError.validation(e.message));
      _showErrorSnackbar(e.message); // Show specific feedback
    } on InsufficientRosesException catch (e) {
      print(
          "[HomeScreen _callLikeRepository] Insufficient Roses: ${e.message}");
      errorNotifier.setError(AppError.validation(e.message));
      _showErrorSnackbar(e.message); // Show specific feedback
    } on ApiException catch (e) {
      print("[HomeScreen _callLikeRepository] API Exception: ${e.message}");
      errorNotifier.setError(AppError.server(e.message));
      _showErrorSnackbar(e.message); // Show API error message
    } catch (e) {
      print(
          "[HomeScreen _callLikeRepository] Unexpected Error: ${e.toString()}");
      errorNotifier.setError(AppError.generic("An unexpected error occurred."));
      _showErrorSnackbar("An unexpected error occurred.");
    } finally {
      if (mounted) setState(() => _isInteracting = false); // Hide overlay
    }
    print("[HomeScreen _callLikeRepository] Returning success: $success");
    return success; // Return the outcome
  }

  void _showErrorSnackbar(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
          content: Text(message, style: GoogleFonts.poppins()),
          backgroundColor: Colors.redAccent), // Use red for errors
    );
  }

  Future<void> _openFilterDialog() async {
    print("[HomeScreen] Opening Filter Dialog.");
    await showDialog<bool>(
      context: context,
      builder: (context) => const FilterSettingsDialog(),
    );
  }

  @override
  Widget build(BuildContext context) {
    final feedState = ref.watch(feedProvider);
    final filters = ref.watch(filterProvider);

    // Update local profile list when provider changes
    ref.listen<HomeFeedState>(feedProvider, (_, next) {
      if (mounted) {
        setState(() {
          _feedProfiles = next.profiles;
        });
      }
    });

    final error = feedState.error ?? ref.watch(errorProvider);
    final isLoadingFeed = feedState.isLoading && !feedState.hasFetchedOnce;
    final bool hasProfilesToShow = _feedProfiles.isNotEmpty;

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text("Discover",
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 0,
        automaticallyImplyLeading: false,
        actions: [
          IconButton(
            icon: const Icon(Icons.tune_rounded, color: Color(0xFF8B5CF6)),
            tooltip: "Filters",
            onPressed: _openFilterDialog,
          ),
        ],
      ),
      body: Column(
        children: [
          // Filter Chips Row (remains the same)
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 12.0, vertical: 10.0),
            child: GestureDetector(
                onTap: _openFilterDialog,
                child: Container(
                  color: Colors.transparent,
                  height: 34,
                  child: SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    physics: const BouncingScrollPhysics(),
                    child: Row(
                      children: _buildFilterChips(filters),
                    ),
                  ),
                )),
          ),

          // Feed Area (Expanded)
          Expanded(
            child: Stack(
              alignment: Alignment.center, // Center children like indicators
              children: [
                if (isLoadingFeed)
                  const CircularProgressIndicator(color: Color(0xFF8B5CF6))
                // Show loading only if initial fetch AND no profiles loaded yet
                else if (error != null && !hasProfilesToShow)
                  _buildErrorState(error) // Show error only if no profiles
                else if (!hasProfilesToShow)
                  _buildEmptyState() // Show empty state if no profiles and no error
                else // Only build the card if there are profiles
                  _buildProfileCardAtIndex(0),

                // General interaction loading overlay (covers everything)
                if (_isInteracting)
                  Positioned.fill(
                    child: Container(
                      color: Colors.white.withOpacity(0.5),
                      child: const Center(
                          child: CircularProgressIndicator(
                              color: Color(0xFF8B5CF6))),
                    ),
                  ),
              ],
            ),
          ),

          // --- REMOVED BOTTOM ACTION BUTTONS ---
          // Padding(...) // Removed the entire Padding widget with action buttons
        ],
      ),
    );
  }

  // --- Helper methods (_buildFilterChips, _buildFilterChip, _buildEmptyState, _buildErrorState) remain the same ---
  List<Widget> _buildFilterChips(FilterSettings filters) {
    List<Widget> chips = [];
    chips.add(_buildFilterChip(
        Icons.wc_rounded,
        filters.whoYouWantToSee?.value.replaceFirst(
                filters.whoYouWantToSee!.value[0],
                filters.whoYouWantToSee!.value[0].toUpperCase()) ??
            FilterSettings.defaultGenderPref.value.replaceFirst(
                FilterSettings.defaultGenderPref.value[0],
                FilterSettings.defaultGenderPref.value[0].toUpperCase())));
    chips.add(_buildFilterChip(Icons.cake_outlined,
        '${filters.ageMin ?? FilterSettings.defaultAgeMin}-${filters.ageMax ?? FilterSettings.defaultAgeMax}'));
    chips.add(_buildFilterChip(Icons.social_distance_outlined,
        '${filters.radiusKm ?? FilterSettings.defaultRadius} km'));
    bool activeTodayValue =
        filters.activeToday ?? FilterSettings.defaultActiveToday;
    chips.add(_buildFilterChip(
      activeTodayValue
          ? Icons.access_time_filled_rounded
          : Icons.access_time_rounded,
      activeTodayValue ? 'Active Today' : 'Active: Any',
    ));
    return chips;
  }

  Widget _buildFilterChip(IconData icon, String label) {
    const Color themeColor = Color(0xFF8B5CF6);
    const Color themeBgColor = Color(0xFFEDE9FE);
    const Color themeTextColor = themeColor;

    return Padding(
      padding: const EdgeInsets.only(right: 8.0),
      child: Chip(
        avatar: Icon(icon, size: 16, color: themeColor),
        label: Text(label),
        labelStyle: GoogleFonts.poppins(
            fontSize: 12, color: themeTextColor, fontWeight: FontWeight.w500),
        backgroundColor: themeBgColor,
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: const VisualDensity(horizontal: 0.0, vertical: -2),
        side: BorderSide.none,
        elevation: 0.5,
        shadowColor: themeColor.withOpacity(0.2),
      ),
    );
  }

  Widget _buildProfileCardAtIndex(int index) {
    if (index >= 0 && index < _feedProfiles.length) {
      final currentProfile = _feedProfiles[index];
      return HomeProfileCard(
        profile: currentProfile,
        // Pass the callback function to handle the API call
        performLikeApiCall: (
            {required contentType,
            required contentIdentifier,
            required interactionType,
            comment}) async {
          if (currentProfile.id == null) return false;
          return await _callLikeRepository(
              targetUserId: currentProfile.id!,
              contentType: contentType,
              contentIdentifier: contentIdentifier,
              interactionType: interactionType,
              comment: comment);
        },
        // Callback to remove the card after success
        onInteractionComplete: _removeTopCard,
      );
    }
    return Container(
        alignment: Alignment.center,
        child: const Text("Error loading profile."));
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.people_outline_rounded, size: 80, color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "That's everyone for now!",
            style: GoogleFonts.poppins(fontSize: 18, color: Colors.grey[600]),
          ),
          const SizedBox(height: 10),
          Text(
            "Adjust your filters or check back later.",
            textAlign: TextAlign.center,
            style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[500]),
          ),
          const SizedBox(height: 20),
          ElevatedButton.icon(
            icon: const Icon(Icons.refresh_rounded, size: 18),
            label: const Text("Refresh Feed"),
            style: ElevatedButton.styleFrom(
              foregroundColor: Colors.white,
              backgroundColor: const Color(0xFF8B5CF6),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20)),
              padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
            ),
            onPressed: () => _fetchFeed(force: true),
          ),
        ],
      ),
    );
  }

  Widget _buildErrorState(AppError error) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                size: 60, color: Colors.redAccent[100]),
            const SizedBox(height: 20),
            Text(
              "Oops! Something went wrong",
              style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[700]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 10),
            Text(
              error.message,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded, size: 18),
              label: const Text("Retry"),
              style: ElevatedButton.styleFrom(
                foregroundColor: Colors.white,
                backgroundColor: const Color(0xFF8B5CF6),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20)),
                padding:
                    const EdgeInsets.symmetric(horizontal: 30, vertical: 12),
              ),
              onPressed: () => _fetchFeed(force: true),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/hometown.dart
================================================
// File: lib/views/hometown.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/job.dart'; // Keep for onboarding flow

class HometownScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const HometownScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<HometownScreen> createState() => _HometownScreenState();
}

class _HometownScreenState extends ConsumerState<HometownScreen> {
  final TextEditingController _hometownController = TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _hometownController.text = ref.read(userProvider).hometown ?? '';
    }
    // Add listener to enable/disable Done button
    _hometownController.addListener(() {
      if (widget.isEditing) setState(() {});
    });
  }

  @override
  void dispose() {
    _hometownController.dispose();
    super.dispose();
  }

  void _handleNext() {
    String? hometown;
    if (_hometownController.text.trim().isNotEmpty) {
      hometown = _hometownController.text.trim();
    } else {
      hometown = null; // Explicitly set to null if empty
    }
    ref.read(userProvider.notifier).updateHometown(hometown);

    if (widget.isEditing) {
      print("[HometownScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[HometownScreen] Onboarding next: Job.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const JobTitleScreen()));
    }
  }

  void _handleSkipOrClear() {
    FocusScope.of(context).unfocus();
    _hometownController.clear(); // Clear text field
    ref
        .read(userProvider.notifier)
        .updateHometown(null); // Update provider to null
    if (widget.isEditing) {
      print("[HometownScreen] Clearing field and popping back.");
      Navigator.of(context).pop(); // Pop back immediately after clearing
    } else {
      // Original onboarding skip navigation
      print("[HometownScreen] Skipping to Job.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const JobTitleScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    // Determine if Done button should be enabled in Edit mode
    final bool canProceedEditing =
        widget.isEditing && _hometownController.text.trim().isNotEmpty;

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      IconButton(
                        // Keep original icon for onboarding
                        icon: const Icon(Icons.home_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {}, // No action needed here
                      ),

                    Text(
                      widget.isEditing ? "Edit Hometown" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    // Show "Done" in edit mode, "Skip" in onboarding
                    if (widget.isEditing)
                      TextButton(
                        onPressed:
                            _handleNext, // Always enabled, saves empty as null
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color:
                                const Color(0xFF8B5CF6), // Always enabled color
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      TextButton(
                        onPressed: _handleSkipOrClear, // Use unified handler
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                              fontSize: 16, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),

              // Question Text
              Text(
                widget.isEditing
                    ? "Edit your hometown"
                    : "Where's your home\ntown?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),

              SizedBox(height: screenSize.height * 0.05),

              // Text Field
              Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                child: TextField(
                  controller: _hometownController,
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    color: Colors.black87,
                  ),
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    hintText: "e.g., New Delhi",
                    hintStyle: GoogleFonts.poppins(
                      fontSize: 22,
                      color: Colors.grey.shade500,
                    ),
                    border: const UnderlineInputBorder(
                      borderSide: BorderSide(color: Colors.grey, width: 1.0),
                    ),
                    focusedBorder: const UnderlineInputBorder(
                      borderSide:
                          BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                    ),
                    // Add clear button in edit mode if text exists
                    suffixIcon: widget.isEditing &&
                            _hometownController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, color: Colors.grey),
                            onPressed: () {
                              _hometownController.clear();
                              // Optionally update provider immediately on clear
                              // ref.read(userProvider.notifier).updateHometown(null);
                            },
                          )
                        : null,
                  ),
                ),
              ),

              const Spacer(),

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: GestureDetector(
                      onTap: _handleNext, // Always enabled for onboarding
                      child: Container(
                        width: 70,
                        height: 70,
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(35),
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/job.dart
================================================
// File: lib/views/job.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/study.dart'; // Keep for onboarding flow

class JobTitleScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const JobTitleScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<JobTitleScreen> createState() => _JobTitleScreenState();
}

class _JobTitleScreenState extends ConsumerState<JobTitleScreen> {
  final TextEditingController _jobTitleController = TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _jobTitleController.text = ref.read(userProvider).jobTitle ?? '';
    }
    // Add listener to enable/disable Done button in edit mode if needed
    _jobTitleController.addListener(() {
      if (widget.isEditing) setState(() {});
    });
  }

  @override
  void dispose() {
    _jobTitleController.dispose();
    super.dispose();
  }

  void _handleNext() {
    String? jobTitle;
    if (_jobTitleController.text.trim().isNotEmpty) {
      jobTitle = _jobTitleController.text.trim();
    } else {
      jobTitle = null; // Explicitly set to null if empty
    }
    ref.read(userProvider.notifier).updateJobTitle(jobTitle);

    if (widget.isEditing) {
      print("[JobTitleScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[JobTitleScreen] Onboarding next: Study.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const StudyLocationScreen()));
    }
  }

  void _handleSkipOrClear() {
    FocusScope.of(context).unfocus();
    _jobTitleController.clear(); // Clear text field
    ref
        .read(userProvider.notifier)
        .updateJobTitle(null); // Update provider to null
    if (widget.isEditing) {
      print("[JobTitleScreen] Clearing field and popping back.");
      Navigator.of(context).pop(); // Pop back immediately after clearing
    } else {
      // Original onboarding skip navigation
      print("[JobTitleScreen] Skipping to Study.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const StudyLocationScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    // Determine if Done button should be enabled in Edit mode (optional, could always allow saving null)
    // final bool canProceedEditing = widget.isEditing && _jobTitleController.text.trim().isNotEmpty;

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      IconButton(
                        // Keep original icon for onboarding
                        icon: const Icon(Icons.work_outline_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {}, // No action needed here
                      ),

                    Text(
                      widget.isEditing ? "Edit Job Title" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    // Show "Done" in edit mode, "Skip" in onboarding
                    if (widget.isEditing)
                      TextButton(
                        onPressed: _handleNext, // Always enabled
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color:
                                const Color(0xFF8B5CF6), // Always enabled color
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      TextButton(
                        onPressed: _handleSkipOrClear, // Use unified handler
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                              fontSize: 16, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),

              // Question Text
              Text(
                widget.isEditing
                    ? "Edit your job title"
                    : "What's your job\ntitle?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),

              SizedBox(height: screenSize.height * 0.05),

              // Text Field
              Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                child: TextField(
                  controller: _jobTitleController,
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    color: Colors.black87,
                  ),
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    hintText: "e.g., Software Engineer",
                    hintStyle: GoogleFonts.poppins(
                      fontSize: 22,
                      color: Colors.grey.shade500,
                    ),
                    border: const UnderlineInputBorder(
                      borderSide: BorderSide(color: Colors.grey, width: 1.0),
                    ),
                    focusedBorder: const UnderlineInputBorder(
                      borderSide:
                          BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                    ),
                    // Add clear button in edit mode if text exists
                    suffixIcon: widget.isEditing &&
                            _jobTitleController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, color: Colors.grey),
                            onPressed: () {
                              _jobTitleController.clear();
                            },
                          )
                        : null,
                  ),
                ),
              ),

              const Spacer(),

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: GestureDetector(
                      onTap: _handleNext, // Always enabled for onboarding
                      child: Container(
                        width: 70,
                        height: 70,
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(35),
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/liker_profile_screen.dart
================================================
// File: views/liker_profile_screen.dart
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/liker_profile_provider.dart';
import 'package:dtx/views/profile_screens.dart'; // Re-use ProfileScreen's building blocks (Keep for reference, but structure is replicated)
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

// --- ADDED IMPORTS ---
import 'package:dtx/models/user_model.dart';
import 'package:dtx/utils/app_enums.dart'; // For Gender enum etc. if needed in helpers
// --- END ADDED ---

class LikerProfileScreen extends ConsumerWidget {
  final int likerUserId;

  const LikerProfileScreen({super.key, required this.likerUserId});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watch the specific provider instance for this liker's ID
    final state = ref.watch(likerProfileProvider(likerUserId));
    final profile = state.profile;
    final likeDetails = state.likeDetails;

    return Scaffold(
      backgroundColor: Colors.white,
      body: _buildBody(context, state, profile, likeDetails, ref),
    );
  }

  Widget _buildBody(
      BuildContext context,
      LikerProfileState state,
      UserProfileData? profile,
      LikeInteractionDetails? likeDetails,
      WidgetRef ref) {
    if (state.isLoading) {
      return const Center(
          child: CircularProgressIndicator(color: Color(0xFF8B5CF6)));
    }

    if (state.error != null) {
      return _buildErrorState(context, state.error!, ref); // Pass context
    }

    if (profile == null || likeDetails == null) {
      return _buildErrorState(
          context,
          AppError.generic("Profile data could not be loaded."),
          ref); // Pass context
    }

    // --- If data loaded successfully ---
    return CustomScrollView(
      slivers: [
        SliverAppBar(
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          elevation: 1,
          pinned: true,
          leading: IconButton(
            icon: Icon(Icons.arrow_back_ios_new,
                color: Colors.grey[700], size: 20),
            onPressed: () => Navigator.of(context).pop(),
          ),
          title: Text(
            // --- FIX: Use profile.name ---
            profile.name ?? 'Profile',
            // --- END FIX ---
            style:
                GoogleFonts.poppins(fontWeight: FontWeight.w600, fontSize: 18),
          ),
          actions: [
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: IconButton(
                icon: const Icon(Icons.message_outlined,
                    color: Color(0xFF8B5CF6)),
                tooltip: "Send Message",
                onPressed: () {
                  // --- FIX: Use profile.id ---
                  print("Navigate to chat with user ${profile.id}");
                  // --- END FIX ---
                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                      content:
                          Text('Chat functionality not yet implemented.')));
                },
              ),
            )
          ],
        ),

        // --- Like Details Banner ---
        SliverToBoxAdapter(
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            margin: const EdgeInsets.all(16),
            decoration: BoxDecoration(
                color: likeDetails.isRose
                    ? Colors.purple.shade50
                    : Colors.blue.shade50,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                    color: likeDetails.isRose
                        ? Colors.purple.shade100
                        : Colors.blue.shade100)),
            child: Row(
              children: [
                Icon(
                  likeDetails.isRose
                      ? Icons.star_rounded
                      : Icons.favorite_rounded,
                  color: likeDetails.isRose
                      ? Colors.purple.shade400
                      : Colors.pink.shade300,
                  size: 24,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    likeDetails.likeComment != null &&
                            likeDetails.likeComment!.isNotEmpty
                        ? '"${likeDetails.likeComment}"' // Show comment if exists
                        : (likeDetails.isRose
                            ? 'Sent you a Rose!'
                            : 'Liked your profile!'), // Default message
                    style: GoogleFonts.poppins(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                      fontStyle: (likeDetails.likeComment != null &&
                              likeDetails.likeComment!.isNotEmpty)
                          ? FontStyle.italic
                          : FontStyle.normal,
                      color: likeDetails.isRose
                          ? Colors.purple.shade700
                          : Colors.blue.shade700,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),

        // --- Profile Content ---
        SliverPadding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          sliver: SliverList(
            delegate: SliverChildListDelegate([
              _buildProfileHeader(profile),
              const SizedBox(height: 24),
              _buildMediaGallery(
                  context, profile.mediaUrls ?? []), // Pass context
              const SizedBox(height: 32),
              if (profile.datingIntention != null)
                _buildInfoSection(
                    "Looking for", profile.datingIntention!.label),
              const SizedBox(height: 24),
              _buildPromptSection(profile.prompts),
              const SizedBox(height: 32),
              if (profile.audioPrompt != null)
                _buildAudioPrompt(
                    context, profile.audioPrompt!), // Pass context
              const SizedBox(height: 32),
              _buildPersonalDetailsSection(profile),
              const SizedBox(height: 40), // Bottom padding
            ]),
          ),
        ),
      ],
    );
  }

  // --- Error State Widget ---
  Widget _buildErrorState(BuildContext context, AppError error, WidgetRef ref) {
    // Added context
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(30.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                size: 60, color: Colors.redAccent[100]),
            const SizedBox(height: 20),
            Text(
              "Oops!",
              style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[700]),
            ),
            const SizedBox(height: 10),
            Text(
              error.message,
              style: GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded, size: 18),
              label: const Text("Retry"),
              style: ElevatedButton.styleFrom(
                foregroundColor: Colors.white,
                backgroundColor: const Color(0xFF8B5CF6),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20)),
                padding:
                    const EdgeInsets.symmetric(horizontal: 30, vertical: 12),
              ),
              onPressed: () => ref
                  .read(likerProfileProvider(likerUserId).notifier)
                  .fetchProfile(),
            ),
            const SizedBox(height: 10),
            TextButton(
              child: const Text("Go Back"),
              style: TextButton.styleFrom(foregroundColor: Colors.grey[600]),
              onPressed: () => Navigator.of(context).pop(),
            )
          ],
        ),
      ),
    );
  }

  // --- Replicated/Adapted Widgets ---

  Widget _buildProfileHeader(UserProfileData user) {
    // --- FIX: Use user.age getter ---
    final age = user.age;
    // --- END FIX ---
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          // --- FIX: Use user.name and check lastName ---
          '${user.name ?? ''}${user.lastName != null && user.lastName!.isNotEmpty ? ' ${user.lastName}' : ''}${age != null ? ' • $age' : ''}',
          // --- END FIX ---
          style: GoogleFonts.poppins(
            fontSize: 36, // Slightly smaller if too large
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
            height: 1.2,
          ),
        ),
        const SizedBox(height: 8),
        if (user.gender != null ||
            (user.hometown != null && user.hometown!.isNotEmpty))
          Wrap(
            spacing: 8,
            runSpacing: 4,
            children: [
              if (user.gender != null)
                _buildDetailChip(Icons.person_outline, user.gender!.label,
                    subtle: true),
              if (user.hometown != null && user.hometown!.isNotEmpty)
                _buildDetailChip(Icons.location_on_outlined, user.hometown!,
                    subtle: true),
            ],
          ),
      ],
    );
  }

  Widget _buildMediaGallery(BuildContext context, List<String> images) {
    // Added context
    if (images.isEmpty) return const SizedBox.shrink();

    return Container(
      height: MediaQuery.of(context).size.height * 0.4, // Responsive height
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: images.length,
        itemBuilder: (context, index) {
          return Container(
            width: MediaQuery.of(context).size.width * 0.6, // Responsive width
            margin: EdgeInsets.only(right: index == images.length - 1 ? 0 : 10),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              color: Colors.grey[200],
            ),
            child: ClipRRect(
              // Clip the image
              borderRadius: BorderRadius.circular(12),
              child: Image.network(
                images[index],
                fit: BoxFit.cover,
                loadingBuilder: (context, child, progress) {
                  if (progress == null) return child;
                  return Center(
                      child: CircularProgressIndicator(
                          value: progress.expectedTotalBytes != null
                              ? progress.cumulativeBytesLoaded /
                                  progress.expectedTotalBytes!
                              : null,
                          color: Color(0xFF8B5CF6)));
                },
                errorBuilder: (context, error, stackTrace) {
                  print("Error loading image: ${images[index]} - $error");
                  return Center(
                      child: Icon(Icons.broken_image, color: Colors.grey[400]));
                },
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildInfoSection(String title, String content) {
    // Check if content is not empty before building
    if (content.isEmpty) return const SizedBox.shrink();
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 12.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: GoogleFonts.poppins(
              fontSize: 14,
              fontWeight: FontWeight.w500,
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 4),
          Text(
            content,
            style: GoogleFonts.poppins(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: const Color(0xFF1A1A1A),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPromptSection(List<Prompt> prompts) {
    if (prompts.isEmpty) return const SizedBox.shrink();
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          "About Me",
          style: GoogleFonts.poppins(
            fontSize: 20,
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
          ),
        ),
        const SizedBox(height: 16),
        ...prompts.map((prompt) => _buildPromptCard(prompt)).toList(),
      ],
    );
  }

  Widget _buildPromptCard(Prompt prompt) {
    // Check if answer is not empty before building
    if (prompt.answer.isEmpty) return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey[200]!),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            prompt.question.label,
            style: GoogleFonts.poppins(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: const Color(0xFF8B5CF6),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            prompt.answer,
            style: GoogleFonts.poppins(
              fontSize: 14,
              color: const Color(0xFF1A1A1A),
              height: 1.4,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAudioPrompt(BuildContext context, AudioPromptModel audio) {
    // Added context
    // Simple display, no playback logic here for now
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          "Voice Prompt",
          style: GoogleFonts.poppins(
            fontSize: 20,
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
          ),
        ),
        const SizedBox(height: 16),
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.grey[50],
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.grey[200]!),
          ),
          child: Row(
            children: [
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6),
                  borderRadius: BorderRadius.circular(24),
                ),
                child: const Icon(
                  Icons.graphic_eq, // Use a different icon for display only
                  color: Colors.white,
                  size: 28,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Text(
                  audio.prompt.label,
                  style: GoogleFonts.poppins(
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                    color: const Color(0xFF1A1A1A),
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildPersonalDetailsSection(UserProfileData user) {
    final details = <Widget>[];
    // Add checks for empty strings as well
    if (user.height != null && user.height!.isNotEmpty)
      details.add(_buildDetailChip(Icons.height, "Height: ${user.height}"));
    if (user.religiousBeliefs != null)
      details.add(_buildDetailChip(
          Icons.church_outlined, user.religiousBeliefs!.label));
    if (user.jobTitle != null && user.jobTitle!.isNotEmpty)
      details.add(_buildDetailChip(Icons.work_outline, user.jobTitle!));
    if (user.education != null && user.education!.isNotEmpty)
      details.add(_buildDetailChip(Icons.school_outlined, user.education!));
    if (user.drinkingHabit != null)
      details.add(_buildDetailChip(
          Icons.local_bar_outlined, user.drinkingHabit!.label));
    if (user.smokingHabit != null)
      details.add(_buildDetailChip(
          Icons.smoking_rooms_outlined, user.smokingHabit!.label));

    if (details.isEmpty) return const SizedBox.shrink();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          "Personal Details",
          style: GoogleFonts.poppins(
            fontSize: 20,
            fontWeight: FontWeight.w700,
            color: const Color(0xFF1A1A1A),
          ),
        ),
        const SizedBox(height: 16),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: details,
        ),
      ],
    );
  }

  Widget _buildDetailChip(IconData icon, String label, {bool subtle = false}) {
    // Check if label is empty
    if (label.isEmpty) return const SizedBox.shrink();
    return Container(
      padding: EdgeInsets.symmetric(
          horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
      decoration: BoxDecoration(
        color: subtle ? Colors.transparent : Colors.grey[100],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
            color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: subtle ? 16 : 18,
            color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6),
          ),
          const SizedBox(width: 6),
          Flexible(
            // Allow text to wrap if needed
            child: Text(
              label,
              style: GoogleFonts.poppins(
                fontSize: subtle ? 13 : 14,
                fontWeight: FontWeight.w500,
                color: subtle ? Colors.grey.shade700 : Colors.grey[800],
              ),
              overflow: TextOverflow.ellipsis, // Prevent long text overflow
              maxLines: 2,
            ),
          ),
        ],
      ),
    );
  }
}



================================================
File: views/location.dart
================================================
// File: views/location.dart
import 'package:dtx/models/error_model.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:app_settings/app_settings.dart'; // Keep for opening settings
import '../providers/location_provider.dart';
import '../providers/error_provider.dart';
import '../providers/user_provider.dart'; // Ensure user provider is imported
import 'gender.dart'; // Ensure GenderSelectionScreen is imported

class LocationInputScreen extends ConsumerStatefulWidget {
  const LocationInputScreen({super.key});

  @override
  ConsumerState<LocationInputScreen> createState() =>
      _LocationInputScreenState();
}

class _LocationInputScreenState extends ConsumerState<LocationInputScreen> {
  late final MapController _mapController;

  @override
  void initState() {
    super.initState();
    _mapController = MapController();
    // Fetch location after the first frame is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Only fetch if location isn't already valid in the user state
      // This prevents unnecessary fetches if the user navigates back and forth
      if (!ref.read(userProvider.notifier).isLocationValid()) {
        print("[LocationInputScreen] Initial location fetch triggered.");
        ref.read(locationProvider.notifier).fetchCurrentLocation();
      } else {
        print(
            "[LocationInputScreen] Skipping initial fetch, location already set.");
        // Ensure the map moves to the existing location if needed
        _moveToCurrentLocation();
      }
    });
  }

  void _onMapReady() {
    print("[LocationInputScreen] Map Ready.");
    // It might be safer to set map ready state in the provider
    // ref.read(locationProvider.notifier).setMapReady(true);
    _moveToCurrentLocation();
  }

  void _moveToCurrentLocation() {
    final locationState = ref.read(locationProvider);
    final userLocation =
        ref.read(userProvider); // Get location from user provider

    // Use user provider's location if valid, otherwise use location provider's state
    final LatLng targetLocation = LatLng(
      userLocation.latitude ?? locationState.latitude,
      userLocation.longitude ?? locationState.longitude,
    );

    print("[LocationInputScreen] Moving map to: $targetLocation");
    // Check if mapController is initialized and ready
    // Note: FlutterMap doesn't have a direct 'isReady' flag accessible here easily.
    // We rely on onMapReady having been called implicitly before this might be needed.
    // A small delay could be a workaround if needed, but usually direct call is fine.
    try {
      _mapController.move(targetLocation, _mapController.camera.zoom);
    } catch (e) {
      print(
          "[LocationInputScreen] Error moving map (potentially before ready): $e");
      // Optionally, schedule the move again slightly later
      // Future.delayed(Duration(milliseconds: 100), () => _moveToCurrentLocation());
    }
  }

  // Dialog for location services disabled
  Future<void> _showLocationServiceDialog() async {
    // Prevent showing multiple dialogs
    if (ModalRoute.of(context)?.isCurrent ?? false) {
      print("[LocationInputScreen] Showing Location Service Dialog.");
      return showDialog<void>(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext dialogContext) {
          // Use different context name
          return AlertDialog(
            title: Text('Location Services Required',
                style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
            content: SingleChildScrollView(
              child: ListBody(
                children: <Widget>[
                  Text(
                      'To show you relevant places around you, we need access to your location.',
                      style: GoogleFonts.poppins()),
                  const SizedBox(height: 15),
                  Text(
                      'Please enable location services in your device settings.',
                      style: GoogleFonts.poppins()),
                ],
              ),
            ),
            actions: <Widget>[
              TextButton(
                child: Text('Open Settings',
                    style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6))),
                onPressed: () {
                  Navigator.pop(dialogContext); // Use dialogContext
                  ref.read(locationProvider.notifier).openLocationSettings();
                },
              ),
              TextButton(
                child: Text('Retry',
                    style: GoogleFonts.poppins(color: const Color(0xFF8B5CF6))),
                onPressed: () {
                  Navigator.pop(dialogContext); // Use dialogContext
                  ref.read(errorProvider.notifier).clearError();
                  ref.read(locationProvider.notifier).fetchCurrentLocation();
                },
              ),
            ],
          );
        },
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // Listen to location provider for map center and loading state
    final locationState = ref.watch(locationProvider);
    // Listen to user provider for the marker position (the confirmed location)
    final userState = ref.watch(userProvider);
    final error = ref.watch(errorProvider);

    // Use user's location for the marker if available, otherwise default
    final markerLatLng = LatLng(userState.latitude ?? locationState.latitude,
        userState.longitude ?? locationState.longitude);

    // Show location service dialog if needed after the build phase
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (error?.type == ErrorType.locationService) {
        _showLocationServiceDialog();
      }
    });

    return Scaffold(
      backgroundColor: Colors.white, // Use a clean white background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: screenSize.height * 0.04),
              // Progress Indicator (Optional) - Can use a step indicator if preferred
              // Center(child: Text("Step 1 of X", style: GoogleFonts.poppins(color: Colors.grey))),

              SizedBox(height: screenSize.height * 0.03),
              Row(
                children: [
                  Icon(
                    Icons.location_on_outlined,
                    color: const Color(0xFF8B5CF6), // Themed icon color
                    size: 32,
                  ),
                  const SizedBox(width: 10),
                  Text(
                    "Where do you live?",
                    style: GoogleFonts.poppins(
                      fontSize: screenSize.width * 0.07,
                      fontWeight: FontWeight.bold,
                      color: const Color(0xFF1A1A1A), // Darker text color
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 10),
              Text(
                "Drag the map to set your approximate location. Only your general area will be shown.",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey.shade600,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              Expanded(
                child: locationState.isLoading && !userState.isLocationValid()
                    ? const Center(
                        child: CircularProgressIndicator(
                        color: Color(0xFF8B5CF6),
                      ))
                    : ClipRRect(
                        // Use ClipRRect for rounded corners
                        borderRadius: BorderRadius.circular(15.0),
                        child: FlutterMap(
                          mapController: _mapController,
                          options: MapOptions(
                            initialCenter:
                                markerLatLng, // Start centered on user/default
                            initialZoom: 14.0,
                            onMapReady: _onMapReady,
                            // Update location provider AND user provider on tap/drag end
                            onTap: (tapPosition, latlng) {
                              print(
                                  "[LocationInputScreen] Map Tapped: $latlng");
                              ref
                                  .read(locationProvider.notifier)
                                  .updateLocation(
                                      latlng.latitude, latlng.longitude);
                            },
                            // Optional: Update on position changed (can be laggy)
                            // onPositionChanged: (position, hasGesture) {
                            //   if (hasGesture) {
                            //     final center = position.center;
                            //     if (center != null) {
                            //       ref.read(locationProvider.notifier)
                            //          .updateLocation(center.latitude, center.longitude);
                            //     }
                            //   }
                            // },
                          ),
                          children: [
                            TileLayer(
                              urlTemplate:
                                  'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                              // Use standard OSM tiles
                              userAgentPackageName:
                                  'com.peeple.dating', // Replace with your app's package name
                            ),
                            MarkerLayer(
                              markers: [
                                Marker(
                                  point:
                                      markerLatLng, // Marker follows user's selected location
                                  width: 50, // Slightly larger marker
                                  height: 50,
                                  child: const Icon(
                                    Icons.location_pin, // Use a pin icon
                                    color: Color(0xFF8B5CF6),
                                    size: 50,
                                  ),
                                ),
                              ],
                            ),
                            // Add a button to re-center on fetched location
                            if (locationState.cachedLatitude != null &&
                                locationState.cachedLongitude != null)
                              Positioned(
                                bottom:
                                    80, // Position above the main next button
                                right: 16,
                                child: FloatingActionButton.small(
                                  // Smaller FAB
                                  heroTag: 'recenter_fab', // Unique heroTag
                                  onPressed: () {
                                    print(
                                        "[LocationInputScreen] Recenter button pressed.");
                                    ref
                                        .read(locationProvider.notifier)
                                        .useCachedLocation();
                                    // Move map after state updates
                                    WidgetsBinding.instance
                                        .addPostFrameCallback(
                                            (_) => _moveToCurrentLocation());
                                  },
                                  backgroundColor: const Color(0xFF8B5CF6),
                                  child: Icon(
                                      locationState.isFetching
                                          ? Icons
                                              .location_searching // Indicate fetching
                                          : Icons.my_location,
                                      color: Colors.white),
                                ),
                              ),
                          ],
                        ),
                      ),
              ),
              SizedBox(height: screenSize.height * 0.02),
              // Show error messages from ErrorProvider
              if (error != null &&
                  error.type !=
                      ErrorType
                          .locationService) // Don't show non-service errors here if dialog handles it
                Padding(
                  padding: const EdgeInsets.only(bottom: 8.0),
                  child: Text(
                    error.message,
                    style: GoogleFonts.poppins(color: Colors.redAccent),
                    textAlign: TextAlign.center,
                  ),
                ),
              // Next Button
              Align(
                alignment: Alignment.centerRight,
                child: Padding(
                  padding: const EdgeInsets.only(
                      bottom: 16.0), // Add some bottom padding
                  child: FloatingActionButton(
                    heroTag: 'next_fab', // Unique heroTag
                    onPressed: userState
                            .isLocationValid() // Enable only if location is set
                        ? () {
                            print(
                                "[LocationInputScreen] Next button pressed. Navigating to Gender.");
                            Navigator.push(
                                context,
                                MaterialPageRoute(
                                    builder: (context) =>
                                        const GenderSelectionScreen()));
                          }
                        : null, // Disable button if location is not valid
                    backgroundColor: userState.isLocationValid()
                        ? const Color(0xFF8B5CF6)
                        : Colors.grey.shade400,
                    foregroundColor: Colors.white,
                    child: const Icon(Icons.arrow_forward_rounded),
                  ),
                ),
              ),
              SizedBox(
                  height: screenSize.height * 0.02), // Adjust bottom spacing
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    // Avoid potential errors if _mapController wasn't initialized
    // _mapController?.dispose(); // No need to dispose MapController typically
    super.dispose();
  }
}



================================================
File: views/main_navigation_screen.dart
================================================
// File: lib/views/main_navigation_screen.dart
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/chat_screen.dart';
import 'package:dtx/views/home.dart';
import 'package:dtx/views/profile_screens.dart';
import 'package:dtx/views/who_liked_you_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class MainNavigationScreen extends ConsumerStatefulWidget {
  const MainNavigationScreen({super.key});

  @override
  ConsumerState<MainNavigationScreen> createState() =>
      _MainNavigationScreenState();
}

class _MainNavigationScreenState extends ConsumerState<MainNavigationScreen> {
  int _selectedIndex = 0;

  static const List<Widget> _widgetOptions = <Widget>[
    HomeScreen(),
    WhoLikedYouScreen(),
    ChatPlaceholderScreen(),
    ProfileScreen(),
  ];

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      print(
          "[MainNavigationScreen] Post-frame callback: Initiating Likes and Profile fetches if needed.");

      // --- Simplified Fetch Logic ---
      // Fetch Likes only if data is empty (initial load)
      final likesState = ref.read(receivedLikesProvider);
      if (likesState.fullProfiles.isEmpty && likesState.otherLikers.isEmpty) {
        print(
            "[MainNavigationScreen] Likes data is empty, calling fetchLikes.");
        // We don't check isLoading here, let the notifier handle it if needed.
        // Adding a direct read+call might be slightly risky if the user switches tabs
        // VERY fast, but generally okay for initial load. A safer pattern might
        // involve listening or using FutureProvider if concurrent calls are a major concern.
        ref.read(receivedLikesProvider.notifier).fetchLikes();
      } else {
        print(
            "[MainNavigationScreen] Likes data already present, skipping fetchLikes call.");
      }

      // Fetch Profile only if data is missing (initial load)
      final userState = ref.read(userProvider);
      if (userState.name == null) {
        print(
            "[MainNavigationScreen] User profile data is empty, calling fetchProfile.");
        // Same note as above regarding potential concurrency.
        ref.read(userProvider.notifier).fetchProfile();
      } else {
        print(
            "[MainNavigationScreen] User profile data already present, skipping fetchProfile call.");
      }
      // --- End Simplified Fetch Logic ---
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: IndexedStack(
          index: _selectedIndex,
          children: _widgetOptions,
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(
            icon: Icon(Icons.home_outlined),
            activeIcon: Icon(Icons.home_filled),
            label: 'Discover',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.favorite_border_rounded),
            activeIcon: Icon(Icons.favorite_rounded),
            label: 'Likes',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.chat_bubble_outline_rounded),
            activeIcon: Icon(Icons.chat_bubble_rounded),
            label: 'Chat',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person_outline_rounded),
            activeIcon: Icon(Icons.person_rounded),
            label: 'Profile',
          ),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: const Color(0xFF8B5CF6),
        unselectedItemColor: Colors.grey[600],
        onTap: _onItemTapped,
        type: BottomNavigationBarType.fixed,
        showUnselectedLabels: true,
        backgroundColor: Colors.white,
        elevation: 5.0,
        selectedLabelStyle:
            GoogleFonts.poppins(fontSize: 12, fontWeight: FontWeight.w500),
        unselectedLabelStyle: GoogleFonts.poppins(fontSize: 12),
      ),
    );
  }
}



================================================
File: views/media.dart
================================================
// File: lib/views/media.dart
import 'dart:io';
import 'dart:typed_data';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/media_upload_provider.dart'; // Keep for potential size checks?
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/prompt.dart'; // Keep for onboarding flow
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:reorderable_grid_view/reorderable_grid_view.dart';
import 'package:dotted_border/dotted_border.dart';
import '../models/error_model.dart'; // Keep

// Wrapper class remains the same
class EditableMediaItem {
  final String? url;
  final File? file;
  final MediaType type;
  final UniqueKey key;

  EditableMediaItem({
    this.url,
    this.file,
    required this.type,
    required this.key,
  }) : assert(
            url != null || file != null, 'Either url or file must be provided');

  bool get isNewFile => file != null;
  String get displayIdentifier => url ?? file!.path; // Use path for new files
}

class MediaPickerScreen extends ConsumerStatefulWidget {
  final bool isEditing;

  const MediaPickerScreen({
    super.key,
    this.isEditing = false,
  });

  @override
  ConsumerState<MediaPickerScreen> createState() => _MediaPickerState();
}

class _MediaPickerState extends ConsumerState<MediaPickerScreen> {
  late List<EditableMediaItem?> _editableMedia;
  bool _isForwardButtonEnabled = false;
  bool _mediaHasChanged = false;

  // Allowed types (keep as before)
  final Set<String> _allowedImageMime = {
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/jpg'
  };
  final Set<String> _allowedVideoMime = {
    'video/mp4',
    'video/quicktime',
    'video/x-msvideo',
    'video/mpeg',
    'video/3gpp',
    'video/mp2t'
  };
  final Set<String> _allowedImageExtensions = {
    'jpg',
    'jpeg',
    'png',
    'gif',
    'webp',
    'bmp',
    'tiff'
  };
  final Set<String> _allowedVideoExtensions = {
    'mp4',
    'mov',
    'avi',
    'mpeg',
    'mpg',
    '3gp',
    'ts',
    'mkv'
  };

  @override
  void initState() {
    super.initState();
    _initializeMedia();
    WidgetsBinding.instance
        .addPostFrameCallback((_) => _updateForwardButtonState());
  }

  void _initializeMedia() {
    _editableMedia = List.filled(6, null);
    if (widget.isEditing) {
      final currentUrls = ref.read(userProvider).mediaUrls ?? [];
      for (int i = 0; i < currentUrls.length && i < 6; i++) {
        final url = currentUrls[i];
        final isVideo = url.toLowerCase().endsWith('.mp4') ||
            url.toLowerCase().endsWith('.mov');
        _editableMedia[i] = EditableMediaItem(
          url: url,
          type: isVideo ? MediaType.video : MediaType.image,
          key: UniqueKey(),
        );
      }
    }
    // Ensure list has 6 elements
    while (_editableMedia.length < 6) {
      _editableMedia.add(null);
    }
  }

  @override
  void dispose() {
    super.dispose();
  }

  Future<void> _pickMedia(int index) async {
    ref.read(errorProvider.notifier).clearError();
    final ImagePicker picker = ImagePicker();
    final XFile? media = await picker.pickMedia();

    if (media != null) {
      final mimeType = media.mimeType?.toLowerCase();
      final extension = media.path.split('.').last.toLowerCase();
      final filePath = media.path.replaceFirst('file://', '');
      final file = File(filePath);

      final isValidImage = _allowedImageMime.contains(mimeType) ||
          _allowedImageExtensions.contains(extension);
      final isValidVideo = _allowedVideoMime.contains(mimeType) ||
          _allowedVideoExtensions.contains(extension);
      final fileSize = await file.length();
      final isImage = isValidImage;
      final isVideo = isValidVideo;

      if (isImage && fileSize > 10 * 1024 * 1024) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Image is too large. Maximum size is 10 MB."));
        _clearSlot(index);
        return;
      }
      if (isVideo && fileSize > 50 * 1024 * 1024) {
        ref.read(errorProvider.notifier).setError(
            AppError.validation("Video is too large. Maximum size is 50 MB."));
        _clearSlot(index);
        return;
      }
      if (index == 0 && !isValidImage) {
        await _showErrorDialog(context, isMainImage: true);
        _clearSlot(index);
        return;
      }
      if (!isValidImage && !isValidVideo) {
        await _showErrorDialog(context);
        _clearSlot(index);
        return;
      }

      setState(() {
        _editableMedia[index] = EditableMediaItem(
          file: file,
          type: isVideo ? MediaType.video : MediaType.image,
          key: UniqueKey(),
        );
        _mediaHasChanged = true;
        _updateForwardButtonState();
      });
    }
  }

  void _clearSlot(int index) {
    // Prevent clearing main photo if <= 3 items
    final currentCount = _countSelectedMedia();
    if (index == 0 && currentCount <= 3 && _editableMedia[index] != null) {
      ref.read(errorProvider.notifier).setError(AppError.validation(
          "Cannot remove the main photo when less than 3 items are present."));
      return;
    }
    // Prevent clearing any item if it would result in less than 3 items remaining
    if (_editableMedia[index] != null && currentCount <= 3) {
      ref
          .read(errorProvider.notifier)
          .setError(AppError.validation("Minimum of 3 media items required."));
      return;
    }
    setState(() {
      _editableMedia[index] = null;
      _mediaHasChanged = true;
      _updateForwardButtonState();
    });
  }

  Future<void> _showErrorDialog(BuildContext context,
      {bool isMainImage = false}) async {
    // ... (same as before) ...
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(isMainImage ? 'Invalid Main Image' : 'Invalid File Type'),
        content: Text(isMainImage
            ? 'Main image must be an image file.\nAllowed formats: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF'
            : 'Allowed formats:\n• Images: JPG, JPEG, PNG, GIF, WEBP, BMP, TIFF\n• Videos: MP4, MOV, AVI, MPEG, 3GP, TS, MKV'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _reorderMedia(int oldGridIndex, int newGridIndex) {
    if (oldGridIndex == 0 || newGridIndex == 0) return;
    setState(() {
      final EditableMediaItem? item = _editableMedia.removeAt(oldGridIndex);
      if (item != null) {
        _editableMedia.insert(newGridIndex, item);
        _mediaHasChanged = true;
      } else {
        _editableMedia.insert(newGridIndex, null);
      }
      while (_editableMedia.length > 6) {
        _editableMedia.removeLast();
      }
      while (_editableMedia.length < 6) {
        _editableMedia.add(null);
      }
      _updateForwardButtonState();
    });
  }

  int _countSelectedMedia() {
    return _editableMedia.where((item) => item != null).length;
  }

  void _updateForwardButtonState() {
    int selectedCount = _countSelectedMedia();
    setState(() {
      _isForwardButtonEnabled = selectedCount >= 3;
    });
  }

  void _handleDone() {
    if (!_isForwardButtonEnabled) return;

    // --- *** CORE CHANGE for EDITING *** ---
    if (widget.isEditing) {
      // Create the list of strings (URLs or local paths)
      final List<String> finalMediaIdentifiers = _editableMedia
          .where((item) => item != null)
          .map((item) => item!.displayIdentifier) // Use url or file path
          .toList();

      // Update the user provider directly with this mixed list
      ref.read(userProvider.notifier).updateMediaUrls(finalMediaIdentifiers);

      // Set the flag if changes were made
      if (_mediaHasChanged) {
        ref.read(userProvider.notifier).setMediaChangedFlag(true);
      }
      print("[MediaPickerScreen Edit] Updated provider. Popping back.");
      Navigator.of(context).pop(); // Pop back to ProfileScreen
    } else {
      // --- ONBOARDING Flow (remains the same conceptually) ---
      final List<File> filesToUpload = _editableMedia
          .where((item) => item?.isNewFile == true)
          .map((item) => item!.file!)
          .toList();

      if (filesToUpload.isEmpty) {
        print(
            "[MediaPickerScreen Onboarding] No files selected? Navigating anyway.");
        Navigator.pushReplacement(
            context,
            MaterialPageRoute(
                builder: (context) => const ProfileAnswersScreen()));
        return;
      }

      final uploadNotifier = ref.read(mediaUploadProvider.notifier);
      // Create a temporary list matching the desired order
      List<File?> orderedFilesForUpload = List.filled(6, null);
      for (int i = 0; i < _editableMedia.length; i++) {
        if (_editableMedia[i]?.isNewFile == true) {
          orderedFilesForUpload[i] = _editableMedia[i]!.file;
        }
      }
      // Set the files in the provider
      for (int i = 0; i < orderedFilesForUpload.length; i++) {
        if (orderedFilesForUpload[i] != null) {
          uploadNotifier.setMediaFile(i, orderedFilesForUpload[i]!);
        } else {
          // uploadNotifier.removeMedia(i); // If provider needs explicit removal
        }
      }
      print(
          "[MediaPickerScreen Onboarding] Files set in provider. Navigating to Prompts.");
      Navigator.pushReplacement(
          context,
          MaterialPageRoute(
              builder: (context) => const ProfileAnswersScreen()));
      // --- End ONBOARDING Flow ---
    }
  }

  @override
  Widget build(BuildContext context) {
    // ... (build method remains the same, header and bottom bar logic unchanged) ...
    final errorState = ref.watch(errorProvider);
    final screenSize = MediaQuery.of(context).size;

    return Scaffold(
      backgroundColor: const Color(0xFFFAFAFA), // Lighter background
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: Icon(Icons.photo_library_rounded,
                            color: const Color(0xFF8B5CF6), size: 30),
                      ),
                    Text(
                      widget.isEditing ? "Edit Media" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: _isForwardButtonEnabled ? _handleDone : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: _isForwardButtonEnabled
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---
              SizedBox(height: screenSize.height * 0.02),
              Text(
                widget.isEditing
                    ? "Manage Your Gallery"
                    : "Create Your Gallery",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.07
                      : screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  letterSpacing: -0.5,
                ),
              ),
              Text(
                widget.isEditing
                    ? "Add, remove, or reorder photos/videos (min 3)"
                    : "Select at least 3 photos or videos",
                style: GoogleFonts.poppins(
                  fontSize: screenSize.width * 0.04,
                  color: Colors.grey[600],
                  fontWeight: FontWeight.w500,
                ),
              ),
              SizedBox(height: screenSize.height * 0.03),
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(20),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  padding: const EdgeInsets.all(16),
                  child: ReorderableGridView.count(
                    crossAxisCount: 2,
                    mainAxisSpacing: 16,
                    crossAxisSpacing: 16,
                    childAspectRatio: 0.95,
                    shrinkWrap: true,
                    physics: const BouncingScrollPhysics(),
                    children: List.generate(_editableMedia.length,
                        (index) => _buildMediaPlaceholder(index)),
                    onReorder: _reorderMedia,
                  ),
                ),
              ),
              if (errorState != null)
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 8.0),
                  child: Center(
                    child: Text(
                      errorState.message,
                      style:
                          GoogleFonts.poppins(color: Colors.red, fontSize: 14),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
              // --- Hide Bottom Bar in Edit Mode ---
              if (!widget.isEditing)
                Container(
                  padding: EdgeInsets.symmetric(
                    vertical: screenSize.height * 0.02,
                    horizontal: screenSize.width * 0.04,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(16),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, -4),
                      ),
                    ],
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "${_countSelectedMedia()}/6 Selected",
                            style: GoogleFonts.poppins(
                              fontSize: screenSize.width * 0.04,
                              fontWeight: FontWeight.w600,
                              color: const Color(0xFF8B5CF6),
                            ),
                          ),
                          Text(
                            "Minimum 3 required",
                            style: GoogleFonts.poppins(
                              fontSize: screenSize.width * 0.035,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                      GestureDetector(
                        onTap: _handleDone,
                        child: AnimatedContainer(
                          duration: const Duration(milliseconds: 200),
                          width: 60,
                          height: 60,
                          decoration: BoxDecoration(
                            color: _isForwardButtonEnabled
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey[300],
                            borderRadius: BorderRadius.circular(30),
                            boxShadow: _isForwardButtonEnabled
                                ? [
                                    BoxShadow(
                                      color: const Color(0xFF8B5CF6)
                                          .withOpacity(0.3),
                                      blurRadius: 8,
                                      offset: const Offset(0, 4),
                                    ),
                                  ]
                                : null,
                          ),
                          child: Icon(
                            Icons.arrow_forward_rounded,
                            color: _isForwardButtonEnabled
                                ? Colors.white
                                : Colors.grey[500],
                            size: 28,
                          ),
                        ),
                      )
                    ],
                  ),
                ),
              // --- End Hide Bottom Bar ---
              SizedBox(height: widget.isEditing ? 0 : screenSize.height * 0.02),
            ],
          ),
        ),
      ),
    );
  }

  // --- Placeholder builder remains the same conceptually ---
  Widget _buildMediaPlaceholder(int index) {
    final item = _editableMedia[index];
    return GestureDetector(
      key: item?.key ?? ValueKey('empty_$index'),
      onTap: () => _pickMedia(index),
      child: DottedBorder(
        dashPattern: const [6, 3],
        color: index == 0
            ? const Color(0xFF8B5CF6)
            : const Color(0xFF8B5CF6).withOpacity(0.6),
        strokeWidth: 2,
        borderType: BorderType.RRect,
        radius: const Radius.circular(16),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (item != null)
                ClipRRect(
                  borderRadius: BorderRadius.circular(16),
                  child: item.isNewFile
                      ? (item.type == MediaType.image
                          ? Image.file(item.file!, fit: BoxFit.cover)
                          : Container(
                              color: Colors.grey[300],
                              child: const Center(
                                  child: Icon(Icons.videocam_outlined,
                                      color: Colors.grey, size: 40))))
                      : (item.type == MediaType.image
                          ? Image.network(item.url!,
                              fit: BoxFit.cover,
                              errorBuilder: (_, __, ___) =>
                                  const Icon(Icons.broken_image))
                          : Container(
                              color: Colors.grey[300],
                              child: const Center(
                                  child: Icon(Icons.videocam_outlined,
                                      color: Colors.grey, size: 40)))),
                ),
              if (item == null)
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        index == 0
                            ? Icons.add_photo_alternate_rounded
                            : Icons.add_rounded,
                        color: const Color(0xFF8B5CF6).withOpacity(0.6),
                        size: 36,
                      ),
                      if (index == 0)
                        Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: Text("Main Photo",
                              style: GoogleFonts.poppins(fontSize: 14)),
                        ),
                    ],
                  ),
                ),
              if (item?.type == MediaType.video)
                const Center(
                  child: Icon(Icons.play_circle_fill_rounded,
                      color: Colors.white70, size: 48),
                ),
              if (widget.isEditing && item != null)
                Positioned(
                  top: 4,
                  right: 4,
                  child: GestureDetector(
                    onTap: () => _clearSlot(index),
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.6),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(Icons.close_rounded,
                          color: Colors.white, size: 16),
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

enum MediaType { image, video } // Keep enum



================================================
File: views/name.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/dob.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class NameInputScreen extends ConsumerStatefulWidget {
  const NameInputScreen({super.key});

  @override
  ConsumerState<NameInputScreen> createState() => _NameInputScreenState();
}

class _NameInputScreenState extends ConsumerState<NameInputScreen> {
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;

  @override
  void initState() {
    super.initState();
    final user = ref.read(userProvider);
    _firstNameController = TextEditingController(text: user.name);
    _lastNameController = TextEditingController(text: user.lastName ?? '');
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final error = ref.watch(errorProvider);

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF8B5CF6), Color(0xFF4C1D95)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.08),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(height: screenSize.height * 0.04),
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      child: const Icon(
                        Icons.badge_outlined,
                        size: 28,
                        color: Colors.white,
                      ),
                    ),
                    const SizedBox(width: 10),
                    Text(
                      "What's your name?",
                      style: GoogleFonts.poppins(
                        fontSize: screenSize.width * 0.06,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                  ],
                ),
                SizedBox(height: screenSize.height * 0.04),
                _buildFirstNameInput(error, screenSize),
                SizedBox(height: screenSize.height * 0.03),
                _buildLastNameInput(screenSize),
                const Spacer(),
                _buildNextButton(screenSize, error),
                SizedBox(height: screenSize.height * 0.04),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFirstNameInput(AppError? error, Size screenSize) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          decoration: BoxDecoration(
            border: Border(
              bottom: BorderSide(
                color: error?.type == ErrorType.validation
                    ? Colors.red
                    : Colors.white54,
                width: 1.5,
              ),
            ),
          ),
          child: TextField(
            controller: _firstNameController,
            style: GoogleFonts.poppins(
              fontSize: screenSize.width * 0.05,
              fontWeight: FontWeight.w500,
              color: Colors.white,
            ),
            cursorColor: Colors.white,
            decoration: InputDecoration(
              labelText: "First name (required)",
              labelStyle: GoogleFonts.poppins(
                fontSize: screenSize.width * 0.042,
                color: Colors.white54,
              ),
              border: InputBorder.none,
            ),
            onChanged: (value) => _updateName(value, _lastNameController.text),
          ),
        ),
        if (error?.type == ErrorType.validation)
          Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Text(
              error!.message,
              style: GoogleFonts.poppins(
                color: Colors.redAccent,
                fontSize: screenSize.width * 0.035,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildLastNameInput(Size screenSize) {
    return TextField(
      controller: _lastNameController,
      style: GoogleFonts.poppins(
        fontSize: screenSize.width * 0.05,
        fontWeight: FontWeight.w500,
        color: Colors.white,
      ),
      cursorColor: Colors.white,
      decoration: InputDecoration(
        labelText: "Last name (optional)",
        labelStyle: GoogleFonts.poppins(
          fontSize: screenSize.width * 0.042,
          color: Colors.white54,
        ),
        enabledBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white54, width: 1.5),
        ),
        focusedBorder: const UnderlineInputBorder(
          borderSide: BorderSide(color: Colors.white, width: 2.0),
        ),
      ),
      onChanged: (value) => _updateName(_firstNameController.text, value),
    );
  }

  Widget _buildNextButton(Size screenSize, AppError? error) {
    final isValid = ref.read(userProvider.notifier).isNameValid();

    return Align(
      alignment: Alignment.centerRight,
      child: ElevatedButton(
        onPressed: error == null && isValid
            ? () => _handleNextButton()
            : null, // Disable button if there are errors
        style: ElevatedButton.styleFrom(
          shape: const CircleBorder(),
          backgroundColor: error != null || !isValid
              ? Colors.grey.shade400 // Disable button if there are errors
              : Colors.white,
          shadowColor: Colors.black.withOpacity(0.2),
          elevation: 8,
          padding: EdgeInsets.all(16), // Adjusted padding
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          size: 24, // Adjusted icon size
          color: error != null || !isValid
              ? Colors.white54 // Change icon color when disabled
              : const Color(0xFF8B5CF6),
        ),
      ),
    );
  }

  void _updateName(String firstName, String lastName) {
    ref.read(userProvider.notifier).updateName(firstName, lastName);
  }

  void _handleNextButton() {
    ref.read(errorProvider.notifier).clearError();
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DateOfBirthScreen()),
    );
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    super.dispose();
  }
}



================================================
File: views/profile_screens.dart
================================================
// File: views/profile_screens.dart
import 'dart:math'; // Needed for interleaving logic
import 'dart:io'; // Needed for File type checking

import 'package:dtx/models/media_upload_model.dart';
import 'package:dtx/views/audioprompt.dart';
import 'package:dtx/views/dating_intentions.dart';
import 'package:dtx/views/drinking.dart';
import 'package:dtx/views/height.dart';
import 'package:dtx/views/hometown.dart';
import 'package:dtx/views/job.dart';
import 'package:dtx/views/media.dart';
import 'package:dtx/views/prompt.dart';
import 'package:dtx/views/religion.dart';
import 'package:dtx/views/smoking.dart';
import 'package:dtx/views/study.dart';
import 'package:dtx/views/textpromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:audioplayers/audioplayers.dart'; // Keep for local player

import 'package:dtx/models/user_model.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/settings_screen.dart';
import 'package:dtx/providers/error_provider.dart'; // <<< ADDED
import 'package:dtx/models/error_model.dart'; // <<< ADDED
import 'package:dtx/providers/service_provider.dart'; // <<< ADDED for repository
import 'package:dtx/providers/media_upload_provider.dart'; // <<< ADDED for upload
import 'package:dtx/services/api_service.dart'; // <<< ADDED for ApiException

class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  // --- Retained State for Local Audio Player ---
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isPlaying = false;
  String? _currentAudioUrl;
  // --- End Retained State ---

  // --- NEW State for Edit Mode ---
  bool _isEditing = false;
  bool _isSaving = false;
  UserModel? _originalProfileData; // To store data before editing starts
  // --- END NEW State ---

  @override
  void initState() {
    super.initState();
    // Fetching initiated in MainNavigationScreen initState now

    // --- Retained Audio Player Listeners ---
    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted) {
        setState(() {
          _isPlaying = state == PlayerState.playing;
          if (state == PlayerState.stopped || state == PlayerState.completed) {
            _currentAudioUrl = null;
          }
        });
      }
    });
    _audioPlayer.onPlayerComplete.listen((_) {
      if (mounted) {
        setState(() {
          _isPlaying = false;
          _currentAudioUrl = null;
        });
      }
    });
    // --- End Retained Listeners ---
  }

  @override
  void dispose() {
    try {
      if (_audioPlayer.state == PlayerState.playing ||
          _audioPlayer.state == PlayerState.paused) {
        _audioPlayer.stop();
      }
      _audioPlayer.dispose();
    } catch (e) {
      print("Error stopping/disposing audio player: $e");
    }
    // _pageController.dispose(); // Removed PageController
    super.dispose();
  }

  // --- Retained Local Audio Control ---
  Future<void> _playOrPauseAudio(String audioUrl) async {
    if (!mounted) return;
    try {
      final currentState = _audioPlayer.state;
      if (currentState == PlayerState.playing && _currentAudioUrl == audioUrl) {
        await _audioPlayer.pause();
      } else if (currentState == PlayerState.paused &&
          _currentAudioUrl == audioUrl) {
        await _audioPlayer.resume();
      } else {
        if (currentState == PlayerState.playing ||
            currentState == PlayerState.paused) {
          await _audioPlayer.stop();
        }
        await _audioPlayer.play(UrlSource(audioUrl));
        if (mounted) setState(() => _currentAudioUrl = audioUrl);
      }
    } catch (e) {
      print("Error playing/pausing audio: $e");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error playing audio: ${e.toString()}')));
        setState(() {
          _isPlaying = false;
          _currentAudioUrl = null;
        });
      }
    }
  }
  // --- End Retained Local Audio Control ---

  // --- NEW Edit Mode Handlers ---
  void _enterEditMode() {
    // Store current state before starting edits
    _originalProfileData = ref.read(userProvider);
    setState(() => _isEditing = true);
  }

  void _cancelEditMode() {
    // Discard changes by restoring original data or refetching
    if (_originalProfileData != null) {
      ref.read(userProvider.notifier).state = _originalProfileData!;
    } else {
      // Fallback: Refetch if original data wasn't stored
      ref.read(userProvider.notifier).fetchProfile();
    }
    // Reset media changed flag
    ref.read(userProvider.notifier).setMediaChangedFlag(false);
    setState(() => _isEditing = false);
  }

  Future<void> _handleSave() async {
    print("[ProfileScreen] Starting Save Process...");
    ref.read(errorProvider.notifier).clearError(); // Clear previous errors
    if (!mounted) return;
    setState(() => _isSaving = true);

    final userState = ref.read(userProvider);
    final userNotifier = ref.read(userProvider.notifier);
    List<String> finalMediaUrls =
        List<String>.from(userState.mediaUrls ?? []); // Start with current URLs

    try {
      // --- Media Upload Logic (if changed) ---
      if (userState.mediaChangedDuringEdit) {
        print("[ProfileScreen] Media changed, initiating upload...");
        final mediaUploadNotifier = ref.read(mediaUploadProvider.notifier);
        final currentMediaItems = userState.mediaUrls ??
            []; // List might contain URLs and local paths now

        // Identify new files to upload
        final List<File> filesToUpload = [];
        final List<int> fileIndices = []; // Track original indices of files
        final List<String> existingUrls = []; // Track existing URLs in order

        // Prepare the list for the upload provider based on the mixed list
        List<File?> filesForProvider = List.filled(6, null);

        for (int i = 0; i < currentMediaItems.length && i < 6; i++) {
          final item = currentMediaItems[i];
          File potentialFile = File(item); // Try treating it as a path
          if (await potentialFile.exists()) {
            // Check if it's a local file path
            filesToUpload.add(potentialFile);
            fileIndices.add(i);
            filesForProvider[i] =
                potentialFile; // Place file at correct index for provider
            print("   - Found new file at index $i: ${potentialFile.path}");
          } else if (item.startsWith('http')) {
            existingUrls.add(item); // Keep existing URLs
            print("   - Found existing URL at index $i: $item");
            // No file to upload for this slot
          } else {
            print(
                "   - Warning: Item at index $i is neither a valid file path nor a URL: $item");
          }
        }
        // Ensure minimum 3 media items rule is still met before upload/save
        if ((existingUrls.length + filesToUpload.length) < 3) {
          throw ApiException("Minimum of 3 media items required.");
        }

        if (filesToUpload.isNotEmpty) {
          // Set files in the provider in their correct order
          for (int i = 0; i < filesForProvider.length; i++) {
            if (filesForProvider[i] != null) {
              mediaUploadNotifier.setMediaFile(i, filesForProvider[i]!);
            } else {
              // If you have a clear method in provider, call it here for slots that are now empty
              // mediaUploadNotifier.removeMedia(i);
            }
          }

          print("[ProfileScreen] Calling uploadAllMedia...");
          final uploadSuccess = await mediaUploadNotifier.uploadAllMedia();

          if (!uploadSuccess) {
            print("[ProfileScreen] Media upload failed.");
            throw ApiException("Failed to upload media. Please try again.");
          }
          print("[ProfileScreen] Media upload successful.");

          // --- Reconstruct the final URL list ---
          final uploadedItemsState =
              ref.read(mediaUploadProvider); // Get the state AFTER upload
          final Map<String, String> uploadedFileNameToUrl = {};
          for (final uploadedItem in uploadedItemsState) {
            if (uploadedItem != null &&
                uploadedItem.status == UploadStatus.success &&
                uploadedItem.presignedUrl != null) {
              // Assuming presignedUrl IS the final URL after upload (adjust if not)
              uploadedFileNameToUrl[uploadedItem.fileName] =
                  uploadedItem.presignedUrl!;
            }
          }

          // Build the final list based on the original order
          final List<String> reconstructedUrls = [];
          for (final itemPathOrUrl in currentMediaItems) {
            File potentialFile = File(itemPathOrUrl);
            if (await potentialFile.exists()) {
              final fileName = potentialFile.path.split('/').last;
              if (uploadedFileNameToUrl.containsKey(fileName)) {
                reconstructedUrls.add(uploadedFileNameToUrl[fileName]!);
              } else {
                print("Warning: Uploaded file URL not found for $fileName");
              }
            } else if (itemPathOrUrl.startsWith('http')) {
              reconstructedUrls.add(itemPathOrUrl);
            }
          }
          finalMediaUrls = reconstructedUrls;
          print(
              "[ProfileScreen] Final reconstructed Media URLs: $finalMediaUrls");
        } else {
          print(
              "[ProfileScreen] Media marked changed, but no new files found to upload.");
          // Use the potentially reordered/deleted list directly
          finalMediaUrls = currentMediaItems
              .where((item) => item.startsWith('http'))
              .toList();
          if (finalMediaUrls.length < 3) {
            throw ApiException(
                "Minimum of 3 media items required after edits.");
          }
        }
      } else {
        print("[ProfileScreen] Media not changed, using existing URLs.");
        finalMediaUrls = userState.mediaUrls ?? [];
        if (finalMediaUrls.length < 3) {
          throw ApiException("Minimum of 3 media items required.");
        }
      }
      // --- End Media Upload Logic ---

      // --- Prepare PATCH Payload ---
      // Get the latest state which includes edits from other screens
      final latestUserState = ref.read(userProvider);
      Map<String, dynamic> payload = latestUserState.toJsonForEdit();
      // IMPORTANT: Overwrite media_urls in payload with the potentially updated list
      payload['media_urls'] = finalMediaUrls;

      // Remove non-editable fields explicitly just in case they slipped in
      payload.remove('name');
      payload.remove('last_name');
      payload.remove('date_of_birth');
      payload.remove('latitude');
      payload.remove('longitude');
      payload.remove('gender');
      payload.remove('id'); // Don't send ID in payload

      print("[ProfileScreen] Preparing PATCH payload: $payload");

      // --- Call API ---
      final userRepository = ref.read(userRepositoryProvider);
      final bool success = await userRepository.editProfile(payload);

      if (success) {
        print("[ProfileScreen] Profile edit successful.");
        // Update user provider with the final media URLs and reset flags
        userNotifier.updateMediaUrls(
            finalMediaUrls); // Updates URLs and resets mediaChanged flag
        userNotifier.setMediaChangedFlag(false); // Explicitly reset flag

        // Optionally refetch profile for absolute certainty (might be redundant)
        // await userNotifier.fetchProfile();

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
                content: Text("Profile updated successfully!"),
                backgroundColor: Colors.green),
          );
          setState(() => _isEditing = false); // Exit edit mode
        }
      } else {
        print(
            "[ProfileScreen] Profile edit failed (API returned false or non-success).");
        // Error should ideally be thrown by the repository/service layer
        if (mounted && ref.read(errorProvider) == null) {
          // Check if error already exists
          ref
              .read(errorProvider.notifier)
              .setError(AppError.server("Failed to save profile changes."));
        }
      }
    } on ApiException catch (e) {
      print("[ProfileScreen] Save failed: API Exception - ${e.message}");
      if (mounted)
        ref.read(errorProvider.notifier).setError(AppError.server(e.message));
    } catch (e, stack) {
      print("[ProfileScreen] Save failed: Unexpected error - $e");
      print(stack); // Print stack trace for debugging
      if (mounted)
        ref
            .read(errorProvider.notifier)
            .setError(AppError.generic("An unexpected error occurred."));
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  // --- END NEW Edit Mode Handlers ---

  // --- Helper Methods (some adapted from HomeProfileCard) ---

  String capitalizeFirstLetter(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }

  // --- UPDATED Top Icon Button Builder ---
  Widget _buildTopIconButton({
    required IconData icon,
    required String tooltip,
    required VoidCallback onPressed,
    bool isDisabled = false, // Added disabled state
    Color? color, // Optional color override
  }) {
    final iconColor =
        isDisabled ? Colors.grey[400] : (color ?? const Color(0xFF8B5CF6));
    return IconButton(
      icon: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: isDisabled
              ? Colors.grey[200]
              : Colors.grey[100], // Different bg when disabled
          borderRadius: BorderRadius.circular(12),
        ),
        child: Icon(icon, color: iconColor, size: 20),
      ),
      tooltip: isDisabled ? null : tooltip, // No tooltip if disabled
      onPressed: isDisabled ? null : onPressed,
    );
  }
  // --- END UPDATED ---

  Widget _buildEmptySection(
      String title, String message, IconData icon, VoidCallback? onEditTap) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: 30, horizontal: 20),
      margin: const EdgeInsets.symmetric(vertical: 16),
      decoration: BoxDecoration(
          color: Colors.grey[50],
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.grey[200]!)),
      child: Stack(// Use stack for edit button
          children: [
        Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Padding(
              padding: const EdgeInsets.only(bottom: 16.0),
              child: Text(title,
                  style: GoogleFonts.poppins(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                      color: Colors.grey[800])),
            ),
            Icon(icon, size: 40, color: Colors.grey[400]),
            const SizedBox(height: 12),
            Text(message,
                textAlign: TextAlign.center,
                style:
                    GoogleFonts.poppins(fontSize: 14, color: Colors.grey[600])),
          ],
        ),
        // Edit button overlay (visible only in edit mode)
        if (_isEditing && onEditTap != null)
          Positioned(
            top: 8,
            right: 8,
            child: _buildSmallEditButton(onPressed: onEditTap),
          ),
      ]),
    );
  }

  Widget _buildDetailChip(IconData icon, String label, {bool subtle = false}) {
    if (label.isEmpty) return const SizedBox.shrink();
    return Container(
      padding: EdgeInsets.symmetric(
          horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
      decoration: BoxDecoration(
        color: subtle ? Colors.transparent : Colors.grey[100],
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
            color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon,
              size: subtle ? 16 : 18,
              color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6)),
          const SizedBox(width: 6),
          Flexible(
            child: Text(label,
                style: GoogleFonts.poppins(
                    fontSize: subtle ? 13 : 14,
                    fontWeight: FontWeight.w500,
                    color: subtle ? Colors.grey.shade700 : Colors.grey[800]),
                overflow: TextOverflow.ellipsis),
          ),
        ],
      ),
    );
  }

  // --- NEW: Small Edit Button ---
  Widget _buildSmallEditButton(
      {required VoidCallback onPressed,
      IconData icon = Icons.edit_outlined,
      String? tooltip = 'Edit'}) {
    return Material(
      // Provides ink splash effect
      color: Colors.white.withOpacity(0.8),
      shape: const CircleBorder(),
      child: InkWell(
        customBorder: const CircleBorder(),
        onTap: onPressed,
        child: Container(
          padding: const EdgeInsets.all(6), // Smaller padding
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 3)
            ],
          ),
          child: Icon(icon,
              color: const Color(0xFF8B5CF6), size: 18), // Smaller icon
        ),
      ),
    );
  }
  // --- END NEW ---

  @override
  Widget build(BuildContext context) {
    final user = ref.watch(userProvider);
    final isLoadingProfile = ref.watch(userLoadingProvider);
    final apiError =
        ref.watch(errorProvider); // Watch for API errors during save

    // --- Loading State ---
    if (isLoadingProfile && user.name == null && !_isEditing) {
      // Show loading only on initial load
      // ... (loading scaffold remains the same) ...
      return Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          title: Text("Profile",
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          elevation: 0,
          automaticallyImplyLeading: false,
          actions: [
            _buildTopIconButton(
                icon: Icons.edit_outlined,
                tooltip: 'Edit Profile',
                onPressed: () {},
                isDisabled: true),
            const SizedBox(width: 8),
            _buildTopIconButton(
                icon: Icons.settings_outlined,
                tooltip: 'Settings',
                onPressed: () {},
                isDisabled: true),
            const SizedBox(width: 8),
          ],
        ),
        body: const Center(
            child: CircularProgressIndicator(color: Color(0xFF8B5CF6))),
      );
    }

    // --- Error State (Show general API errors if not saving) ---
    if (apiError != null && !_isSaving) {
      return Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          /* ... AppBar ... */
          title: Text("Profile",
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          elevation: 0,
          automaticallyImplyLeading: false,
          actions: [
            /* ... Actions (can be disabled) ... */
            _buildTopIconButton(
                icon: Icons.edit_outlined,
                tooltip: 'Edit Profile',
                onPressed: _enterEditMode), // Still allow entering edit maybe?
            const SizedBox(width: 8),
            _buildTopIconButton(
                icon: Icons.settings_outlined,
                tooltip: 'Settings',
                onPressed: () => Navigator.push(
                    context,
                    MaterialPageRoute(
                        builder: (context) => const SettingsScreen()))),
            const SizedBox(width: 8),
          ],
        ),
        body: Center(
            child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, color: Colors.red, size: 50),
              const SizedBox(height: 15),
              Text(apiError.message,
                  textAlign: TextAlign.center, style: GoogleFonts.poppins()),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  ref.read(errorProvider.notifier).clearError();
                  ref.read(userProvider.notifier).fetchProfile(); // Retry fetch
                },
                child: const Text("Retry"),
              )
            ],
          ),
        )),
      );
    }

    // --- Prepare Content Blocks (Logic from HomeProfileCard) ---
    final List<dynamic> contentBlocks = [];
    final mediaUrls =
        user.mediaUrls ?? []; // Use potentially modified list from provider
    final prompts = user.prompts;

    // 1. Header (Not editable, always show)
    contentBlocks.add("header_section");

    // 2. Media Section (Uses _buildMediaGallery wrapper now)
    contentBlocks.add("media_gallery");

    // 3. First Prompt (if available, else empty section)
    if (prompts.isNotEmpty) {
      contentBlocks.add(prompts[0]);
    } else {
      contentBlocks.add("empty_prompt_section");
    }

    // 4. Vitals Section
    contentBlocks.add("vitals_section");

    // 5. Interleave remaining media and prompts (Starting from index 1)
    int mediaBlockIndex = 1; // Index within the displayed media blocks
    int promptIndex = 1;

    // Find the actual number of remaining media items to display
    int remainingMediaCount =
        mediaUrls.length - 1; // Exclude the first one (handled in gallery)

    int maxRemaining = max(remainingMediaCount, prompts.length - 1);

    for (int i = 0; i < maxRemaining; i++) {
      // Add remaining prompts first
      if (promptIndex < prompts.length) {
        contentBlocks.add(prompts[promptIndex]);
        promptIndex++;
      }
      // Add remaining media after prompts (if any) - Now handled by Media Gallery
      // if (mediaBlockIndex < remainingMediaCount) {
      //    // Calculate the correct URL index (since first is handled by gallery)
      //    if (mediaBlockIndex < mediaUrls.length) { // Double check bounds
      //       contentBlocks.add(mediaUrls[mediaBlockIndex]);
      //    }
      //    mediaBlockIndex++;
      // }
    }
    // Add remaining prompts if media ran out first
    while (promptIndex < prompts.length) {
      contentBlocks.add(prompts[promptIndex]);
      promptIndex++;
    }

    // 6. Add Audio Prompt (if available, else empty section)
    if (user.audioPrompt != null) {
      contentBlocks.add(user.audioPrompt!);
    } else {
      contentBlocks.add("empty_audio_section");
    }
    // --- End Content Block Preparation ---

    // --- Build UI using SliverAppBar and ListView ---
    return Scaffold(
      backgroundColor: Colors.white,
      body: RefreshIndicator(
        color: const Color(0xFF8B5CF6),
        onRefresh: () async {
          if (!_isEditing) {
            // Allow refresh only when not editing
            await ref.read(userProvider.notifier).fetchProfile();
          }
        },
        child: CustomScrollView(
          physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics()),
          slivers: [
            SliverAppBar(
              pinned: true,
              floating: false,
              elevation: 1,
              backgroundColor: Colors.white,
              foregroundColor: Colors.black,
              automaticallyImplyLeading: false,
              title: Text(_isEditing ? "Edit Profile" : "Profile",
                  style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
              actions: _isEditing
                  ? [
                      // Actions in Edit Mode
                      if (_isSaving) // Show loading indicator instead of buttons
                        const Padding(
                          padding: EdgeInsets.all(16.0),
                          child: SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(strokeWidth: 2)),
                        )
                      else ...[
                        TextButton(
                          onPressed: _cancelEditMode,
                          child: Text("Cancel",
                              style: GoogleFonts.poppins(color: Colors.grey)),
                        ),
                        TextButton(
                          onPressed: _handleSave,
                          child: Text("Save",
                              style: GoogleFonts.poppins(
                                  color: const Color(0xFF8B5CF6),
                                  fontWeight: FontWeight.bold)),
                        ),
                        const SizedBox(width: 8),
                      ],
                    ]
                  : [
                      // Actions in View Mode
                      _buildTopIconButton(
                          icon: Icons.edit_outlined,
                          tooltip: 'Edit Profile',
                          onPressed: _enterEditMode),
                      const SizedBox(width: 8),
                      _buildTopIconButton(
                          icon: Icons.settings_outlined,
                          tooltip: 'Settings',
                          onPressed: () => Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) =>
                                      const SettingsScreen()))),
                      const SizedBox(width: 8),
                    ],
            ),

            // Use SliverList with ListView.builder equivalent logic
            SliverPadding(
              padding: const EdgeInsets.only(top: 8.0),
              sliver: SliverList(
                delegate: SliverChildBuilderDelegate(
                  (context, index) {
                    final item = contentBlocks[index];
                    final double bottomPadding = 24.0; // Consistent spacing
                    final double horizontalPadding =
                        16.0; // Consistent horizontal padding

                    Widget contentWidget;

                    // Build content based on type
                    if (item is String && item == "header_section") {
                      contentWidget = _buildHeaderBlock(user);
                    } else if (item is String && item == "media_gallery") {
                      contentWidget = _buildMediaGallery(
                          context, ref, mediaUrls); // Use gallery builder
                    }
                    // Handle empty sections with edit callbacks
                    else if (item is String && item == "empty_media_section") {
                      contentWidget = _buildEmptySection(
                          "Photos & Videos",
                          "Add photos and videos to show off your personality!",
                          Icons.add_photo_alternate_outlined,
                          () => Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) => const MediaPickerScreen(
                                      isEditing: true))));
                    } else if (item is String &&
                        item == "empty_prompt_section") {
                      contentWidget = _buildEmptySection(
                          "About Me",
                          "Add prompt answers to share more about yourself!",
                          Icons.chat_bubble_outline,
                          () => Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) =>
                                      ProfileAnswersScreen(isEditing: true))));
                    } else if (item is String &&
                        item == "empty_audio_section") {
                      contentWidget = _buildEmptySection(
                          "Voice Prompt",
                          "Record a voice prompt to let matches hear your voice!",
                          Icons.mic_none_rounded,
                          () => Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) => const VoicePromptScreen(
                                      isEditing: true))));
                    }
                    // Handle individual items
                    // else if (item is String && item.startsWith('http')) { // Media items are now handled by the gallery
                    //   contentWidget = _buildMediaItem(item);
                    // }
                    else if (item is Prompt) {
                      // Find the original index of this prompt for editing
                      int promptEditIndex = user.prompts
                          .indexWhere((p) => p.question == item.question);
                      contentWidget = _buildPromptItem(item,
                          onEditTap: () => Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) => TextSelectPromptScreen(
                                      isEditing: true,
                                      editIndex: promptEditIndex >= 0
                                          ? promptEditIndex
                                          : null))));
                    } else if (item is AudioPromptModel) {
                      contentWidget = _buildAudioItem(item,
                          onEditTap: () => Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (context) => const VoicePromptScreen(
                                      isEditing: true))));
                    } else if (item is String && item == "vitals_section") {
                      contentWidget = _buildVitalsBlock(user,
                          onEditTap: () =>
                              _navigateToVitalsEditFlow() // Navigate to first vitals screen
                          );
                    } else {
                      contentWidget = const SizedBox.shrink();
                    }

                    // Wrap content with Padding
                    return Padding(
                      padding: EdgeInsets.fromLTRB(horizontalPadding, 0,
                          horizontalPadding, bottomPadding),
                      child: contentWidget,
                    );
                  },
                  childCount: contentBlocks.length,
                ),
              ),
            ),
            // Add final padding at the bottom if needed
            const SliverToBoxAdapter(child: SizedBox(height: 20)),
          ],
        ),
      ),
    );
  }

  // --- Block Builder Widgets (Adapted for ProfileScreen with Edit Icons) ---

  Widget _buildHeaderBlock(UserModel user) {
    // (No edit icon needed here based on requirements)
    final age = user.age;
    final capitalizedName =
        user.name != null ? capitalizeFirstLetter(user.name!) : "Your Name";
    final capitalizedLastName =
        user.lastName != null && user.lastName!.isNotEmpty
            ? capitalizeFirstLetter(user.lastName!)
            : "";

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '$capitalizedName $capitalizedLastName ${age != null ? "• $age" : ""}',
          style: GoogleFonts.poppins(
              fontSize: 28,
              fontWeight: FontWeight.w700,
              color: const Color(0xFF1A1A1A),
              height: 1.2),
        ),
        const SizedBox(height: 12),
        if (user.gender != null ||
            (user.hometown != null && user.hometown!.isNotEmpty))
          Wrap(
            spacing: 10,
            runSpacing: 8,
            children: [
              // These are not editable per requirements
              if (user.gender != null)
                _buildDetailChip(
                    Icons.person_outline_rounded, user.gender!.label,
                    subtle: true),
              if (user.hometown != null && user.hometown!.isNotEmpty)
                _buildDetailChip(Icons.location_on_outlined, user.hometown!,
                    subtle: true),
              // --- ADD EDITABLE CHIP ---
              if (user.datingIntention != null)
                _buildEditableChip(
                    icon: Icons.favorite_border_rounded,
                    label: user.datingIntention!.label,
                    onEditTap: () => Navigator.push(
                        context,
                        MaterialPageRoute(
                            builder: (context) =>
                                const DatingIntentionsScreen(isEditing: true))),
                    subtle: true)
              else if (_isEditing) // Show add button if editing and no intention set
                _buildAddChip(
                    label: "Add Intention",
                    onAddTap: () => Navigator.push(
                        context,
                        MaterialPageRoute(
                            builder: (context) =>
                                const DatingIntentionsScreen(isEditing: true))),
                    subtle: true),
            ],
          ),
      ],
    );
  }

  // --- NEW: Media Gallery Builder ---
  Widget _buildMediaGallery(
      BuildContext context, WidgetRef ref, List<String> mediaUrls) {
    // Use a GridView or similar to display media items.
    // Add an Edit button visible only in _isEditing mode.
    return Stack(
      children: [
        if (mediaUrls.isEmpty)
          _buildEmptySection(
            "Photos & Videos",
            "Add photos and videos to show off your personality!",
            Icons.add_photo_alternate_outlined,
            () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const MediaPickerScreen(isEditing: true))),
          )
        else
          Container(
            // Simple GridView example - adjust styling as needed
            constraints: BoxConstraints(
                maxHeight:
                    MediaQuery.of(context).size.height * 0.5), // Limit height
            child: GridView.builder(
              shrinkWrap: true,
              physics:
                  const NeverScrollableScrollPhysics(), // Disable grid scrolling, rely on CustomScrollView
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 3,
                crossAxisSpacing: 8,
                mainAxisSpacing: 8,
                childAspectRatio: 1.0, // Square aspect ratio
              ),
              itemCount: mediaUrls.length,
              itemBuilder: (context, index) {
                final url = mediaUrls[index];
                final isVideo = url.toLowerCase().endsWith('.mp4') ||
                    url.toLowerCase().endsWith('.mov');
                return ClipRRect(
                  borderRadius: BorderRadius.circular(12),
                  child: Stack(
                    fit: StackFit.expand,
                    children: [
                      Image.network(
                        url,
                        fit: BoxFit.cover,
                        errorBuilder: (_, __, ___) => Container(
                            color: Colors.grey[200],
                            child: const Icon(Icons.broken_image)),
                        loadingBuilder: (_, child, progress) => progress == null
                            ? child
                            : Center(
                                child: CircularProgressIndicator(
                                    value: progress.expectedTotalBytes != null
                                        ? progress.cumulativeBytesLoaded /
                                            progress.expectedTotalBytes!
                                        : null)),
                      ),
                      if (isVideo)
                        const Center(
                            child: Icon(Icons.play_circle_fill,
                                color: Colors.white70, size: 30)),
                    ],
                  ),
                );
              },
            ),
          ),

        // Centralized Edit Button for the Gallery
        if (_isEditing && mediaUrls.isNotEmpty)
          Positioned(
            top: 8,
            right: 8,
            child: _buildSmallEditButton(
              tooltip: "Edit Media",
              onPressed: () => Navigator.push(
                  context,
                  MaterialPageRoute(
                      builder: (context) =>
                          const MediaPickerScreen(isEditing: true))),
            ),
          ),
      ],
    );
  }
  // --- END NEW Media Gallery Builder ---

  Widget _buildPromptItem(Prompt prompt, {required VoidCallback onEditTap}) {
    if (prompt.answer.trim().isEmpty && !_isEditing)
      return const SizedBox.shrink(); // Hide empty in view mode

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.grey[200]!),
        boxShadow: [
          BoxShadow(
              color: Colors.grey.withOpacity(0.06),
              blurRadius: 10,
              offset: const Offset(0, 3))
        ],
      ),
      child: Stack(
        // Use Stack for edit button
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(prompt.question.label,
                  style: GoogleFonts.poppins(
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                      color: const Color(0xFF8B5CF6))),
              const SizedBox(height: 10),
              if (prompt.answer.trim().isNotEmpty)
                Text(prompt.answer,
                    style: GoogleFonts.poppins(
                        fontSize: 16,
                        color: Colors.grey[850],
                        height: 1.5,
                        fontWeight: FontWeight.w500))
              else if (_isEditing) // Show placeholder if editing and empty
                Text("Tap edit to add your answer...",
                    style: GoogleFonts.poppins(
                        fontSize: 16,
                        color: Colors.grey[400],
                        fontStyle: FontStyle.italic)),
            ],
          ),
          // Edit button overlay
          if (_isEditing)
            Positioned(
              top: -8, // Adjust position
              right: -8, // Adjust position
              child: _buildSmallEditButton(onPressed: onEditTap),
            ),
        ],
      ),
    );
  }

  Widget _buildAudioItem(AudioPromptModel audio,
      {required VoidCallback onEditTap}) {
    final bool isThisPlaying = _currentAudioUrl == audio.audioUrl && _isPlaying;
    final bool isThisPaused = _currentAudioUrl == audio.audioUrl &&
        !_isPlaying &&
        _audioPlayer.state == PlayerState.paused;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(bottom: 8.0),
          child: Row(
            // Add Row for title and edit button
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text("Voice Prompt",
                  style: GoogleFonts.poppins(
                      fontSize: 20,
                      fontWeight: FontWeight.w600,
                      color: const Color(0xFF1A1A1A))),
              if (_isEditing)
                _buildSmallEditButton(
                    onPressed: onEditTap, tooltip: "Edit Voice Prompt"),
            ],
          ),
        ),
        GestureDetector(
          onTap: () => _playOrPauseAudio(audio.audioUrl),
          child: Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(color: Colors.grey[200]!),
              boxShadow: [
                BoxShadow(
                    color: Colors.grey.withOpacity(0.06),
                    blurRadius: 10,
                    offset: const Offset(0, 3))
              ],
            ),
            child: Row(
              children: [
                Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                      color: const Color(0xFF8B5CF6),
                      borderRadius: BorderRadius.circular(24),
                      boxShadow: [
                        BoxShadow(
                            color: const Color(0xFF8B5CF6).withOpacity(0.3),
                            blurRadius: 8,
                            offset: const Offset(0, 2))
                      ]),
                  child: Icon(
                      isThisPlaying
                          ? Icons.pause_rounded
                          : Icons.play_arrow_rounded,
                      color: Colors.white,
                      size: 28),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(audio.prompt.label,
                          style: GoogleFonts.poppins(
                              fontSize: 15,
                              fontWeight: FontWeight.w500,
                              color: const Color(0xFF1A1A1A))),
                      const SizedBox(height: 4),
                      Text(
                          isThisPlaying
                              ? "Playing..."
                              : (isThisPaused ? "Paused" : "Tap to listen"),
                          style: GoogleFonts.poppins(
                              fontSize: 13, color: Colors.grey[600])),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildVitalsBlock(UserModel user, {required VoidCallback onEditTap}) {
    final List<Widget> vitals = [];
    // Use _buildEditableChip for editable vitals
    if (user.height != null && user.height!.isNotEmpty)
      vitals.add(_buildEditableChip(
          icon: Icons.height_rounded,
          label: user.height!,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const HeightSelectionScreen(isEditing: true)))));
    if (user.religiousBeliefs != null)
      vitals.add(_buildEditableChip(
          icon: Icons.church_outlined,
          label: user.religiousBeliefs!.label,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const ReligionScreen(isEditing: true)))));
    if (user.jobTitle != null && user.jobTitle!.isNotEmpty)
      vitals.add(_buildEditableChip(
          icon: Icons.work_outline_rounded,
          label: user.jobTitle!,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const JobTitleScreen(isEditing: true)))));
    if (user.education != null && user.education!.isNotEmpty)
      vitals.add(_buildEditableChip(
          icon: Icons.school_outlined,
          label: user.education!,
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const StudyLocationScreen(isEditing: true)))));
    if (user.drinkingHabit != null)
      vitals.add(_buildEditableChip(
          icon: Icons.local_bar_outlined,
          label: "Drinks: ${user.drinkingHabit!.label}",
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const DrinkingScreen(isEditing: true)))));
    if (user.smokingHabit != null)
      vitals.add(_buildEditableChip(
          icon: Icons.smoking_rooms_outlined,
          label: "Smokes: ${user.smokingHabit!.label}",
          onEditTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                  builder: (context) =>
                      const SmokingScreen(isEditing: true)))));

    // Add "Add" buttons if editing and field is empty
    if (_isEditing) {
      if (user.height == null || user.height!.isEmpty)
        vitals.add(_buildAddChip(
            label: "Add Height",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const HeightSelectionScreen(isEditing: true)))));
      if (user.religiousBeliefs == null)
        vitals.add(_buildAddChip(
            label: "Add Religion",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const ReligionScreen(isEditing: true)))));
      if (user.jobTitle == null || user.jobTitle!.isEmpty)
        vitals.add(_buildAddChip(
            label: "Add Job",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const JobTitleScreen(isEditing: true)))));
      if (user.education == null || user.education!.isEmpty)
        vitals.add(_buildAddChip(
            label: "Add Education",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const StudyLocationScreen(isEditing: true)))));
      if (user.drinkingHabit == null)
        vitals.add(_buildAddChip(
            label: "Add Drinking Habit",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const DrinkingScreen(isEditing: true)))));
      if (user.smokingHabit == null)
        vitals.add(_buildAddChip(
            label: "Add Smoking Habit",
            onAddTap: () => Navigator.push(
                context,
                MaterialPageRoute(
                    builder: (context) =>
                        const SmokingScreen(isEditing: true)))));
    }

    if (vitals.isEmpty && !_isEditing) {
      // Hide if empty and not editing
      return const SizedBox.shrink();
    }
    if (vitals.isEmpty && _isEditing) {
      // Show empty section if editing and empty
      return _buildEmptySection(
          "Vitals & Habits",
          "Add more details like your height, job, habits, etc.",
          Icons.list_alt_rounded,
          onEditTap // Pass the main edit tap handler
          );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(bottom: 12.0),
          child: Row(
            // Row for title and edit button
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text("Vitals & Habits",
                  style: GoogleFonts.poppins(
                      fontSize: 20,
                      fontWeight: FontWeight.w600,
                      color: const Color(0xFF1A1A1A))),
              if (_isEditing &&
                  vitals.isNotEmpty) // Show edit only if editing and not empty
                _buildSmallEditButton(
                    onPressed: onEditTap, tooltip: "Edit Vitals"),
            ],
          ),
        ),
        Container(
            padding: const EdgeInsets.symmetric(
                horizontal: 0, vertical: 8), // Reduced padding
            width: double.infinity,
            // Removed background decoration - let chips handle their own style
            child: Wrap(
              // Use Wrap for better layout
              spacing: 8,
              runSpacing: 8,
              children: vitals,
            )),
      ],
    );
  }

  // --- NEW: Editable Chip Widget ---
  Widget _buildEditableChip({
    required IconData icon,
    required String label,
    required VoidCallback onEditTap,
    bool subtle = false,
  }) {
    if (label.isEmpty) return const SizedBox.shrink();
    return InkWell(
      // Make chip tappable in edit mode
      onTap: _isEditing ? onEditTap : null,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
        decoration: BoxDecoration(
          color: subtle ? Colors.transparent : Colors.grey[100],
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
              color: subtle ? Colors.grey.shade400 : Colors.grey.shade200),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon,
                size: subtle ? 16 : 18,
                color: subtle ? Colors.grey.shade600 : const Color(0xFF8B5CF6)),
            const SizedBox(width: 6),
            Flexible(
                child: Text(label,
                    style: GoogleFonts.poppins(
                        fontSize: subtle ? 13 : 14,
                        fontWeight: FontWeight.w500,
                        color:
                            subtle ? Colors.grey.shade700 : Colors.grey[800]),
                    overflow: TextOverflow.ellipsis)),
            if (_isEditing) ...[
              // Show mini edit icon if editing
              const SizedBox(width: 6),
              Icon(Icons.edit, size: 14, color: Colors.grey[500]),
            ]
          ],
        ),
      ),
    );
  }
  // --- END NEW Editable Chip ---

  // --- NEW: Add Chip Widget ---
  Widget _buildAddChip({
    required String label,
    required VoidCallback onAddTap,
    bool subtle = false,
  }) {
    return InkWell(
      onTap: onAddTap,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: subtle ? 10 : 12, vertical: subtle ? 6 : 8),
        decoration: BoxDecoration(
          color: Colors.transparent,
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
              color: Colors.grey.shade400,
              style: BorderStyle
                  .solid), // Dashed border? DottedBorder package needed
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.add_circle_outline,
                size: subtle ? 16 : 18, color: Colors.grey.shade600),
            const SizedBox(width: 6),
            Flexible(
                child: Text(label,
                    style: GoogleFonts.poppins(
                        fontSize: subtle ? 13 : 14,
                        fontWeight: FontWeight.w500,
                        color: Colors.grey.shade700),
                    overflow: TextOverflow.ellipsis)),
          ],
        ),
      ),
    );
  }
  // --- END NEW Add Chip ---

  // Helper to navigate to the start of the vitals editing flow
  // This might need refinement if you want specific edit targets
  void _navigateToVitalsEditFlow() {
    // Start with Height as an example
    Navigator.push(
        context,
        MaterialPageRoute(
            builder: (context) =>
                const HeightSelectionScreen(isEditing: true)));
    // You might chain navigations or create a dedicated "Edit Vitals" screen
  }
} // End of _ProfileScreenState



================================================
File: views/prompt.dart
================================================
// File: lib/views/prompt.dart
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/audioprompt.dart'; // Keep for onboarding flow
// Removed unused audiopromptsselect import
// Removed unused media import
import 'package:dtx/views/textpromptsselect.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';

class ProfileAnswersScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const ProfileAnswersScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<ProfileAnswersScreen> createState() =>
      _ProfileAnswersScreenState();
}

class _ProfileAnswersScreenState extends ConsumerState<ProfileAnswersScreen> {
  // Removed _isForwardButtonEnabled - logic handled by checking prompt count now

  // --- No need for initState/updateForwardButtonState ---

  void _handlePromptTap(Prompt? prompt, int index) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => TextSelectPromptScreen(
          editIndex: prompt != null ? index : null,
          isEditing: widget.isEditing, // <<< Pass editing flag
        ),
      ),
    ); // No need for .then() as UI updates reactively
  }

  void _handleRemovePrompt(int index) {
    // Add confirmation dialog?
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text("Remove Prompt?"),
        content:
            const Text("Are you sure you want to remove this prompt answer?"),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: const Text("Cancel"),
          ),
          TextButton(
            onPressed: () {
              ref.read(userProvider.notifier).removePromptAtIndex(index);
              Navigator.pop(dialogContext);
            },
            child: const Text("Remove", style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  void _handleNext() {
    final prompts = ref.read(userProvider).prompts;
    // Onboarding requires at least one prompt
    if (!widget.isEditing &&
        prompts.where((p) => p.answer.trim().isNotEmpty).isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text("Please answer at least one prompt.",
              style: GoogleFonts.poppins()),
          backgroundColor: Colors.red[400],
        ),
      );
      return;
    }

    if (widget.isEditing) {
      print("[ProfileAnswersScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[ProfileAnswersScreen] Onboarding next: Audio Prompt.");
      Navigator.pushReplacement(
        // Use replacement for onboarding
        context,
        MaterialPageRoute(builder: (context) => const VoicePromptScreen()),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    final userState = ref.watch(userProvider);
    final prompts = userState.prompts;
    final bool canProceed =
        prompts.where((p) => p.answer.trim().isNotEmpty).isNotEmpty;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: 0, // No back button needed here typically
                  right: 0,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder for onboarding alignment
                      const SizedBox(width: 48),
                    Text(
                      widget.isEditing ? "Edit Prompts" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed:
                            _handleNext, // Always enabled for edit? Or check canProceed? Let's allow saving empty.
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: const Color(0xFF8B5CF6), // Always enabled
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for onboarding
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              const SizedBox(height: 20), // Reduced top space
              Text(
                widget.isEditing ? "Edit Your Prompts" : "Profile Prompts",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? 28
                      : 36, // Slightly smaller title in edit
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 12),
              Text(
                widget.isEditing
                    ? "Tap a prompt to edit or remove it."
                    : "Share three interesting facts about yourself",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 40),
              Expanded(
                child: ListView.separated(
                  itemCount: 3,
                  separatorBuilder: (_, __) => const SizedBox(height: 24),
                  itemBuilder: (context, index) {
                    final prompt =
                        index < prompts.length ? prompts[index] : null;
                    return _buildPromptCard(prompt, index);
                  },
                ),
              ),
              const SizedBox(height: 16),
              // --- Hide Bottom Bar in Edit Mode ---
              if (!widget.isEditing)
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Text(
                      "At least 1 prompt required",
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        color: Colors.grey[600],
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                    _buildForwardButton(canProceed), // Pass enabled state
                  ],
                ),
              // --- End Hide Bottom Bar ---
              SizedBox(
                  height: widget.isEditing ? 16 : 32), // Adjust bottom padding
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPromptCard(Prompt? prompt, int index) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: prompt != null ? const Color(0xFF8B5CF6) : Colors.grey[300]!,
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(16),
          onTap: () => _handlePromptTap(prompt, index),
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        prompt?.question.label ?? "Add a prompt",
                        style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w500,
                          color: prompt != null
                              ? Colors.black87
                              : Colors.grey[700],
                        ),
                      ),
                    ),
                    // Show Edit or Add Icon
                    Icon(
                      prompt != null
                          ? Icons.edit_outlined
                          : Icons.add_circle_outline,
                      color: const Color(0xFF8B5CF6),
                      size: 24,
                    ),
                    // Add Remove Icon if editing and prompt exists
                    if (widget.isEditing && prompt != null) ...[
                      const SizedBox(width: 10),
                      IconButton(
                        icon: Icon(Icons.delete_outline,
                            color: Colors.redAccent.withOpacity(0.7), size: 24),
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                        tooltip: "Remove Prompt",
                        onPressed: () => _handleRemovePrompt(index),
                      ),
                    ]
                  ],
                ),
                if (prompt?.answer.isNotEmpty ?? false) ...[
                  const SizedBox(height: 12),
                  Text(
                    prompt!.answer,
                    style: GoogleFonts.poppins(
                      fontSize: 16,
                      color: Colors.grey[700], // Slightly muted answer color
                      height: 1.4,
                    ),
                    maxLines: 3, // Limit display lines
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  // Onboarding Forward Button
  Widget _buildForwardButton(bool isEnabled) {
    return GestureDetector(
      onTap: isEnabled ? _handleNext : null,
      child: Container(
        width: 70,
        height: 70,
        decoration: BoxDecoration(
          color: isEnabled ? const Color(0xFF8B5CF6) : Colors.grey.shade400,
          borderRadius: BorderRadius.circular(35),
          boxShadow: [
            if (isEnabled)
              BoxShadow(
                color: const Color(0xFF8B5CF6).withOpacity(0.3),
                blurRadius: 12,
                offset: const Offset(0, 4),
              ),
          ],
        ),
        child: Icon(
          Icons.arrow_forward_rounded,
          color: isEnabled ? Colors.white : Colors.grey.shade600,
          size: 32,
        ),
      ),
    );
  }
}



================================================
File: views/religion.dart
================================================
// File: lib/views/religion.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/drinking.dart'; // Keep for onboarding flow

class ReligionScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const ReligionScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<ReligionScreen> createState() => _ReligionScreenState();
}

class _ReligionScreenState extends ConsumerState<ReligionScreen> {
  Religion? _selectedReligion; // Local state

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _selectedReligion = ref.read(userProvider).religiousBeliefs;
    }
  }

  void _handleNext() {
    if (_selectedReligion != null) {
      ref.read(userProvider.notifier).updateReligiousBeliefs(_selectedReligion);
      if (widget.isEditing) {
        print("[ReligionScreen] Editing done, popping back.");
        Navigator.of(context).pop();
      } else {
        // Original onboarding navigation
        print("[ReligionScreen] Onboarding next: Drinking.");
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const DrinkingScreen()));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder for alignment in onboarding
                      const SizedBox(
                          width: 48), // Matches IconButton width approx

                    Text(
                      widget.isEditing ? "Edit Religion" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    if (widget.isEditing)
                      TextButton(
                        onPressed:
                            _selectedReligion != null ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: _selectedReligion != null
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for alignment in onboarding
                      const SizedBox(
                          width: 48), // Matches TextButton width approx
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),
              Text(
                widget.isEditing
                    ? "Edit your religious beliefs"
                    : "What are your religious beliefs?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),
              SizedBox(height: screenSize.height * 0.05),
              Wrap(
                spacing: screenSize.width * 0.03,
                runSpacing: screenSize.height * 0.015,
                children: Religion.values
                    .map((religion) =>
                        _buildReligionButton(religion, screenSize))
                    .toList(),
              ),
              const Spacer(),
              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Padding(
                  padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      GestureDetector(
                        onTap: _selectedReligion != null ? _handleNext : null,
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: _selectedReligion != null
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey.shade300,
                            borderRadius: BorderRadius.circular(35),
                          ),
                          child: const Icon(
                            Icons.arrow_forward_rounded,
                            color: Colors.white,
                            size: 32,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildReligionButton(Religion religion, Size screenSize) {
    bool isSelected = _selectedReligion == religion; // Use local state
    return GestureDetector(
      onTap: () =>
          setState(() => _selectedReligion = religion), // Update local state
      child: Container(
        padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.015),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
          borderRadius: BorderRadius.circular(25),
          border: Border.all(color: Colors.grey.shade300, width: 1.0),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              religion.label,
              style: GoogleFonts.poppins(
                fontSize: 18,
                fontWeight: FontWeight.w500,
                color: isSelected ? Colors.white : Colors.black87,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/selfie_capture_screen.dart
================================================
// File: views/selfie_capture_screen.dart
import 'dart:async';
import 'dart:io';
import 'package:dtx/providers/media_upload_provider.dart';
import 'package:dtx/views/verification_pending_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:camera/camera.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class SelfieCaptureScreen extends ConsumerStatefulWidget {
  const SelfieCaptureScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<SelfieCaptureScreen> createState() => _SelfieCaptureScreenState();
}

class _SelfieCaptureScreenState extends ConsumerState<SelfieCaptureScreen>
    with WidgetsBindingObserver {
  CameraController? _cameraController;
  List<CameraDescription> _cameras = [];
  bool _isCameraInitialized = false;
  bool _hasError = false;
  double _aspectRatio = 1.0;
  bool _isUploading = false; // Track uploading state

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initializeCamera();
  }

  Future<void> _initializeCamera() async {
    try {
      _cameras = await availableCameras();
      if (_cameras.isEmpty) throw Exception('No cameras available');

      final frontCamera = _cameras.firstWhere(
        (camera) => camera.lensDirection == CameraLensDirection.front,
        orElse: () => _cameras.first,
      );

      _cameraController = CameraController(
        frontCamera,
        ResolutionPreset.medium,
        enableAudio: false,
      );

      await _cameraController!.initialize();
      
      final previewSize = _cameraController!.value.previewSize!;
      _aspectRatio = previewSize.width / previewSize.height;

      if (mounted) setState(() => _isCameraInitialized = true);
      
    } catch (e) {
      if (mounted) setState(() => _hasError = true);
      print('Camera Error: $e');
    }
  }

  Widget _buildCameraPreview() {
    if (_hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, color: Colors.white, size: 50),
            const SizedBox(height: 20),
            Text(
              'Camera Error',
              style: GoogleFonts.poppins(color: Colors.white, fontSize: 20),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: _initializeCamera,
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF8B5CF6),
              ),
              child: Text(
                'Retry',
                style: GoogleFonts.poppins(color: Colors.white),
              ),
            ),
          ],
        ),
      );
    }

    if (!_isCameraInitialized || _cameraController == null) {
      return const Center(
        child: CircularProgressIndicator(color: Color(0xFF8B5CF6)),
      );
    }

    return AspectRatio(
      aspectRatio: _aspectRatio,
      child: CameraPreview(_cameraController!),
    );
  }

  Future<void> _captureImage() async {
    if (!_isCameraInitialized || _cameraController == null) return;

    try {
      setState(() => _isUploading = true);

      final image = await _cameraController!.takePicture();
      final imageFile = File(image.path);

      // Set verification image in provider
      ref.read(mediaUploadProvider.notifier).setVerificationImage(imageFile);

      // Upload verification image
      final success = await ref.read(mediaUploadProvider.notifier).uploadVerificationImage();

      setState(() => _isUploading = false);

      if (success) {
        // Navigate to verification pending screen
        if (mounted) {
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (context) => const VerificationPendingScreen()),
          );
        }
      } else {
        // Handle upload failure
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to upload verification image. Please try again.')),
        );
      }
    } catch (e) {
      setState(() => _isUploading = false);
      print('Capture Error: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Capture Error: ${e.toString()}')),
      );
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _cameraController?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Stack(
          children: [
            Column(
              children: [
                // Header
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.arrow_back, color: Colors.white),
                        onPressed: () => Navigator.pop(context),
                      ),
                      Text(
                        "Take Selfie",
                        style: GoogleFonts.poppins(
                          color: Colors.white,
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
                Expanded(
                  child: _buildCameraPreview(),
                ),
              ],
            ),

            // Loading indicator overlay
            if (_isUploading)
              Container(
                color: Colors.black.withOpacity(0.5),
                child: const Center(
                  child: CircularProgressIndicator(
                    color: Color(0xFF8B5CF6),
                  ),
                ),
              ),
          ],
        ),
      ),
      floatingActionButton: !_isUploading ? FloatingActionButton(
        backgroundColor: const Color(0xFF8B5CF6),
        onPressed: _captureImage,
        child: const Icon(Icons.camera_alt, color: Colors.white),
      ) : null,
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
    );
  }
}



================================================
File: views/settings_screen.dart
================================================
// File: lib/views/settings_screen.dart
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class SettingsScreen extends ConsumerWidget {
  const SettingsScreen({super.key});

  Future<void> _showLogoutConfirmationDialog(
      BuildContext context, WidgetRef ref) async {
    return showDialog<void>(
      context: context,
      barrierDismissible: false, // User must tap button!
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text('Confirm Logout',
              style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
          content: Text('Are you sure you want to log out?',
              style: GoogleFonts.poppins()),
          actions: <Widget>[
            TextButton(
              child: Text('Cancel',
                  style: GoogleFonts.poppins(color: Colors.grey)),
              onPressed: () {
                Navigator.of(dialogContext).pop(); // Close the dialog
              },
            ),
            TextButton(
              child: Text('Logout',
                  style: GoogleFonts.poppins(color: Colors.redAccent)),
              onPressed: () async {
                Navigator.of(dialogContext).pop(); // Close the dialog first
                await _performLogout(context, ref); // Perform logout
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _performLogout(BuildContext context, WidgetRef ref) async {
    print("[SettingsScreen] Performing logout...");
    // Call the logout method from the auth provider
    await ref.read(authProvider.notifier).logout();
    print("[SettingsScreen] Logout complete. Navigating to SignInScreen.");

    // Navigate to the sign-in screen and remove all previous routes
    // Check if context is still valid before navigating
    if (context.mounted) {
      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (context) => const GoogleSignInScreen()),
        (Route<dynamic> route) => false, // Remove all routes
      );
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      backgroundColor: Colors.grey[100], // Light background for settings
      appBar: AppBar(
        title: Text(
          'Settings',
          style: GoogleFonts.poppins(fontWeight: FontWeight.w600),
        ),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 1,
      ),
      body: ListView(
        padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 16),
        children: [
          // Example Setting (can add more later)
          // ListTile(
          //   leading: Icon(Icons.notifications_outlined, color: Colors.grey[700]),
          //   title: Text('Notifications', style: GoogleFonts.poppins()),
          //   trailing: Icon(Icons.arrow_forward_ios_rounded, size: 16, color: Colors.grey[500]),
          //   onTap: () {
          //     // TODO: Navigate to Notification Settings
          //   },
          // ),
          // Divider(), // Separator

          // Logout Option
          ListTile(
            leading: Icon(Icons.logout_rounded, color: Colors.redAccent[200]),
            title: Text('Logout',
                style: GoogleFonts.poppins(color: Colors.redAccent[200])),
            onTap: () => _showLogoutConfirmationDialog(context, ref),
          ),
          Divider(),
        ],
      ),
    );
  }
}



================================================
File: views/smoking.dart
================================================
// File: lib/views/smoking.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/views/media.dart'; // Keep for onboarding flow

class SmokingScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const SmokingScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<SmokingScreen> createState() => _SmokingScreenState();
}

class _SmokingScreenState extends ConsumerState<SmokingScreen>
    with SingleTickerProviderStateMixin {
  DrinkingSmokingHabits? _selectedSmokingHabit; // Local state
  // Removed _isOptionSelected
  late AnimationController _controller; // Keep for animations if desired
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );

    // Load initial value if editing
    if (widget.isEditing) {
      _selectedSmokingHabit = ref.read(userProvider).smokingHabit;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleNext() {
    if (_selectedSmokingHabit != null) {
      ref.read(userProvider.notifier).updateSmokingHabit(_selectedSmokingHabit);
      if (widget.isEditing) {
        print("[SmokingScreen] Editing done, popping back.");
        Navigator.of(context).pop();
      } else {
        // Original onboarding navigation
        print("[SmokingScreen] Onboarding next: Media.");
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const MediaPickerScreen()));
      }
    } else {
      if (!widget.isEditing) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content:
                Text("Please select an option", style: GoogleFonts.poppins()),
            backgroundColor: Colors.red[400],
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically
    final bool canProceed = _selectedSmokingHabit != null; // Check local state

    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else // Keep placeholder icon for onboarding
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6).withOpacity(0.1),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: const Icon(Icons.smoking_rooms_rounded,
                            color: Color(0xFF8B5CF6),
                            size: 30), // Slightly smaller
                      ),
                    Text(
                      widget.isEditing ? "Edit Smoking Habit" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),
                    if (widget.isEditing)
                      TextButton(
                        onPressed: canProceed ? _handleNext : null,
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else // Keep placeholder for onboarding
                      const SizedBox(width: 48),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.03),
              Text(
                widget.isEditing ? "Edit your smoking habits" : "Do you smoke?",
                textAlign: TextAlign.left,
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.07
                      : screenSize.width * 0.08,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                  height: 1.1,
                ),
              ),
              if (!widget.isEditing) // Show subtitle only during onboarding
                Text(
                  "Select your smoking habits",
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    color: Colors.grey[600],
                    height: 1.5,
                  ),
                ),
              SizedBox(height: screenSize.height * 0.04),
              Expanded(
                child: ListView.separated(
                  itemCount: DrinkingSmokingHabits.values.length,
                  separatorBuilder: (context, index) =>
                      const SizedBox(height: 12),
                  itemBuilder: (context, index) {
                    final habit = DrinkingSmokingHabits.values[index];
                    return _buildSmokingOptionTile(
                      screenSize: screenSize,
                      title: habit.label,
                      value: habit,
                    );
                  },
                ),
              ),
              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: AnimatedScale(
                      scale: canProceed ? 1.0 : 0.95, // Use local state
                      duration: const Duration(milliseconds: 200),
                      child: GestureDetector(
                        onTap: _handleNext, // Use unified handler
                        child: Container(
                          width: 70,
                          height: 70,
                          decoration: BoxDecoration(
                            color: canProceed
                                ? const Color(0xFF8B5CF6)
                                : Colors.grey.shade300,
                            borderRadius: BorderRadius.circular(35),
                            boxShadow: canProceed
                                ? [
                                    BoxShadow(
                                      color: const Color(0xFF8B5CF6)
                                          .withOpacity(0.3),
                                      blurRadius: 8,
                                      offset: const Offset(0, 4),
                                    ),
                                  ]
                                : null,
                          ),
                          child: Icon(
                            Icons.arrow_forward_rounded,
                            color: canProceed
                                ? Colors.white
                                : Colors.grey.shade600,
                            size: 32,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSmokingOptionTile({
    required Size screenSize,
    required String title,
    required DrinkingSmokingHabits value,
  }) {
    bool isSelected = _selectedSmokingHabit == value; // Use local state

    return AnimatedScale(
      scale: isSelected ? 1.02 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedSmokingHabit = value; // Update local state
          });
        },
        child: Container(
          decoration: BoxDecoration(
            color: isSelected ? const Color(0xFF8B5CF6) : Colors.white,
            borderRadius: BorderRadius.circular(15),
            border: Border.all(
              color:
                  isSelected ? const Color(0xFF8B5CF6) : Colors.grey.shade200,
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          padding: EdgeInsets.symmetric(
            horizontal: screenSize.width * 0.05,
            vertical: screenSize.height * 0.022,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: isSelected ? Colors.white : const Color(0xFF2D3748),
                ),
              ),
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected ? Colors.white : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey.shade400,
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Center(
                        child: Icon(
                          Icons.check,
                          size: 16,
                          color: Color(0xFF8B5CF6),
                        ),
                      )
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/splash_screen.dart
================================================
import 'package:dtx/providers/auth_provider.dart';
import 'package:dtx/models/auth_model.dart';
import 'package:dtx/providers/feed_provider.dart'; // Import FeedProvider
import 'package:dtx/providers/filter_provider.dart'; // Import FilterProvider
import 'package:dtx/views/google_sign_in_screen.dart';
import 'package:dtx/views/location.dart';
import 'package:dtx/views/main_navigation_screen.dart'; // Import MainNavigationScreen
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
// Removed FeedType import
// Removed NameInputScreen import
// Removed Home import

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnim;
  late Animation<double> _scaleAnim;
  bool _animationComplete = false;
  bool _statusCheckComplete = false;
  AuthStatus _authStatus = AuthStatus.unknown;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
    _checkAuthStatus();
  }

  void _setupAnimation() {
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );

    _fadeAnim = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.0, 0.8, curve: Curves.easeIn),
      ),
    );

    _scaleAnim = Tween<double>(begin: 0.7, end: 1).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.elasticOut,
      ),
    );

    _controller.forward();

    Future.delayed(const Duration(milliseconds: 2000), () {
      if (mounted) {
        setState(() {
          _animationComplete = true;
        });
        _navigateIfReady();
      }
    });
  }

  Future<void> _checkAuthStatus() async {
    print('[SplashScreen] Checking Auth Status...');
    try {
      final status = await ref
          .read(authProvider.notifier)
          .checkAuthStatus(updateState: false);
      print('[SplashScreen] Auth Status Check Result: $status');

      if (!mounted) return;

      setState(() {
        _authStatus = status;
        _statusCheckComplete = true;
      });
      _navigateIfReady();
    } catch (e) {
      print('[SplashScreen] Error during Auth Status Check: $e');
      if (!mounted) return;
      setState(() {
        _authStatus = AuthStatus.login; // Default to login on error
        _statusCheckComplete = true;
      });
      _navigateIfReady();
    }
  }

  void _initiateEarlyFetches() {
    print("[SplashScreen] Initiating early data fetches (Filters, HomeFeed).");
    // Don't await, let them run in background
    ref.read(filterProvider.notifier).loadFilters();
    ref.read(feedProvider.notifier).fetchFeed();
  }

  void _navigateIfReady() {
    print(
        '[SplashScreen] Navigate If Ready: Animation Complete=$_animationComplete, Status Check Complete=$_statusCheckComplete, Status=$_authStatus');

    if (_animationComplete && _statusCheckComplete) {
      print('[SplashScreen] Conditions met. Navigating...');
      Widget destination;

      switch (_authStatus) {
        case AuthStatus.home:
        case AuthStatus
              .onboarding2: // Both home and onboarding2 go to main screen
          print('[SplashScreen] Navigating to MainNavigationScreen');
          _initiateEarlyFetches(); // Start loading data needed for MainNavigationScreen
          destination = const MainNavigationScreen();
          break;
        case AuthStatus.onboarding1:
          print('[SplashScreen] Navigating to LocationInputScreen');
          destination = const LocationInputScreen();
          break;
        case AuthStatus.login:
        case AuthStatus.unknown:
        default:
          print('[SplashScreen] Navigating to GoogleSignInScreen');
          destination = const GoogleSignInScreen();
          break;
      }

      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (_) => destination),
      );
    } else {
      print('[SplashScreen] Conditions not met. Waiting...');
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Build method remains largely the same, only navigation logic changed
    final Size screenSize = MediaQuery.of(context).size;
    final double responsiveFontSize = screenSize.width * 0.18;
    final double subtitleFontSize = screenSize.width * 0.04;
    final double bottomPadding = screenSize.height * 0.05;

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF4C1D95), Color(0xFF7C3AED), Color(0xFF8B5CF6)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Stack(
          children: [
            Center(
              child: AnimatedBuilder(
                animation: _controller,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Transform.scale(
                      scale: _scaleAnim.value,
                      child: FittedBox(
                        fit: BoxFit.scaleDown,
                        child: Text(
                          'Peeple',
                          style: GoogleFonts.pacifico(
                            fontSize: responsiveFontSize,
                            color: Colors.white,
                            shadows: [
                              Shadow(
                                color: Colors.black.withOpacity(0.6),
                                blurRadius: 15,
                                offset: const Offset(0, 4),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
            Positioned(
              bottom: bottomPadding,
              left: 0,
              right: 0,
              child: AnimatedBuilder(
                animation: _fadeAnim,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnim.value,
                    child: Text(
                      'Connect. Share. Thrive.',
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                        color: Colors.white.withOpacity(0.9),
                        fontSize: subtitleFontSize,
                        fontWeight: FontWeight.w300,
                        letterSpacing: 0.5,
                      ),
                    ),
                  );
                },
              ),
            ),
            if (_animationComplete && !_statusCheckComplete)
              Positioned(
                bottom: bottomPadding + 50,
                left: 0,
                right: 0,
                child: const Center(
                  child: SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(
                      strokeWidth: 2.5,
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/study.dart
================================================
// File: lib/views/study.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/views/religion.dart'; // Keep for onboarding flow

class StudyLocationScreen extends ConsumerStatefulWidget {
  final bool isEditing; // <<< ADDED

  const StudyLocationScreen({
    super.key,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<StudyLocationScreen> createState() =>
      _StudyLocationScreenState();
}

class _StudyLocationScreenState extends ConsumerState<StudyLocationScreen> {
  final TextEditingController _studyLocationController =
      TextEditingController();

  @override
  void initState() {
    super.initState();
    // Load initial value if editing
    if (widget.isEditing) {
      _studyLocationController.text = ref.read(userProvider).education ?? '';
    }
    // Add listener to enable/disable Done button in edit mode if needed
    _studyLocationController.addListener(() {
      if (widget.isEditing) setState(() {});
    });
  }

  @override
  void dispose() {
    _studyLocationController.dispose();
    super.dispose();
  }

  void _handleNext() {
    String? education;
    if (_studyLocationController.text.trim().isNotEmpty) {
      education = _studyLocationController.text.trim();
    } else {
      education = null; // Explicitly set to null if empty
    }
    ref.read(userProvider.notifier).updateEducation(education);

    if (widget.isEditing) {
      print("[StudyLocationScreen] Editing done, popping back.");
      Navigator.of(context).pop();
    } else {
      // Original onboarding navigation
      print("[StudyLocationScreen] Onboarding next: Religion.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const ReligionScreen()));
    }
  }

  void _handleSkipOrClear() {
    FocusScope.of(context).unfocus();
    _studyLocationController.clear(); // Clear text field
    ref
        .read(userProvider.notifier)
        .updateEducation(null); // Update provider to null
    if (widget.isEditing) {
      print("[StudyLocationScreen] Clearing field and popping back.");
      Navigator.of(context).pop(); // Pop back immediately after clearing
    } else {
      // Original onboarding skip navigation
      print("[StudyLocationScreen] Skipping to Religion.");
      Navigator.push(context,
          MaterialPageRoute(builder: (context) => const ReligionScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenSize = MediaQuery.of(context).size;
    // final userState = ref.watch(userProvider); // Only needed if UI depends on it dynamically

    return Scaffold(
      backgroundColor: const Color(0xFFF4F4F4),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.symmetric(horizontal: screenSize.width * 0.06),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // --- Adjusted Header for Edit Mode ---
              Padding(
                padding: EdgeInsets.only(
                  top: screenSize.height * 0.02,
                  left: screenSize.width * 0.02,
                  right: screenSize.width * 0.06,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    if (widget.isEditing)
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      )
                    else
                      IconButton(
                        // Keep original icon for onboarding
                        icon: const Icon(Icons.school_rounded,
                            color: Color(0xFF8B5CF6), size: 32),
                        onPressed: () {}, // No action needed here
                      ),

                    Text(
                      widget.isEditing ? "Edit Education" : "",
                      style: GoogleFonts.poppins(
                          fontSize: 18, fontWeight: FontWeight.w600),
                    ),

                    // Show "Done" in edit mode, "Skip" in onboarding
                    if (widget.isEditing)
                      TextButton(
                        onPressed: _handleNext, // Always enabled
                        child: Text(
                          "Done",
                          style: GoogleFonts.poppins(
                            color:
                                const Color(0xFF8B5CF6), // Always enabled color
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      )
                    else
                      TextButton(
                        onPressed: _handleSkipOrClear, // Use unified handler
                        style: TextButton.styleFrom(
                          foregroundColor: Colors.grey.shade600,
                          padding: EdgeInsets.zero,
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                        child: Text(
                          "Skip",
                          style: GoogleFonts.poppins(
                              fontSize: 16, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                ),
              ),
              // --- End Adjusted Header ---

              SizedBox(height: screenSize.height * 0.07),

              // Question Text
              Text(
                widget.isEditing
                    ? "Edit where you studied"
                    : "Where did you study?",
                style: GoogleFonts.poppins(
                  fontSize: widget.isEditing
                      ? screenSize.width * 0.08
                      : screenSize.width * 0.1,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF333333),
                  height: 1.1,
                ),
              ),

              SizedBox(height: screenSize.height * 0.05),

              // Text Field
              Padding(
                padding:
                    EdgeInsets.symmetric(horizontal: screenSize.width * 0.02),
                child: TextField(
                  controller: _studyLocationController,
                  style: GoogleFonts.poppins(
                    fontSize: 22,
                    color: Colors.black87,
                  ),
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    hintText: "e.g., IIT Delhi",
                    hintStyle: GoogleFonts.poppins(
                      fontSize: 22,
                      color: Colors.grey.shade500,
                    ),
                    border: const UnderlineInputBorder(
                      borderSide: BorderSide(color: Colors.grey, width: 1.0),
                    ),
                    focusedBorder: const UnderlineInputBorder(
                      borderSide:
                          BorderSide(color: Color(0xFF8B5CF6), width: 1.5),
                    ),
                    // Add clear button in edit mode if text exists
                    suffixIcon: widget.isEditing &&
                            _studyLocationController.text.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, color: Colors.grey),
                            onPressed: () {
                              _studyLocationController.clear();
                            },
                          )
                        : null,
                  ),
                ),
              ),

              const Spacer(),

              // --- Hide FAB in Edit Mode ---
              if (!widget.isEditing)
                Align(
                  alignment: Alignment.bottomRight,
                  child: Padding(
                    padding: EdgeInsets.only(bottom: screenSize.height * 0.04),
                    child: GestureDetector(
                      onTap: _handleNext, // Always enabled for onboarding
                      child: Container(
                        width: 70,
                        height: 70,
                        decoration: BoxDecoration(
                          color: const Color(0xFF8B5CF6),
                          borderRadius: BorderRadius.circular(35),
                        ),
                        child: const Icon(
                          Icons.arrow_forward_rounded,
                          color: Colors.white,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                ),
              // --- End Hide FAB ---
              if (widget.isEditing)
                SizedBox(
                    height:
                        screenSize.height * 0.04) // Add padding if FAB hidden
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/textpromptsselect.dart
================================================
// File: lib/views/textpromptsselect.dart
import 'package:dtx/models/user_model.dart';
import 'package:dtx/views/writeprompt.dart';
import 'package:flutter/material.dart';
// Removed unused Riverpod import
// Removed unused google_fonts import
import 'package:dtx/utils/app_enums.dart';

class TextSelectPromptScreen extends StatefulWidget {
  final int? editIndex;
  final bool isEditing; // <<< ADDED

  const TextSelectPromptScreen({
    super.key,
    this.editIndex,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  State<TextSelectPromptScreen> createState() => _TextSelectPromptScreenState();
}

class _TextSelectPromptScreenState extends State<TextSelectPromptScreen> {
  PromptCategory selectedCategory = PromptCategory.storyTime;
  bool showAllPrompts = false;
  // Removed unused selectedPrompt state

  List<PromptType> get currentPrompts {
    if (showAllPrompts) {
      return PromptCategory.values
          .expand((category) => category.getPrompts())
          .toList();
    }
    return selectedCategory.getPrompts();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  GestureDetector(
                    onTap: () {
                      setState(() {
                        showAllPrompts = !showAllPrompts;
                      });
                    },
                    child: Text(
                      showAllPrompts
                          ? 'View by Category'
                          : 'View all', // Toggle text
                      style: TextStyle(
                        color: const Color(0xFF8b5cf6),
                        fontSize: 16,
                        fontWeight:
                            showAllPrompts ? FontWeight.bold : FontWeight.w500,
                      ),
                    ),
                  ),
                  const Text(
                    'Prompts',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  GestureDetector(
                    onTap: () =>
                        Navigator.pop(context), // Always pop back from here
                    child: const Icon(Icons.close),
                  ),
                ],
              ),
            ),
            if (!showAllPrompts)
              SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: Row(
                  children: PromptCategory.values.map((category) {
                    final isSelected = category == selectedCategory;
                    return Padding(
                      padding: const EdgeInsets.only(right: 8),
                      child: GestureDetector(
                        onTap: () =>
                            setState(() => selectedCategory = category),
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 20,
                            vertical: 10,
                          ),
                          decoration: BoxDecoration(
                            color: isSelected
                                ? const Color(0xFF8b5cf6)
                                : Colors.white,
                            borderRadius: BorderRadius.circular(20),
                            border: Border.all(
                              color: const Color(0xFF8b5cf6),
                              width: 1,
                            ),
                          ),
                          child: Text(
                            category.label,
                            style: TextStyle(
                              color: isSelected
                                  ? Colors.white
                                  : const Color(0xFF8b5cf6),
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ),
            const SizedBox(height: 16),
            Expanded(
              child: ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: currentPrompts.length,
                itemBuilder: (context, index) {
                  final promptType = currentPrompts[index];
                  return GestureDetector(
                    onTap: () {
                      final category = promptType.getCategory();
                      // Navigate to WriteAnswerScreen, potentially replacing this one
                      // if we don't want the user coming back here after writing.
                      // Using push ensures they can come back to select a different prompt if needed.
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => WriteAnswerScreen(
                            category: category,
                            question: promptType,
                            editIndex: widget.editIndex,
                            isEditing:
                                widget.isEditing, // <<< Pass editing flag
                          ),
                        ),
                      );
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(
                            color: Colors.grey[200]!,
                            width: 1,
                          ),
                        ),
                      ),
                      child: Text(
                        promptType.label,
                        style: const TextStyle(
                          fontSize: 16,
                          color: Colors.black87,
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/verification_message_screen.dart
================================================

import 'package:dtx/views/home.dart';
import 'package:dtx/views/selfie_capture_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationMessageScreen extends StatelessWidget {
  const VerificationMessageScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40), // Top spacing
              // Illustration or Icon
              Container(
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  shape: BoxShape.circle,
                ),
                child: Center(
                  child: Icon(
                    Icons.verified_user_outlined,
                    size: 100,
                    color: const Color(0xFF8B5CF6),
                  ),
                ),
              ),
              const SizedBox(height: 32),
              // Title
              Text(
                "Profile Verification",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 16),
              // Subtitle/Description
              Text(
                "We are verifying your profile to ensure that no one else can use your photo. This helps us keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),
              const Spacer(), // Pushes the button to the bottom
              // Continue Button
              GestureDetector(
onTap: () {
  // Navigate to HomeScreen
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(builder: (context) => const SelfieCaptureScreen(),
  ));
},
                child: Container(
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 32), // Bottom spacing
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/verification_pending_screen.dart
================================================
// File: views/verification_pending_screen.dart
import 'dart:io';
// Removed FeedType import
// Import MainNavigationScreen
import 'package:dtx/views/main_navigation_screen.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class VerificationPendingScreen extends StatelessWidget {
  final File? selfieImage;

  const VerificationPendingScreen({
    Key? key,
    this.selfieImage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              // ... (rest of the build method remains the same until the button) ...
              const SizedBox(height: 40),

              // Selfie preview (keep existing)
              Container(
                width: 180,
                height: 180,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: const Color(0xFF8B5CF6),
                    width: 4,
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: const Color(0xFF8B5CF6).withOpacity(0.2),
                      blurRadius: 15,
                      spreadRadius: 5,
                    ),
                  ],
                ),
                child: ClipOval(
                  child: selfieImage != null
                      ? Image.file(
                          selfieImage!,
                          fit: BoxFit.cover,
                        )
                      : Container(
                          color: Colors.grey[200],
                          child: Icon(
                            Icons.person,
                            size: 80,
                            color: Colors.grey[400],
                          ),
                        ),
                ),
              ),
              const SizedBox(height: 32),
              Text(
                "Verification in Progress",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 28,
                  fontWeight: FontWeight.w700,
                  color: const Color(0xFF1A1A1A),
                ),
              ),
              const SizedBox(height: 16),
              Text(
                "We're verifying your profile to ensure no one else can use your photos. This helps keep our community safe and authentic.",
                textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                  fontSize: 16,
                  fontWeight: FontWeight.w400,
                  color: Colors.grey[600],
                  height: 1.5,
                ),
              ),
              const SizedBox(height: 24),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 20,
                  vertical: 12,
                ),
                decoration: BoxDecoration(
                  color: const Color(0xFF8B5CF6).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          Color(0xFF8B5CF6),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Text(
                      "Verification in progress",
                      style: GoogleFonts.poppins(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF8B5CF6),
                      ),
                    ),
                  ],
                ),
              ),
              const Spacer(),

              // Continue Button - FIXED NAVIGATION
              GestureDetector(
                onTap: () {
                  Navigator.pushAndRemoveUntil(
                    context,
                    MaterialPageRoute(
                      // Navigate to MainNavigationScreen instead of HomeScreen
                      builder: (context) => const MainNavigationScreen(),
                    ),
                    (route) => false, // Remove all previous routes
                  );
                },
                child: Container(
                  /* ... Button container ... */
                  width: double.infinity,
                  height: 56,
                  decoration: BoxDecoration(
                    color: const Color(0xFF8B5CF6),
                    borderRadius: BorderRadius.circular(28),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF8B5CF6).withOpacity(0.3),
                        blurRadius: 12,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Center(
                    child: Text(
                      "Continue Swiping",
                      style: GoogleFonts.poppins(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/who_liked_you_screen.dart
================================================
import 'package:dtx/models/error_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/providers/recieved_likes_provider.dart';
import 'package:dtx/views/liker_profile_screen.dart';
import 'package:dtx/widgets/basic_liker_profile_card.dart';
import 'package:dtx/widgets/full_liker_profile_card.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

class WhoLikedYouScreen extends ConsumerStatefulWidget {
  const WhoLikedYouScreen({super.key});

  @override
  ConsumerState<WhoLikedYouScreen> createState() => _WhoLikedYouScreenState();
}

class _WhoLikedYouScreenState extends ConsumerState<WhoLikedYouScreen> {
  @override
  void initState() {
    super.initState();
    // Fetching is initiated in MainNavigationScreen initState now
  }

  // _navigateToLikerProfile remains the same...
  void _navigateToLikerProfile(int likerUserId) {
    print(
        "[WhoLikedYouScreen] Navigating to profile for liker ID: $likerUserId");
    ref.read(errorProvider.notifier).clearError();
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => LikerProfileScreen(likerUserId: likerUserId),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(receivedLikesProvider);
    // Error watching remains the same
    final generalError = ref.watch(errorProvider);
    final displayError = state.error ?? generalError;

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: Text("Likes You've Received",
            style: GoogleFonts.poppins(fontWeight: FontWeight.w600)),
        elevation: 1,
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        automaticallyImplyLeading: false,
      ),
      body: RefreshIndicator(
        color: const Color(0xFF8B5CF6),
        onRefresh: () async {
          // Clear previous error before refresh if needed
          ref.read(errorProvider.notifier).clearError();
          await ref.read(receivedLikesProvider.notifier).fetchLikes();
        },
        // *** Check isLoading state from the provider ***
        child: state.isLoading // Check the provider's loading state directly
            ? const Center(
                child: CircularProgressIndicator(color: Color(0xFF8B5CF6)))
            : _buildBody(state, displayError), // Pass state and combined error
      ),
    );
  }

  // _buildBody should now assume isLoading is false when called
  Widget _buildBody(ReceivedLikesState state, AppError? error) {
    if (error != null) {
      return _buildErrorState(error.message);
    }

    if (state.fullProfiles.isEmpty && state.otherLikers.isEmpty) {
      return _buildEmptyState();
    }

    // CustomScrollView structure remains the same
    return CustomScrollView(
      slivers: [
        if (state.fullProfiles.isNotEmpty)
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 20, 16, 12),
              child: Text(
                "Recent Likes & Roses",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[800],
                ),
              ),
            ),
          ),
        if (state.fullProfiles.isNotEmpty)
          SliverPadding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            sliver: SliverGrid(
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2,
                crossAxisSpacing: 12,
                mainAxisSpacing: 12,
                childAspectRatio: 0.75,
              ),
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  final liker = state.fullProfiles[index];
                  return FullLikerProfileCard(
                    liker: liker,
                    onTap: () => _navigateToLikerProfile(liker.likerUserId),
                  );
                },
                childCount: state.fullProfiles.length,
              ),
            ),
          ),
        if (state.otherLikers.isNotEmpty)
          SliverToBoxAdapter(
            child: Padding(
              padding: EdgeInsets.fromLTRB(
                  16, state.fullProfiles.isNotEmpty ? 24 : 20, 16, 12),
              child: Text(
                state.fullProfiles.isNotEmpty ? "Older Likes" : "Likes",
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[800],
                ),
              ),
            ),
          ),
        if (state.otherLikers.isNotEmpty)
          SliverPadding(
            padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
            sliver: SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  final liker = state.otherLikers[index];
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 10.0),
                    child: BasicLikerProfileCard(
                      liker: liker,
                      onTap: () => _navigateToLikerProfile(liker.likerUserId),
                    ),
                  );
                },
                childCount: state.otherLikers.length,
              ),
            ),
          ),
        const SliverToBoxAdapter(child: SizedBox(height: 20)),
      ],
    );
  }

  // _buildEmptyState and _buildErrorState remain the same
  Widget _buildEmptyState() {
    return LayoutBuilder(
      // Use LayoutBuilder to ensure Center takes full space for scrollable refresh
      builder: (context, constraints) => SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(30.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.favorite_border_rounded,
                      size: 70, color: Colors.grey[300]),
                  const SizedBox(height: 20),
                  Text("No Likes Yet",
                      style: GoogleFonts.poppins(
                          fontSize: 20,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey[700])),
                  const SizedBox(height: 10),
                  Text("People who like you will appear here.",
                      textAlign: TextAlign.center,
                      style: GoogleFonts.poppins(
                          fontSize: 15, color: Colors.grey[500])),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildErrorState(String message) {
    return LayoutBuilder(
      // Use LayoutBuilder for scrollable refresh
      builder: (context, constraints) => SingleChildScrollView(
        physics: const AlwaysScrollableScrollPhysics(),
        child: ConstrainedBox(
          constraints: BoxConstraints(minHeight: constraints.maxHeight),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.all(30.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline_rounded,
                      size: 60, color: Colors.redAccent[100]),
                  const SizedBox(height: 20),
                  Text("Oops!",
                      style: GoogleFonts.poppins(
                          fontSize: 18,
                          fontWeight: FontWeight.w600,
                          color: Colors.grey[700])),
                  const SizedBox(height: 10),
                  Text(message,
                      style: GoogleFonts.poppins(
                          fontSize: 14, color: Colors.grey[600]),
                      textAlign: TextAlign.center),
                  const SizedBox(height: 20),
                  ElevatedButton.icon(
                    icon: const Icon(Icons.refresh_rounded, size: 18),
                    label: const Text("Retry"),
                    style: ElevatedButton.styleFrom(
                      foregroundColor: Colors.white,
                      backgroundColor: const Color(0xFF8B5CF6),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(20)),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 30, vertical: 12),
                    ),
                    onPressed: () =>
                        ref.read(receivedLikesProvider.notifier).fetchLikes(),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: views/writeprompt.dart
================================================
// File: lib/views/writeprompt.dart
import 'package:dtx/utils/app_enums.dart';
// Removed unused prompt.dart import
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// Removed unused google_fonts import
import 'package:dtx/providers/user_provider.dart';
import 'package:dtx/models/user_model.dart';

class WriteAnswerScreen extends ConsumerStatefulWidget {
  final PromptCategory category;
  final PromptType question;
  final int? editIndex;
  final bool isEditing; // <<< ADDED

  const WriteAnswerScreen({
    super.key,
    required this.category,
    required this.question,
    this.editIndex,
    this.isEditing = false, // <<< ADDED default
  });

  @override
  ConsumerState<WriteAnswerScreen> createState() => _WriteAnswerScreenState();
}

class _WriteAnswerScreenState extends ConsumerState<WriteAnswerScreen> {
  late final TextEditingController _answerController;

  @override
  void initState() {
    super.initState();
    _answerController = TextEditingController();
    _loadExistingAnswer();

    // Add listener to update UI when text changes
    _answerController.addListener(() {
      if (mounted) {
        setState(() {}); // Trigger rebuild to enable/disable Done button
      }
    });
  }

  void _loadExistingAnswer() {
    // Load only if editing an *existing* prompt (editIndex is not null)
    if (widget.editIndex != null && widget.isEditing) {
      final prompts = ref.read(userProvider).prompts;
      if (widget.editIndex! < prompts.length) {
        // Check if the question being edited matches the passed question
        // This prevents loading the wrong answer if the user selected a different question for the same slot
        if (prompts[widget.editIndex!].question == widget.question) {
          _answerController.text = prompts[widget.editIndex!].answer;
        } else {
          print(
              "Warning: Editing index ${widget.editIndex} but question changed. Starting fresh.");
        }
      }
    }
  }

  void _saveAnswer() {
    final answerText = _answerController.text.trim();
    if (answerText.isNotEmpty) {
      final newPrompt = Prompt(
        category: widget.category,
        question: widget.question,
        answer: answerText,
      );

      // Determine the correct index to update/add
      int targetIndex =
          widget.editIndex ?? ref.read(userProvider).prompts.length;

      // If editIndex is provided and valid, update. Otherwise, add if not full.
      if (widget.editIndex != null &&
          widget.editIndex! < ref.read(userProvider).prompts.length) {
        ref
            .read(userProvider.notifier)
            .updatePromptAtIndex(widget.editIndex!, newPrompt);
        print("Updated prompt at index: ${widget.editIndex}");
      } else if (ref.read(userProvider).prompts.length < 3) {
        ref.read(userProvider.notifier).addPrompt(newPrompt);
        print("Added new prompt.");
      } else {
        // This case should ideally be prevented by the UI, but as a fallback:
        print("Error: Cannot add prompt, maximum reached.");
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("You can only have 3 prompts.")));
        return; // Don't pop
      }

      // Navigate back differently based on mode
      if (widget.isEditing) {
        // Pop twice: once for this screen, once for TextSelectPromptScreen
        int popCount = 0;
        Navigator.of(context).popUntil((route) {
          return popCount++ == 2;
        });
      } else {
        // Onboarding: Pop back to ProfileAnswersScreen
        Navigator.of(context).pop(); // Pop WriteAnswerScreen
        // Note: Onboarding flow might need adjustment if ProfileAnswersScreen isn't the direct previous route.
        // If TextSelectPromptScreen should also be popped in onboarding:
        // Navigator.of(context).popUntil((route) => route.isFirst); // Or pop back to specific route
      }
    } else {
      // If user clears text and hits Done, consider it as removing the prompt if editing existing
      if (widget.isEditing && widget.editIndex != null) {
        print(
            "Removing prompt at index: ${widget.editIndex} due to empty answer.");
        ref.read(userProvider.notifier).removePromptAtIndex(widget.editIndex!);
        // Pop twice
        int popCount = 0;
        Navigator.of(context).popUntil((route) {
          return popCount++ == 2;
        });
      }
    }
  }

  @override
  void dispose() {
    _answerController.dispose(); // Clean up the controller
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final bool canSave = _answerController.text.trim().isNotEmpty;
    // Or, if clearing is allowed via Done button:
    // final bool canSave = true; // Always allow Done, handle empty in _saveAnswer

    return Scaffold(
      backgroundColor: const Color(0xFFF8FAFC),
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 1,
        centerTitle: true,
        title: Text(
          widget.editIndex != null && widget.isEditing
              ? 'Edit Answer'
              : 'Write Answer', // Dynamic title
          style: const TextStyle(
            color: Colors.black,
            fontSize: 18,
            fontWeight: FontWeight.w700,
          ),
        ),
        leadingWidth: 80,
        leading: GestureDetector(
          onTap: () => Navigator.pop(context), // Always pop back to selection
          child: const Center(
            child: Text(
              'Cancel',
              style: TextStyle(
                color: Color(0xFF8B5CF6),
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ),
        actions: [
          TextButton(
            // Enable based on whether text is present OR if editing an existing prompt (to allow clearing)
            onPressed: canSave || (widget.isEditing && widget.editIndex != null)
                ? _saveAnswer
                : null,
            child: Text(
              'Done',
              style: TextStyle(
                // Adjust color based on combined condition
                color: canSave || (widget.isEditing && widget.editIndex != null)
                    ? const Color(0xFF8B5CF6)
                    : const Color(0xFF8B5CF6).withOpacity(0.5),
                fontSize: 16,
                fontWeight: FontWeight.w700,
              ),
            ),
          ),
        ],
      ),
      body: SingleChildScrollView(
        // Wrap in SingleChildScrollView
        child: Column(
          children: [
            const SizedBox(height: 64),
            Container(
              margin: const EdgeInsets.symmetric(horizontal: 16),
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: const Color(0xFF8B5CF6).withOpacity(0.3),
                  width: 2,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.grey.withOpacity(0.1),
                    spreadRadius: 2,
                    blurRadius: 8,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      widget.question.label,
                      style: const TextStyle(
                        fontSize: 17,
                        fontWeight: FontWeight.w600,
                        color: Colors.black87,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Icon(
                    // Dynamic icon based on action
                    widget.editIndex != null && widget.isEditing
                        ? Icons.edit_note_rounded
                        : Icons.question_answer_outlined,
                    color: const Color(0xFF8B5CF6).withOpacity(0.8),
                    size: 24,
                  ),
                ],
              ),
            ),
            const SizedBox(height: 54),
            Container(
              height: 200,
              margin: const EdgeInsets.symmetric(horizontal: 16),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: const Color(0xFFE5E7EB),
                  width: 1.5,
                ),
              ),
              child: Stack(
                children: [
                  Padding(
                    padding: const EdgeInsets.all(16),
                    child: TextField(
                      controller: _answerController,
                      maxLength: 255,
                      maxLines: null, // Allows multiline input
                      minLines: 5, // Set a minimum line count
                      keyboardType: TextInputType
                          .multiline, // Explicitly set keyboard type
                      textCapitalization:
                          TextCapitalization.sentences, // Capitalize sentences
                      style: const TextStyle(
                        fontSize: 16,
                        color: Colors.black87,
                        height: 1.4,
                      ),
                      decoration: const InputDecoration(
                        border: InputBorder.none,
                        hintText: 'Type your answer here...',
                        hintStyle: TextStyle(
                          color: Color(0xFF94A3B8),
                          fontSize: 16,
                          fontWeight: FontWeight.w400,
                        ),
                        counterText: '', // Hide the default counter
                      ),
                    ),
                  ),
                  Positioned(
                    right: 16,
                    bottom: 16,
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: Colors.grey[100],
                        borderRadius: BorderRadius.circular(6),
                      ),
                      child: Text(
                        // Use characters method for accurate length including newlines
                        '${_answerController.text.characters.length}/255',
                        style: const TextStyle(
                          color: Color(0xFF64748B),
                          fontSize: 13,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 24),
          ],
        ),
      ),
    );
  }
}



================================================
File: views/youtube.dart
================================================
import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:flutter/services.dart'; // Required for Clipboard

// --- Configuration (kept outside the widget for clarity) ---

// Define the necessary YouTube scope
const List<String> _scopes = <String>[
  'https://www.googleapis.com/auth/youtube.readonly',
];

// Instantiate GoogleSignIn with the defined scopes
// You might want to manage this instance more globally in your app
// (e.g., using a service locator or provider) if other parts need it,
// but keeping it here works for a self-contained screen.
final GoogleSignIn _googleSignIn = GoogleSignIn(
  scopes: _scopes,
);

// --- Screen Widget ---

class YoutubeSignInScreen extends StatefulWidget {
  // You can add parameters here if needed, e.g., callbacks for when login succeeds/fails
  // final VoidCallback? onLoginSuccess;
  // final Function(String)? onTokenReceived;

  const YoutubeSignInScreen({
    super.key,
    // this.onLoginSuccess,
    // this.onTokenReceived,
  });

  @override
  State<YoutubeSignInScreen> createState() => _YoutubeSignInScreenState();
}

class _YoutubeSignInScreenState extends State<YoutubeSignInScreen> {
  GoogleSignInAccount? _currentUser;
  String _message = 'Not logged in';
  String? _accessToken; // To store the access token
  bool _isSigningIn = false; // To prevent multiple sign-in attempts
  bool _isFetchingToken = false; // To show progress while getting token

  @override
  void initState() {
    super.initState();

    // Listen for user changes (e.g., sign out from elsewhere or successful sign-in)
    _googleSignIn.onCurrentUserChanged.listen((GoogleSignInAccount? account) {
      // Important: Check if the widget is still mounted before calling setState
      if (mounted) {
        _updateUser(account);
      }
    }).onError((error) {
      // Handle stream errors if necessary
      print("Error listening to user changes: $error");
      if (mounted) {
        setState(() {
          _message = "Error listening for user changes.";
          _currentUser = null;
          _accessToken = null;
        });
      }
    });

    // Try silent sign-in on screen initialization
    // Make sure this doesn't interfere with other login logic in your app
    _googleSignIn.signInSilently().then((account) {
      // No need to call _updateUser here, the listener above will handle it
    }).catchError((err) {
      print('Error during silent sign-in attempt: $err');
      // Don't necessarily show an error here, silent sign-in failing is common
      if (mounted) {
        setState(() {
          _message = 'Not logged in (silent sign-in failed or not available)';
        });
      }
    });
  }

  @override
  void dispose() {
    // It's generally good practice to cancel stream subscriptions,
    // though onCurrentUserChanged might be managed internally by the plugin.
    // If you had custom StreamSubscriptions, you'd cancel them here.
    super.dispose();
  }

  void _updateUser(GoogleSignInAccount? account) async {
    // Check mounted again just to be safe, especially with async operations
    if (!mounted) return;

    setState(() {
      _currentUser = account;
      _accessToken = null; // Reset token when user changes
      _isFetchingToken = account != null; // Start fetching if user is not null
      if (_currentUser != null) {
        _message =
            "Logged in as ${_currentUser!.displayName ?? _currentUser!.email}";
      } else {
        _message = "Not logged in";
      }
    });

    // If user is logged in, print details and get the access token
    if (_currentUser != null) {
      // --- ADDED: Print User Details to Console ---
      print("--- Google User Details ---");
      print(
          "Display Name: ${_currentUser!.displayName ?? 'Not Provided'}"); // Handle potential null display name
      print("Email: ${_currentUser!.email}");
      print("User ID: ${_currentUser!.id}"); // Added User ID as well
      print("---------------------------");
      // --- END ADDED ---

      await _getAccessToken();
    }
  }

  // Function to get the access token
  Future<void> _getAccessToken() async {
    if (_currentUser == null) return;

    // Ensure mounted check before async operation and setState
    if (!mounted) return;

    setState(() {
      _isFetchingToken = true; // Show loading indicator
    });

    try {
      final GoogleSignInAuthentication auth =
          await _currentUser!.authentication;
      if (mounted) {
        // Check again after await
        setState(() {
          _accessToken = auth.accessToken;
          _isFetchingToken = false; // Hide loading indicator
          print("Access Token: $_accessToken"); // Print for debugging
          print("ID Token: ${auth.idToken}"); // Also available
          // Optional: Call a callback if provided via widget constructor
          // widget.onTokenReceived?.call(_accessToken!);
        });
      }
    } catch (err) {
      print('Error getting authentication token: $err');
      if (mounted) {
        // Check again after await
        setState(() {
          _message = 'Error getting token: $err';
          _accessToken = null;
          _isFetchingToken = false; // Hide loading indicator
        });
      }
    }
  }

  // Sign-in function
  Future<void> _handleSignIn() async {
    if (_isSigningIn) return; // Prevent double taps

    if (!mounted) return;
    setState(() {
      _isSigningIn = true;
      _message = "Signing in..."; // Provide feedback
    });

    try {
      // Start the sign-in process
      await _googleSignIn.signIn();
      // The onCurrentUserChanged listener will handle the update upon success.
      // If signIn() returns null (user cancelled), the listener will also get null.
    } catch (error) {
      print('Error signing in: $error');
      if (mounted) {
        // Check after await
        setState(() {
          _message = 'Error signing in: $error';
          _accessToken = null; // Clear token on error
        });
      }
    } finally {
      if (mounted) {
        // Check in finally block
        setState(() {
          _isSigningIn = false; // Allow sign-in attempts again
          // If _currentUser is still null here, sign-in likely failed or was cancelled
          if (_currentUser == null && !_message.startsWith("Error")) {
            _message = "Sign in cancelled or failed.";
          }
        });
      }
    }
  }

  // Sign-out function
  Future<void> _handleSignOut() async {
    if (!mounted) return;

    setState(() {
      _message = "Signing out...";
    });

    try {
      // Disconnect removes permissions, signOut just logs out locally
      await _googleSignIn.disconnect();
      // The onCurrentUserChanged listener handles the UI update.
    } catch (error) {
      print('Error signing out: $error');
      if (mounted) {
        // Check after await
        setState(() {
          // Restore user info if disconnect fails? Or keep logged-out state?
          // Keeping logged-out state might be less confusing.
          _message = 'Error signing out: $error';
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Determine button states
    final bool canSignIn = !_isSigningIn && _currentUser == null;
    final bool canSignOut = _currentUser != null;
    final bool showTokenInfo = _currentUser != null;
    final bool showCopyButton = _accessToken != null;

    return Scaffold(
      // You might want to remove this AppBar if the screen is embedded
      // within another Scaffold that already has one.
      appBar: AppBar(
        title: const Text('YouTube Account Login'),
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment:
                CrossAxisAlignment.center, // Center items horizontally
            children: <Widget>[
              // Display User Info or Status Message
              if (showTokenInfo) ...[
                ListTile(
                  leading: GoogleUserCircleAvatar(identity: _currentUser!),
                  title: Text(_currentUser!.displayName ?? 'No Name'),
                  subtitle: Text(_currentUser!.email),
                  contentPadding: EdgeInsets.zero, // Adjust padding if needed
                ),
                const SizedBox(height: 20),
                const Text("Access Token:",
                    style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 5),
                if (_isFetchingToken)
                  const Padding(
                    padding: EdgeInsets.symmetric(vertical: 10.0),
                    child: CircularProgressIndicator(),
                  )
                else if (_accessToken != null)
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey.shade300),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: SelectableText(
                      _accessToken!,
                      style: const TextStyle(fontSize: 12),
                      textAlign: TextAlign.center,
                      maxLines: 5, // Limit display lines if needed
                      scrollPhysics:
                          const ClampingScrollPhysics(), // Prevent scrolling within text box
                    ),
                  )
                else
                  const Text("Could not retrieve token.",
                      style:
                          TextStyle(color: Colors.red)), // Show if fetch failed
                const SizedBox(height: 10),
                ElevatedButton.icon(
                  icon: const Icon(Icons.copy, size: 16),
                  label: const Text('Copy Token'),
                  onPressed: showCopyButton
                      ? () {
                          Clipboard.setData(ClipboardData(text: _accessToken!));
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text('Access Token Copied!'),
                                duration: Duration(seconds: 2)),
                          );
                        }
                      : null, // Disable button if no token
                ),
              ] else ...[
                // Show Status Message when logged out or during sign-in process
                Text(_message, textAlign: TextAlign.center),
                const SizedBox(height: 20),
              ],

              const Spacer(), // Pushes buttons towards the bottom if desired

              // Sign In / Sign Out Buttons
              if (canSignIn)
                ElevatedButton.icon(
                  icon: const Icon(Icons.login),
                  label: const Text('Sign In with Google'),
                  onPressed: _handleSignIn,
                  style: ElevatedButton.styleFrom(
                      minimumSize:
                          const Size(200, 40)), // Ensure decent button size
                )
              else if (_isSigningIn)
                const CircularProgressIndicator() // Show progress during sign-in action
              else if (canSignOut)
                ElevatedButton.icon(
                  icon: const Icon(Icons.logout),
                  label: const Text('Sign Out & Disconnect'),
                  onPressed: _handleSignOut,
                  style: ElevatedButton.styleFrom(
                      backgroundColor:
                          Colors.redAccent, // Indicate destructive action
                      minimumSize: const Size(200, 40)),
                ),
              const SizedBox(height: 20), // Add some padding at the bottom
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: views/core/error_handler.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dtx/providers/error_provider.dart';
import 'package:dtx/models/error_model.dart';

class GlobalErrorHandler extends ConsumerWidget {
  final Widget child;
  const GlobalErrorHandler({super.key, required this.child});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final error = ref.watch(errorProvider);

    return Stack(
      children: [
        child,
        if (error != null) _buildErrorOverlay(context, error, ref),
      ],
    );
  }

  Widget _buildErrorOverlay(
      BuildContext context, AppError error, WidgetRef ref) {
    return Positioned.fill(
      child: Material(
        color: Colors.black54,
        child: Center(
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 20),
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  error.message,
                  style: const TextStyle(fontSize: 16),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () =>
                      ref.read(errorProvider.notifier).clearError(),
                  child: const Text('OK'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
File: widgets/basic_liker_profile_card.dart
================================================
// File: widgets/basic_liker_profile_card.dart
import 'package:dtx/models/like_models.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart'; // For date formatting

class BasicLikerProfileCard extends StatelessWidget {
  final BasicProfileLiker liker;
  final VoidCallback onTap;

  const BasicLikerProfileCard({
    super.key,
    required this.liker,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final timeAgo = liker.likedAt != null
        ? DateFormat.yMd().add_jm().format(liker.likedAt!) // Example format
        : 'Some time ago';

    return InkWell(
      // Make the card tappable
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.grey.shade200),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.03),
              blurRadius: 5,
              offset: const Offset(0, 1),
            )
          ],
        ),
        child: Row(
          children: [
            // Profile Picture Placeholder/Image
            CircleAvatar(
              radius: 25,
              backgroundColor: Colors.grey[200],
              backgroundImage: (liker.firstProfilePicUrl != null)
                  ? NetworkImage(liker.firstProfilePicUrl!)
                  : null,
              child: (liker.firstProfilePicUrl == null)
                  ? Icon(Icons.person, color: Colors.grey[400])
                  : null,
            ),
            const SizedBox(width: 12),
            // Name and Like Info
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    liker.name.isNotEmpty ? liker.name : 'Unknown User',
                    style: GoogleFonts.poppins(
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'Liked you $timeAgo',
                    style: GoogleFonts.poppins(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 8),
            // Rose/Comment Indicators
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                if (liker.isRose)
                  Icon(Icons.star_rounded,
                      color: Colors.purple.shade300, size: 20),
                if (liker.likeComment != null &&
                    liker.likeComment!.isNotEmpty) ...[
                  if (liker.isRose) const SizedBox(width: 4), // Spacing if both
                  Icon(Icons.chat_bubble_outline_rounded,
                      color: Colors.blue.shade300, size: 18),
                ]
              ],
            )
          ],
        ),
      ),
    );
  }
}



================================================
File: widgets/full_liker_profile_card.dart
================================================
// File: widgets/full_liker_profile_card.dart
import 'package:dtx/models/like_models.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart'; // For date formatting

class FullLikerProfileCard extends StatelessWidget {
  // --- FIX: Correct class name ---
  final FullProfileLiker liker;
  // --- END FIX ---
  final VoidCallback onTap;

  const FullLikerProfileCard({
    super.key,
    required this.liker,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final profile = liker.profile;
    final age = profile.age;
    final firstImage = profile.firstMediaUrl;
    final timeAgo = liker.likedAt != null
        ? DateFormat.yMd().add_jm().format(liker.likedAt!) // Example format
        : 'Some time ago';

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(15.0),
      child: Container(
        // Removed fixed height to allow content to define height
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(15.0),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
          image: firstImage != null
              ? DecorationImage(
                  image: NetworkImage(firstImage),
                  fit: BoxFit.cover,
                  onError: (err, st) => print(
                      "Error loading image $firstImage: $err"), // Add error logging
                  colorFilter: ColorFilter.mode(
                    Colors.black.withOpacity(0.3),
                    BlendMode.darken,
                  ),
                )
              : null, // No image if null
          color: firstImage == null
              ? Colors.grey[300]
              : Colors.white, // Placeholder color or white background
        ),
        child: Stack(
          children: [
            // Placeholder Icon if no image
            if (firstImage == null)
              Center(
                  child: Icon(Icons.person, size: 60, color: Colors.grey[500])),

            // Gradient Overlay for text (only if image exists)
            if (firstImage != null)
              Positioned.fill(
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(15.0),
                    gradient: LinearGradient(
                        colors: [
                          Colors.transparent,
                          Colors.black.withOpacity(0.7)
                        ],
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        stops: const [0.4, 1.0]),
                  ),
                ),
              ),

            // Info Text
            Positioned(
              bottom: 12,
              left: 12,
              right: 12,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Name & Age
                  Text(
                    '${profile.name ?? 'Unknown User'}${age != null ? ', $age' : ''}',
                    style: GoogleFonts.poppins(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      // Adjust text color based on background
                      color: firstImage != null ? Colors.white : Colors.black87,
                      shadows: firstImage != null
                          ? [
                              Shadow(
                                  blurRadius: 2,
                                  color: Colors.black.withOpacity(0.7))
                            ]
                          : [],
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),

                  // Like Timestamp
                  Text(
                    'Liked you $timeAgo',
                    style: GoogleFonts.poppins(
                      fontSize: 11,
                      color: firstImage != null
                          ? Colors.white.withOpacity(0.8)
                          : Colors.grey[600],
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),

                  // Comment Preview (if exists)
                  if (liker.likeComment != null &&
                      liker.likeComment!.isNotEmpty) ...[
                    const SizedBox(height: 6),
                    Row(
                      children: [
                        Icon(Icons.chat_bubble_outline_rounded,
                            color: firstImage != null
                                ? Colors.white.withOpacity(0.8)
                                : Colors.blue.shade300,
                            size: 14),
                        const SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            '"${liker.likeComment!}"',
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              fontStyle: FontStyle.italic,
                              color: firstImage != null
                                  ? Colors.white.withOpacity(0.9)
                                  : Colors.black87,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ],
                    ),
                  ],
                ],
              ),
            ),

            // Rose Indicator (Top Right)
            if (liker.isRose)
              Positioned(
                top: 8,
                right: 8,
                child: Container(
                  padding: const EdgeInsets.all(5),
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.5),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(Icons.star_rounded,
                      color: Colors.yellow.shade600, size: 18),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



================================================
File: widgets/home_profile_card.dart
================================================
// File: widgets/home_profile_card.dart
import 'dart:async'; // Import async
import 'dart:math';
import 'package:dtx/models/user_model.dart';
import 'package:dtx/models/like_models.dart';
import 'package:dtx/providers/audio_player_provider.dart';
import 'package:dtx/utils/app_enums.dart';
import 'package:dtx/providers/user_provider.dart'; // Import user provider
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

// Function Type Definitions
typedef PerformLikeApiCall = Future<bool> Function({
  required ContentLikeType contentType,
  required String contentIdentifier,
  required LikeInteractionType interactionType,
  String? comment,
});

typedef InteractionCompleteCallback = void Function();

class HomeProfileCard extends ConsumerWidget {
  final UserModel profile;
  final PerformLikeApiCall performLikeApiCall;
  final InteractionCompleteCallback onInteractionComplete;

  const HomeProfileCard({
    super.key,
    required this.profile,
    required this.performLikeApiCall,
    required this.onInteractionComplete,
  });

  // --- METHOD TO SHOW INTERACTION DIALOG (REFINED) ---
  Future<void> _showInteractionDialog(
    BuildContext context,
    WidgetRef ref,
    ContentLikeType contentType,
    String contentIdentifier,
    String? previewImageUrl,
  ) async {
    // Use try-finally for resource cleanup (controllers, notifiers)
    final currentUserGender = ref.read(userProvider).gender;
    final isMale = currentUserGender == Gender.man;
    final FocusNode commentFocusNode = FocusNode();
    final TextEditingController commentController = TextEditingController();
    // Notifier to enable/disable buttons based on comment (for male users)
    final ValueNotifier<bool> sendLikeEnabledNotifier =
        ValueNotifier<bool>(!isMale);
    // Notifier to track if the dialog's interaction process is active (for disabling buttons)
    final ValueNotifier<bool> _isDialogInteractionActive =
        ValueNotifier<bool>(false);
    VoidCallback? listenerCallback;

    // Setup listener for comment field if user is male
    if (isMale) {
      listenerCallback = () {
        if (context.mounted && commentController.value.text != null) {
          try {
            sendLikeEnabledNotifier.value =
                commentController.text.trim().isNotEmpty;
          } catch (e) {
            // Handle potential error if notifier disposed unexpectedly
            print(
                "Error accessing sendLikeEnabledNotifier in listener (might be disposed): $e");
          }
        }
      };
      commentController.addListener(listenerCallback);
    }

    // Define the interaction handler
    Future<void> _handleInteraction(LikeInteractionType interactionType) async {
      // Prevent multiple taps if already interacting
      if (_isDialogInteractionActive.value) return;

      String comment = "";
      try {
        comment = commentController.text.trim();
      } catch (e) {
        print("Error reading commentController text: $e");
        return; // Exit if controller disposed
      }

      commentFocusNode.unfocus();
      // Small delay to allow keyboard dismissal animation
      await Future.delayed(const Duration(milliseconds: 100));

      // Set dialog interaction state to true (disables buttons)
      try {
        _isDialogInteractionActive.value = true;
      } catch (e) {
        print("Error setting _isDialogInteractionActive to true: $e");
        return;
      }

      bool success = false;
      try {
        // Call the function passed from HomeScreen (this triggers screen overlay)
        success = await performLikeApiCall(
          contentType: contentType,
          contentIdentifier: contentIdentifier,
          interactionType: interactionType,
          comment: comment.isNotEmpty ? comment : null,
        );

        // Pop dialog ONLY on successful API call completion
        // The HomeScreen overlay handles visual loading feedback.
        if (success && context.mounted) {
          Navigator.of(context, rootNavigator: true).pop(); // Close dialog
          onInteractionComplete(); // Notify HomeScreen to remove card
        }
      } finally {
        // Set dialog interaction state back to false (enables buttons)
        // Add checks for mounted status and notifier validity
        try {
          if (context.mounted && _isDialogInteractionActive.value) {
            _isDialogInteractionActive.value = false;
          }
        } catch (e) {
          print(
              "Error setting _isDialogInteractionActive to false (notifier disposed?): $e");
        }
      }
    } // End of _handleInteraction

    // Show the actual dialog
    try {
      await showDialog<void>(
        context: context,
        barrierDismissible: true, // User can dismiss by tapping outside
        builder: (BuildContext dialogContext) {
          return AlertDialog(
            contentPadding: const EdgeInsets.all(16),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(20.0),
            ),
            content: SizedBox(
              width: MediaQuery.of(dialogContext).size.width * 0.8,
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    // Preview Image or Placeholder (same as before)
                    if (previewImageUrl != null)
                      ClipRRect(
                        borderRadius: BorderRadius.circular(12.0),
                        child: Image.network(
                          previewImageUrl,
                          height: 100,
                          width: double.infinity,
                          fit: BoxFit.cover,
                          errorBuilder: (_, __, ___) => Container(
                              height: 100,
                              color: Colors.grey[200],
                              child: Icon(Icons.broken_image,
                                  color: Colors.grey[400])),
                        ),
                      ),
                    if (previewImageUrl == null &&
                        contentType == ContentLikeType.audioPrompt)
                      Container(
                        height: 100,
                        width: double.infinity,
                        decoration: BoxDecoration(
                          color: Colors.grey[100],
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        child: Center(
                            child: Icon(Icons.multitrack_audio_rounded,
                                size: 40, color: Colors.grey[500])),
                      ),
                    if (previewImageUrl == null &&
                        contentType != ContentLikeType.audioPrompt)
                      Container(
                        height: 100,
                        width: double.infinity,
                        decoration: BoxDecoration(
                          color: Colors.grey[100],
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                        child: Center(
                            child: Icon(Icons.article_outlined,
                                size: 40, color: Colors.grey[500])),
                      ),
                    const SizedBox(height: 16),

                    // Comment Text Field (same as before)
                    TextField(
                      controller: commentController,
                      focusNode: commentFocusNode,
                      decoration: InputDecoration(
                        hintText: "Add a comment...",
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide: BorderSide(color: Colors.grey.shade300),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide:
                              const BorderSide(color: Color(0xFF8B5CF6)),
                        ),
                        contentPadding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 10),
                      ),
                      maxLength: 150,
                      maxLines: 3,
                      minLines: 1,
                      textCapitalization: TextCapitalization.sentences,
                    ),
                    const SizedBox(height: 16),

                    // --- ACTION BUTTONS ROW (MODIFIED - No Spinners) ---
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        // Send Rose Button
                        ValueListenableBuilder<bool>(
                          // Listens to comment validity for enabling
                          valueListenable: sendLikeEnabledNotifier,
                          builder: (context, isCommentValid, child) {
                            final bool roseButtonEnabled =
                                !isMale || isCommentValid;
                            // Listen also to interaction state for disabling
                            return ValueListenableBuilder<bool>(
                              valueListenable: _isDialogInteractionActive,
                              builder: (context, isInteractionActive, child) {
                                final bool effectiveEnabled =
                                    roseButtonEnabled && !isInteractionActive;
                                return OutlinedButton.icon(
                                  // REMOVED spinner icon logic
                                  icon: Icon(
                                    Icons.star_rounded,
                                    color: effectiveEnabled
                                        ? Colors.purple.shade300
                                        : Colors.grey.shade400,
                                    size: 18,
                                  ),
                                  label: Text(
                                    "Send Rose",
                                    style: GoogleFonts.poppins(
                                      fontWeight: FontWeight.w500,
                                      color: effectiveEnabled
                                          ? Colors.purple.shade400
                                          : Colors.grey.shade500,
                                      fontSize: 13,
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                  style: OutlinedButton.styleFrom(
                                    foregroundColor: effectiveEnabled
                                        ? Colors.purple.shade400
                                        : Colors.grey.shade500,
                                    side: BorderSide(
                                      color: effectiveEnabled
                                          ? Colors.purple.shade100
                                          : Colors.grey.shade300,
                                    ),
                                    shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(25),
                                    ),
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 10, horizontal: 12),
                                  ),
                                  onPressed: effectiveEnabled
                                      ? () => _handleInteraction(
                                          LikeInteractionType.rose)
                                      : null,
                                );
                              },
                            );
                          },
                        ),

                        // Send Like Button
                        ValueListenableBuilder<bool>(
                          // Listens to comment validity for enabling
                          valueListenable: sendLikeEnabledNotifier,
                          builder: (context, isCommentValid, child) {
                            final bool likeButtonEnabled =
                                !isMale || isCommentValid;
                            // Listen also to interaction state for disabling
                            return ValueListenableBuilder<bool>(
                              valueListenable: _isDialogInteractionActive,
                              builder: (context, isInteractionActive, child) {
                                final bool effectiveEnabled =
                                    likeButtonEnabled && !isInteractionActive;
                                return ElevatedButton.icon(
                                  // REMOVED spinner icon logic
                                  icon: Icon(
                                    Icons.favorite_rounded,
                                    color: effectiveEnabled
                                        ? Colors.white
                                        : Colors.grey.shade400,
                                    size: 18,
                                  ),
                                  label: Text(
                                    "Send Like",
                                    style: GoogleFonts.poppins(
                                        fontWeight: FontWeight.w600,
                                        color: effectiveEnabled
                                            ? Colors.white
                                            : Colors.grey.shade500,
                                        fontSize: 13),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: effectiveEnabled
                                        ? Colors.pink.shade300
                                        : Colors.grey.shade200,
                                    disabledBackgroundColor:
                                        Colors.grey.shade200,
                                    shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(25),
                                    ),
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 10, horizontal: 12),
                                    elevation: effectiveEnabled ? 2 : 0,
                                  ),
                                  onPressed: effectiveEnabled
                                      ? () => _handleInteraction(
                                          LikeInteractionType.standard)
                                      : null,
                                );
                              },
                            );
                          },
                        ),
                      ],
                    ),
                    // --- END ACTION BUTTONS ROW ---

                    // Cancel Button (Disabled during interaction)
                    ValueListenableBuilder<bool>(
                        valueListenable: _isDialogInteractionActive,
                        builder: (context, isInteractionActive, child) {
                          return TextButton(
                            child: Text("Cancel",
                                style: GoogleFonts.poppins(
                                    color: isInteractionActive
                                        ? Colors.grey.shade400
                                        : Colors.grey)),
                            onPressed: isInteractionActive
                                ? null // Disable cancel while interaction is happening
                                : () => Navigator.of(dialogContext).pop(),
                          );
                        }),
                  ],
                ),
              ),
            ),
          );
        },
      );
    } finally {
      // --- ENSURE CLEANUP ---
      // Remove listener safely
      if (listenerCallback != null) {
        try {
          commentController.removeListener(listenerCallback);
          listenerCallback = null; // Avoid potential duplicate removal
        } catch (e) {
          print(
              "Error removing commentController listener (already removed?): $e");
        }
      }
      // Dispose controllers and notifiers safely
      try {
        sendLikeEnabledNotifier.dispose();
      } catch (e) {
        print("Error disposing sendLikeEnabledNotifier: $e");
      }
      try {
        commentController.dispose();
      } catch (e) {
        print("Error disposing commentController: $e");
      }
      try {
        commentFocusNode.dispose();
      } catch (e) {
        print("Error disposing commentFocusNode: $e");
      }
      try {
        _isDialogInteractionActive.dispose();
      } catch (e) {
        print("Error disposing _isDialogInteractionActive: $e");
      }
      // --- END CLEANUP ---
    }
  } // End of _showInteractionDialog

  // --- build method and block builders (remain unchanged from previous version) ---
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final List<dynamic> contentBlocks = [];
    final mediaUrls = profile.mediaUrls ?? [];
    final prompts = profile.prompts;

    contentBlocks.add("header_section");
    if (mediaUrls.isNotEmpty) contentBlocks.add(mediaUrls[0]);
    if (prompts.isNotEmpty) contentBlocks.add(prompts[0]);
    contentBlocks.add("vitals_section");

    int mediaIndex = 1;
    int promptIndex = 1;
    int maxRemaining = max(mediaUrls.length, prompts.length);

    for (int i = 1; i < maxRemaining; i++) {
      if (mediaIndex < mediaUrls.length) {
        contentBlocks.add(mediaUrls[mediaIndex]);
        mediaIndex++;
      }
      if (promptIndex < prompts.length) {
        contentBlocks.add(prompts[promptIndex]);
        promptIndex++;
      }
    }
    if (profile.audioPrompt != null) {
      contentBlocks.add(profile.audioPrompt!);
    }

    return Container(
      color: Colors.white,
      child: ListView.builder(
          physics: const ClampingScrollPhysics(),
          padding: EdgeInsets.zero,
          itemCount: contentBlocks.length,
          itemBuilder: (context, index) {
            final item = contentBlocks[index];
            final double topPadding = (index == 0) ? 16.0 : 0;
            final double bottomPadding = 20.0;
            final double horizontalPadding = 12.0;
            Widget contentWidget;

            if (item is String && item == "header_section") {
              contentWidget = _buildHeaderBlock(profile);
            } else if (item is String && item.startsWith('http')) {
              int originalMediaIndex = (profile.mediaUrls ?? []).indexOf(item);
              if (originalMediaIndex == -1) originalMediaIndex = 0;
              contentWidget =
                  _buildMediaItem(context, ref, item, originalMediaIndex);
            } else if (item is Prompt) {
              contentWidget = _buildPromptItem(context, ref, item);
            } else if (item is AudioPromptModel) {
              contentWidget = _buildAudioItem(context, ref, item);
            } else if (item is String && item == "vitals_section") {
              contentWidget = _buildVitalsBlock(profile);
            } else {
              contentWidget = const SizedBox.shrink();
            }

            return Padding(
              padding: EdgeInsets.fromLTRB(horizontalPadding, topPadding,
                  horizontalPadding, bottomPadding),
              child: contentWidget,
            );
          }),
    );
  }

  Widget _buildHeaderBlock(UserModel profile) {
    final age = profile.age;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Flexible(
              child: Text(
                '${profile.name ?? 'Name'}${age != null ? ', $age' : ''}',
                style: GoogleFonts.poppins(
                    fontSize: 26,
                    fontWeight: FontWeight.bold,
                    color: Colors.black87),
              ),
            ),
          ],
        ),
        if (profile.hometown != null && profile.hometown!.isNotEmpty) ...[
          const SizedBox(height: 4),
          Row(
            children: [
              Icon(Icons.location_on_outlined,
                  size: 16, color: Colors.grey[600]),
              const SizedBox(width: 4),
              Text(
                profile.hometown!,
                style:
                    GoogleFonts.poppins(fontSize: 14, color: Colors.grey[700]),
              ),
            ],
          ),
        ]
      ],
    );
  }

  Widget _buildVitalsBlock(UserModel profile) {
    final List<Widget> vitals = [];
    if (profile.height != null && profile.height!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.height, profile.height!));
    }
    if (profile.religiousBeliefs != null) {
      vitals.add(_buildVitalRow(
          Icons.church_outlined, profile.religiousBeliefs!.label));
    }
    if (profile.jobTitle != null && profile.jobTitle!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.work_outline, profile.jobTitle!));
    }
    if (profile.education != null && profile.education!.isNotEmpty) {
      vitals.add(_buildVitalRow(Icons.school_outlined, profile.education!));
    }
    if (profile.drinkingHabit != null) {
      vitals.add(_buildVitalRow(
          Icons.local_bar_outlined, "Drinks: ${profile.drinkingHabit!.label}"));
    }
    if (profile.smokingHabit != null) {
      vitals.add(_buildVitalRow(Icons.smoking_rooms_outlined,
          "Smokes: ${profile.smokingHabit!.label}"));
    }

    if (vitals.isEmpty) return const SizedBox.shrink();

    return Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        width: double.infinity,
        decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(10),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 3),
              )
            ]),
        child: Column(
          children: List.generate(vitals.length * 2 - 1, (index) {
            if (index.isEven) {
              return vitals[index ~/ 2];
            } else {
              return Divider(height: 16, thickness: 1, color: Colors.grey[200]);
            }
          }),
        ));
  }

  Widget _buildVitalRow(IconData icon, String label) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6.0),
      child: Row(
        children: [
          Icon(icon, size: 20, color: Colors.grey[600]),
          const SizedBox(width: 12),
          Expanded(
              child: Text(label,
                  style: GoogleFonts.poppins(
                      fontSize: 15, color: Colors.grey[800]))),
        ],
      ),
    );
  }

  Widget _buildMediaItem(
      BuildContext context, WidgetRef ref, String url, int index) {
    bool isVideo = url.toLowerCase().contains('.mp4') ||
        url.toLowerCase().contains('.mov');

    return ClipRRect(
      borderRadius: BorderRadius.circular(10), // Consistent rounding
      child: AspectRatio(
        aspectRatio: 4 / 5.5, // Or your desired ratio
        child: Container(
          decoration: BoxDecoration(color: Colors.grey[200]), // Placeholder bg
          child: Stack(
            fit: StackFit.expand,
            children: [
              Image.network(url,
                  fit: BoxFit.cover,
                  loadingBuilder: (ctx, child, prog) => prog == null
                      ? child
                      : Center(
                          child: CircularProgressIndicator(
                              value: prog.expectedTotalBytes != null
                                  ? prog.cumulativeBytesLoaded /
                                      prog.expectedTotalBytes!
                                  : null,
                              color: Colors.grey[400])),
                  errorBuilder: (ctx, err, st) => Center(
                      child: Icon(Icons.image_not_supported_outlined,
                          color: Colors.grey[400], size: 40))),
              if (isVideo) // Show video indicator
                Center(
                  child: Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.5),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.play_arrow_rounded,
                        color: Colors.white, size: 30),
                  ),
                ),
              Positioned(
                  bottom: 10,
                  right: 10,
                  child: _buildSmallLikeButton(() => _showInteractionDialog(
                        context,
                        ref,
                        ContentLikeType.media,
                        index.toString(), // Use index as identifier for media
                        url,
                      )))
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPromptItem(BuildContext context, WidgetRef ref, Prompt prompt) {
    if (prompt.answer.trim().isEmpty) return const SizedBox.shrink();

    return Container(
      width: double.infinity, // Take full width
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
          color: Colors.white, // White background
          borderRadius: BorderRadius.circular(10), // Rounded corners
          boxShadow: [
            // Subtle shadow
            BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ]),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start, // Align top
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Prompt Question
                Text(prompt.question.label,
                    style: GoogleFonts.poppins(
                        fontSize: 14, // Slightly smaller question
                        fontWeight: FontWeight.w600,
                        color: Colors.grey[600])), // Subdued color
                const SizedBox(height: 10),
                // Prompt Answer
                Text(prompt.answer,
                    style: GoogleFonts.poppins(
                        fontSize: 20, // Larger answer text
                        color: Colors.black87,
                        height: 1.4, // Line height
                        fontWeight: FontWeight.w500)),
              ],
            ),
          ),
          const SizedBox(width: 12), // Spacing before button
          // Like Button
          _buildSmallLikeButton(() => _showInteractionDialog(
                context,
                ref,
                prompt.category.contentType, // Get type from category
                prompt.question.value, // Use question enum value as identifier
                null, // No image preview for prompts
              )),
        ],
      ),
    );
  }

  Widget _buildAudioItem(
      BuildContext context, WidgetRef ref, AudioPromptModel audio) {
    final audioPlayerState = ref.watch(audioPlayerStateProvider);
    final currentPlayingUrl = ref.watch(currentAudioUrlProvider);
    final playerNotifier = ref.read(audioPlayerControllerProvider.notifier);

    final bool isThisPlaying = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.playing;
    final bool isThisLoading = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.loading;
    final bool isThisPaused = currentPlayingUrl == audio.audioUrl &&
        audioPlayerState == AudioPlayerState.paused;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16), // More rounded
          border: Border.all(color: Colors.grey[200]!),
          boxShadow: [
            BoxShadow(
                color: Colors.grey.withOpacity(0.06),
                blurRadius: 10,
                offset: const Offset(0, 3))
          ]),
      child: Row(
        children: [
          InkWell(
            onTap: () {
              if (isThisLoading) return;

              if (isThisPlaying) {
                playerNotifier.pause();
              } else if (isThisPaused) {
                playerNotifier.resume();
              } else {
                playerNotifier.play(audio.audioUrl);
              }
            },
            borderRadius: BorderRadius.circular(24),
            child: Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: const Color(0xFF8B5CF6),
                borderRadius: BorderRadius.circular(24),
                boxShadow: [
                  BoxShadow(
                      color: const Color(0xFF8B5CF6).withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2))
                ],
              ),
              child: isThisLoading
                  ? const Padding(
                      padding: EdgeInsets.all(12.0),
                      child: CircularProgressIndicator(
                          strokeWidth: 2, color: Colors.white))
                  : Icon(
                      isThisPlaying
                          ? Icons.pause_rounded
                          : Icons.play_arrow_rounded,
                      color: Colors.white,
                      size: 28,
                    ),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(audio.prompt.label,
                    style: GoogleFonts.poppins(
                        fontSize: 15,
                        fontWeight: FontWeight.w500,
                        color: const Color(0xFF1A1A1A))),
                const SizedBox(height: 4),
                Text(
                    isThisLoading
                        ? "Loading..."
                        : isThisPlaying
                            ? "Playing..."
                            : isThisPaused
                                ? "Paused"
                                : "Tap to listen",
                    style: GoogleFonts.poppins(
                        fontSize: 13, color: Colors.grey[600])),
              ],
            ),
          ),
          const SizedBox(width: 16),
          _buildSmallLikeButton(() => _showInteractionDialog(
                context,
                ref,
                ContentLikeType.audioPrompt,
                "0", // API requires "0" for audio prompts
                null,
              )),
        ],
      ),
    );
  }

  Widget _buildSmallLikeButton(VoidCallback onPressed) {
    return Container(
      width: 40,
      height: 40,
      decoration: BoxDecoration(
          color: Colors.white, // White background
          shape: BoxShape.circle,
          boxShadow: [
            // Subtle shadow
            BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 5)
          ]),
      child: IconButton(
        padding: EdgeInsets.zero, // Remove default padding
        icon: Icon(Icons.favorite_border_rounded,
            color: Colors.pink[200], // Soft pink color
            size: 22), // Icon size
        tooltip: 'Like this item',
        onPressed: onPressed,
      ),
    );
  }
} // End of HomeProfileCard


